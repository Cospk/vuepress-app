import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as n}from"./app-DIJDtupu.js";const l={};function r(c,e){return n(),i("div",null,e[0]||(e[0]=[a('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Go能实现接口的动态性和反射的基础是：编译期为运行时提供了类型信息。interface底层有两种结构，上一节讲了带方法的iface，这一节补充不带方法的eface结构。 ## [](#interface之eface &quot;interface之eface&quot;)interface之eface Go中的任何对象都可以表示为**interface{}**。它扮演的角色与C中的**void\\***差不多，区别在于interface{}中包含有类型信息，可以实现反射。 &gt; **eface数据结构描述**：`gcdata`域用于垃圾回收，`size`描述类型的大小，`hash`表示数据的hash值，`align`是对齐，`fieldalign`是这个数据嵌入结构体时的对齐，`kind`是枚举值。`alg`是函数指针的数组，存储了`hash/equal/print/copy`四个函数操作。`uncommentType`指向这个类型的方法集。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type eface struct { \\_type \\*\\_type data unsafe.Pointer } type \\_type struct { size uintptr ptrdata uintptr // size of memory prefix holding all pointers hash uint32 \\_unused uint8 align uint8 fieldalign uint8 kind uint8 alg \\*typeAlg gcdata \\*byte \\_string \\*string x \\*uncommontype ptrto \\*\\_type zero \\*byte // ptr to the zero value for this type }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="运行时convt2e-运行时convt2e-运行时convt2e-t2e的转换-赋值给空interface-运行时会调用conv类函数-convt2e-。与-convt2i-一样-向interface的类型转换-var-i-interface-u-都存在内存拷贝。看iface-go源码时发现-convi2i-等接口转换时没有分配内存和拷贝数据-原因可能是go接口内部的data域-并不开放途径让外部修改-所以接口之间转换可以用同一块内存。" tabindex="-1"><a class="header-anchor" href="#运行时convt2e-运行时convt2e-运行时convt2e-t2e的转换-赋值给空interface-运行时会调用conv类函数-convt2e-。与-convt2i-一样-向interface的类型转换-var-i-interface-u-都存在内存拷贝。看iface-go源码时发现-convi2i-等接口转换时没有分配内存和拷贝数据-原因可能是go接口内部的data域-并不开放途径让外部修改-所以接口之间转换可以用同一块内存。"><span>[](#运行时convT2E &quot;运行时convT2E&quot;)运行时convT2E **T2E的转换** 赋值给空interface{}，运行时会调用conv类函数`convT2E`。与`convT2I`一样，向interface的类型转换`var i interface{} = u`都存在内存拷贝。看iface.go源码时发现`convI2I`等接口转换时没有分配内存和拷贝数据，原因可能是Go接口内部的data域，并不开放途径让外部修改，所以接口之间转换可以用同一块内存。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func convT2E(t \\*\\_type, elem unsafe.Pointer, x unsafe.Pointer) (e interface{}) { ep := (\\*eface)(unsafe.Pointer(&amp;e)) ... if x == nil { x = newobject(t) } typedmemmove(t, x, elem) ep.\\_type = t ep.data = x } return }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>下面的例子中修改u并不影响i interface的内存数据，因为i在赋值时通过convT2E对u进行了拷贝。这也是**反射非指针变量时无法直接改变变量数据**的原因，因为反射会先把变量转成interface类型，拿到的是变量的副本。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go u := User{1, &quot;Tom&quot;} var i interface{} = u u.id = 2 u.name = &quot;Jack&quot; // u {2, &quot;Jack&quot;} // i.(User) {1, &quot;Tom&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="nil的理解-nil的理解-nil的理解-未初始化的interface类型-指针-函数-slice-cannel和map都是nil的。-对于interface比较特殊-只有eface的type和data都是nil-或者iface的type和data都是nil时-interface-才是nil。" tabindex="-1"><a class="header-anchor" href="#nil的理解-nil的理解-nil的理解-未初始化的interface类型-指针-函数-slice-cannel和map都是nil的。-对于interface比较特殊-只有eface的type和data都是nil-或者iface的type和data都是nil时-interface-才是nil。"><span>[](#nil的理解 &quot;nil的理解&quot;)nil的理解 未初始化的interface类型，指针，函数，slice，cannel和map都是nil的。**对于interface比较特殊，只有eface的type和data都是nil，或者iface的type和data都是nil时，interface{}才是nil。**</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Duck interface{ Walk() } var i interface{} // nil var d Duck // nil var v \\*T // nil i = v // (\\*T)(nil) not nil</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="type-assertion-type-assertion-type-assertion-严格来说go并不支持泛型编程-但通过interface可实现泛型编程-后面reflect浅析中有个通过reflect实现泛型的例子。interface像其它类型转换的时候一般需要断言。下面只给出了eface的例子-当然也可以通过断言来判断某个类型是否实现了某个接口。" tabindex="-1"><a class="header-anchor" href="#type-assertion-type-assertion-type-assertion-严格来说go并不支持泛型编程-但通过interface可实现泛型编程-后面reflect浅析中有个通过reflect实现泛型的例子。interface像其它类型转换的时候一般需要断言。下面只给出了eface的例子-当然也可以通过断言来判断某个类型是否实现了某个接口。"><span>[](#type-assertion &quot;type assertion&quot;)type assertion 严格来说Go并不支持泛型编程，但通过interface可实现泛型编程，后面reflect浅析中有个通过reflect实现泛型的例子。interface像其它类型转换的时候一般需要断言。下面只给出了eface的例子，当然也可以通过断言来判断某个类型是否实现了某个接口。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func do(v interface{}) { n, ok := v.(int) if !ok {...} } func doswitch(i interface{}) { switch v := i.(type) { case int: ... } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对应的go源码在iface.go当中。`assertE2T`过程判断了eface的type字段是否和目标type相等，相等则还需要拷贝数据。`assertI2T`也要拷贝数据，不过他比较的是iface.tab.\\_type与目标type是否一致。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func assertE2T(t \\*\\_type, e interface{}, r unsafe.Pointer) { ep := (\\*eface)(unsafe.Pointer(&amp;e)) if ep.\\_type == nil { panic(&amp;TypeAssertionError{&quot;&quot;, &quot;&quot;, \\*t.\\_string, &quot;&quot;}) } if ep.\\_type != t { panic(&amp;TypeAssertionError{&quot;&quot;, \\*ep.\\_type.\\_string, \\*t.\\_string, &quot;&quot;}) } if r != nil { if isDirectIface(t) { writebarrierptr((\\*uintptr)(r), uintptr(ep.data)) } else { typedmemmove(t, r, ep.data) } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="reflect浅析-reflect浅析-reflect浅析-反射机制提供了检查存储在接口变量中的-类型-值-对的机制。根据-laws-of-reflection-https-studygolang-com-articles-2157-go的反射可以总结三点-即反射可以从interface中获取reflect对象-同时可以通过-interface-方法恢复reflect对象为一个interface-如果要修改反射对象-该对象必须是-settable-的。-typeof与valueof实现-typeof与valueof实现-typeof与valueof实现-获取反射对象的实现-是基于对interface底层数据的操作。首先对象经过了-convt2e-然后emptyinterface直接指向了eface的type字段。-typeof-返回的-type-是接口-在类型-type上实现了很多操作。-valueof-返回的就是-value-结构体-它包含了数据域和type域信息。" tabindex="-1"><a class="header-anchor" href="#reflect浅析-reflect浅析-reflect浅析-反射机制提供了检查存储在接口变量中的-类型-值-对的机制。根据-laws-of-reflection-https-studygolang-com-articles-2157-go的反射可以总结三点-即反射可以从interface中获取reflect对象-同时可以通过-interface-方法恢复reflect对象为一个interface-如果要修改反射对象-该对象必须是-settable-的。-typeof与valueof实现-typeof与valueof实现-typeof与valueof实现-获取反射对象的实现-是基于对interface底层数据的操作。首先对象经过了-convt2e-然后emptyinterface直接指向了eface的type字段。-typeof-返回的-type-是接口-在类型-type上实现了很多操作。-valueof-返回的就是-value-结构体-它包含了数据域和type域信息。"><span>[](#reflect浅析 &quot;reflect浅析&quot;)reflect浅析 反射机制提供了检查存储在接口变量中的\\[类型 值]对的机制。根据[Laws Of Reflection](<a href="https://studygolang.com/articles/2157" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/2157</a>)Go的反射可以总结三点，即反射可以从interface中获取reflect对象；同时可以通过`Interface()`方法恢复reflect对象为一个interface；如果要修改反射对象，该对象必须是`settable`的。 ### [](#TypeOf与ValueOf实现 &quot;TypeOf与ValueOf实现&quot;)TypeOf与ValueOf实现 获取反射对象的实现，是基于对interface底层数据的操作。首先对象经过了`convT2E`，然后emptyInterface直接指向了eface的type字段。`typeOf`返回的**Type**是接口，在类型\\_type上实现了很多操作。`valueOf`返回的就是**Value**结构体，它包含了数据域和type域信息。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func TypeOf(i interface{}) Type { eface := \\*(\\*emptyInterface)(unsafe.Pointer(&amp;i)) return toType(eface.typ) } func ValueOf(i interface{}) Value { if i == nil { return Value{} } escapes(i) return unpackEface(i) } func unpackEface(i interface{}) Value { e := (\\*emptyInterface)(unsafe.Pointer(&amp;i)) t := e.typ if t == nil { return Value{} } f := flag(t.Kind()) if ifaceIndir(t) { f |= flagIndir } return Value{t, unsafe.Pointer(e.word), f} }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Type interface{ ... Method(int) Method MethodByName(string) (Method, bool) NumMethod() int NumField() Field(i) StructField FieldByName(name string) (StructField, bool) ... } type Value struct { typ \\*rtype ptr unsafe.Pointer flag }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="通过type获取struct-field信息-通过type获取struct-field信息-通过type获取struct-field信息-可以通过reflect获取类型实例的结构体信息-比如每个field的名字类型或标签。" tabindex="-1"><a class="header-anchor" href="#通过type获取struct-field信息-通过type获取struct-field信息-通过type获取struct-field信息-可以通过reflect获取类型实例的结构体信息-比如每个field的名字类型或标签。"><span>[](#通过Type获取Struct-Field信息 &quot;通过Type获取Struct Field信息&quot;)通过Type获取Struct Field信息 可以通过reflect获取类型实例的结构体信息，比如每个field的名字类型或标签。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // A StructField describes a single field in a struct. type StructField struct { Name string // Name is the field name. PkgPath string Type Type // field type Tag StructTag // field tag string Offset uintptr // offset within struct, in bytes Index \\[\\]int // index sequence for Type.FieldByIndex Anonymous bool // is an embedded field } type Person struct { Name string \\`json:&quot;name&quot;\\` Age int \\`json:&quot;age&quot;\\` } func main() { nino := Person{&quot;nino&quot;, 27} t := reflect.TypeOf(nino) n := t.NumField() for i := 0; i &lt; n; i++ { fmt.Println(t.Field(i).Name, t.Field(i).Type, t.Field(i).Tag) } } // Name string json:&quot;name&quot; // Age int json:&quot;age&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="通过value实现泛型-通过value实现泛型-通过value实现泛型-为了解决method接受不同类型的slice为入参-可以用反射来完成。对于可记长度和可随机访问的类型-可以通过-v-len-和-v-index-i-获取他们的第几个元素。-v-index-i-interface-将reflect-value反射回了interface类型" tabindex="-1"><a class="header-anchor" href="#通过value实现泛型-通过value实现泛型-通过value实现泛型-为了解决method接受不同类型的slice为入参-可以用反射来完成。对于可记长度和可随机访问的类型-可以通过-v-len-和-v-index-i-获取他们的第几个元素。-v-index-i-interface-将reflect-value反射回了interface类型"><span>[](#通过Value实现泛型 &quot;通过Value实现泛型&quot;)通过Value实现泛型 为了解决method接受不同类型的slice为入参，可以用反射来完成。对于可记长度和可随机访问的类型，可以通过`v.Len()`和`v.Index(i)`获取他们的第几个元素。 &gt; **v.Index(i).Interface()**将reflect.Value反射回了interface类型</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func method(in interface{}) (ok bool) { v := reflect.ValueOf(in) if v.Kind() == reflect.Slice { ok = true } else { return false } num := v.Len() for i := 0; i &lt; num; i++ { fmt.Println(v.Index(i).Interface()) } return ok } func main() { s := \\[\\]int{1, 3, 5, 7, 9} b := \\[\\]float64{1.2, 3.4, 5.6, 7.8} method(s) method(b) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="通过elem修改reflect对象值-通过elem修改reflect对象值-通过elem修改reflect对象值-对lawsofreflect第三点的理解-reflect-valueof-如果直接传入x-则v是x的一个副本的-reflect-对象。修改v的值并不会作用到x上。p是指向x的指针的reflect对象-修改p的值是在修改指针的指向-同样不会作用到x上-因此也是-cannotset-的。只有通过-p-elem-相当于获取了-p的-reflect-对象-这时才能使用-v-setfloat-7-2-来对原始的数据进行修改。" tabindex="-1"><a class="header-anchor" href="#通过elem修改reflect对象值-通过elem修改reflect对象值-通过elem修改reflect对象值-对lawsofreflect第三点的理解-reflect-valueof-如果直接传入x-则v是x的一个副本的-reflect-对象。修改v的值并不会作用到x上。p是指向x的指针的reflect对象-修改p的值是在修改指针的指向-同样不会作用到x上-因此也是-cannotset-的。只有通过-p-elem-相当于获取了-p的-reflect-对象-这时才能使用-v-setfloat-7-2-来对原始的数据进行修改。"><span>[](#通过Elem修改reflect对象值 &quot;通过Elem修改reflect对象值&quot;)通过Elem修改reflect对象值 **对LawsOfReflect第三点的理解** `reflect.ValueOf` 如果直接传入x，则v是x的一个副本的**reflect**对象。修改v的值并不会作用到x上。p是指向x的指针的reflect对象，修改p的值是在修改指针的指向，同样不会作用到x上，因此也是**CanNotSet**的。只有通过`p.Elem()`相当于获取了\\*p的**reflect**对象，这时才能使用`v.SetFloat(7.2)`来对原始的数据进行修改。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go var x float64 = 3.4 v := reflect.ValueOf(x) // can not set p := reflect.ValueOf(&amp;x) // can not set e := p.Elem() // can set</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',22)]))}const f=t(l,[["render",r],["__file","Go-反射与interface拾遗.html.vue"]]),d=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%8F%8D%E5%B0%84%E4%B8%8Einterface%E6%8B%BE%E9%81%97.html","title":"Go 反射与interface拾遗","lang":"zh-CN","frontmatter":{"title":"Go 反射与interface拾遗","source_url":"https://studygolang.com/articles/11994","category":"Go原理教程","description":"Go能实现接口的动态性和反射的基础是：编译期为运行时提供了类型信息。interface底层有两种结构，上一节讲了带方法的iface，这一节补充不带方法的eface结构。 ## [](#interface之eface \\"interface之eface\\")interface之eface Go中的任何对象都可以表示为**interface{}**。它扮演的角...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%8F%8D%E5%B0%84%E4%B8%8Einterface%E6%8B%BE%E9%81%97.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 反射与interface拾遗"}],["meta",{"property":"og:description","content":"Go能实现接口的动态性和反射的基础是：编译期为运行时提供了类型信息。interface底层有两种结构，上一节讲了带方法的iface，这一节补充不带方法的eface结构。 ## [](#interface之eface \\"interface之eface\\")interface之eface Go中的任何对象都可以表示为**interface{}**。它扮演的角..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 反射与interface拾遗\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"[](#运行时convT2E \\"运行时convT2E\\")运行时convT2E **T2E的转换** 赋值给空interface{}，运行时会调用conv类函数`convT2E`。与`convT2I`一样，向interface的类型转换`var i interface{} = u`都存在内存拷贝。看iface.go源码时发现`convI2I`等接口转换时没有分配内存和拷贝数据，原因可能是Go接口内部的data域，并不开放途径让外部修改，所以接口之间转换可以用同一块内存。","slug":"运行时convt2e-运行时convt2e-运行时convt2e-t2e的转换-赋值给空interface-运行时会调用conv类函数-convt2e-。与-convt2i-一样-向interface的类型转换-var-i-interface-u-都存在内存拷贝。看iface-go源码时发现-convi2i-等接口转换时没有分配内存和拷贝数据-原因可能是go接口内部的data域-并不开放途径让外部修改-所以接口之间转换可以用同一块内存。","link":"#运行时convt2e-运行时convt2e-运行时convt2e-t2e的转换-赋值给空interface-运行时会调用conv类函数-convt2e-。与-convt2i-一样-向interface的类型转换-var-i-interface-u-都存在内存拷贝。看iface-go源码时发现-convi2i-等接口转换时没有分配内存和拷贝数据-原因可能是go接口内部的data域-并不开放途径让外部修改-所以接口之间转换可以用同一块内存。","children":[]},{"level":3,"title":"[](#nil的理解 \\"nil的理解\\")nil的理解 未初始化的interface类型，指针，函数，slice，cannel和map都是nil的。**对于interface比较特殊，只有eface的type和data都是nil，或者iface的type和data都是nil时，interface{}才是nil。**","slug":"nil的理解-nil的理解-nil的理解-未初始化的interface类型-指针-函数-slice-cannel和map都是nil的。-对于interface比较特殊-只有eface的type和data都是nil-或者iface的type和data都是nil时-interface-才是nil。","link":"#nil的理解-nil的理解-nil的理解-未初始化的interface类型-指针-函数-slice-cannel和map都是nil的。-对于interface比较特殊-只有eface的type和data都是nil-或者iface的type和data都是nil时-interface-才是nil。","children":[]},{"level":3,"title":"[](#type-assertion \\"type assertion\\")type assertion 严格来说Go并不支持泛型编程，但通过interface可实现泛型编程，后面reflect浅析中有个通过reflect实现泛型的例子。interface像其它类型转换的时候一般需要断言。下面只给出了eface的例子，当然也可以通过断言来判断某个类型是否实现了某个接口。","slug":"type-assertion-type-assertion-type-assertion-严格来说go并不支持泛型编程-但通过interface可实现泛型编程-后面reflect浅析中有个通过reflect实现泛型的例子。interface像其它类型转换的时候一般需要断言。下面只给出了eface的例子-当然也可以通过断言来判断某个类型是否实现了某个接口。","link":"#type-assertion-type-assertion-type-assertion-严格来说go并不支持泛型编程-但通过interface可实现泛型编程-后面reflect浅析中有个通过reflect实现泛型的例子。interface像其它类型转换的时候一般需要断言。下面只给出了eface的例子-当然也可以通过断言来判断某个类型是否实现了某个接口。","children":[]},{"level":2,"title":"[](#reflect浅析 \\"reflect浅析\\")reflect浅析 反射机制提供了检查存储在接口变量中的\\\\[类型 值]对的机制。根据[Laws Of Reflection](https://studygolang.com/articles/2157)Go的反射可以总结三点，即反射可以从interface中获取reflect对象；同时可以通过`Interface()`方法恢复reflect对象为一个interface；如果要修改反射对象，该对象必须是`settable`的。 ### [](#TypeOf与ValueOf实现 \\"TypeOf与ValueOf实现\\")TypeOf与ValueOf实现 获取反射对象的实现，是基于对interface底层数据的操作。首先对象经过了`convT2E`，然后emptyInterface直接指向了eface的type字段。`typeOf`返回的**Type**是接口，在类型\\\\_type上实现了很多操作。`valueOf`返回的就是**Value**结构体，它包含了数据域和type域信息。","slug":"reflect浅析-reflect浅析-reflect浅析-反射机制提供了检查存储在接口变量中的-类型-值-对的机制。根据-laws-of-reflection-https-studygolang-com-articles-2157-go的反射可以总结三点-即反射可以从interface中获取reflect对象-同时可以通过-interface-方法恢复reflect对象为一个interface-如果要修改反射对象-该对象必须是-settable-的。-typeof与valueof实现-typeof与valueof实现-typeof与valueof实现-获取反射对象的实现-是基于对interface底层数据的操作。首先对象经过了-convt2e-然后emptyinterface直接指向了eface的type字段。-typeof-返回的-type-是接口-在类型-type上实现了很多操作。-valueof-返回的就是-value-结构体-它包含了数据域和type域信息。","link":"#reflect浅析-reflect浅析-reflect浅析-反射机制提供了检查存储在接口变量中的-类型-值-对的机制。根据-laws-of-reflection-https-studygolang-com-articles-2157-go的反射可以总结三点-即反射可以从interface中获取reflect对象-同时可以通过-interface-方法恢复reflect对象为一个interface-如果要修改反射对象-该对象必须是-settable-的。-typeof与valueof实现-typeof与valueof实现-typeof与valueof实现-获取反射对象的实现-是基于对interface底层数据的操作。首先对象经过了-convt2e-然后emptyinterface直接指向了eface的type字段。-typeof-返回的-type-是接口-在类型-type上实现了很多操作。-valueof-返回的就是-value-结构体-它包含了数据域和type域信息。","children":[{"level":3,"title":"[](#通过Type获取Struct-Field信息 \\"通过Type获取Struct Field信息\\")通过Type获取Struct Field信息 可以通过reflect获取类型实例的结构体信息，比如每个field的名字类型或标签。","slug":"通过type获取struct-field信息-通过type获取struct-field信息-通过type获取struct-field信息-可以通过reflect获取类型实例的结构体信息-比如每个field的名字类型或标签。","link":"#通过type获取struct-field信息-通过type获取struct-field信息-通过type获取struct-field信息-可以通过reflect获取类型实例的结构体信息-比如每个field的名字类型或标签。","children":[]},{"level":3,"title":"[](#通过Value实现泛型 \\"通过Value实现泛型\\")通过Value实现泛型 为了解决method接受不同类型的slice为入参，可以用反射来完成。对于可记长度和可随机访问的类型，可以通过`v.Len()`和`v.Index(i)`获取他们的第几个元素。 > **v.Index(i).Interface()**将reflect.Value反射回了interface类型","slug":"通过value实现泛型-通过value实现泛型-通过value实现泛型-为了解决method接受不同类型的slice为入参-可以用反射来完成。对于可记长度和可随机访问的类型-可以通过-v-len-和-v-index-i-获取他们的第几个元素。-v-index-i-interface-将reflect-value反射回了interface类型","link":"#通过value实现泛型-通过value实现泛型-通过value实现泛型-为了解决method接受不同类型的slice为入参-可以用反射来完成。对于可记长度和可随机访问的类型-可以通过-v-len-和-v-index-i-获取他们的第几个元素。-v-index-i-interface-将reflect-value反射回了interface类型","children":[]},{"level":3,"title":"[](#通过Elem修改reflect对象值 \\"通过Elem修改reflect对象值\\")通过Elem修改reflect对象值 **对LawsOfReflect第三点的理解** `reflect.ValueOf` 如果直接传入x，则v是x的一个副本的**reflect**对象。修改v的值并不会作用到x上。p是指向x的指针的reflect对象，修改p的值是在修改指针的指向，同样不会作用到x上，因此也是**CanNotSet**的。只有通过`p.Elem()`相当于获取了\\\\*p的**reflect**对象，这时才能使用`v.SetFloat(7.2)`来对原始的数据进行修改。","slug":"通过elem修改reflect对象值-通过elem修改reflect对象值-通过elem修改reflect对象值-对lawsofreflect第三点的理解-reflect-valueof-如果直接传入x-则v是x的一个副本的-reflect-对象。修改v的值并不会作用到x上。p是指向x的指针的reflect对象-修改p的值是在修改指针的指向-同样不会作用到x上-因此也是-cannotset-的。只有通过-p-elem-相当于获取了-p的-reflect-对象-这时才能使用-v-setfloat-7-2-来对原始的数据进行修改。","link":"#通过elem修改reflect对象值-通过elem修改reflect对象值-通过elem修改reflect对象值-对lawsofreflect第三点的理解-reflect-valueof-如果直接传入x-则v是x的一个副本的-reflect-对象。修改v的值并不会作用到x上。p是指向x的指针的reflect对象-修改p的值是在修改指针的指向-同样不会作用到x上-因此也是-cannotset-的。只有通过-p-elem-相当于获取了-p的-reflect-对象-这时才能使用-v-setfloat-7-2-来对原始的数据进行修改。","children":[]}]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":5.39,"words":1616},"filePathRelative":"golang/原理/theory/Go-反射与interface拾遗.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{f as comp,d as data};
