import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as t,o as s}from"./app-DIJDtupu.js";const n={};function r(l,e){return s(),i("div",null,e[0]||(e[0]=[t('<p>欢迎来到 [Golang 系列教程](/subject/2)的第 15 个教程。 ### 什么是指针？ 指针是一种存储变量内存地址（Memory Address）的变量。 ![指针示意图](<a href="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/pointer-explained.png" target="_blank" rel="noopener noreferrer">https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/pointer-explained.png</a> &quot;指针示意图&quot;) 如上图所示，变量 `b` 的值为 `156`，而 `b` 的内存地址为 `0x1040a124`。变量 `a` 存储了 `b` 的地址。我们就称 `a` 指向了 `b`。 ### 指针的声明 指针变量的类型为 **`*T`**，该指针指向一个 **T** 类型的变量。 接下来我们写点代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { b := 255 var a \\*int = &amp;b fmt.Printf(&quot;Type of a is %T\\\\n&quot;, a) fmt.Println(&quot;address of b is&quot;, a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/A4vmlgxAy8" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/A4vmlgxAy8</a>) **&amp;** 操作符用于获取变量的地址。上面程序的第 9 行我们把 `b` 的地址赋值给 **`*int`** 类型的 `a`。我们称 `a` 指向了 `b`。当我们打印 `a` 的值时，会打印出 `b` 的地址。程序将输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Type of a is \\*int address of b is 0x1040a124</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>由于 b 可能处于内存的任何位置，你应该会得到一个不同的地址。 ### 指针的零值（Zero Value） 指针的零值是 `nil`。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { a := 25 var b \\*int if b == nil { fmt.Println(&quot;b is&quot;, b) b = &amp;a fmt.Println(&quot;b after initialization is&quot;, b) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/yAeGhzgQE1" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/yAeGhzgQE1</a>) 上面的程序中，`b` 初始化为 `nil`，接着将 `a` 的地址赋值给 `b`。程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> b is b after initialisation is 0x1040a124</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="指针的解引用-指针的解引用可以获取指针所指向的变量的值。将-a-解引用的语法是-a-。-通过下面的代码-可以看到如何使用解引用。" tabindex="-1"><a class="header-anchor" href="#指针的解引用-指针的解引用可以获取指针所指向的变量的值。将-a-解引用的语法是-a-。-通过下面的代码-可以看到如何使用解引用。"><span>指针的解引用 指针的解引用可以获取指针所指向的变量的值。将 `a` 解引用的语法是 `*a`。 通过下面的代码，可以看到如何使用解引用。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { b := 255 a := &amp;b fmt.Println(&quot;address of b is&quot;, a) fmt.Println(&quot;value of b is&quot;, \\*a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/m5pNbgFwbM" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/m5pNbgFwbM</a>) 在上面程序的第 10 行，我们将 `a` 解引用，并打印了它的值。不出所料，我们会打印出 `b` 的值。程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> address of b is 0x1040a124 value of b is 255</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们再编写一个程序，用指针来修改 b 的值。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { b := 255 a := &amp;b fmt.Println(&quot;address of b is&quot;, a) fmt.Println(&quot;value of b is&quot;, \\*a) \\*a++ fmt.Println(&quot;new value of b is&quot;, b) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/cdmvlpBNmb" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/cdmvlpBNmb</a>) 在上面程序的第 12 行中，我们把 `a` 指向的值加 1，由于 `a` 指向了 `b`，因此 `b` 的值也发生了同样的改变。于是 `b` 的值变为 256。程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> address of b is 0x1040a124 value of b is 255 new value of b is 256</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="向函数传递指针参数" tabindex="-1"><a class="header-anchor" href="#向函数传递指针参数"><span>向函数传递指针参数</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func change(val \\*int) { \\*val = 55 } func main() { a := 58 fmt.Println(&quot;value of a before function call is&quot;,a) b := &amp;a change(b) fmt.Println(&quot;value of a after function call is&quot;, a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/3n2nHRJJqn" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/3n2nHRJJqn</a>) 在上面程序中的第 14 行，我们向函数 `change` 传递了指针变量 `b`，而 `b` 存储了 `a` 的地址。程序的第 8 行在 `change` 函数内使用解引用，修改了 a 的值。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> value of a before function call is 58 value of a after function call is 55</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="不要向函数传递数组的指针-而应该使用切片-假如我们想要在函数内修改一个数组-并希望调用函数的地方也能得到修改后的数组-一种解决方案是把一个指向数组的指针传递给这个函数。" tabindex="-1"><a class="header-anchor" href="#不要向函数传递数组的指针-而应该使用切片-假如我们想要在函数内修改一个数组-并希望调用函数的地方也能得到修改后的数组-一种解决方案是把一个指向数组的指针传递给这个函数。"><span>不要向函数传递数组的指针，而应该使用切片 假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func modify(arr \\*\\[3\\]int) { (\\*arr)\\[0\\] = 90 } func main() { a := \\[3\\]int{89, 90, 91} modify(&amp;a) fmt.Println(a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/lOIznCbcvs" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/lOIznCbcvs</a>) 在上面程序的第 13 行中，我们将数组的地址传递给了 `modify` 函数。在第 8 行，我们在 `modify` 函数里把 `arr` 解引用，并将 `90` 赋值给这个数组的第一个元素。程序会输出 `[90 90 91]`。 **`a[x]` 是 `(*a)[x]` 的简写形式，因此上面代码中的 `(*arr)[0]` 可以替换为 `arr[0]`**。下面我们用简写形式重写以上代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func modify(arr \\*\\[3\\]int) { arr\\[0\\] = 90 } func main() { a := \\[3\\]int{89, 90, 91} modify(&amp;a) fmt.Println(a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/k7YR0EUE1G" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/k7YR0EUE1G</a>) 该程序也会输出 `[90 90 91]`。 **这种方式向函数传递一个数组指针参数，并在函数内修改数组。尽管它是有效的，但却不是 Go 语言惯用的实现方式。我们最好使用[切片](<a href="https://golangbot.com/arrays-and-slices/" target="_blank" rel="noopener noreferrer">https://golangbot.com/arrays-and-slices/</a>)来处理。** 接下来我们用[切片](<a href="https://golangbot.com/arrays-and-slices/" target="_blank" rel="noopener noreferrer">https://golangbot.com/arrays-and-slices/</a>)来重写之前的代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func modify(sls \\[\\]int) { sls\\[0\\] = 90 } func main() { a := \\[3\\]int{89, 90, 91} modify(a\\[:\\]) fmt.Println(a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/rRvbvuI67W" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/rRvbvuI67W</a>) 在上面程序的第 13 行，我们将一个切片传递给了 `modify` 函数。在 `modify` 函数中，我们把切片的第一个元素修改为 `90`。程序也会输出 `[90 90 91]`。**所以别再传递数组指针了，而是使用切片吧**。上面的代码更加简洁，也更符合 Go 语言的习惯。 ### Go 不支持指针运算 Go 并不支持其他语言（例如 C）中的指针运算。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main func main() { b := \\[...\\]int{109, 110, 111} p := &amp;b p++ }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/WRaj4pkqRD" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/WRaj4pkqRD</a>) 上面的程序会抛出编译错误：**`main.go:6: invalid operation: p++ (non-numeric type *[3]int)`**。 我在 [github](<a href="https://github.com/golangbot/pointers" target="_blank" rel="noopener noreferrer">https://github.com/golangbot/pointers</a>) 上创建了一个程序，涵盖了所有我们讨论过的内容。 关于指针的介绍到此结束。祝您愉快。 **上一教程 - [字符串](<a href="https://studygolang.com/articles/12261" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12261</a>)** **下一教程 - [结构体](<a href="https://studygolang.com/articles/12263" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12263</a>)**</p>',29)]))}const p=a(n,[["render",r],["__file","15-指针.html.vue"]]),g=JSON.parse('{"path":"/golang/%E5%9F%BA%E7%A1%80/15-%E6%8C%87%E9%92%88.html","title":"Go 系列教程 —— 15. 指针","lang":"zh-CN","frontmatter":{"title":"Go 系列教程 —— 15. 指针","source_url":"https://studygolang.com/articles/12262","category":"Go系列教程","description":"欢迎来到 [Golang 系列教程](/subject/2)的第 15 个教程。 ### 什么是指针？ 指针是一种存储变量内存地址（Memory Address）的变量。 ![指针示意图](https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/poi...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%9F%BA%E7%A1%80/15-%E6%8C%87%E9%92%88.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 系列教程 —— 15. 指针"}],["meta",{"property":"og:description","content":"欢迎来到 [Golang 系列教程](/subject/2)的第 15 个教程。 ### 什么是指针？ 指针是一种存储变量内存地址（Memory Address）的变量。 ![指针示意图](https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/poi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 系列教程 —— 15. 指针\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"指针的解引用 指针的解引用可以获取指针所指向的变量的值。将 `a` 解引用的语法是 `*a`。 通过下面的代码，可以看到如何使用解引用。","slug":"指针的解引用-指针的解引用可以获取指针所指向的变量的值。将-a-解引用的语法是-a-。-通过下面的代码-可以看到如何使用解引用。","link":"#指针的解引用-指针的解引用可以获取指针所指向的变量的值。将-a-解引用的语法是-a-。-通过下面的代码-可以看到如何使用解引用。","children":[]},{"level":3,"title":"向函数传递指针参数","slug":"向函数传递指针参数","link":"#向函数传递指针参数","children":[]},{"level":3,"title":"不要向函数传递数组的指针，而应该使用切片 假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数。","slug":"不要向函数传递数组的指针-而应该使用切片-假如我们想要在函数内修改一个数组-并希望调用函数的地方也能得到修改后的数组-一种解决方案是把一个指向数组的指针传递给这个函数。","link":"#不要向函数传递数组的指针-而应该使用切片-假如我们想要在函数内修改一个数组-并希望调用函数的地方也能得到修改后的数组-一种解决方案是把一个指向数组的指针传递给这个函数。","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":4.52,"words":1357},"filePathRelative":"golang/基础/15-指针.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>欢迎来到 [Golang 系列教程](/subject/2)的第 15 个教程。 ### 什么是指针？ 指针是一种存储变量内存地址（Memory Address）的变量。 ![指针示意图](<a href=\\"https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/pointer-explained.png\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/pointer-explained.png</a> \\"指针示意图\\") 如上图所示，变量 `b` 的值为 `156`，而 `b` 的内存地址为 `0x1040a124`。变量 `a` 存储了 `b` 的地址。我们就称 `a` 指向了 `b`。 ### 指针的声明 指针变量的类型为 **`*T`**，该指针指向一个 **T** 类型的变量。 接下来我们写点代码。</p>"}');export{p as comp,g as data};
