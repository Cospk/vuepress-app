import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as n}from"./app-DIJDtupu.js";const s={};function r(l,e){return n(),t("div",null,e[0]||(e[0]=[a(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>golang的nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。nil是预先说明的标识符，也即通常意义上的关键字。在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量。如果未遵循这个规则，则会引发panic。对此官方有明确的说明：[http://pkg.golang.org/pkg/builtin/#Type](http://pkg.golang.org/pkg/builtin/#Type)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>![](<a href="http://static.oschina.net/uploads/space/2014/0119/065810%5C_Lqtu%5C_182025.jpg" target="_blank" rel="noopener noreferrer">http://static.oschina.net/uploads/space/2014/0119/065810\\_Lqtu\\_182025.jpg</a>) golang中的interface类似于java的interface、PHP的interface或C++的纯虚基类。接口就是一个协议，规定了一组成员。这个没什么好说的，本文不打算对宏观上的接口概念和基于接口的范式编程做剖析。golang语言的接口有其独到之处：只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方。这种做法的学名叫做[Structural Typing](<a href="http://en.wikipedia.org/wiki/Structural%5C_type%5C_system" target="_blank" rel="noopener noreferrer">http://en.wikipedia.org/wiki/Structural\\_type\\_system</a>)，有人也把它看作是一种静态的Duck Typing。所谓类型T的公开方法完全满足接口I的要求，也即是类型T实现了接口I所规定的一组成员。 在底层，interface作为两个成员来实现，一个类型和一个值。对此官方也有文档说明：，如果您不习惯看英文，这里有一篇柴大的翻译：[Go中error类型的nil值和nil](<a href="http://my.oschina.net/chai2010/blog/117923" target="_blank" rel="noopener noreferrer">http://my.oschina.net/chai2010/blog/117923</a>) 。 接下来通过编写测试代码和gdb来看看interface倒底是什么。会用到反射，如果您不太了解golang的反射是什么，这里有刑星翻译自官方博客的一篇文章：[反射的规则](<a href="http://mikespook.com/2011/09/%E5%8F%8D%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99/" target="_blank" rel="noopener noreferrer">http://mikespook.com/2011/09/反射的规则/</a>)，原文在：[laws-of-reflection](<a href="http://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener noreferrer">http://blog.golang.org/laws-of-reflection</a>)。 $GOPATH/src \\----interface\\_test \\--------main.go main.go的代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;fmt&quot; &quot;reflect&quot; ) func main() { var val interface{} = int64(58) fmt.Println(reflect.TypeOf(val)) val = 50 fmt.Println(reflect.TypeOf(val)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们已经知道接口类型的变量底层是作为两个成员来实现，一个是type，一个是data。type用于存储变量的动态类型，data用于存储变量的具体数据。在上面的例子中，第一条打印语句输出的是：int64。这是因为已经显示的将类型为int64的数据58赋值给了interface类型的变量val���所以val的底层结构应该是：(int64, 58)。我们暂且用这种二元组的方式来描述，二元组的第一个成员为type，第二个成员为data。第二条打印语句输出的是：int。这是因为字面量的整数在golang中默认的类型是int，所以这个时候val的底层结构就变成了：(int, 50)。借助于gdb很容易观察到这点：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GOPATH/src/interface\\_test $ go build -gcflags &quot;-N -l&quot; $ gdb interface\\_test</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>![](<a href="http://static.oschina.net/uploads/space/2014/0119/142225%5C_3P7p%5C_182025.jpg" target="_blank" rel="noopener noreferrer">http://static.oschina.net/uploads/space/2014/0119/142225\\_3P7p\\_182025.jpg</a>) 接下来说说interface类型的值和nil的比较问题。这是个比较经典的问题，也算是golang的一个坑。 ![](<a href="http://static.oschina.net/uploads/space/2014/0119/152857%5C_7lsq%5C_182025.jpg" target="_blank" rel="noopener noreferrer">http://static.oschina.net/uploads/space/2014/0119/152857\\_7lsq\\_182025.jpg</a>)                                                                                                                 ---来自柴大的翻译 接着来看代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;fmt&quot; ) func main() { var val interface{} = nil if val == nil { fmt.Println(&quot;val is nil&quot;) } else { fmt.Println(&quot;val is not nil&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>变量val是interface类型，它的底层结构必然是(type, data)。由于nil是untyped(无类型)，而又将nil赋值给了变量val，所以val实际上存储的是(nil, nil)。因此很容易就知道val和nil的相等比较是为true的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GOPATH/src/interface\\_test $ go build $ ./interface\\_test val is nil</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于将任何其它有意义的值类型赋值给val，都导致val持有一个有效的类型和数据。也就是说变量val的底层结构肯定不为(nil, nil)，因此它和nil的相等比较总是为false。 上面的讨论都是在围绕值类型来进行的。在继续讨论之前，让我们来看一种特例：(\\*interface{})(nil)。将nil转成interface类型的指针，其实得到的结果仅仅是空接口类型指针并且它指向无效的地址。注意是空接口类型指针而不是空指针，这两者的区别蛮大的，学过C的童鞋都知道空指针是什么概念。 关于(\\*interface{})(nil)还有一些要注意的地方。这里仅仅是拿(\\*interface{})(nil)来举例，对于(\\*int)(nil)、(\\*byte)(nil)等等来说是一样的。上面的代码定义了接口指针类型变量val，它指向无效的地址(0x0)，因此val持有无效的数据。但它是有类型的(\\*interface{})。所以val的底层结构应该是：(\\*interface{}, nil)。有时候您会看到(\\*interface{})(nil)的应用，比如var ptrIface = (\\*interface{})(nil)，如果您接下来将ptrIface指向其它类型的指针，将通不过编译。或者您这样赋值：\\*ptrIface = 123，那样的话编译是通过了，但在运行时还是会panic的，这是因为ptrIface指向的是无效的内存地址。其实声明类似ptrIface这样的变量，是因为使用者只是关心指针的类型，而忽略它存储的值是什么。还是以例子来说明：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;fmt&quot; ) func main() { var val interface{} = (\\*interface{})(nil) // val = (\\*int)(nil) if val == nil { fmt.Println(&quot;val is nil&quot;) } else { fmt.Println(&quot;val is not nil&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>很显然，无论该指针的值是什么：(\\*interface{}, nil)，这样的接口值总是非nil的，即使在该指针的内部为nil。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GOPATH/src/interface\\_test $ go build $ ./interface\\_test val is not nil</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>interface类型的变量和nil的相等比较出现最多的地方应该是error接口类型的值与nil的比较。有时候您想自定义一个返回错误的函数来做这个事，可能会写出以下代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;fmt&quot; ) type data struct{} func (this \\*data) Error() string { return &quot;&quot; } func test() error { var p \\*data = nil return p } func main() { var e error = test() if e == nil { fmt.Println(&quot;e is nil&quot;) } else { fmt.Println(&quot;e is not nil&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但是很可惜，以上代码是有问题的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GOPATH/src/interface\\_test $ go build $ ./interface\\_test e is not nil</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们可以来分析一下。error是一个接口类型，test方法中返回的指针p虽然数据是nil，但是由于它被返回成包装的error类型，也即它是有类型的。所以它的底层结构应该是(\\*data, nil)，很明显它是非nil的。 可以打印观察下底层结构数据：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;fmt&quot; &quot;unsafe&quot; ) type data struct{} func (this \\*data) Error() string { return &quot;&quot; } func test() error { var p \\*data = nil return p } func main() { var e error = test() d := (\\*struct { itab uintptr data uintptr })(unsafe.Pointer(&amp;e)) fmt.Println(d) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GOPATH/src/interface\\_test $ go build $ ./interface\\_test &amp;{3078907912 0}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>正确的做法应该是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;fmt&quot; ) type data struct{} func (this \\*data) Error() string { return &quot;&quot; } func bad() bool { return true } func test() error { var p \\*data = nil if bad() { return p } return nil } func main() { var e error = test() if e == nil { fmt.Println(&quot;e is nil&quot;) } else { fmt.Println(&quot;e is not nil&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>--- 有疑问加站长微信联系（非本文作者） ![](<a href="https://static.golangjob.cn/static/img/footer.png?imageView2/2/w/280" target="_blank" rel="noopener noreferrer">https://static.golangjob.cn/static/img/footer.png?imageView2/2/w/280</a>)</p>`,23)]))}const d=i(s,[["render",r],["__file","golang--详解interface和nil.html.vue"]]),p=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/golang--%E8%AF%A6%E8%A7%A3interface%E5%92%8Cnil.html","title":"\\"\\"golang: 详解interface和nil\\"\\"","lang":"zh-CN","frontmatter":{"title":"\\"\\"golang: 详解interface和nil\\"\\"","source_url":"https://studygolang.com/articles/671","category":"Go原理教程","description":"![](http://static.oschina.net/uploads/space/2014/0119/065810\\\\_Lqtu\\\\_182025.jpg) golang中的interface类似于java的interface、PHP的interface或C++的纯虚基类。接口就是一个协议，规定了一组成员。这个没什么好说的，本文不打算对宏观上的接口概...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang--%E8%AF%A6%E8%A7%A3interface%E5%92%8Cnil.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"\\"\\"golang: 详解interface和nil\\"\\""}],["meta",{"property":"og:description","content":"![](http://static.oschina.net/uploads/space/2014/0119/065810\\\\_Lqtu\\\\_182025.jpg) golang中的interface类似于java的interface、PHP的interface或C++的纯虚基类。接口就是一个协议，规定了一组成员。这个没什么好说的，本文不打算对宏观上的接口概..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\\\\\"\\\\\\"golang: 详解interface和nil\\\\\\"\\\\\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":5.69,"words":1707},"filePathRelative":"golang/原理/theory/golang--详解interface和nil.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>golang的nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。nil是预先说明的标识符，也即通常意义上的关键字。在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量。如果未遵循这个规则，则会引发panic。对此官方有明确的说明：[http://pkg.golang.org/pkg/builtin/#Type](http://pkg.golang.org/pkg/builtin/#Type)</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{d as comp,p as data};
