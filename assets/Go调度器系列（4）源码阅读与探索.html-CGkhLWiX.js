import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as t,o as a}from"./app-DIJDtupu.js";const n={};function o(r,e){return a(),s("div",null,e[0]||(e[0]=[t('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>各位朋友，这次想跟大家分享一下Go调度器源码阅读相关的知识和经验，网络上已经有很多剖析源码的好文章，所以这篇文章**不是又一篇源码剖析文章，注重的不是源码分析分享，而是带给大家一些学习经验，希望大家能更好的阅读和掌握Go调度器的实现**。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>本文主要分2个部分： 1. **解决如何阅读源码的问题**。阅读源码本质是把脑海里已经有的调度设计，看看到底是不是这么实现的，是怎么实现的。 2. **带给你一个探索Go调度器实现的办法**。源码都到手了，你可以修改、**窥探**，通过这种方式解决阅读源码过程中的疑问，验证一些想法。比如：负责调度的是g0，怎么才能`schedule()`在执行时，当前是g0呢？ ## [](#如何阅读源码 &quot;如何阅读源码&quot;)如何阅读源码 ### [](#阅读前提 &quot;阅读前提&quot;)阅读前提 阅读Go源码前，最好已经掌握Go调度器的设计和原理，如果你还无法回答以下问题： 1. 为什么需要Go调度器？ 2. Go调度器与系统调度器有什么区别和关系/联系？ 3. G、P、M是什么，三者的关系是什么？ 4. P有默认几个？ 5. M同时能绑定几个P？ 6. M怎么获得G？ 7. M没有G怎么办？ 8. 为什么需要全局G队列？ 9. Go调度器中的负载均衡的2种方式是什么？ 10. work stealing是什么？什么原理？ 11. 系统调用对G、P、M有什么影响？ 12. Go调度器抢占是什么样的？一定能抢占成功吗？ 建议阅读Go调度器系列文章，以及文章中的参考资料： 1. [Go调度器系列（1）起源](<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/" target="_blank" rel="noopener noreferrer">http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/</a>) 2. [Go调度器系列（2）宏观看调度器](<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/" target="_blank" rel="noopener noreferrer">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a>) 3. [Go调度器系列（3）图解调度原理](<a href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/" target="_blank" rel="noopener noreferrer">http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/</a>) ### [](#优秀源码资料推荐 &quot;优秀源码资料推荐&quot;)优秀源码资料推荐 既然你已经能回答以上问题，说明你对Go调度器的设计已经有了一定的掌握，关于Go调度器源码的优秀资料已经有很多，我这里推荐2个： 1. **雨痕的Go源码剖析**六章并发调度，不止是源码，是以源码为基础进行了详细的Go调度器介绍：ttps://github.com/qyuhen/book 2. **Go夜读**第12期，golang中goroutine的调度，M、P、G各自的一生状态，以及转换关系： Go调度器的源码还涉及GC等，阅读源码时，可以暂时先跳过，主抓调度的逻辑。 另外，Go调度器涉及汇编，也许你不懂汇编，不用担心，雨痕的文章对汇编部分有进行解释。 最后，送大家一幅流程图，画出了主要的调度流程，大家也可边阅读边画，增加理解，**高清版可到博客下载（原图原文跳转）**。 ![](<a href="http://img.lessisbetter.site/2019-04-shcedule-flow.png" target="_blank" rel="noopener noreferrer">http://img.lessisbetter.site/2019-04-shcedule-flow.png</a>) ## [](#如何探索调度器 &quot;如何探索调度器&quot;)如何探索调度器 这部分教你探索Go调度器的源码，验证想法，主要思想就是，下载Go的源码，添加调试打印，编译修改的源文件，生成修改的go，然后使用修改go运行测试代码，观察结果。 ### [](#下载和编译Go &quot;下载和编译Go&quot;)下载和编译Go 1. Github下载，并且换到go1.11.2分支，本文所有代码修改都基于go1.11.2版本。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ GODIR=$GOPATH/src/github.com/golang/go $ mkdir -p $GODIR $ cd $GODIR/.. $ git clone https://github.com/golang/go.git $ cd go $ git fetch origin go1.11.2 $ git checkout origin/go1.11.2 $ git checkout -b go1.11.2 $ git checkout go1.11.2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>初次编译，会跑测试，耗时长一点</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GODIR/src $ ./all.bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="3"><li>以后每次修改go源码后可以这样，4分钟左右可以编译完成</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GODIR/src $ time ./make.bash Building Go cmd/dist using /usr/local/go. Building Go toolchain1 using /usr/local/go. Building Go bootstrap cmd/go (go\\_bootstrap) using Go toolchain1. Building Go toolchain2 using go\\_bootstrap and Go toolchain1. Building Go toolchain3 using go\\_bootstrap and Go toolchain2. Building packages and commands for linux/amd64. --- Installed Go for linux/amd64 in /home/xxx/go/src/github.com/golang/go Installed commands in /home/xxx/go/src/github.com/golang/go/bin real 1m11.675s user 4m4.464s sys 0m18.312s</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>编译好的go和gofmt在`$GODIR/bin`目录。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ ll $GODIR/bin total 16044 -rwxrwxr-x 1 vnt vnt 13049123 Apr 14 10:53 go -rwxrwxr-x 1 vnt vnt 3377614 Apr 14 10:53 gofmt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="4"><li>为了防止我们修改的go和过去安装的go冲突，创建igo软连接，指向修改的go。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ mkdir -p ~/testgo/bin $ cd ~/testgo/bin $ ln -sf $GODIR/bin/go igo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="5"><li>最后，把`~/testgo/bin`加入到`PATH`，就能使用`igo`来编译代码了，运行下igo，应当获得go1.11.2的版本：</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ igo version go version go1.11.2 linux/amd64</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当前，已经掌握编译和使用修改的go的办法，接下来就以1个简单的例子，教大家如何验证想法。 ### [](#验证schedule-由g0执行 &quot;验证schedule()由g0执行&quot;)验证schedule()由g0执行 阅读源码的文章，你已经知道了g0是负责调度的，并且g0是全局变量，可在runtime包的任何地方直接使用，看到`schedule()`代码如下（所在文件：`$GODIR/src/runtime/proc.go`）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { // 获取当前g，调度时这个g应当是g0 \\_g\\_ := getg() if \\_g\\_.m.locks != 0 { throw(&quot;schedule: holding locks&quot;) } // m已经被某个g锁定，先停止当前m，等待g可运行时，再执行g，并且还得到了g所在的p if \\_g\\_.m.lockedg != 0 { stoplockedm() execute(\\_g\\_.m.lockedg.ptr(), false) // Never returns. } // 省略... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>**问题**：既然g0是负责调度的，为何`schedule()`每次还都执行`_g_ := getg()`，直接使用g0不行吗？`schedule()`真的是g0执行的吗？ 在[《Go调度器系列（2）宏观看调度器》](<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/" target="_blank" rel="noopener noreferrer">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a>)这篇文章中我曾介绍了trace的用法，阅读代码时发现**使用`debug.schedtrace`和`print()`函数可以用作打印调试信息**，那我们是不是可以使用这种方法打印我们想获取的信息呢？当然可以。 另外，注意`print()`并不是`fmt.Print()`，也不是C语言的`printf`，所以不是格式化输出，它是汇编实现的，我们不深入去了解它的实现了，现在要掌握它的用法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // The print built-in function formats its arguments in an // implementation-specific way and writes the result to standard error. // Print is useful for bootstrapping and debugging; it is not guaranteed // to stay in the language. func print(args ...Type)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从上面可以看到，它接受可变长参数，我们使用的时候只需要传进去即可，但要手动控制格式。 我们修改`schedule()`函数，使用`debug.schedtrace &gt; 0`控制打印，加入3行代码，把goid给打印出来，如果始终打印goid为0，则代表调度确实是由g0执行的：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go if debug.schedtrace &gt; 0 { print(&quot;schedule(): goid = &quot;, \\_g\\_.goid, &quot;\\\\n&quot;) // 会是0吗？是的 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>`schedule()`如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { // 获取当前g，调度时这个g应当是g0 \\_g\\_ := getg() if debug.schedtrace &gt; 0 { print(&quot;schedule(): goid = &quot;, \\_g\\_.goid, &quot;\\\\n&quot;) // 会是0吗？是的 } if \\_g\\_.m.locks != 0 { throw(&quot;schedule: holding locks&quot;) } // ... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>编译igo：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ cd $GODIR/src $ ./make.bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>编写一个简单的demo（不能更简单）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main func main() { }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结果如下，你会发现所有的`schedule()`函数调用都打印`goid = 0`，足以证明Go调度器的调度由g0完成（如果你认为还是缺乏说服力，可以写复杂一些的demo）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> $ GODEBUG=schedtrace=1000 igo run demo1.go schedule(): goid = 0 schedule(): goid = 0 SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 \\[0 0 0 0 0 0 0 0\\] schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 schedule(): goid = 0 // 省略几百行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>**启发比结论更重要，希望各位朋友在学习Go调度器的时候，能多一些自己的探索和研究，而不仅仅停留在看看别人文章之上**。 ### [](#参考资料 &quot;参考资料&quot;)参考资料 1. [Installing Go from source](<a href="https://golang.org/doc/install/source" target="_blank" rel="noopener noreferrer">https://golang.org/doc/install/source</a>) &gt; 1) 如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。 &gt; 2) 本文作者：[大彬](<a href="http://lessisbetter.site/about/" target="_blank" rel="noopener noreferrer">http://lessisbetter.site/about/</a>) &gt; 3) 如果喜欢本文，随意转载，但请保留此原文链接： --- 有疑问加站长微信联系（非本文作者） ![](<a href="https://static.golangjob.cn/static/img/footer.png?imageView2/2/w/280" target="_blank" rel="noopener noreferrer">https://static.golangjob.cn/static/img/footer.png?imageView2/2/w/280</a>)</p>',28)]))}const g=i(n,[["render",o],["__file","Go调度器系列（4）源码阅读与探索.html.vue"]]),h=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E6%8E%A2%E7%B4%A2.html","title":"Go调度器系列（4）源码阅读与探索","lang":"zh-CN","frontmatter":{"title":"Go调度器系列（4）源码阅读与探索","source_url":"https://studygolang.com/articles/19762","category":"Go原理教程","description":"本文主要分2个部分： 1. **解决如何阅读源码的问题**。阅读源码本质是把脑海里已经有的调度设计，看看到底是不是这么实现的，是怎么实现的。 2. **带给你一个探索Go调度器实现的办法**。源码都到手了，你可以修改、**窥探**，通过这种方式解决阅读源码过程中的疑问，验证一些想法。比如：负责调度的是g0，怎么才能`schedule()`在执行时，当前...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E6%8E%A2%E7%B4%A2.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go调度器系列（4）源码阅读与探索"}],["meta",{"property":"og:description","content":"本文主要分2个部分： 1. **解决如何阅读源码的问题**。阅读源码本质是把脑海里已经有的调度设计，看看到底是不是这么实现的，是怎么实现的。 2. **带给你一个探索Go调度器实现的办法**。源码都到手了，你可以修改、**窥探**，通过这种方式解决阅读源码过程中的疑问，验证一些想法。比如：负责调度的是g0，怎么才能`schedule()`在执行时，当前..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go调度器系列（4）源码阅读与探索\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":7.1,"words":2129},"filePathRelative":"golang/原理/theory/Go调度器系列（4）源码阅读与探索.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>各位朋友，这次想跟大家分享一下Go调度器源码阅读相关的知识和经验，网络上已经有很多剖析源码的好文章，所以这篇文章**不是又一篇源码剖析文章，注重的不是源码分析分享，而是带给大家一些学习经验，希望大家能更好的阅读和掌握Go调度器的实现**。</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{g as comp,h as data};
