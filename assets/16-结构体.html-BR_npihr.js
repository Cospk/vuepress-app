import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as s}from"./app-DIJDtupu.js";const n={};function r(l,e){return s(),a("div",null,e[0]||(e[0]=[t('<p>欢迎来到 [Golang 系列教程](/subject/2)的第 16 个教程。 ### 什么是结构体？ 结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。 例如，一个职员有 `firstName`、`lastName` 和 `age` 三个属性，而把这些属性组合在一个结构体 `employee` 中就很合理。 ### 结构体的声明</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Employee struct { firstName string lastName string age int }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面的代码片段里，声明了一个结构体类型 `Employee`，它有 `firstName`、`lastName` 和 `age` 三个字段。通过把相同类型的字段声明在同一行，结构体可以变得更加紧凑。在上面的结构体中，`firstName` 和 `lastName` 属于相同的 `string` 类型，于是这个结构体可以重写为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Employee struct { firstName, lastName string age, salary int }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的结构体 `Employee` 称为 **命名的结构体（Named Structure）**。我们创建了名为 `Employee` 的新类型，而它可以用于创建 `Employee` 类型的结构体变量。   声明结构体时也可以不用声明一个新类型，这样的结构体类型称为 **匿名结构体（Anonymous Structure）**。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go var employee struct { firstName, lastName string age int }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上述代码片段创建一个**匿名结构体** `employee`。 ### 创建命名的结构体 通过下面代码，我们定义了一个**命名的结构体 `Employee`**。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { //creating structure using field names emp1 := Employee{ firstName: &quot;Sam&quot;, age: 25, salary: 500, lastName: &quot;Anderson&quot;, } //creating structure without using field names emp2 := Employee{&quot;Thomas&quot;, &quot;Paul&quot;, 29, 800} fmt.Println(&quot;Employee 1&quot;, emp1) fmt.Println(&quot;Employee 2&quot;, emp2) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/uhPAHeUwvK" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/uhPAHeUwvK</a>) 在上述程序的第 7 行，我们创建了一个命名的结构体 `Employee`。而在第 15 行，通过指定每个字段名的值，我们定义了结构体变量 `emp1`。字段名的顺序不一定要与声明结构体类型时的顺序相同。在这里，我们改变了 `lastName` 的位置，将其移到了末尾。这样做也不会有任何的问题。 在上面程序的第 23 行，定义 `emp2` 时我们省略了字段名。在这种情况下，就需要保证字段名的顺序与声明结构体时的顺序相同。 该程序将输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Employee 1 {Sam Anderson 25 500} Employee 2 {Thomas Paul 29 800}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="创建匿名结构体" tabindex="-1"><a class="header-anchor" href="#创建匿名结构体"><span>创建匿名结构体</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { emp3 := struct { firstName, lastName string age, salary int }{ firstName: &quot;Andreah&quot;, lastName: &quot;Nikola&quot;, age: 31, salary: 5000, } fmt.Println(&quot;Employee 3&quot;, emp3) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/TEMFM3oZiq" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/TEMFM3oZiq</a>) 在上述程序的第 3 行，我们定义了一个**匿名结构体变量** `emp3`。上面我们已经提到，之所以称这种结构体是匿名的，是因为它只是创建一个新的结构体变量 `em3`，而没有定义任何结构体类型。 该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Employee 3 {Andreah Nikola 31 5000}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="结构体的零值-zero-value-当定义好的结构体并没有被显式地初始化时-该结构体的字段将默认赋为零值。" tabindex="-1"><a class="header-anchor" href="#结构体的零值-zero-value-当定义好的结构体并没有被显式地初始化时-该结构体的字段将默认赋为零值。"><span>结构体的零值（Zero Value） 当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { var emp4 Employee //zero valued structure fmt.Println(&quot;Employee 4&quot;, emp4) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/p7%5C_OpVdFXJ" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/p7\\_OpVdFXJ</a>) 该程序定义了 `emp4`，却没有初始化任何值。因此 `firstName` 和 `lastName` 赋值为 string 的零值（`&quot;&quot;`）。而 `age` 和 `salary` 赋值为 int 的零值（0）。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Employee 4 { 0 0}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当然还可以为某些字段指定初始值，而忽略其他字段。这样，忽略的字段名会赋值为零值。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { emp5 := Employee{ firstName: &quot;John&quot;, lastName: &quot;Paul&quot;, } fmt.Println(&quot;Employee 5&quot;, emp5) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/w2gPoCnlZ1" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/w2gPoCnlZ1</a>) 在上面程序中的第 14 行和第 15 行，我们初始化了 `firstName` 和 `lastName`，而 `age` 和 `salary` 没有进行初始化。因此 `age` 和 `salary` 赋值为零值。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Employee 5 {John Paul 0 0}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="访问结构体的字段-点号操作符-用于访问结构体的字段。" tabindex="-1"><a class="header-anchor" href="#访问结构体的字段-点号操作符-用于访问结构体的字段。"><span>访问结构体的字段 点号操作符 `.` 用于访问结构体的字段。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { emp6 := Employee{&quot;Sam&quot;, &quot;Anderson&quot;, 55, 6000} fmt.Println(&quot;First Name:&quot;, emp6.firstName) fmt.Println(&quot;Last Name:&quot;, emp6.lastName) fmt.Println(&quot;Age:&quot;, emp6.age) fmt.Printf(&quot;Salary: $%d&quot;, emp6.salary) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/GPd%5C_sT85IS" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/GPd\\_sT85IS</a>) 上面程序中的 **emp6.firstName** 访问了结构体 `emp6` 的字段 `firstName`。该程序输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> First Name: Sam Last Name: Anderson Age: 55 Salary: $6000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>还可以创建零值的 `struct`，以后再给各个字段赋值。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { var emp7 Employee emp7.firstName = &quot;Jack&quot; emp7.lastName = &quot;Adams&quot; fmt.Println(&quot;Employee 7:&quot;, emp7) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/ZEOx10g7nN" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/ZEOx10g7nN</a>) 在上面程序中，我们定义了 `emp7`，接着给 `firstName` 和 `lastName` 赋值。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Employee 7: {Jack Adams 0 0}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="结构体的指针-还可以创建指向结构体的指针。" tabindex="-1"><a class="header-anchor" href="#结构体的指针-还可以创建指向结构体的指针。"><span>结构体的指针 还可以创建指向结构体的指针。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { emp8 := &amp;Employee{&quot;Sam&quot;, &quot;Anderson&quot;, 55, 6000} fmt.Println(&quot;First Name:&quot;, (\\*emp8).firstName) fmt.Println(&quot;Age:&quot;, (\\*emp8).age) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/xj87UCnBtH" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/xj87UCnBtH</a>) 在上面程序中，**emp8** 是一个指向结构体 `Employee` 的指针。`(*emp8).firstName` 表示访问结构体 `emp8` 的 `firstName` 字段。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> First Name: Sam Age: 55</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>**Go 语言允许我们在访问 `firstName` 字段时，可以使用 `emp8.firstName` 来代替显式的解引用 `(*emp8).firstName`**。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Employee struct { firstName, lastName string age, salary int } func main() { emp8 := &amp;Employee{&quot;Sam&quot;, &quot;Anderson&quot;, 55, 6000} fmt.Println(&quot;First Name:&quot;, emp8.firstName) fmt.Println(&quot;Age:&quot;, emp8.age) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/0ZE265qQ1h" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/0ZE265qQ1h</a>) 在上面的程序中，我们使用 `emp8.firstName` 来访问 `firstName` 字段，该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> First Name: Sam Age: 55</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="匿名字段-当我们创建结构体时-字段可以只有类型-而没有字段名。这样的字段称为匿名字段-anonymous-field-。-以下代码创建一个-person-结构体-它含有两个匿名字段-string-和-int-。" tabindex="-1"><a class="header-anchor" href="#匿名字段-当我们创建结构体时-字段可以只有类型-而没有字段名。这样的字段称为匿名字段-anonymous-field-。-以下代码创建一个-person-结构体-它含有两个匿名字段-string-和-int-。"><span>匿名字段 当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。 以下代码创建一个 `Person` 结构体，它含有两个匿名字段 `string` 和 `int`。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Person struct { string int }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们接下来使用匿名字段来编写一个程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Person struct { string int } func main() { p := Person{&quot;Naveen&quot;, 50} fmt.Println(p) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/YF-DgdVSrC" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/YF-DgdVSrC</a>) 在上面的程序中，结构体 `Person` 有两个匿名字段。`p := Person{&quot;Naveen&quot;, 50}` 定义了一个 `Person` 类型的变量。该程序输出 `{Naveen 50}`。 **虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型**。比如在上面的 `Person` 结构体里，虽说字段是匿名的，但 Go 默认这些字段名是它们各自的类型。所以 `Person` 结构体有两个名为 `string` 和 `int` 的字段。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Person struct { string int } func main() { var p1 Person p1.string = &quot;naveen&quot; p1.int = 50 fmt.Println(p1) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/K-fGNxVyiA" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/K-fGNxVyiA</a>) 在上面程序的第 14 行和第 15 行，我们访问了 `Person` 结构体的匿名字段，我们把字段类型作为字段名，分别为 &quot;string&quot; 和 &quot;int&quot;。上面程序的输出如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> {naveen 50}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="嵌套结构体-nested-structs-结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。" tabindex="-1"><a class="header-anchor" href="#嵌套结构体-nested-structs-结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。"><span>嵌套结构体（Nested Structs） 结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Address struct { city, state string } type Person struct { name string age int address Address } func main() { var p Person p.name = &quot;Naveen&quot; p.age = 50 p.address = Address { city: &quot;Chicago&quot;, state: &quot;Illinois&quot;, } fmt.Println(&quot;Name:&quot;, p.name) fmt.Println(&quot;Age:&quot;,p.age) fmt.Println(&quot;City:&quot;,p.address.city) fmt.Println(&quot;State:&quot;,p.address.state) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/46jkQFdTPO" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/46jkQFdTPO</a>) 上面的结构体 `Person` 有一个字段 `address`，而 `address` 也是结构体。该程序输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Name: Naveen Age: 50 City: Chicago State: Illinois</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="提升字段-promoted-fields-如果是结构体中有匿名的结构体类型字段-则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样-可以用外部结构体直接访问。我知道这种定义很复杂-所以我们直接研究下代码来理解吧。" tabindex="-1"><a class="header-anchor" href="#提升字段-promoted-fields-如果是结构体中有匿名的结构体类型字段-则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样-可以用外部结构体直接访问。我知道这种定义很复杂-所以我们直接研究下代码来理解吧。"><span>提升字段（Promoted Fields） 如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。我知道这种定义很复杂，所以我们直接研究下代码来理解吧。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Address struct { city, state string } type Person struct { name string age int Address }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面的代码片段中，`Person` 结构体有一个匿名字段 `Address`，而 `Address` 是一个结构体。现在结构体 `Address` 有 `city` 和 `state` 两个字段，访问这两个字段就像在 `Person` 里直接声明的一样，因此我们称之为提升字段。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Address struct { city, state string } type Person struct { name string age int Address } func main() { var p Person p.name = &quot;Naveen&quot; p.age = 50 p.Address = Address{ city: &quot;Chicago&quot;, state: &quot;Illinois&quot;, } fmt.Println(&quot;Name:&quot;, p.name) fmt.Println(&quot;Age:&quot;, p.age) fmt.Println(&quot;City:&quot;, p.city) //city is promoted field fmt.Println(&quot;State:&quot;, p.state) //state is promoted field }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/OgeHCJYoEy" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/OgeHCJYoEy</a>) 在上面代码中的第 26 行和第 27 行，我们使用了语法 `p.city` 和 `p.state`，访问提升字段 `city` 和 `state` 就像它们是在结构体 `p` 中声明的一样。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Name: Naveen Age: 50 City: Chicago State: Illinois</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="导出结构体和字段-如果结构体名称以大写字母开头-则它是其他包可以访问的导出类型-exported-type-。同样-如果结构体里的字段首字母大写-它也能被其他包访问到。-让我们使用自定义包-编写一个程序来更好地去理解它。-在你的-go-工作区的-src-目录中-创建一个名为-structs-的文件夹。另外在-structs-中再创建一个目录-computer-。-在-computer-目录中-在名为-spec-go-的文件中保存下面的程序。" tabindex="-1"><a class="header-anchor" href="#导出结构体和字段-如果结构体名称以大写字母开头-则它是其他包可以访问的导出类型-exported-type-。同样-如果结构体里的字段首字母大写-它也能被其他包访问到。-让我们使用自定义包-编写一个程序来更好地去理解它。-在你的-go-工作区的-src-目录中-创建一个名为-structs-的文件夹。另外在-structs-中再创建一个目录-computer-。-在-computer-目录中-在名为-spec-go-的文件中保存下面的程序。"><span>导出结构体和字段 如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。 让我们使用自定义包，编写一个程序来更好地去理解它。 在你的 Go 工作区的 `src` 目录中，创建一个名为 `structs` 的文件夹。另外在 `structs` 中再创建一个目录 `computer`。 在 `computer` 目录中，在名为 `spec.go` 的文件中保存下面的程序。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package computer type Spec struct { //exported struct Maker string //exported field model string //unexported field Price int //exported field }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的代码片段中，创建了一个 `computer` 包，里面有一个导出结构体类型 `Spec`。`Spec` 有两个导出字段 `Maker` 和 `Price`，和一个未导出的字段 `model`。接下来我们会在 main 包中导入这个包，并使用 `Spec` 结构体。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import &quot;structs/computer&quot; import &quot;fmt&quot; func main() { var spec computer.Spec spec.Maker = &quot;apple&quot; spec.Price = 50000 fmt.Println(&quot;Spec:&quot;, spec) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>包结构如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> src structs computer spec.go main.go</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上述程序的第 3 行，我们导入了 `computer` 包。在第 8 行和第 9 行，我们访问了结构体 `Spec` 的两个导出字段 `Maker` 和 `Price`。执行命令 `go install structs` 和 `workspacepath/bin/structs`，运行该程序。 如果我们试图访问未导出的字段 `model`，编译器会报错。将 `main.go` 的内容替换为下面的代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import &quot;structs/computer&quot; import &quot;fmt&quot; func main() { var spec computer.Spec spec.Maker = &quot;apple&quot; spec.Price = 50000 spec.model = &quot;Mac Mini&quot; fmt.Println(&quot;Spec:&quot;, spec) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面程序的第 10 行，我们试图访问未导出的字段 `model`。如果运行这个程序，编译器会产生错误：**spec.model undefined (cannot refer to unexported field or method model)**。 ### 结构体相等性（Structs Equality） **结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的**。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type name struct { firstName string lastName string } func main() { name1 := name{&quot;Steve&quot;, &quot;Jobs&quot;} name2 := name{&quot;Steve&quot;, &quot;Jobs&quot;} if name1 == name2 { fmt.Println(&quot;name1 and name2 are equal&quot;) } else { fmt.Println(&quot;name1 and name2 are not equal&quot;) } name3 := name{firstName:&quot;Steve&quot;, lastName:&quot;Jobs&quot;} name4 := name{} name4.firstName = &quot;Steve&quot; if name3 == name4 { fmt.Println(&quot;name3 and name4 are equal&quot;) } else { fmt.Println(&quot;name3 and name4 are not equal&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/AU1FkdsPk7" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/AU1FkdsPk7</a>) 在上面的代码中，结构体类型 `name` 包含两个 `string` 类型。由于字符串是可比较的，因此可以比较两个 `name` 类型的结构体变量。 上面代码中 `name1` 和 `name2` 相等，而 `name3` 和 `name4` 不相等。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> name1 and name2 are equal name3 and name4 are not equal</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>**如果结构体包含不可比较的字段，则结构体变量也不可比较。**</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type image struct { data map\\[int\\]int } func main() { image1 := image{data: map\\[int\\]int{ 0: 155, }} image2 := image{data: map\\[int\\]int{ 0: 155, }} if image1 == image2 { fmt.Println(&quot;image1 and image2 are equal&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在线运行程序](<a href="https://play.golang.org/p/T4svXOTYSg" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/T4svXOTYSg</a>) 在上面代码中，结构体类型 `image` 包含一个 `map` 类型的字段。由于 `map` 类型是不可比较的，因此 `image1` 和 `image2` 也不可比较。如果运行该程序，编译器会报错：**`main.go:18: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)`**。 [github](<a href="https://github.com/golangbot/structs" target="_blank" rel="noopener noreferrer">https://github.com/golangbot/structs</a>) 上有本教程的源代码。 **上一教程 - [指针](<a href="https://studygolang.com/articles/12262" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12262</a>)** **下一教程 - [方法](<a href="https://studygolang.com/articles/12264" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12264</a>)**</p>',71)]))}const p=i(n,[["render",r],["__file","16-结构体.html.vue"]]),h=JSON.parse('{"path":"/golang/%E5%9F%BA%E7%A1%80/16-%E7%BB%93%E6%9E%84%E4%BD%93.html","title":"Go 系列教程 —— 16. 结构体","lang":"zh-CN","frontmatter":{"title":"Go 系列教程 —— 16. 结构体","source_url":"https://studygolang.com/articles/12263","category":"Go系列教程","description":"欢迎来到 [Golang 系列教程](/subject/2)的第 16 个教程。 ### 什么是结构体？ 结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。 例如，一个职员有 `firstName`、`lastName` 和 `age` 三个属性，而把这些属性组合在...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%9F%BA%E7%A1%80/16-%E7%BB%93%E6%9E%84%E4%BD%93.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 系列教程 —— 16. 结构体"}],["meta",{"property":"og:description","content":"欢迎来到 [Golang 系列教程](/subject/2)的第 16 个教程。 ### 什么是结构体？ 结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。 例如，一个职员有 `firstName`、`lastName` 和 `age` 三个属性，而把这些属性组合在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 系列教程 —— 16. 结构体\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"创建匿名结构体","slug":"创建匿名结构体","link":"#创建匿名结构体","children":[]},{"level":3,"title":"结构体的零值（Zero Value） 当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。","slug":"结构体的零值-zero-value-当定义好的结构体并没有被显式地初始化时-该结构体的字段将默认赋为零值。","link":"#结构体的零值-zero-value-当定义好的结构体并没有被显式地初始化时-该结构体的字段将默认赋为零值。","children":[]},{"level":3,"title":"访问结构体的字段 点号操作符 `.` 用于访问结构体的字段。","slug":"访问结构体的字段-点号操作符-用于访问结构体的字段。","link":"#访问结构体的字段-点号操作符-用于访问结构体的字段。","children":[]},{"level":3,"title":"结构体的指针 还可以创建指向结构体的指针。","slug":"结构体的指针-还可以创建指向结构体的指针。","link":"#结构体的指针-还可以创建指向结构体的指针。","children":[]},{"level":3,"title":"匿名字段 当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。 以下代码创建一个 `Person` 结构体，它含有两个匿名字段 `string` 和 `int`。","slug":"匿名字段-当我们创建结构体时-字段可以只有类型-而没有字段名。这样的字段称为匿名字段-anonymous-field-。-以下代码创建一个-person-结构体-它含有两个匿名字段-string-和-int-。","link":"#匿名字段-当我们创建结构体时-字段可以只有类型-而没有字段名。这样的字段称为匿名字段-anonymous-field-。-以下代码创建一个-person-结构体-它含有两个匿名字段-string-和-int-。","children":[]},{"level":3,"title":"嵌套结构体（Nested Structs） 结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。","slug":"嵌套结构体-nested-structs-结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。","link":"#嵌套结构体-nested-structs-结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。","children":[]},{"level":3,"title":"提升字段（Promoted Fields） 如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。我知道这种定义很复杂，所以我们直接研究下代码来理解吧。","slug":"提升字段-promoted-fields-如果是结构体中有匿名的结构体类型字段-则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样-可以用外部结构体直接访问。我知道这种定义很复杂-所以我们直接研究下代码来理解吧。","link":"#提升字段-promoted-fields-如果是结构体中有匿名的结构体类型字段-则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样-可以用外部结构体直接访问。我知道这种定义很复杂-所以我们直接研究下代码来理解吧。","children":[]},{"level":3,"title":"导出结构体和字段 如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。 让我们使用自定义包，编写一个程序来更好地去理解它。 在你的 Go 工作区的 `src` 目录中，创建一个名为 `structs` 的文件夹。另外在 `structs` 中再创建一个目录 `computer`。 在 `computer` 目录中，在名为 `spec.go` 的文件中保存下面的程序。","slug":"导出结构体和字段-如果结构体名称以大写字母开头-则它是其他包可以访问的导出类型-exported-type-。同样-如果结构体里的字段首字母大写-它也能被其他包访问到。-让我们使用自定义包-编写一个程序来更好地去理解它。-在你的-go-工作区的-src-目录中-创建一个名为-structs-的文件夹。另外在-structs-中再创建一个目录-computer-。-在-computer-目录中-在名为-spec-go-的文件中保存下面的程序。","link":"#导出结构体和字段-如果结构体名称以大写字母开头-则它是其他包可以访问的导出类型-exported-type-。同样-如果结构体里的字段首字母大写-它也能被其他包访问到。-让我们使用自定义包-编写一个程序来更好地去理解它。-在你的-go-工作区的-src-目录中-创建一个名为-structs-的文件夹。另外在-structs-中再创建一个目录-computer-。-在-computer-目录中-在名为-spec-go-的文件中保存下面的程序。","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":9.87,"words":2960},"filePathRelative":"golang/基础/16-结构体.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>欢迎来到 [Golang 系列教程](/subject/2)的第 16 个教程。 ### 什么是结构体？ 结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。 例如，一个职员有 `firstName`、`lastName` 和 `age` 三个属性，而把这些属性组合在一个结构体 `employee` 中就很合理。 ### 结构体的声明</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>go type Employee struct { firstName string lastName string age int }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{p as comp,h as data};
