import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as s,o as a}from"./app-DIJDtupu.js";const r={};function g(o,t){return a(),i("div",null,t[0]||(t[0]=[s('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>text func newstack() { thisg := getg() // TODO: double check all gp. shouldn&#39;t be getg(). if thisg.m.morebuf.g.ptr().stackguard0 == stackFork { throw(&quot;stack growth after fork&quot;) } if thisg.m.morebuf.g.ptr() != thisg.m.curg { print(&quot;runtime: newstack called from g=&quot;, thisg.m.morebuf.g, &quot;\\\\n&quot;+&quot;\\\\tm=&quot;, thisg.m, &quot; m-&gt;curg=&quot;, thisg.m.curg, &quot; m-&gt;g0=&quot;, thisg.m.g0, &quot; m-&gt;gsignal=&quot;, thisg.m.gsignal, &quot;\\\\n&quot;) morebuf := thisg.m.morebuf traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr()) throw(&quot;runtime: wrong goroutine in newstack&quot;) } gp := thisg.m.curg morebuf := thisg.m.morebuf thisg.m.morebuf.pc = 0 thisg.m.morebuf.lr = 0 thisg.m.morebuf.sp = 0 thisg.m.morebuf.g = 0 rewindmorestack(&amp;gp.sched) // NOTE: stackguard0 may change underfoot, if another thread // is about to try to preempt gp. Read it just once and use that same // value now and below. preempt := atomicloaduintptr(&amp;gp.stackguard0) == stackPreempt if preempt { if thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != &quot;&quot; || thisg.m.p.ptr().status != \\_Prunning { // Let the goroutine keep running for now. // gp-&gt;preempt is set, so it will be preempted next time. gp.stackguard0 = gp.stack.lo + \\_StackGuard gogo(&amp;gp.sched) // never return } } ...... // 进行重新调度 if preempt { if gp == thisg.m.g0 { throw(&quot;runtime: preempt g0&quot;) } if thisg.m.p == 0 &amp;&amp; thisg.m.locks == 0 { throw(&quot;runtime: g is running but p is not&quot;) } if gp.preemptscan { for !castogscanstatus(gp, \\_Gwaiting, \\_Gscanwaiting) { // Likely to be racing with the GC as // it sees a \\_Gwaiting and does the // stack scan. If so, gcworkdone will // be set and gcphasework will simply // return. } if !gp.gcscandone { scanstack(gp) gp.gcscandone = true } gp.preemptscan = false gp.preempt = false casfrom\\_Gscanstatus(gp, \\_Gscanwaiting, \\_Gwaiting) casgstatus(gp, \\_Gwaiting, \\_Grunning) gp.stackguard0 = gp.stack.lo + \\_StackGuard gogo(&amp;gp.sched) // never return } // Act like goroutine called runtime.Gosched. casgstatus(gp, \\_Gwaiting, \\_Grunning) // 放弃当前协程，调度新协程执行 gopreempt\\_m(gp) // never return } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',1)]))}const p=e(r,[["render",g],["__file","协程调度时机三：抢占式调度.html.vue"]]),c=JSON.parse(`{"path":"/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%89%EF%BC%9A%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.html","title":"协程调度时机三：抢占式调度","lang":"zh-CN","frontmatter":{"title":"协程调度时机三：抢占式调度","source_url":"https://studygolang.com/articles/11865","category":"Go原理教程","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%89%EF%BC%9A%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"协程调度时机三：抢占式调度"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"协程调度时机三：抢占式调度\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":0.99,"words":298},"filePathRelative":"golang/原理/theory/协程调度时机三：抢占式调度.md","localizedDate":"2025年8月26日","excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>text func newstack() { thisg := getg() // TODO: double check all gp. shouldn't be getg(). if thisg.m.morebuf.g.ptr().stackguard0 == stackFork { throw(\\"stack growth after fork\\") } if thisg.m.morebuf.g.ptr() != thisg.m.curg { print(\\"runtime: newstack called from g=\\", thisg.m.morebuf.g, \\"\\\\\\\\n\\"+\\"\\\\\\\\tm=\\", thisg.m, \\" m-&gt;curg=\\", thisg.m.curg, \\" m-&gt;g0=\\", thisg.m.g0, \\" m-&gt;gsignal=\\", thisg.m.gsignal, \\"\\\\\\\\n\\") morebuf := thisg.m.morebuf traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr()) throw(\\"runtime: wrong goroutine in newstack\\") } gp := thisg.m.curg morebuf := thisg.m.morebuf thisg.m.morebuf.pc = 0 thisg.m.morebuf.lr = 0 thisg.m.morebuf.sp = 0 thisg.m.morebuf.g = 0 rewindmorestack(&amp;gp.sched) // NOTE: stackguard0 may change underfoot, if another thread // is about to try to preempt gp. Read it just once and use that same // value now and below. preempt := atomicloaduintptr(&amp;gp.stackguard0) == stackPreempt if preempt { if thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != \\"\\" || thisg.m.p.ptr().status != \\\\_Prunning { // Let the goroutine keep running for now. // gp-&gt;preempt is set, so it will be preempted next time. gp.stackguard0 = gp.stack.lo + \\\\_StackGuard gogo(&amp;gp.sched) // never return } } ...... // 进行重新调度 if preempt { if gp == thisg.m.g0 { throw(\\"runtime: preempt g0\\") } if thisg.m.p == 0 &amp;&amp; thisg.m.locks == 0 { throw(\\"runtime: g is running but p is not\\") } if gp.preemptscan { for !castogscanstatus(gp, \\\\_Gwaiting, \\\\_Gscanwaiting) { // Likely to be racing with the GC as // it sees a \\\\_Gwaiting and does the // stack scan. If so, gcworkdone will // be set and gcphasework will simply // return. } if !gp.gcscandone { scanstack(gp) gp.gcscandone = true } gp.preemptscan = false gp.preempt = false casfrom\\\\_Gscanstatus(gp, \\\\_Gscanwaiting, \\\\_Gwaiting) casgstatus(gp, \\\\_Gwaiting, \\\\_Grunning) gp.stackguard0 = gp.stack.lo + \\\\_StackGuard gogo(&amp;gp.sched) // never return } // Act like goroutine called runtime.Gosched. casgstatus(gp, \\\\_Gwaiting, \\\\_Grunning) // 放弃当前协程，调度新协程执行 gopreempt\\\\_m(gp) // never return } }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}`);export{p as comp,c as data};
