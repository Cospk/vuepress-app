import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as s}from"./app-DIJDtupu.js";const n={};function l(r,e){return s(),t("div",null,e[0]||(e[0]=[a('<p>![reading files](<a href="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/golang-read-files.png" target="_blank" rel="noopener noreferrer">https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/golang-read-files.png</a>) 欢迎来到 [Golang 系列教程](<a href="https://studygolang.com/subject/2" target="_blank" rel="noopener noreferrer">https://studygolang.com/subject/2</a>)的第 35 篇。 文件读取是所有编程语言中最常见的操作之一。本教程我们会学习如何使用 Go 读取文件。 本教程分为如下小节。 - 将整个文件读取到内存 - 使用绝对文件路径 - 使用命令行标记来传递文件路径 - 将文件绑定在二进制文件中 - 分块读取文件 - 逐行读取文件 ## 将整个文件读取到内存 将整个文件读取到内存是最基本的文件操作之一。这需要使用 [`ioutil`](<a href="https://golang.org/pkg/io/ioutil/" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/io/ioutil/</a>) 包中的 [`ReadFile`](<a href="https://golang.org/pkg/io/ioutil/#ReadFile" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/io/ioutil/#ReadFile</a>) 函数。 让我们在 Go 程序所在的目录中，读取一个文件。我已经在 GOPATH（译注：原文是 GOROOT，应该是笔误）中创建了文件夹，在该文件夹内部，有一个文本文件 `test.txt`，我们会使用 Go 程序 `filehandling.go` 来读取它。`test.txt` 包含文本 “Hello World. Welcome to file handling in Go”。我的文件夹结构如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> src filehandling filehandling.go test.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来我们来看看代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; ) func main() { data, err := ioutil.ReadFile(&quot;test.txt&quot;) if err != nil { fmt.Println(&quot;File reading error&quot;, err) return } fmt.Println(&quot;Contents of file:&quot;, string(data)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>由于无法在 playground 上读取文件，因此请在你的本地环境运行这个程序。 在上述程序的第 9 行，程序会读取文件，并返回一个字节[切片](<a href="https://studygolang.com/articles/12121" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12121</a>)，而这个切片保存在 `data` 中。在第 14 行，我们将 `data` 转换为 `string`，显示出文件的内容。 请在 **test.txt** 所在的位置运行该程序。 例如，对于 **linux/mac**，如果 **test.txt** 位于 **/home/naveen/go/src/filehandling**，可以使用下列步骤来运行程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash $ cd /home/naveen/go/src/filehandling/ $ go install filehandling $ workspacepath/bin/filehandling</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于 **windows**，如果 **test.txt** 位于 **C:\\Users\\naveen.r\\go\\src\\filehandling**，则使用下列步骤。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash &gt; cd C:\\\\Users\\\\naveen.r\\\\go\\\\src\\\\filehandling &gt; go install filehandling &gt; workspacepath\\\\bin\\\\filehandling.exe</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash Contents of file: Hello World. Welcome to file handling in Go.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果在其他位置运行这个程序（比如 `/home/userdirectory`），会打印下面的错误。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash File reading error open test.txt: The system cannot find the file specified.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是因为 Go 是编译型语言。`go install` 会根据源代码创建一个二进制文件。二进制文件独立于源代码，可以在任何位置上运行。由于在运行二进制文件的位置上没有找到 `test.txt`，因此程序会报错，提示无法找到指定的文件。 有三种方法可以解决这个问题。 1. 使用绝对文件路径 2. 使用命令行标记来传递文件路径 3. 将文件绑定在二进制文件中 让我们来依次介绍。 ### 1. 使用绝对文件路径 要解决问题，最简单的方法就是传入绝对文件路径。我已经修改了程序，把路径改成了绝对路径。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; ) func main() { data, err := ioutil.ReadFile(&quot;/home/naveen/go/src/filehandling/test.txt&quot;) if err != nil { fmt.Println(&quot;File reading error&quot;, err) return } fmt.Println(&quot;Contents of file:&quot;, string(data)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在可以在任何位置上运行程序，打印出 `test.txt` 的内容。 例如，可以在我的家目录运行。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash $ cd $HOME $ go install filehandling $ workspacepath/bin/filehandling</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该程序打印出了 `test.txt` 的内容。 看似这是一个简单的方法，但它的缺点是：文件必须放在程序指定的路径中，否则就会出错。 ### 2. 使用命令行标记来传递文件路径 另一种解决方案是使用命令行标记来传递文件路径。使用 [flag](<a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/flag/</a>) 包，我们可以从输入的命令行获取到文件路径，接着读取文件内容。 首先我们来看看 `flag` 包是如何工作的。`flag` 包有一个名为 [`String`](<a href="https://golang.org/pkg/flag/#String" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/flag/#String</a>) 的[函数](<a href="https://studygolang.com/articles/11892" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11892</a>)。该函数接收三个参数。第一个参数是标记名，第二个是默认值，第三个是标记的简短描述。 让我们来编写程序，从命令行读取文件名。将 `filehandling.go` 的内容替换如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;flag&quot; &quot;fmt&quot; ) func main() { fptr := flag.String(&quot;fpath&quot;, &quot;test.txt&quot;, &quot;file path to read from&quot;) flag.Parse() fmt.Println(&quot;value of fpath is&quot;, \\*fptr) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上述程序中第 8 行，通过 `String` 函数，创建了一个字符串标记，名称是 `fpath`，默认值是 `test.txt`，描述为 `file path to read from`。这个函数返回存储 flag 值的字符串[变量](<a href="https://studygolang.com/articles/11756" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11756</a>)的地址。 在程序访问 flag 之前，必须先调用 `flag.Parse()`。 在第 10 行，程序会打印出 flag 值。 使用下面命令运行程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们传入 `/path-of-file/test.txt`，赋值给了 `fpath` 标记。 该程序输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash value of fpath is /path-of-file/test.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是因为 `fpath` 的默认值是 `test.txt`。 现在我们知道如何从命令行读取文件路径了，让我们继续完成我们的文件读取程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;io/ioutil&quot; ) func main() { fptr := flag.String(&quot;fpath&quot;, &quot;test.txt&quot;, &quot;file path to read from&quot;) flag.Parse() data, err := ioutil.ReadFile(\\*fptr) if err != nil { fmt.Println(&quot;File reading error&quot;, err) return } fmt.Println(&quot;Contents of file:&quot;, string(data)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上述程序里，命令行传入文件路径，程序读取了该文件的内容。使用下面命令运行该程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>请将 `/path-of-file/` 替换为 `test.txt` 的真实路径。该程序将打印：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Contents of file: Hello World. Welcome to file handling in Go.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3-将文件绑定在二进制文件中-虽然从命令行获取文件路径的方法很好-但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件-岂不是很棒-这就是我们下面要做的事情。-有很多-包-https-studygolang-com-articles-11893-可以帮助我们实现。我们会使用-packr-https-github-com-gobuffalo-packr-因为它很简单-并且我在项目中使用它时-没有出现任何问题。-第一步就是安装-packr-包。-在命令提示符中输入下面命令-安装-packr-包。" tabindex="-1"><a class="header-anchor" href="#_3-将文件绑定在二进制文件中-虽然从命令行获取文件路径的方法很好-但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件-岂不是很棒-这就是我们下面要做的事情。-有很多-包-https-studygolang-com-articles-11893-可以帮助我们实现。我们会使用-packr-https-github-com-gobuffalo-packr-因为它很简单-并且我在项目中使用它时-没有出现任何问题。-第一步就是安装-packr-包。-在命令提示符中输入下面命令-安装-packr-包。"><span>3. 将文件绑定在二进制文件中 虽然从命令行获取文件路径的方法很好，但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件，岂不是很棒？这就是我们下面要做的事情。 有很多[包](<a href="https://studygolang.com/articles/11893" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11893</a>)可以帮助我们实现。我们会使用 [packr](<a href="https://github.com/gobuffalo/packr" target="_blank" rel="noopener noreferrer">https://github.com/gobuffalo/packr</a>)，因为它很简单，并且我在项目中使用它时，没有出现任何问题。 第一步就是安装 `packr` 包。 在命令提示符中输入下面命令，安装 `packr` 包。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash go get -u github.com/gobuffalo/packr/...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>`packr` 会把静态文件（例如 `.txt` 文件）转换为 `.go` 文件，接下来，`.go` 文件会直接嵌入到二进制文件中。`packer` 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。 我们通过程序来更好地理解它。用以下内容来替换 `handling.go` 文件。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;github.com/gobuffalo/packr&quot; ) func main() { box := packr.NewBox(&quot;../filehandling&quot;) data := box.String(&quot;test.txt&quot;) fmt.Println(&quot;Contents of file:&quot;, data) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面程序的第 10 行，我们创建了一个新盒子（New Box）。盒子表示一个文件夹，其内容会嵌入到二进制中。在这里，我指定了 `filehandling` 文件夹，其内容包含 `test.txt`。在下一行，我们读取了文件内容，并打印出来。 在开发阶段时，我们可以使用 `go install` 命令来运行程序。程序可以正常运行。`packr` 非常智能，在开发阶段可以从磁盘加载文件。 使用下面命令来运行程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash go install filehandling workspacepath/bin/filehandling</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该命令可以在其他位置运行。`packr` 很聪明，可以获取传递给 `NewBox` 命令的目录的绝对路径。 该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Contents of file: Hello World. Welcome to file handling in Go.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>你可以试着改变 `test.txt` 的内容，然后再运行 `filehandling`。可以看到，无需再次编译，程序打印出了 `test.txt` 的更新内容。完美！😃 现在我们来看看如何将 `test.txt` 打包到我们的二进制文件中。我们使用 `packr` 命令来实现。 运行下面的命令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash packr install -v filehandling</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它会打印：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash building box ../filehandling packing file filehandling.go packed file filehandling.go packing file test.txt packed file test.txt built box ../filehandling with \\[&quot;filehandling.go&quot; &quot;test.txt&quot;\\] filehandling</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该命令将静态文件绑定到了二进制文件中。 在运行上述命令之后，使用命令 `workspacepath/bin/filehandling` 来运行程序。程序会打印出 `test.txt` 的内容。于是从二进制文件中，我们读取了 `test.txt` 的内容。 如果你不知道文件到底是由二进制还是磁盘来提供，我建议你删除 `test.txt`，并在此运行 `filehandling` 命令。你将看到，程序打印出了 `test.txt` 的内容。太棒了:D。我们已经成功将静态文件嵌入到了二进制文件中。 ## 分块读取文件 在前面的章节，我们学习了如何把整个文件读取到内存。当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 [bufio](<a href="https://golang.org/pkg/bufio" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/bufio</a>) 包来完成。 让我们来编写一个程序，以 3 个字节的块为单位读取 `test.txt` 文件。如下所示，替换 `filehandling.go` 的内容。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;bufio&quot; &quot;flag&quot; &quot;fmt&quot; &quot;log&quot; &quot;os&quot; ) func main() { fptr := flag.String(&quot;fpath&quot;, &quot;test.txt&quot;, &quot;file path to read from&quot;) flag.Parse() f, err := os.Open(\\*fptr) if err != nil { log.Fatal(err) } defer func() { if err = f.Close(); err != nil { log.Fatal(err) } }() r := bufio.NewReader(f) b := make(\\[\\]byte, 3) for { \\_, err := r.Read(b) if err != nil { fmt.Println(&quot;Error reading file:&quot;, err) break } fmt.Println(string(b)) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上述程序的第 15 行，我们使用命令行标记传递的路径，打开文件。 在第 19 行，我们延迟了文件的关闭操作。 在上面程序的第 24 行，我们新建了一个缓冲读取器（buffered reader）。在下一行，我们创建了长度和容量为 3 的字节切片，程序会把文件的字节读取到切片中。 第 27 行的 `Read` [方法](<a href="https://studygolang.com/articles/12264" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12264</a>)会读取 len(b) 个字节（达到 3 字节），并返回所读取的字节数。当到达文件最后时，它会返回一个 EOF 错误。程序的其他地方比较简单，不做解释。 如果我们使用下面命令来运行程序：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash $ go install filehandling $ wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>会得到以下输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash Hel lo Wor ld. We lco me to fil e h and lin g i n G o. Error reading file: EOF</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="逐行读取文件-本节我们讨论如何使用-go-逐行读取文件。这可以使用-bufio-https-golang-org-pkg-bufio-来实现。-请将-test-txt-替换为以下内容。" tabindex="-1"><a class="header-anchor" href="#逐行读取文件-本节我们讨论如何使用-go-逐行读取文件。这可以使用-bufio-https-golang-org-pkg-bufio-来实现。-请将-test-txt-替换为以下内容。"><span>逐行读取文件 本节我们讨论如何使用 Go 逐行读取文件。这可以使用 [bufio](<a href="https://golang.org/pkg/bufio/" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/bufio/</a>) 来实现。 请将 `test.txt` 替换为以下内容。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Hello World. Welcome to file handling in Go. This is the second line of the file. We have reached the end of the file.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>逐行读取文件涉及到以下步骤。 1. 打开文件； 2. 在文件上新建一个 scanner； 3. 扫描文件并且逐行读取。 将 `filehandling.go` 替换为以下内容。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;bufio&quot; &quot;flag&quot; &quot;fmt&quot; &quot;log&quot; &quot;os&quot; ) func main() { fptr := flag.String(&quot;fpath&quot;, &quot;test.txt&quot;, &quot;file path to read from&quot;) flag.Parse() f, err := os.Open(\\*fptr) if err != nil { log.Fatal(err) } defer func() { if err = f.Close(); err != nil { log.Fatal(err) } }() s := bufio.NewScanner(f) for s.Scan() { fmt.Println(s.Text()) } err = s.Err() if err != nil { log.Fatal(err) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上述程序的第 15 行，我们用命令行标记传入的路径，打开文件。在第 24 行，我们用文件创建了一个新的 scanner。第 25 行的 `Scan()` 方法读取文件的下一行，如果可以读取，就可以使用 `Text()` 方法。 当 `Scan` 返回 false 时，除非已经到达文件末尾（此时 `Err()` 返回 `nil`），否则 `Err()` 就会返回扫描过程中出现的错误。 如果我使用下面命令来运行程序：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash $ go install filehandling $ workspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash Hello World. Welcome to file handling in Go. This is the second line of the file. We have reached the end of the file.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>本教程到此结束。希望你能喜欢，祝你愉快。 **上一教程** - [反射](<a href="https://studygolang.com/articles/13178" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/13178</a>)\\ **下一教程** - [写入文件](<a href="https://studygolang.com/articles/19475" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/19475</a>)</p>',55)]))}const g=i(n,[["render",l],["__file","35-读取文件.html.vue"]]),h=JSON.parse('{"path":"/golang/%E5%9F%BA%E7%A1%80/35-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6.html","title":"Go 系列教程 —— 35. 读取文件","lang":"zh-CN","frontmatter":{"title":"Go 系列教程 —— 35. 读取文件","source_url":"https://studygolang.com/articles/14669","category":"Go系列教程","description":"![reading files](https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/golang-read-files.png) 欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 35...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%9F%BA%E7%A1%80/35-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 系列教程 —— 35. 读取文件"}],["meta",{"property":"og:description","content":"![reading files](https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/golang-read-files.png) 欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 35..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 系列教程 —— 35. 读取文件\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"3. 将文件绑定在二进制文件中 虽然从命令行获取文件路径的方法很好，但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件，岂不是很棒？这就是我们下面要做的事情。 有很多[包](https://studygolang.com/articles/11893)可以帮助我们实现。我们会使用 [packr](https://github.com/gobuffalo/packr)，因为它很简单，并且我在项目中使用它时，没有出现任何问题。 第一步就是安装 `packr` 包。 在命令提示符中输入下面命令，安装 `packr` 包。","slug":"_3-将文件绑定在二进制文件中-虽然从命令行获取文件路径的方法很好-但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件-岂不是很棒-这就是我们下面要做的事情。-有很多-包-https-studygolang-com-articles-11893-可以帮助我们实现。我们会使用-packr-https-github-com-gobuffalo-packr-因为它很简单-并且我在项目中使用它时-没有出现任何问题。-第一步就是安装-packr-包。-在命令提示符中输入下面命令-安装-packr-包。","link":"#_3-将文件绑定在二进制文件中-虽然从命令行获取文件路径的方法很好-但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件-岂不是很棒-这就是我们下面要做的事情。-有很多-包-https-studygolang-com-articles-11893-可以帮助我们实现。我们会使用-packr-https-github-com-gobuffalo-packr-因为它很简单-并且我在项目中使用它时-没有出现任何问题。-第一步就是安装-packr-包。-在命令提示符中输入下面命令-安装-packr-包。","children":[]},{"level":2,"title":"逐行读取文件 本节我们讨论如何使用 Go 逐行读取文件。这可以使用 [bufio](https://golang.org/pkg/bufio/) 来实现。 请将 `test.txt` 替换为以下内容。","slug":"逐行读取文件-本节我们讨论如何使用-go-逐行读取文件。这可以使用-bufio-https-golang-org-pkg-bufio-来实现。-请将-test-txt-替换为以下内容。","link":"#逐行读取文件-本节我们讨论如何使用-go-逐行读取文件。这可以使用-bufio-https-golang-org-pkg-bufio-来实现。-请将-test-txt-替换为以下内容。","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":9.45,"words":2835},"filePathRelative":"golang/基础/35-读取文件.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>![reading files](<a href=\\"https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/golang-read-files.png\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/golang-read-files.png</a>) 欢迎来到 [Golang 系列教程](<a href=\\"https://studygolang.com/subject/2\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://studygolang.com/subject/2</a>)的第 35 篇。 文件读取是所有编程语言中最常见的操作之一。本教程我们会学习如何使用 Go 读取文件。 本教程分为如下小节。 - 将整个文件读取到内存 - 使用绝对文件路径 - 使用命令行标记来传递文件路径 - 将文件绑定在二进制文件中 - 分块读取文件 - 逐行读取文件 ## 将整个文件读取到内存 将整个文件读取到内存是最基本的文件操作之一。这需要使用 [`ioutil`](<a href=\\"https://golang.org/pkg/io/ioutil/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://golang.org/pkg/io/ioutil/</a>) 包中的 [`ReadFile`](<a href=\\"https://golang.org/pkg/io/ioutil/#ReadFile\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://golang.org/pkg/io/ioutil/#ReadFile</a>) 函数。 让我们在 Go 程序所在的目录中，读取一个文件。我已经在 GOPATH（译注：原文是 GOROOT，应该是笔误）中创建了文件夹，在该文件夹内部，有一个文本文件 `test.txt`，我们会使用 Go 程序 `filehandling.go` 来读取它。`test.txt` 包含文本 “Hello World. Welcome to file handling in Go”。我的文件夹结构如下：</p>"}');export{g as comp,h as data};
