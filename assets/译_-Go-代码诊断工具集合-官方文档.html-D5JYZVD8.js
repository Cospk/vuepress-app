import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as o,o as n}from"./app-DIJDtupu.js";const i={};function a(p,e){return n(),r("div",null,e[0]||(e[0]=[o('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>[Introduction](#introduction) - [Profiling](#profiling) - [Tracing](#tracing) - [Debugging](#debugging) - [Runtime statistics and events](#runtime-statistics-and-events) - [Execution tracer](#execution-tracer) - [GODEBUG](#godebug) ### Introduction Go生态系统提供了大量API和工具来诊断Go程序中的逻辑和性能问题。 此页面总结了可用的工具，并帮助Go用户针对他们的特定问题选择正确的工具。 诊断解决方案可分为以下几组： - **Profiling**：Profiling 工具分析Go程序的复杂性和成本，例如其内存使用情况和频繁调用的函数，以识别Go程序的昂贵部分。 - **Tracing**：Tracing 是一种检测代码的方法，用于分析调用或用户请求的整个生命周期中的延迟。 Traces 提供了每个组件对系统总体延迟影响的概览。 Traces 可以跨越多个Go进程。 - **Debugging**: Debugging 允许我们暂停Go程序并检查其执行。可以通过 debugging 验证程序状态和流程。 - **Runtime statistics and events**： 对运行时统计信息、事件的收集和分析提供了Go程序运行状况的高层次概览。 指标的尖峰/下降有助于我们识别吞吐量，利用率和性能的变化。 &gt; 注意：某些诊断工具可能会相互干扰。 例如，精确的 memory profiling 会扭曲 CPU profiles，而goroutine blocking profiling 会影响 scheduler trace。 隔离使用工具可获得更精确的信息。 ### Profiling Profiling 对于识别昂贵或经常调用的代码段很有用。 Go runtime 以 [pprof 可视化工具](<a href="https://github.com/google/pprof/blob/master/doc/README.md" target="_blank" rel="noopener noreferrer">https://github.com/google/pprof/blob/master/doc/README.md</a>)所期望的格式提供 [profiling data](<a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/runtime/pprof/</a>)。 在测试期间可以通过 `go test` 或 [net/http/pprof](<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/net/http/pprof/</a>) 包提供的 endpoints 收集 profiling data。 用户需要收集 profiling data 并使用 pprof 工具来过滤和可视化顶部代码路径。 [runtime/pprof](<a href="https://golang.org/pkg/runtime/pprof" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/runtime/pprof</a>) 包提供的预定义 profiles： - **cpu**: CPU profile 确定程序在活跃的消耗CPU周期（而不是在睡眠或等待I/O时）花费时间的位置。 - **heap**: Heap profile 报告内存分配样本; 用于监视当前和历史内存使用情况，并检查内存泄漏。 - **threadcreate**: Thread creation profile 报告程序中导致创建新OS线程的部分。 - **goroutine**: Goroutine profile 报告所有当前 goroutines 的 stack traces。 - **block**: Block profile 显示goroutine阻止等待同步原语（包括 timer channels）的位置。 Block profile 默认情况下未开启; 使用 `runtime.SetBlockProfileRate` 启用。 - **mutex**: Mutex profile 报告锁竞争。 如果您认为由于互斥竞争而未充分利用您的CPU，请使用此 profile。 Mutex profile 默认情况下未开启，请参阅 `runtime.SetMutexProfileFraction` 启用。 **我可以使用其他哪些 profilers 来介绍Go程序？** 在Linux上，[perf tools](<a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="noopener noreferrer">https://perf.wiki.kernel.org/index.php/Tutorial</a>) 可用于分析Go程序。 Perf 可以 profile 和展开 cgo/SWIG 代码和内核，因此深入了解native/内核性能瓶颈非常有用。 在macOS上， [Instruments](<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/" target="_blank" rel="noopener noreferrer">https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/</a>) 套件可以用来 profile Go 程序。 **我可以 profile 我的生产环境的服务吗？** 是的。 在生产环境中对程序进行 profile 是安全的，但启用某些 profiles（例如：CPU profile）会增加消耗。 您应该会看到性能降级。 在生产中打开探测器之前，可以通过测量 profiler 的开销来估计性能损失。 您可能希望定期分析您的生产服务。 特别是在具有单进程多副本的系统中，定期选择随机副本是安全的选择。 选择一个生产服务， 每隔Y秒 profile X秒并保存结果以进行可视化和分析; 然后定期重复。 可以 手动/自动 检查结果以发现问题。 profiles 收集可能会相互干扰，因此建议一次只收集一个 profile。 **可视化分析数据的最佳方法是什么？** Go tools使用 [`go tool pprof`](<a href="https://github.com/google/pprof/blob/master/doc/README.md" target="_blank" rel="noopener noreferrer">https://github.com/google/pprof/blob/master/doc/README.md</a>) 提供文本，图形和 [callgrind](<a href="http://valgrind.org/docs/manual/cl-manual.html" target="_blank" rel="noopener noreferrer">http://valgrind.org/docs/manual/cl-manual.html</a>) 可视化的 profile data。 阅读 [Profiling Go programs](<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener noreferrer">https://blog.golang.org/profiling-go-programs</a>) 以查看它们的实际使用。 ![738fb1d54bd36c74ac3c98052ed7db24.png](<a href="https://storage.googleapis.com/golangorg-assets/pprof-text.png" target="_blank" rel="noopener noreferrer">https://storage.googleapis.com/golangorg-assets/pprof-text.png</a>) &gt; 文本方式查看最大的消耗的调用 ![9271bb2658eb3b3fb8bf034d2675f4d2.png](<a href="https://storage.googleapis.com/golangorg-assets/pprof-dot.png" target="_blank" rel="noopener noreferrer">https://storage.googleapis.com/golangorg-assets/pprof-dot.png</a>) &gt; 图片方式可视化最大的消耗的调用 Weblist视图在HTML页面中逐行显示源代码最大消耗的部分。 在以下示例中，530ms用于 `runtime.concatstrings`，每行的消耗显示在列表中。 ![18b069d57a4f697cc580ea69478dea77.png](<a href="https://storage.googleapis.com/golangorg-assets/pprof-weblist.png" target="_blank" rel="noopener noreferrer">https://storage.googleapis.com/golangorg-assets/pprof-weblist.png</a>) &gt; weblist方式可视化最大的消耗的调用 另一种可视化轮廓数据的方法是[火焰图](<a href="http://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener noreferrer">http://www.brendangregg.com/flamegraphs.html</a>)。 火焰图允许您在特定的祖先路径中移动，因此您可以放大/缩小特定的代码段。[upstream pprof](<a href="https://github.com/google/pprof" target="_blank" rel="noopener noreferrer">https://github.com/google/pprof</a>)支持火焰图。 ![77471e15e5c54e282982377b454320c5.png](<a href="https://storage.googleapis.com/golangorg-assets/flame.png" target="_blank" rel="noopener noreferrer">https://storage.googleapis.com/golangorg-assets/flame.png</a>) &gt; 火焰图方式可视化以发现最昂贵的代码路径 **我是否仅限于内置profiles？** 除了 runtime 提供的工具之外，Go用户还可以通过 [pprof.Profile](<a href="https://golang.org/pkg/runtime/pprof/#Profile" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/runtime/pprof/#Profile</a>) 创建自定义 profiles，并使用现有工具对其进行检查。 **我可以在不同的路径和端口上提供 profiler handlers(/debug/pprof/…) 吗？** 是的。 默认情况下， `net/http/pprof` 包将其 handlers 注册到默认的mux，但您也可以使用从包中导出的handler net/http/pprof注册它们。 例如，以下示例将在7777端口/custom\\_debug\\_path/profile上提供 pprof.Profile handler：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> package main import ( &quot;log&quot; &quot;net/http&quot; &quot;net/http/pprof&quot; ) func main() { mux := http.NewServeMux() mux.HandleFunc(&quot;/custom\\_debug\\_path/profile&quot;, pprof.Profile) log.Fatal(http.ListenAndServe(&quot;:7777&quot;, mux)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',3)]))}const s=t(i,[["render",a],["__file","译_-Go-代码诊断工具集合-官方文档.html.vue"]]),c=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%91_-Go-%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.html","title":"\\"\\"[译] Go 代码诊断工具集合-官方文档\\"\\"","lang":"zh-CN","frontmatter":{"title":"\\"\\"[译] Go 代码诊断工具集合-官方文档\\"\\"","source_url":"https://studygolang.com/articles/22260","category":"Go原理教程","description":"[Introduction](#introduction) - [Profiling](#profiling) - [Tracing](#tracing) - [Debugging](#debugging) - [Runtime statistics and events](#runtime-statistics-and-events) - [Exec...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%91_-Go-%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"\\"\\"[译] Go 代码诊断工具集合-官方文档\\"\\""}],["meta",{"property":"og:description","content":"[Introduction](#introduction) - [Profiling](#profiling) - [Tracing](#tracing) - [Debugging](#debugging) - [Runtime statistics and events](#runtime-statistics-and-events) - [Exec..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\\\\\"\\\\\\"[译] Go 代码诊断工具集合-官方文档\\\\\\"\\\\\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":4.45,"words":1335},"filePathRelative":"golang/原理/theory/[译]-Go-代码诊断工具集合-官方文档.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{s as comp,c as data};
