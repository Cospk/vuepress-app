import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as i}from"./app-DIJDtupu.js";const t={};function l(r,a){return i(),s("div",null,a[0]||(a[0]=[n(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>## 主协程初始化</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Golang的主协程指的是运行main函数的协程，而子协程指的是在程序运行过程中由主协程创建的协程。每个线程(m)只会有一个主协程，而子协程可能会有很多很多。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>子协程和主协程在概念和内部实现上几乎没有任何区别，唯一的不同在于它们的初始栈大小不同。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>我们先看看测试过程中生成的主协程堆栈示例。我测试代码中就生成了一个主协程，通过反汇编代码看到他的样子大概如下：</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![](<a href="https://static.studygolang.com/171207/50b07f36861aac261f0b344753dcbc0a.jpg" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/171207/50b07f36861aac261f0b344753dcbc0a.jpg</a>) ## 主协程启动 分析连接器（libinit()）发现go程序的入口函数是\\_rt0\\_amd64\\_linux（linux amd64机器） ## 子协程初始化 Golang子协程堆栈在协程被创建时也一并创建，代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func newproc1(fn \\*funcval, argp \\*uint8, narg int32, nret int32, callerpc uintptr) \\*g { \\_g\\_ := getg() ...... \\_p\\_ := \\_g\\_.m.p.ptr() newg := gfget(\\_p\\_) if newg == nil { // 创建协程栈 newg = malg(\\_StackMin) casgstatus(newg, \\_Gidle, \\_Gdead) allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack. } ...... totalSize := 4\\*regSize + uintptr(siz) // extra space in case of reads slightly beyond frame if hasLinkRegister { totalSize += ptrSize } totalSize += -totalSize &amp; (spAlign - 1) // align to spAlign // 新协程的栈顶计算，将栈的基地址减去参数占用的空间 sp := newg.stack.hi - totalSize spArg := sp if hasLinkRegister { // caller&#39;s LR \\*(\\*unsafe.Pointer)(unsafe.Pointer(sp)) = nil spArg += ptrSize } ... // 设置新建协程的栈顶sp newg.sched.sp = sp } // Allocate a new g, with a stack big enough for stacksize bytes. func malg(stacksize int32) \\*g { newg := new(g) if stacksize &gt;= 0 { stacksize = round2(\\_StackSystem + stacksize) systemstack(func() { newg.stack, newg.stkbar = stackalloc(uint32(stacksize)) }) // 设置stackguard，在协程栈不够用时再重新申请新的栈 newg.stackguard0 = newg.stack.lo + \\_StackGuard newg.stackguard1 = ^uintptr(0) newg.stackAlloc = uintptr(stacksize) } return newg }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,3)]))}const o=e(t,[["render",l],["__file","Golang协程栈初始化.html.vue"]]),d=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96.html","title":"Golang协程栈初始化","lang":"zh-CN","frontmatter":{"title":"Golang协程栈初始化","source_url":"https://studygolang.com/articles/11859","category":"Go原理教程","description":"![](https://static.studygolang.com/171207/50b07f36861aac261f0b344753dcbc0a.jpg) ## 主协程启动 分析连接器（libinit()）发现go程序的入口函数是\\\\_rt0\\\\_amd64\\\\_linux（linux amd64机器） ## 子协程初始化 Golang子协程堆栈在协程被...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Golang协程栈初始化"}],["meta",{"property":"og:description","content":"![](https://static.studygolang.com/171207/50b07f36861aac261f0b344753dcbc0a.jpg) ## 主协程启动 分析连接器（libinit()）发现go程序的入口函数是\\\\_rt0\\\\_amd64\\\\_linux（linux amd64机器） ## 子协程初始化 Golang子协程堆栈在协程被..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Golang协程栈初始化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":1.5,"words":450},"filePathRelative":"golang/原理/theory/Golang协程栈初始化.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>## 主协程初始化</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>Golang的主协程指的是运行main函数的协程，而子协程指的是在程序运行过程中由主协程创建的协程。每个线程(m)只会有一个主协程，而子协程可能会有很多很多。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>子协程和主协程在概念和内部实现上几乎没有任何区别，唯一的不同在于它们的初始栈大小不同。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>我们先看看测试过程中生成的主协程堆栈示例。我测试代码中就生成了一个主协程，通过反汇编代码看到他的样子大概如下：</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{o as comp,d as data};
