import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as n}from"./app-DIJDtupu.js";const r={};function o(s,e){return n(),i("div",null,e[0]||(e[0]=[a('<p>欢迎来到 [Golang 系列教程](<a href="https://studygolang.com/subject/2" target="_blank" rel="noopener noreferrer">https://studygolang.com/subject/2</a>)的第 28 篇。 Go 通过[接口](<a href="https://studygolang.com/articles/12266" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12266</a>)来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部[方法](<a href="https://studygolang.com/articles/12264" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12264</a>)，那它就实现了该接口。现在我们来看看，利用接口，Go 是如何实现多态的。 ## 使用接口实现多态 一个类型如果定义了接口的所有方法，那它就隐式地实现了该接口。 **所有实现了接口的类型，都可以把它的值保存在一个接口类型的变量中。在 Go 中，我们使用接口的这种特性来实现多态**。 通过一个程序我们来理解 Go 语言的多态，它会计算一个组织机构的净收益。为了简单起见，我们假设这个虚构的组织所获得的收入来源于两个项目：`fixed billing` 和 `time and material`。该组织的净收益等于这两个项目的收入总和。同样为了简单起见，我们假设货币单位是美元，而无需处理美分。因此货币只需简单地用 `int` 来表示。（我建议阅读 <a href="https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413" target="_blank" rel="noopener noreferrer">https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413</a> 上的文章，学习如何表示美分。感谢 Andreas Matuschek 在评论区指出这一点。） 我们首先定义一个接口 `Income`。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Income interface { calculate() int source() string }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面定义了接口 `Interface`，它包含了两个方法：`calculate()` 计算并返回项目的收入，而 `source()` 返回项目名称。 下面我们定义一个表示 `FixedBilling` 项目的结构体类型。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type FixedBilling struct { projectName string biddedAmount int }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>项目 `FixedBillin` 有两个字段：`projectName` 表示项目名称，而 `biddedAmount` 表示组织向该项目投标的金额。 `TimeAndMaterial` 结构体用于表示项目 Time and Material。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type TimeAndMaterial struct { projectName string noOfHours int hourlyRate int }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结构体 `TimeAndMaterial` 拥有三个字段名：`projectName`、`noOfHours` 和 `hourlyRate`。 下一步我们给这些结构体类型定义方法，计算并返回实际收入和项目名称。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func (fb FixedBilling) calculate() int { return fb.biddedAmount } func (fb FixedBilling) source() string { return fb.projectName } func (tm TimeAndMaterial) calculate() int { return tm.noOfHours \\* tm.hourlyRate } func (tm TimeAndMaterial) source() string { return tm.projectName }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在项目 `FixedBilling` 里面，收入就是项目的投标金额。因此我们返回 `FixedBilling` 类型的 `calculate()` 方法。 而在项目 `TimeAndMaterial` 里面，收入等于 `noOfHours` 和 `hourlyRate` 的乘积，作为 `TimeAndMaterial` 类型的 `calculate()` 方法的返回值。 我们还通过 `source()` 方法返回了表示收入来源的项目名称。 由于 `FixedBilling` 和 `TimeAndMaterial` 两个结构体都定义了 `Income` 接口的两个方法：`calculate()` 和 `source()`，因此这两个结构体都实现了 `Income` 接口。 我们来声明一个 `calculateNetIncome` 函数，用来计算并打印总收入。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func calculateNetIncome(ic \\[\\]Income) { var netincome int = 0 for \\_, income := range ic { fmt.Printf(&quot;Income From %s = $%d\\\\n&quot;, income.source(), income.calculate()) netincome += income.calculate() } fmt.Printf(&quot;Net income of organisation = $%d&quot;, netincome) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的[函数](<a href="https://studygolang.com/articles/11892" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11892</a>)接收一个 `Income` 接口类型的[切片](<a href="https://studygolang.com/articles/12121" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12121</a>)作为参数。该函数会遍历这个接口切片，并依个调用 `calculate()` 方法，计算出总收入。该函数同样也会通过调用 `source()` 显示收入来源。根据 `Income` 接口的具体类型，程序会调用不同的 `calculate()` 和 `source()` 方法。于是，我们在 `calculateNetIncome` 函数中就实现了多态。 如果在该组织以后增加了新的收入来源，`calculateNetIncome` 无需修改一行代码，就可以正确地计算总收入了。😃 最后就剩下这个程序的 `main` 函数了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func main() { project1 := FixedBilling{projectName: &quot;Project 1&quot;, biddedAmount: 5000} project2 := FixedBilling{projectName: &quot;Project 2&quot;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25} incomeStreams := \\[\\]Income{project1, project2, project3} calculateNetIncome(incomeStreams) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面的 `main` 函数中，我们创建了三个项目，有两个是 `FixedBilling` 类型，一个是 `TimeAndMaterial` 类型。接着我们创建了一个 `Income` 类型的切片，存放了这三个项目。由于这三个项目都实现了 `Interface` 接口，因此可以把这三个项目放入 `Income` 切片。最后我们将该切片作为参数，调用了 `calculateNetIncome` 函数，显示了项目不同的收益和收入来源。 以下完整的代码供你参考。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Income interface { calculate() int source() string } type FixedBilling struct { projectName string biddedAmount int } type TimeAndMaterial struct { projectName string noOfHours int hourlyRate int } func (fb FixedBilling) calculate() int { return fb.biddedAmount } func (fb FixedBilling) source() string { return fb.projectName } func (tm TimeAndMaterial) calculate() int { return tm.noOfHours \\* tm.hourlyRate } func (tm TimeAndMaterial) source() string { return tm.projectName } func calculateNetIncome(ic \\[\\]Income) { var netincome int = 0 for \\_, income := range ic { fmt.Printf(&quot;Income From %s = $%d\\\\n&quot;, income.source(), income.calculate()) netincome += income.calculate() } fmt.Printf(&quot;Net income of organisation = $%d&quot;, netincome) } func main() { project1 := FixedBilling{projectName: &quot;Project 1&quot;, biddedAmount: 5000} project2 := FixedBilling{projectName: &quot;Project 2&quot;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25} incomeStreams := \\[\\]Income{project1, project2, project3} calculateNetIncome(incomeStreams) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/UClAagvLFT" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/UClAagvLFT</a>) 该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Income From Project 1 = $5000 Income From Project 2 = $10000 Income From Project 3 = $4000 Net income of organisation = $19000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="新增收益流-假设前面的组织通过广告业务-建立了一个新的收益流-income-stream-。我们可以看到添加它非常简单-并且计算总收益也很容易-我们无需对-calculatenetincome-函数进行任何修改。这就是多态的好处。-我们首先定义-advertisement-类型-并在-advertisement-类型中定义-calculate-和-source-方法。" tabindex="-1"><a class="header-anchor" href="#新增收益流-假设前面的组织通过广告业务-建立了一个新的收益流-income-stream-。我们可以看到添加它非常简单-并且计算总收益也很容易-我们无需对-calculatenetincome-函数进行任何修改。这就是多态的好处。-我们首先定义-advertisement-类型-并在-advertisement-类型中定义-calculate-和-source-方法。"><span>新增收益流 假设前面的组织通过广告业务，建立了一个新的收益流（Income Stream）。我们可以看到添加它非常简单，并且计算总收益也很容易，我们无需对 `calculateNetIncome` 函数进行任何修改。这就是多态的好处。 我们首先定义 `Advertisement` 类型，并在 `Advertisement` 类型中定义 `calculate()` 和 `source()` 方法。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Advertisement struct { adName string CPC int noOfClicks int } func (a Advertisement) calculate() int { return a.CPC \\* a.noOfClicks } func (a Advertisement) source() string { return a.adName }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>`Advertisement` 类型有三个字段，分别是 `adName`、`CPC`（每次点击成本）和 `noOfClicks`（点击次数）。广告的总收益等于 `CPC` 和 `noOfClicks` 的乘积。 现在我们稍微修改一下 `main` 函数，把新的收益流添加进来。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func main() { project1 := FixedBilling{projectName: &quot;Project 1&quot;, biddedAmount: 5000} project2 := FixedBilling{projectName: &quot;Project 2&quot;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25} bannerAd := Advertisement{adName: &quot;Banner Ad&quot;, CPC: 2, noOfClicks: 500} popupAd := Advertisement{adName: &quot;Popup Ad&quot;, CPC: 5, noOfClicks: 750} incomeStreams := \\[\\]Income{project1, project2, project3, bannerAd, popupAd} calculateNetIncome(incomeStreams) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们创建了两个广告项目，即 `bannerAd` 和 `popupAd`。`incomeStream` 切片包含了这两个创建的广告项目。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type Income interface { calculate() int source() string } type FixedBilling struct { projectName string biddedAmount int } type TimeAndMaterial struct { projectName string noOfHours int hourlyRate int } type Advertisement struct { adName string CPC int noOfClicks int } func (fb FixedBilling) calculate() int { return fb.biddedAmount } func (fb FixedBilling) source() string { return fb.projectName } func (tm TimeAndMaterial) calculate() int { return tm.noOfHours \\* tm.hourlyRate } func (tm TimeAndMaterial) source() string { return tm.projectName } func (a Advertisement) calculate() int { return a.CPC \\* a.noOfClicks } func (a Advertisement) source() string { return a.adName } func calculateNetIncome(ic \\[\\]Income) { var netincome int = 0 for \\_, income := range ic { fmt.Printf(&quot;Income From %s = $%d\\\\n&quot;, income.source(), income.calculate()) netincome += income.calculate() } fmt.Printf(&quot;Net income of organisation = $%d&quot;, netincome) } func main() { project1 := FixedBilling{projectName: &quot;Project 1&quot;, biddedAmount: 5000} project2 := FixedBilling{projectName: &quot;Project 2&quot;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25} bannerAd := Advertisement{adName: &quot;Banner Ad&quot;, CPC: 2, noOfClicks: 500} popupAd := Advertisement{adName: &quot;Popup Ad&quot;, CPC: 5, noOfClicks: 750} incomeStreams := \\[\\]Income{project1, project2, project3, bannerAd, popupAd} calculateNetIncome(incomeStreams) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 中运行](<a href="https://play.golang.org/p/BYRYGjSxFN" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/BYRYGjSxFN</a>) 上面程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Income From Project 1 = $5000 Income From Project 2 = $10000 Income From Project 3 = $4000 Income From Banner Ad = $1000 Income From Popup Ad = $3750 Net income of organisation = $23750</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>你会发现，尽管我们新增了收益流，但却完全没有修改 `calculateNetIncome` 函数。这就是多态带来的好处。由于新的 `Advertisement` 同样实现了 `Income` 接口，所以我们能够向 `incomeStreams` 切片添加 `Advertisement`。`calculateNetIncome` 无需修改，因为它能够调用 `Advertisement` 类型的 `calculate()` 和 `source()` 方法。 本教程到此结束。祝你愉快。 **上一教程 - [组合取代继承](<a href="https://studygolang.com/articles/12680" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12680</a>)** **下一教程 - [Defer](<a href="https://studygolang.com/articles/12719" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12719</a>)**</p>',25)]))}const d=t(r,[["render",o],["__file","28-多态.html.vue"]]),m=JSON.parse('{"path":"/golang/%E5%9F%BA%E7%A1%80/28-%E5%A4%9A%E6%80%81.html","title":"Go 系列教程 —— 28. 多态","lang":"zh-CN","frontmatter":{"title":"Go 系列教程 —— 28. 多态","source_url":"https://studygolang.com/articles/12681","category":"Go系列教程","description":"欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 28 篇。 Go 通过[接口](https://studygolang.com/articles/12266)来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部[方法](https://st...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%9F%BA%E7%A1%80/28-%E5%A4%9A%E6%80%81.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 系列教程 —— 28. 多态"}],["meta",{"property":"og:description","content":"欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 28 篇。 Go 通过[接口](https://studygolang.com/articles/12266)来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部[方法](https://st..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 系列教程 —— 28. 多态\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":2,"title":"新增收益流 假设前面的组织通过广告业务，建立了一个新的收益流（Income Stream）。我们可以看到添加它非常简单，并且计算总收益也很容易，我们无需对 `calculateNetIncome` 函数进行任何修改。这就是多态的好处。 我们首先定义 `Advertisement` 类型，并在 `Advertisement` 类型中定义 `calculate()` 和 `source()` 方法。","slug":"新增收益流-假设前面的组织通过广告业务-建立了一个新的收益流-income-stream-。我们可以看到添加它非常简单-并且计算总收益也很容易-我们无需对-calculatenetincome-函数进行任何修改。这就是多态的好处。-我们首先定义-advertisement-类型-并在-advertisement-类型中定义-calculate-和-source-方法。","link":"#新增收益流-假设前面的组织通过广告业务-建立了一个新的收益流-income-stream-。我们可以看到添加它非常简单-并且计算总收益也很容易-我们无需对-calculatenetincome-函数进行任何修改。这就是多态的好处。-我们首先定义-advertisement-类型-并在-advertisement-类型中定义-calculate-和-source-方法。","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":6.04,"words":1812},"filePathRelative":"golang/基础/28-多态.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>欢迎来到 [Golang 系列教程](<a href=\\"https://studygolang.com/subject/2\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://studygolang.com/subject/2</a>)的第 28 篇。 Go 通过[接口](<a href=\\"https://studygolang.com/articles/12266\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://studygolang.com/articles/12266</a>)来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部[方法](<a href=\\"https://studygolang.com/articles/12264\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://studygolang.com/articles/12264</a>)，那它就实现了该接口。现在我们来看看，利用接口，Go 是如何实现多态的。 ## 使用接口实现多态 一个类型如果定义了接口的所有方法，那它就隐式地实现了该接口。 **所有实现了接口的类型，都可以把它的值保存在一个接口类型的变量中。在 Go 中，我们使用接口的这种特性来实现多态**。 通过一个程序我们来理解 Go 语言的多态，它会计算一个组织机构的净收益。为了简单起见，我们假设这个虚构的组织所获得的收入来源于两个项目：`fixed billing` 和 `time and material`。该组织的净收益等于这两个项目的收入总和。同样为了简单起见，我们假设货币单位是美元，而无需处理美分。因此货币只需简单地用 `int` 来表示。（我建议阅读 <a href=\\"https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413</a> 上的文章，学习如何表示美分。感谢 Andreas Matuschek 在评论区指出这一点。） 我们首先定义一个接口 `Income`。</p>"}');export{d as comp,m as data};
