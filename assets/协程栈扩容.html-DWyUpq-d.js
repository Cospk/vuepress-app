import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as i}from"./app-DIJDtupu.js";const o={};function n(c,t){return i(),a("div",null,t[0]||(t[0]=[s('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func newstack() { // gp是申请堆栈扩容的协程 gp := thisg.m.curg ...... // Allocate a bigger segment and move the stack. oldsize := int(gp.stackAlloc) // 新的栈大小是原来的两倍 newsize := oldsize \\* 2 if uintptr(newsize) &gt; maxstacksize { print(&quot;runtime: goroutine stack exceeds &quot;, maxstacksize, &quot;-byte limit\\\\n&quot;) throw(&quot;stack overflow&quot;) } casgstatus(gp, \\_Gwaiting, \\_Gcopystack) // The concurrent GC will not scan the stack while we are doing the copy since // the gp is in a Gcopystack status. // 执行堆栈扩容并将原有堆栈数据拷贝至新栈 copystack(gp, uintptr(newsize)) if stackDebug &gt;= 1 { print(&quot;stack grow done\\\\n&quot;) } casgstatus(gp, \\_Gcopystack, \\_Grunning) gogo(&amp;gp.sched) } // 申请新的栈空间并将原有栈数据拷贝至这里 func copystack(gp \\*g, newsize uintptr) { if gp.syscallsp != 0 { throw(&quot;stack growth not allowed in system call&quot;) } old := gp.stack if old.lo == 0 { throw(&quot;nil stackbase&quot;) } // 原有堆栈使用的空间 used := old.hi - gp.sched.sp // allocate new stack // newstkbar是什么？ // 0xfc是什么？ new, newstkbar := stackalloc(uint32(newsize)) if stackPoisonCopy != 0 { fillstack(new, 0xfd) } ...... // adjust pointers in the to-be-copied frames // 这里主要调整g的一些调度相关参数 // 如果它们存储在老的栈上面，需要将它们拷贝到新栈上 var adjinfo adjustinfo adjinfo.old = old adjinfo.delta = new.hi - old.hi gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, adjustframe, noescape(unsafe.Pointer(&amp;adjinfo)), 0) // adjust other miscellaneous things that have pointers into stacks. adjustctxt(gp, &amp;adjinfo) adjustdefers(gp, &amp;adjinfo) adjustpanics(gp, &amp;adjinfo) adjustsudogs(gp, &amp;adjinfo) adjuststkbar(gp, &amp;adjinfo) // copy the stack to the new location // 0xfb又是什么？ if stackPoisonCopy != 0 { fillstack(new, 0xfb) } // 数据拷贝，老的堆栈数据拷贝到新堆栈 memmove(unsafe.Pointer(new.hi-used), unsafe.Pointer(old.hi-used), used) // copy old stack barriers to new stack barrier array newstkbar = newstkbar\\[:len(gp.stkbar)\\] copy(newstkbar, gp.stkbar) // Swap out old stack for new one // 切换到新堆栈上工作 gp.stack = new gp.stackguard0 = new.lo + \\_StackGuard gp.sched.sp = new.hi - used oldsize := gp.stackAlloc gp.stackAlloc = newsize gp.stkbar = newstkbar // 释放老的堆栈 if stackPoisonCopy != 0 { fillstack(old, 0xfc) } stackfree(old, oldsize) } func fillstack(stk stack, b byte) { for p := stk.lo; p &lt; stk.hi; p++ { \\*(\\*byte)(unsafe.Pointer(p)) = b } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',1)]))}const p=e(o,[["render",n],["__file","协程栈扩容.html.vue"]]),d=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E6%A0%88%E6%89%A9%E5%AE%B9.html","title":"协程栈扩容","lang":"zh-CN","frontmatter":{"title":"协程栈扩容","source_url":"https://studygolang.com/articles/11860","category":"Go原理教程","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E6%A0%88%E6%89%A9%E5%AE%B9.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"协程栈扩容"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"协程栈扩容\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":1.5,"words":450},"filePathRelative":"golang/原理/theory/协程栈扩容.md","localizedDate":"2025年8月26日","excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>go func newstack() { // gp是申请堆栈扩容的协程 gp := thisg.m.curg ...... // Allocate a bigger segment and move the stack. oldsize := int(gp.stackAlloc) // 新的栈大小是原来的两倍 newsize := oldsize \\\\* 2 if uintptr(newsize) &gt; maxstacksize { print(\\"runtime: goroutine stack exceeds \\", maxstacksize, \\"-byte limit\\\\\\\\n\\") throw(\\"stack overflow\\") } casgstatus(gp, \\\\_Gwaiting, \\\\_Gcopystack) // The concurrent GC will not scan the stack while we are doing the copy since // the gp is in a Gcopystack status. // 执行堆栈扩容并将原有堆栈数据拷贝至新栈 copystack(gp, uintptr(newsize)) if stackDebug &gt;= 1 { print(\\"stack grow done\\\\\\\\n\\") } casgstatus(gp, \\\\_Gcopystack, \\\\_Grunning) gogo(&amp;gp.sched) } // 申请新的栈空间并将原有栈数据拷贝至这里 func copystack(gp \\\\*g, newsize uintptr) { if gp.syscallsp != 0 { throw(\\"stack growth not allowed in system call\\") } old := gp.stack if old.lo == 0 { throw(\\"nil stackbase\\") } // 原有堆栈使用的空间 used := old.hi - gp.sched.sp // allocate new stack // newstkbar是什么？ // 0xfc是什么？ new, newstkbar := stackalloc(uint32(newsize)) if stackPoisonCopy != 0 { fillstack(new, 0xfd) } ...... // adjust pointers in the to-be-copied frames // 这里主要调整g的一些调度相关参数 // 如果它们存储在老的栈上面，需要将它们拷贝到新栈上 var adjinfo adjustinfo adjinfo.old = old adjinfo.delta = new.hi - old.hi gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, adjustframe, noescape(unsafe.Pointer(&amp;adjinfo)), 0) // adjust other miscellaneous things that have pointers into stacks. adjustctxt(gp, &amp;adjinfo) adjustdefers(gp, &amp;adjinfo) adjustpanics(gp, &amp;adjinfo) adjustsudogs(gp, &amp;adjinfo) adjuststkbar(gp, &amp;adjinfo) // copy the stack to the new location // 0xfb又是什么？ if stackPoisonCopy != 0 { fillstack(new, 0xfb) } // 数据拷贝，老的堆栈数据拷贝到新堆栈 memmove(unsafe.Pointer(new.hi-used), unsafe.Pointer(old.hi-used), used) // copy old stack barriers to new stack barrier array newstkbar = newstkbar\\\\[:len(gp.stkbar)\\\\] copy(newstkbar, gp.stkbar) // Swap out old stack for new one // 切换到新堆栈上工作 gp.stack = new gp.stackguard0 = new.lo + \\\\_StackGuard gp.sched.sp = new.hi - used oldsize := gp.stackAlloc gp.stackAlloc = newsize gp.stkbar = newstkbar // 释放老的堆栈 if stackPoisonCopy != 0 { fillstack(old, 0xfc) } stackfree(old, oldsize) } func fillstack(stk stack, b byte) { for p := stk.lo; p &lt; stk.hi; p++ { \\\\*(\\\\*byte)(unsafe.Pointer(p)) = b } }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{p as comp,d as data};
