import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as r,o as a}from"./app-DIJDtupu.js";const n={};function s(l,e){return a(),i("div",null,e[0]||(e[0]=[r('<p>![reflection](<a href="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/reflection-golang-3.png" target="_blank" rel="noopener noreferrer">https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/reflection-golang-3.png</a>) 欢迎来到 [Golang 系列教程](<a href="https://studygolang.com/subject/2" target="_blank" rel="noopener noreferrer">https://studygolang.com/subject/2</a>)的第 34 篇。 反射是 Go 语言的高级主题之一。我会尽可能让它变得简单易懂。 本教程分为如下小节。 - 什么是反射？ - 为何需要检查变量，确定变量的类型？ - reflect 包 - reflect.Type 和 reflect.Value - reflect.Kind - NumField() 和 Field() 方法 - Int() 和 String() 方法 - 完整的程序 - 我们应该使用反射吗？ 让我们来逐个讨论这些章节。 ## 什么是反射？ 反射就是程序能够在运行时检查变量和值，求出它们的类型。你可能还不太懂，这没关系。在本教程结束后，你就会清楚地理解反射，所以跟着我们的教程学习吧。 ## 为何需要检查变量，确定变量的类型？ 在学习反射时，所有人首先面临的疑惑就是：如果程序中每个变量都是我们自己定义的，那么在编译时就可以知道变量类型了，为什么我们还需要在运行时检查变量，求出它的类型呢？没错，在大多数时候都是这样，但并非总是如此。 我来解释一下吧。下面我们编写一个简单的程序。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { i := 10 fmt.Printf(&quot;%d %T&quot;, i, i) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/1oZzPCCG2Qw" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/1oZzPCCG2Qw</a>) 在上面的程序中，`i` 的类型在编译时就知道了，然后我们在下一行打印出 `i`。这里没什么特别之处。 现在了解一下，需要在运行时求得变量类型的情况。假如我们要编写一个简单的函数，它接收结构体作为参数，并用它来创建一个 SQL 插入查询。 考虑下面的程序：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type order struct { ordId int customerId int } func main() { o := order{ ordId: 1234, customerId: 567, } fmt.Println(o) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/1oZzPCCG2Qw" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/1oZzPCCG2Qw</a>) 在上面的程序中，我们需要编写一个函数，接收结构体变量 `o` 作为参数，返回下面的 SQL 插入查询。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> insert into order values(1234, 567)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个函数写起来很简单。我们现在编写这个函数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type order struct { ordId int customerId int } func createQuery(o order) string { i := fmt.Sprintf(&quot;insert into order values(%d, %d)&quot;, o.ordId, o.customerId) return i } func main() { o := order{ ordId: 1234, customerId: 567, } fmt.Println(createQuery(o)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/jhz4VHKIlQ5" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/jhz4VHKIlQ5</a>) 在第 12 行，`createQuery` 函数用 `o` 的两个字段（`ordId` 和 `customerId`），创建了插入查询。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bash insert into order values(1234, 567)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在我们来升级这个查询生成器。如果我们想让它变得通用，可以适用于任何结构体类型，该怎么办呢？我们用程序来理解一下。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main type order struct { ordId int customerId int } type employee struct { name string id int address string salary int country string } func createQuery(q interface{}) string { } func main() { }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们的目标就是完成 `createQuery` 函数（上述程序中的第 16 行），它可以接收任何结构体作为参数，根据结构体的字段创建插入查询。 例如，如果我们传入下面的结构体：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go o := order { ordId: 1234, customerId: 567 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>`createQuery` 函数应该返回：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> insert into order values (1234, 567)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>类似地，如果我们传入：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go e := employee { name: &quot;Naveen&quot;, id: 565, address: &quot;Science Park Road, Singapore&quot;, salary: 90000, country: &quot;Singapore&quot;, }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该函数会返回：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> insert into employee values(&quot;Naveen&quot;, 565, &quot;Science Park Road, Singapore&quot;, 90000, &quot;Singapore&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>由于 `createQuery` 函数应该适用于任何结构体，因此它接收 `interface{}` 作为参数。为了简单起见，我们只处理包含 `string` 和 `int` 类型字段的结构体，但可以扩展为包含任何类型的字段。 `createQuery` 函数应该适用于所有的结构体。因此，要编写这个函数，就必须在运行时检查传递过来的结构体参数的类型，找到结构体字段，接着创建查询。这时就需要用到反射了。在本教程的下一步，我们将会学习如何使用 `reflect` 包来实现它。 ## reflect 包 在 Go 语言中，[`reflect`](<a href="https://golang.org/pkg/reflect/" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/</a>) 实现了运行时反射。`reflect` 包会帮助识别 [`interface{}`](<a href="https://studygolang.com/articles/12266" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12266</a>) 变量的底层具体类型和具体值。这正是我们所需要的。`createQuery` 函数接收 `interface{}` 参数，根据它的具体类型和具体值，创建 SQL 查询。这正是 `reflect` 包能够帮助我们的地方。 在编写我们通用的查询生成器之前，我们首先需要了解 `reflect` 包中的几种类型和方法。让我们来逐个了解。 ### reflect.Type 和 reflect.Value `reflect.Type` 表示 `interface{}` 的具体类型，而 `reflect.Value` 表示它的具体值。`reflect.TypeOf()` 和 `reflect.ValueOf()` 两个函数可以分别返回 `reflect.Type` 和 `reflect.Value`。这两种类型是我们创建查询生成器的基础。我们现在用一个简单的例子来理解这两种类型。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;reflect&quot; ) type order struct { ordId int customerId int } func createQuery(q interface{}) { t := reflect.TypeOf(q) v := reflect.ValueOf(q) fmt.Println(&quot;Type &quot;, t) fmt.Println(&quot;Value &quot;, v) } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/81BS-bEfbCg" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/81BS-bEfbCg</a>) 在上面的程序中，第 13 行的 `createQuery` 函数接收 `interface{}` 作为参数。在第 14 行，[`reflect.TypeOf`](<a href="https://golang.org/pkg/reflect/#TypeOf" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#TypeOf</a>) 接收了参数 `interface{}`，返回了[`reflect.Type`](<a href="https://golang.org/pkg/reflect/#Type" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Type</a>)，它包含了传入的 `interface{}` 参数的具体类型。同样地，在第 15 行，[`reflect.ValueOf`](<a href="https://golang.org/pkg/reflect/#ValueOf" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#ValueOf</a>) 函数接收参数 `interface{}`，并返回了 [`reflect.Value`](<a href="https://golang.org/pkg/reflect/#Value" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Value</a>)，它包含了传来的 `interface{}` 的具体值。 上述程序会打印：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Type main.order Value {456 56}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从输出我们可以看到，程序打印了接口的具体类型和具体值。 ### reflect.Kind `reflect` 包中还有一个重要的类型：[`Kind`](<a href="https://golang.org/pkg/reflect/#Kind" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Kind</a>)。 在反射包中，`Kind` 和 `Type` 的类型可能看起来很相似，但在下面程序中，可以很清楚地看出它们的不同之处。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;reflect&quot; ) type order struct { ordId int customerId int } func createQuery(q interface{}) { t := reflect.TypeOf(q) k := t.Kind() fmt.Println(&quot;Type &quot;, t) fmt.Println(&quot;Kind &quot;, k) } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/Xw3JIzCm54T" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/Xw3JIzCm54T</a>) 上述程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Type main.order Kind struct</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我想你应该很清楚两者的区别了。`Type` 表示 `interface{}` 的实际类型（在这里是 **`main.Order`**)，而 `Kind` 表示该类型的特定类别（在这里是 **`struct`**）。 ### NumField() 和 Field() 方法 [`NumField()`](<a href="https://golang.org/pkg/reflect/#Value.NumField" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Value.NumField</a>) 方法返回结构体中字段的数量，而 [`Field(i int)`](<a href="https://golang.org/pkg/reflect/#Value.Field" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Value.Field</a>) 方法返回字段 `i` 的 `reflect.Value`。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;reflect&quot; ) type order struct { ordId int customerId int } func createQuery(q interface{}) { if reflect.ValueOf(q).Kind() == reflect.Struct { v := reflect.ValueOf(q) fmt.Println(&quot;Number of fields&quot;, v.NumField()) for i := 0; i &lt; v.NumField(); i++ { fmt.Printf(&quot;Field:%d type:%T value:%v\\\\n&quot;, i, v.Field(i), v.Field(i)) } } } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/FBHfJfuTaEe" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/FBHfJfuTaEe</a>) 在上面的程序中，因为 `NumField` 方法只能在结构体上使用，我们在第 14 行首先检查了 `q` 的类别是 `struct`。程序的其他代码很容易看懂，不作解释。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Number of fields 2 Field:0 type:reflect.Value value:456 Field:1 type:reflect.Value value:56</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="int-和-string-方法-int-https-golang-org-pkg-reflect-value-int-和-string-https-golang-org-pkg-reflect-value-string-可以帮助我们分别取出-reflect-value-作为-int64-和-string-。" tabindex="-1"><a class="header-anchor" href="#int-和-string-方法-int-https-golang-org-pkg-reflect-value-int-和-string-https-golang-org-pkg-reflect-value-string-可以帮助我们分别取出-reflect-value-作为-int64-和-string-。"><span>Int() 和 String() 方法 [`Int`](<a href="https://golang.org/pkg/reflect/#Value.Int" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Value.Int</a>) 和 [`String`](<a href="https://golang.org/pkg/reflect/#Value.String" target="_blank" rel="noopener noreferrer">https://golang.org/pkg/reflect/#Value.String</a>) 可以帮助我们分别取出 `reflect.Value` 作为 `int64` 和 `string`。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;reflect&quot; ) func main() { a := 56 x := reflect.ValueOf(a).Int() fmt.Printf(&quot;type:%T value:%v\\\\n&quot;, x, x) b := &quot;Naveen&quot; y := reflect.ValueOf(b).String() fmt.Printf(&quot;type:%T value:%v\\\\n&quot;, y, y) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/UIllrLVoGwI" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/UIllrLVoGwI</a>) 在上面程序中的第 10 行，我们取出 `reflect.Value`，并转换为 `int64`，而在第 13 行，我们取出 `reflect.Value` 并将其转换为 `string`。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> type:int64 value:56 type:string value:Naveen</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="完整的程序-现在我们已经具备足够多的知识-来完成我们的查询生成器了-我们来实现它把。" tabindex="-1"><a class="header-anchor" href="#完整的程序-现在我们已经具备足够多的知识-来完成我们的查询生成器了-我们来实现它把。"><span>完整的程序 现在我们已经具备足够多的知识，来完成我们的查询生成器了，我们来实现它把。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;reflect&quot; ) type order struct { ordId int customerId int } type employee struct { name string id int address string salary int country string } func createQuery(q interface{}) { if reflect.ValueOf(q).Kind() == reflect.Struct { t := reflect.TypeOf(q).Name() query := fmt.Sprintf(&quot;insert into %s values(&quot;, t) v := reflect.ValueOf(q) for i := 0; i &lt; v.NumField(); i++ { switch v.Field(i).Kind() { case reflect.Int: if i == 0 { query = fmt.Sprintf(&quot;%s%d&quot;, query, v.Field(i).Int()) } else { query = fmt.Sprintf(&quot;%s, %d&quot;, query, v.Field(i).Int()) } case reflect.String: if i == 0 { query = fmt.Sprintf(&quot;%s\\\\&quot;%s\\\\&quot;&quot;, query, v.Field(i).String()) } else { query = fmt.Sprintf(&quot;%s, \\\\&quot;%s\\\\&quot;&quot;, query, v.Field(i).String()) } default: fmt.Println(&quot;Unsupported type&quot;) return } } query = fmt.Sprintf(&quot;%s)&quot;, query) fmt.Println(query) return } fmt.Println(&quot;unsupported type&quot;) } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) e := employee{ name: &quot;Naveen&quot;, id: 565, address: &quot;Coimbatore&quot;, salary: 90000, country: &quot;India&quot;, } createQuery(e) i := 90 createQuery(i) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/82Bi4RU5c7W" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/82Bi4RU5c7W</a>) 在第 22 行，我们首先检查了传来的参数是否是一个结构体。在第 23 行，我们使用了 `Name()` 方法，从该结构体的 `reflect.Type` 获取了结构体的名字。接下来一行，我们用 `t` 来创建查询。 在第 28 行，[case 语句](<a href="https://studygolang.com/articles/11957" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11957</a>) 检查了当前字段是否为 `reflect.Int`，如果是的话，我们会取到该字段的值，并使用 `Int()` 方法转换为 `int64`。[if else 语句](<a href="https://studygolang.com/articles/11902" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11902</a>)用于处理边界情况。请添加日志来理解为什么需要它。在第 34 行，我们用来相同的逻辑来取到 `string`。 我们还作了额外的检查，以防止 `createQuery` 函数传入不支持的类型时，程序发生崩溃。程序的其他代码是自解释性的。我建议你在合适的地方添加日志，检查输出，来更好地理解这个程序。 该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> insert into order values(456, 56) insert into employee values(&quot;Naveen&quot;, 565, &quot;Coimbatore&quot;, 90000, &quot;India&quot;) unsupported type</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>至于向输出的查询中添加字段名，我们把它留给读者作为练习。请尝试着修改程序，打印出以下格式的查询。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> insert into order(ordId, customerId) values(456, 56)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="我们应该使用反射吗-我们已经展示了反射的实际应用-现在考虑一个很现实的问题。我们应该使用反射吗-我想引用-rob-pike-https-en-wikipedia-org-wiki-rob-pike-关于使用反射的格言-来回答这个问题。-清晰优于聪明。而反射并不是一目了然的。-反射是-go-语言中非常强大和高级的概念-我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它-只在必须用到它时-才使用反射。-本教程到此结束。希望你们喜欢。祝你愉快。-上一教程-函数是一等公民-https-studygolang-com-articles-12789-下一教程-读取文件-https-studygolang-com-articles-14669" tabindex="-1"><a class="header-anchor" href="#我们应该使用反射吗-我们已经展示了反射的实际应用-现在考虑一个很现实的问题。我们应该使用反射吗-我想引用-rob-pike-https-en-wikipedia-org-wiki-rob-pike-关于使用反射的格言-来回答这个问题。-清晰优于聪明。而反射并不是一目了然的。-反射是-go-语言中非常强大和高级的概念-我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它-只在必须用到它时-才使用反射。-本教程到此结束。希望你们喜欢。祝你愉快。-上一教程-函数是一等公民-https-studygolang-com-articles-12789-下一教程-读取文件-https-studygolang-com-articles-14669"><span>我们应该使用反射吗？ 我们已经展示了反射的实际应用，现在考虑一个很现实的问题。我们应该使用反射吗？我想引用 [`Rob Pike`](<a href="https://en.wikipedia.org/wiki/Rob%5C_Pike" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Rob\\_Pike</a>) 关于使用反射的格言，来回答这个问题。 &gt; 清晰优于聪明。而反射并不是一目了然的。 反射是 Go 语言中非常强大和高级的概念，我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它，只在必须用到它时，才使用反射。 本教程到此结束。希望你们喜欢。祝你愉快。 **上一教程 - [函数是一等公民](<a href="https://studygolang.com/articles/12789" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12789</a>)**. **下一教程 - [读取文件](<a href="https://studygolang.com/articles/14669" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/14669</a>)**</span></a></h2>',43)]))}const d=t(n,[["render",s],["__file","34-反射.html.vue"]]),p=JSON.parse('{"path":"/golang/%E5%9F%BA%E7%A1%80/34-%E5%8F%8D%E5%B0%84.html","title":"Go 系列教程 —— 34. 反射","lang":"zh-CN","frontmatter":{"title":"Go 系列教程 —— 34. 反射","source_url":"https://studygolang.com/articles/13178","category":"Go系列教程","description":"![reflection](https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/reflection-golang-3.png) 欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 34 ...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%9F%BA%E7%A1%80/34-%E5%8F%8D%E5%B0%84.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 系列教程 —— 34. 反射"}],["meta",{"property":"og:description","content":"![reflection](https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/reflection-golang-3.png) 欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 34 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 系列教程 —— 34. 反射\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"Int() 和 String() 方法 [`Int`](https://golang.org/pkg/reflect/#Value.Int) 和 [`String`](https://golang.org/pkg/reflect/#Value.String) 可以帮助我们分别取出 `reflect.Value` 作为 `int64` 和 `string`。","slug":"int-和-string-方法-int-https-golang-org-pkg-reflect-value-int-和-string-https-golang-org-pkg-reflect-value-string-可以帮助我们分别取出-reflect-value-作为-int64-和-string-。","link":"#int-和-string-方法-int-https-golang-org-pkg-reflect-value-int-和-string-https-golang-org-pkg-reflect-value-string-可以帮助我们分别取出-reflect-value-作为-int64-和-string-。","children":[]},{"level":2,"title":"完整的程序 现在我们已经具备足够多的知识，来完成我们的查询生成器了，我们来实现它把。","slug":"完整的程序-现在我们已经具备足够多的知识-来完成我们的查询生成器了-我们来实现它把。","link":"#完整的程序-现在我们已经具备足够多的知识-来完成我们的查询生成器了-我们来实现它把。","children":[]},{"level":2,"title":"我们应该使用反射吗？ 我们已经展示了反射的实际应用，现在考虑一个很现实的问题。我们应该使用反射吗？我想引用 [`Rob Pike`](https://en.wikipedia.org/wiki/Rob\\\\_Pike) 关于使用反射的格言，来回答这个问题。 > 清晰优于聪明。而反射并不是一目了然的。 反射是 Go 语言中非常强大和高级的概念，我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它，只在必须用到它时，才使用反射。 本教程到此结束。希望你们喜欢。祝你愉快。 **上一教程 - [函数是一等公民](https://studygolang.com/articles/12789)**. **下一教程 - [读取文件](https://studygolang.com/articles/14669)**","slug":"我们应该使用反射吗-我们已经展示了反射的实际应用-现在考虑一个很现实的问题。我们应该使用反射吗-我想引用-rob-pike-https-en-wikipedia-org-wiki-rob-pike-关于使用反射的格言-来回答这个问题。-清晰优于聪明。而反射并不是一目了然的。-反射是-go-语言中非常强大和高级的概念-我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它-只在必须用到它时-才使用反射。-本教程到此结束。希望你们喜欢。祝你愉快。-上一教程-函数是一等公民-https-studygolang-com-articles-12789-下一教程-读取文件-https-studygolang-com-articles-14669","link":"#我们应该使用反射吗-我们已经展示了反射的实际应用-现在考虑一个很现实的问题。我们应该使用反射吗-我想引用-rob-pike-https-en-wikipedia-org-wiki-rob-pike-关于使用反射的格言-来回答这个问题。-清晰优于聪明。而反射并不是一目了然的。-反射是-go-语言中非常强大和高级的概念-我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它-只在必须用到它时-才使用反射。-本教程到此结束。希望你们喜欢。祝你愉快。-上一教程-函数是一等公民-https-studygolang-com-articles-12789-下一教程-读取文件-https-studygolang-com-articles-14669","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":8.49,"words":2547},"filePathRelative":"golang/基础/34-反射.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>![reflection](<a href=\\"https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/reflection-golang-3.png\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/reflection-golang-3.png</a>) 欢迎来到 [Golang 系列教程](<a href=\\"https://studygolang.com/subject/2\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://studygolang.com/subject/2</a>)的第 34 篇。 反射是 Go 语言的高级主题之一。我会尽可能让它变得简单易懂。 本教程分为如下小节。 - 什么是反射？ - 为何需要检查变量，确定变量的类型？ - reflect 包 - reflect.Type 和 reflect.Value - reflect.Kind - NumField() 和 Field() 方法 - Int() 和 String() 方法 - 完整的程序 - 我们应该使用反射吗？ 让我们来逐个讨论这些章节。 ## 什么是反射？ 反射就是程序能够在运行时检查变量和值，求出它们的类型。你可能还不太懂，这没关系。在本教程结束后，你就会清楚地理解反射，所以跟着我们的教程学习吧。 ## 为何需要检查变量，确定变量的类型？ 在学习反射时，所有人首先面临的疑惑就是：如果程序中每个变量都是我们自己定义的，那么在编译时就可以知道变量类型了，为什么我们还需要在运行时检查变量，求出它的类型呢？没错，在大多数时候都是这样，但并非总是如此。 我来解释一下吧。下面我们编写一个简单的程序。</p>"}');export{d as comp,p as data};
