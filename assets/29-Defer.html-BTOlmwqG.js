import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a,o as i}from"./app-DIJDtupu.js";const n={};function s(o,e){return i(),r("div",null,e[0]||(e[0]=[a('<p>欢迎来到 [Golang 系列教程](<a href="https://studygolang.com/subject/2" target="_blank" rel="noopener noreferrer">https://studygolang.com/subject/2</a>)的第 29 篇。 ## 什么是 defer？ `defer` 语句的用途是：含有 `defer` 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。 ## 示例</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func finished() { fmt.Println(&quot;Finished finding largest&quot;) } func largest(nums \\[\\]int) { defer finished() fmt.Println(&quot;Started finding largest&quot;) max := nums\\[0\\] for \\_, v := range nums { if v &gt; max { max = v } } fmt.Println(&quot;Largest number in&quot;, nums, &quot;is&quot;, max) } func main() { nums := \\[\\]int{78, 109, 2, 563, 300} largest(nums) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/IlccOsuSUE" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/IlccOsuSUE</a>) 上面的程序很简单，就是找出一个给定切片的最大值。`largest` 函数接收一个 int 类型的[切片](<a href="https://studygolang.com/articles/12121" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12121</a>)作为参数，然后打印出该切片中的最大值。`largest` 函数的第一行的语句为 `defer finished()`。这表示在 `finished()` 函数将要返回之前，会调用 `finished()` 函数。运行该程序，你会看到有如下输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Started finding largest Largest number in \\[78 109 2 563 300\\] is 563 Finished finding largest</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>`largest` 函数开始执行后，会打印上面的两行输出。而就在 `largest` 将要返回的时候，又调用了我们的延迟函数（Deferred Function），打印出 `Finished finding largest` 的文本。😃 ## 延迟方法 `defer` 不仅限于[函数](<a href="https://studygolang.com/articles/11892" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/11892</a>)的调用，调用[方法](<a href="https://studygolang.com/articles/12264" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12264</a>)也是合法的。我们写一个小程序来测试吧。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) type person struct { firstName string lastName string } func (p person) fullName() { fmt.Printf(&quot;%s %s&quot;,p.firstName,p.lastName) } func main() { p := person { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, } defer p.fullName() fmt.Printf(&quot;Welcome &quot;) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/lZ74OAwnRD" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/lZ74OAwnRD</a>) 在上面的例子中，我们在第 22 行延迟了一个方法调用。而其他的代码很直观，这里不再解释。该程序输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Welcome John Smith</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="实参取值-arguments-evaluation-在-go-语言中-并非在调用延迟函数的时候才确定实参-而是当执行-defer-语句的时候-就会对延迟函数的实参进行求值。-通过一个例子就能够理解了。" tabindex="-1"><a class="header-anchor" href="#实参取值-arguments-evaluation-在-go-语言中-并非在调用延迟函数的时候才确定实参-而是当执行-defer-语句的时候-就会对延迟函数的实参进行求值。-通过一个例子就能够理解了。"><span>实参取值（Arguments Evaluation） 在 Go 语言中，并非在调用延迟函数的时候才确定实参，而是当执行 `defer` 语句的时候，就会对延迟函数的实参进行求值。 通过一个例子就能够理解了。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func printA(a int) { fmt.Println(&quot;value of a in deferred function&quot;, a) } func main() { a := 5 defer printA(a) a = 10 fmt.Println(&quot;value of a before deferred function call&quot;, a) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/sBnwrUgObd" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/sBnwrUgObd</a>) 在上面的程序里的第 11 行，`a` 的初始值为 5。在第 12 行执行 `defer` 语句的时候，由于 `a` 等于 5，因此延迟函数 `printA` 的实参也等于 5。接着我们在第 13 行将 `a` 的值修改为 10。下一行会打印出 `a` 的值。该程序输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> value of a before deferred function call 10 value of a in deferred function 5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从上面的输出，我们可以看出，在调用了 `defer` 语句后，虽然我们将 `a` 修改为 10，但调用延迟函数 `printA(a)`后，仍然打印的是 5。 ## defer 栈 当一个函数内多次调用 `defer` 时，Go 会把 `defer` 调用放入到一个栈中，随后按照后进先出（Last In First Out, LIFO）的顺序执行。 我们下面编写一个小程序，使用 `defer` 栈，将一个字符串逆序打印。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; ) func main() { name := &quot;Naveen&quot; fmt.Printf(&quot;Orignal String: %s\\\\n&quot;, string(name)) fmt.Printf(&quot;Reversed String: &quot;) for \\_, v := range \\[\\]rune(name) { defer fmt.Printf(&quot;%c&quot;, v) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/HDk623ozuw" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/HDk623ozuw</a>) 在上述程序中的第 11 行，`for range` 循环会遍历一个字符串，并在第 12 行调用了 `defer fmt.Printf(&quot;%c&quot;, v)`。这些延迟调用会添加到一个栈中，按照后进先出的顺序执行，因此，该字符串会逆序打印出来。该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> Orignal String: Naveen Reversed String: neevaN</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="defer-的实际应用-目前为止-我们看到的代码示例-都没有体现出-defer-的实际用途。本节我们会看看-defer-的实际应用。-当一个函数应该在与当前代码流-code-flow-无关的环境下调用时-可以使用-defer-。我们通过一个用到了-waitgroup-https-studygolang-com-articles-12512-代码示例来理解这句话的含义。我们首先会写一个没有使用-defer-的程序-然后我们会用-defer-来修改-看到-defer-带来的好处。" tabindex="-1"><a class="header-anchor" href="#defer-的实际应用-目前为止-我们看到的代码示例-都没有体现出-defer-的实际用途。本节我们会看看-defer-的实际应用。-当一个函数应该在与当前代码流-code-flow-无关的环境下调用时-可以使用-defer-。我们通过一个用到了-waitgroup-https-studygolang-com-articles-12512-代码示例来理解这句话的含义。我们首先会写一个没有使用-defer-的程序-然后我们会用-defer-来修改-看到-defer-带来的好处。"><span>defer 的实际应用 目前为止，我们看到的代码示例，都没有体现出 `defer` 的实际用途。本节我们会看看 `defer` 的实际应用。 当一个函数应该在与当前代码流（Code Flow）无关的环境下调用时，可以使用 `defer`。我们通过一个用到了 [`WaitGroup`](<a href="https://studygolang.com/articles/12512" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12512</a>) 代码示例来理解这句话的含义。我们首先会写一个没有使用 `defer` 的程序，然后我们会用 `defer` 来修改，看到 `defer` 带来的好处。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;sync&quot; ) type rect struct { length int width int } func (r rect) area(wg \\*sync.WaitGroup) { if r.length &lt; 0 { fmt.Printf(&quot;rect %v&#39;s length should be greater than zero\\\\n&quot;, r) wg.Done() return } if r.width &lt; 0 { fmt.Printf(&quot;rect %v&#39;s width should be greater than zero\\\\n&quot;, r) wg.Done() return } area := r.length \\* r.width fmt.Printf(&quot;rect %v&#39;s area %d\\\\n&quot;, r, area) wg.Done() } func main() { var wg sync.WaitGroup r1 := rect{-67, 89} r2 := rect{5, -67} r3 := rect{8, 9} rects := \\[\\]rect{r1, r2, r3} for \\_, v := range rects { wg.Add(1) go v.area(&amp;wg) } wg.Wait() fmt.Println(&quot;All go routines finished executing&quot;) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/kXL85U0Dd%5C_" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/kXL85U0Dd\\_</a>) 在上面的程序里，我们在第 8 行创建了 `rect` 结构体，并在第 13 行创建了 `rect` 的方法 `area`，计算出矩形的面积。`area` 检查了矩形的长宽是否小于零。如果矩形的长宽小于零，它会打印出对应的提示信息，而如果大于零，它会打印出矩形的面积。 `main` 函数创建了 3 个 `rect` 类型的变量：`r1`、`r2` 和 `r3`。在第 34 行，我们把这 3 个变量添加到了 `rects` 切片里。该切片接着使用 `for range` 循环遍历，把 `area` 方法作为一个并发的 Go 协程进行调用（第 37 行）。我们用 `WaitGroup wg` 来确保 `main` 函数在其他协程执行完毕之后，���会结束执行。`WaitGroup` 作为参数传递给 `area` 方法后，在第 16 行、第 21 行和第 26 行通知 `main` 函数，表示现在协程已经完成所有任务。**如果你仔细观察，会发现 `wg.Done()` 只在 `area` 函数返回的时候才会调用。`wg.Done()` 应该在 `area` 将要返回之前调用，并且与代码流的路径（Path）无关，因此我们可以只调用一次 `defer`，来有效地替换掉 `wg.Done()` 的多次调用**。 我们来用 `defer` 来重写上面的代码。 在下面的代码中，我们移除了原先程序中的 3 个 `wg.Done` 的调用，而是用一个单独的 `defer wg.Done()` 来取代它（第 14 行）。这使得我们的代码更加简洁易懂。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go package main import ( &quot;fmt&quot; &quot;sync&quot; ) type rect struct { length int width int } func (r rect) area(wg \\*sync.WaitGroup) { defer wg.Done() if r.length &lt; 0 { fmt.Printf(&quot;rect %v&#39;s length should be greater than zero\\\\n&quot;, r) return } if r.width &lt; 0 { fmt.Printf(&quot;rect %v&#39;s width should be greater than zero\\\\n&quot;, r) return } area := r.length \\* r.width fmt.Printf(&quot;rect %v&#39;s area %d\\\\n&quot;, r, area) } func main() { var wg sync.WaitGroup r1 := rect{-67, 89} r2 := rect{5, -67} r3 := rect{8, 9} rects := \\[\\]rect{r1, r2, r3} for \\_, v := range rects { wg.Add(1) go v.area(&amp;wg) } wg.Wait() fmt.Println(&quot;All go routines finished executing&quot;) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[在 playground 上运行](<a href="https://play.golang.org/p/JuUvytLfBv" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/JuUvytLfBv</a>) 该程序会输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> rect {8 9}&#39;s area 72 rect {-67 89}&#39;s length should be greater than zero rect {5 -67}&#39;s width should be greater than zero All go routines finished executing</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面的程序中，使用 `defer` 还有一个好处。假设我们使用 `if` 条件语句，又给 `area` 方法添加了一条返回路径（Return Path）。如果没有使用 `defer` 来调用 `wg.Done()`，我们就得很小心了，确保在这条新添的返回路径里调用了 `wg.Done()`。由于现在我们延迟调用了 `wg.Done()`，因此无需再为这条新的返回路径添加 `wg.Done()` 了。 本教程到此结束。祝你愉快。 **上一教程 - [多态](<a href="https://studygolang.com/articles/12681" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12681</a>)** **下一教程 - [错误处理](<a href="https://studygolang.com/articles/12724" target="_blank" rel="noopener noreferrer">https://studygolang.com/articles/12724</a>)**</p>',23)]))}const g=t(n,[["render",s],["__file","29-Defer.html.vue"]]),h=JSON.parse('{"path":"/golang/%E5%9F%BA%E7%A1%80/29-Defer.html","title":"Go 系列教程 —— 29. Defer","lang":"zh-CN","frontmatter":{"title":"Go 系列教程 —— 29. Defer","source_url":"https://studygolang.com/articles/12719","category":"Go系列教程","description":"欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 29 篇。 ## 什么是 defer？ `defer` 语句的用途是：含有 `defer` 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。 ## 示例 [在 playground...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%9F%BA%E7%A1%80/29-Defer.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 系列教程 —— 29. Defer"}],["meta",{"property":"og:description","content":"欢迎来到 [Golang 系列教程](https://studygolang.com/subject/2)的第 29 篇。 ## 什么是 defer？ `defer` 语句的用途是：含有 `defer` 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。 ## 示例 [在 playground..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 系列教程 —— 29. Defer\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":2,"title":"实参取值（Arguments Evaluation） 在 Go 语言中，并非在调用延迟函数的时候才确定实参，而是当执行 `defer` 语句的时候，就会对延迟函数的实参进行求值。 通过一个例子就能够理解了。","slug":"实参取值-arguments-evaluation-在-go-语言中-并非在调用延迟函数的时候才确定实参-而是当执行-defer-语句的时候-就会对延迟函数的实参进行求值。-通过一个例子就能够理解了。","link":"#实参取值-arguments-evaluation-在-go-语言中-并非在调用延迟函数的时候才确定实参-而是当执行-defer-语句的时候-就会对延迟函数的实参进行求值。-通过一个例子就能够理解了。","children":[]},{"level":2,"title":"defer 的实际应用 目前为止，我们看到的代码示例，都没有体现出 `defer` 的实际用途。本节我们会看看 `defer` 的实际应用。 当一个函数应该在与当前代码流（Code Flow）无关的环境下调用时，可以使用 `defer`。我们通过一个用到了 [`WaitGroup`](https://studygolang.com/articles/12512) 代码示例来理解这句话的含义。我们首先会写一个没有使用 `defer` 的程序，然后我们会用 `defer` 来修改，看到 `defer` 带来的好处。","slug":"defer-的实际应用-目前为止-我们看到的代码示例-都没有体现出-defer-的实际用途。本节我们会看看-defer-的实际应用。-当一个函数应该在与当前代码流-code-flow-无关的环境下调用时-可以使用-defer-。我们通过一个用到了-waitgroup-https-studygolang-com-articles-12512-代码示例来理解这句话的含义。我们首先会写一个没有使用-defer-的程序-然后我们会用-defer-来修改-看到-defer-带来的好处。","link":"#defer-的实际应用-目前为止-我们看到的代码示例-都没有体现出-defer-的实际用途。本节我们会看看-defer-的实际应用。-当一个函数应该在与当前代码流-code-flow-无关的环境下调用时-可以使用-defer-。我们通过一个用到了-waitgroup-https-studygolang-com-articles-12512-代码示例来理解这句话的含义。我们首先会写一个没有使用-defer-的程序-然后我们会用-defer-来修改-看到-defer-带来的好处。","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":5.99,"words":1797},"filePathRelative":"golang/基础/29-Defer.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>欢迎来到 [Golang 系列教程](<a href=\\"https://studygolang.com/subject/2\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://studygolang.com/subject/2</a>)的第 29 篇。 ## 什么是 defer？ `defer` 语句的用途是：含有 `defer` 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。 ## 示例</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>go package main import ( \\"fmt\\" ) func finished() { fmt.Println(\\"Finished finding largest\\") } func largest(nums \\\\[\\\\]int) { defer finished() fmt.Println(\\"Started finding largest\\") max := nums\\\\[0\\\\] for \\\\_, v := range nums { if v &gt; max { max = v } } fmt.Println(\\"Largest number in\\", nums, \\"is\\", max) } func main() { nums := \\\\[\\\\]int{78, 109, 2, 563, 300} largest(nums) }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{g as comp,h as data};
