import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,o as i}from"./app-DIJDtupu.js";const g={};function l(r,t){return i(),s("div",null,t[0]||(t[0]=[a('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>text void ·exitsyscall(int32 dummy) { void (\\*fn)(G\\*); // 这个g到底是什么？ g-&gt;m-&gt;locks++; // see comment in entersyscall if(runtime·getcallersp(&amp;dummy) &gt; g-&gt;syscallsp) runtime·throw(&quot;exitsyscall: syscall frame is no longer valid&quot;); g-&gt;waitsince = 0; // 判断能否快速找到归属 if(exitsyscallfast()) { g-&gt;m-&gt;p-&gt;syscalltick++; // g的状态从syscall变成running，继续欢快地跑着 runtime·casgstatus(g, Gsyscall, Grunning); g-&gt;syscallsp = (uintptr)nil; g-&gt;m-&gt;locks--; if(g-&gt;preempt) { g-&gt;stackguard0 = StackPreempt; } else { g-&gt;stackguard0 = g-&gt;stack.lo + StackGuard; } g-&gt;throwsplit = 0; return; } g-&gt;m-&gt;locks--; // Call the scheduler. // 如果M回来发现P已经有别人服务了，那只能将自己挂起 // 等着服务别人。 fn = exitsyscall0; runtime·mcall(&amp;fn); ...... } static bool exitsyscallfast(void) { void (\\*fn)(void); if(runtime·sched.stopwait) { g-&gt;m-&gt;p = nil; return false; } // 如果之前附属的P尚未被其他M,尝试绑定该P if(g-&gt;m-&gt;p &amp;&amp; g-&gt;m-&gt;p-&gt;status == Psyscall &amp;&amp; runtime·cas(&amp;g-&gt;m-&gt;p-&gt;status, Psyscall, Prunning)) { g-&gt;m-&gt;mcache = g-&gt;m-&gt;p-&gt;mcache; g-&gt;m-&gt;p-&gt;m = g-&gt;m; return true; } // Try to get any other idle P. // 否则从空闲P列表中随便捞一个出来 g-&gt;m-&gt;p = nil; if(runtime·sched.pidle) { fn = exitsyscallfast\\_pidle; runtime·onM(&amp;fn); if(g-&gt;m-&gt;scalararg\\[0\\]) { g-&gt;m-&gt;scalararg\\[0\\] = 0; return true; } } return false; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',1)]))}const m=e(g,[["render",l],["__file","协程调度时机一：系统调用.html.vue"]]),o=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%80%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html","title":"协程调度时机一：系统调用","lang":"zh-CN","frontmatter":{"title":"协程调度时机一：系统调用","source_url":"https://studygolang.com/articles/11863","category":"Go原理教程","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%80%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"协程调度时机一：系统调用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"协程调度时机一：系统调用\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":0.97,"words":292},"filePathRelative":"golang/原理/theory/协程调度时机一：系统调用.md","localizedDate":"2025年8月26日","excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>text void ·exitsyscall(int32 dummy) { void (\\\\*fn)(G\\\\*); // 这个g到底是什么？ g-&gt;m-&gt;locks++; // see comment in entersyscall if(runtime·getcallersp(&amp;dummy) &gt; g-&gt;syscallsp) runtime·throw(\\"exitsyscall: syscall frame is no longer valid\\"); g-&gt;waitsince = 0; // 判断能否快速找到归属 if(exitsyscallfast()) { g-&gt;m-&gt;p-&gt;syscalltick++; // g的状态从syscall变成running，继续欢快地跑着 runtime·casgstatus(g, Gsyscall, Grunning); g-&gt;syscallsp = (uintptr)nil; g-&gt;m-&gt;locks--; if(g-&gt;preempt) { g-&gt;stackguard0 = StackPreempt; } else { g-&gt;stackguard0 = g-&gt;stack.lo + StackGuard; } g-&gt;throwsplit = 0; return; } g-&gt;m-&gt;locks--; // Call the scheduler. // 如果M回来发现P已经有别人服务了，那只能将自己挂起 // 等着服务别人。 fn = exitsyscall0; runtime·mcall(&amp;fn); ...... } static bool exitsyscallfast(void) { void (\\\\*fn)(void); if(runtime·sched.stopwait) { g-&gt;m-&gt;p = nil; return false; } // 如果之前附属的P尚未被其他M,尝试绑定该P if(g-&gt;m-&gt;p &amp;&amp; g-&gt;m-&gt;p-&gt;status == Psyscall &amp;&amp; runtime·cas(&amp;g-&gt;m-&gt;p-&gt;status, Psyscall, Prunning)) { g-&gt;m-&gt;mcache = g-&gt;m-&gt;p-&gt;mcache; g-&gt;m-&gt;p-&gt;m = g-&gt;m; return true; } // Try to get any other idle P. // 否则从空闲P列表中随便捞一个出来 g-&gt;m-&gt;p = nil; if(runtime·sched.pidle) { fn = exitsyscallfast\\\\_pidle; runtime·onM(&amp;fn); if(g-&gt;m-&gt;scalararg\\\\[0\\\\]) { g-&gt;m-&gt;scalararg\\\\[0\\\\] = 0; return true; } } return false; }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{m as comp,o as data};
