import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as r,o as l}from"./app-DIJDtupu.js";const i={};function n(a,e){return l(),o("div",null,e[0]||(e[0]=[r('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>text func netpollWait(pd \\*pollDesc, mode int) int { // 先检查该socket是否有error发生（如关闭、超时等） err := netpollcheckerr(pd, int32(mode)) if err != 0 { return err } // As for now only Solaris uses level-triggered IO. if GOOS == &quot;solaris&quot; { onM(func() { netpollarm(pd, mode) }) } // 循环等待netpollblock返回值为true // 如果返回值为false且该socket未出现任何错误 // 那该协程可能被意外唤醒，需要重新被挂起 // 还有一种可能：该socket由于超时而被唤醒 // 此时netpollcheckerr就是用来检测超时错误的 for !netpollblock(pd, int32(mode), false) { err = netpollcheckerr(pd, int32(mode)) if err != 0 { return err } } return 0 } func netpollblock(pd \\*pollDesc, mode int32, waitio bool) bool { gpp := &amp;pd.rg if mode == &#39;w&#39; { gpp = &amp;pd.wg } // set the gpp semaphore to WAIT // 首先将轮询状态设置为pdWait // 为什么要使用for呢？因为casuintptr使用了自旋锁 // 为什么使用自旋锁就要加for循环呢？ for { old := \\*gpp if old == pdReady { \\*gpp = 0 return true } if old != 0 { gothrow(&quot;netpollblock: double wait&quot;) } // 将socket轮询相关的状态设置为pdWait if casuintptr(gpp, 0, pdWait) { break } } // 如果未出错将该协程挂起，解锁函数是netpollblockcommit if waitio || netpollcheckerr(pd, mode) == 0 { f := netpollblockcommit gopark(\\*\\*(\\*\\*unsafe.Pointer)(unsafe.Pointer(&amp;f)), unsafe.Pointer(gpp), &quot;IO wait&quot;) } // 可能是被挂起的协程被唤醒 // 或者由于某些原因该协程压根未被挂起 // 获取其当前状态记录在old中 old := xchguintptr(gpp, 0) if old &gt; pdWait { gothrow(&quot;netpollblock: corrupted state&quot;) } return old == pdReady }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',1)]))}const d=t(i,[["render",n],["__file","Golang网络-核心API实现剖析二).html.vue"]]),c=JSON.parse(`{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90%E4%BA%8C).html","title":"\\"\\"Golang网络:核心API实现剖析二)\\"\\"","lang":"zh-CN","frontmatter":{"title":"\\"\\"Golang网络:核心API实现剖析二)\\"\\"","source_url":"https://studygolang.com/articles/11955","category":"Go原理教程","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90%E4%BA%8C).html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"\\"\\"Golang网络:核心API实现剖析二)\\"\\""}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\\\\\"\\\\\\"Golang网络:核心API实现剖析二)\\\\\\"\\\\\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":1.24,"words":371},"filePathRelative":"golang/原理/theory/Golang网络-核心API实现剖析二).md","localizedDate":"2025年8月26日","excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>text func netpollWait(pd \\\\*pollDesc, mode int) int { // 先检查该socket是否有error发生（如关闭、超时等） err := netpollcheckerr(pd, int32(mode)) if err != 0 { return err } // As for now only Solaris uses level-triggered IO. if GOOS == \\"solaris\\" { onM(func() { netpollarm(pd, mode) }) } // 循环等待netpollblock返回值为true // 如果返回值为false且该socket未出现任何错误 // 那该协程可能被意外唤醒，需要重新被挂起 // 还有一种可能：该socket由于超时而被唤醒 // 此时netpollcheckerr就是用来检测超时错误的 for !netpollblock(pd, int32(mode), false) { err = netpollcheckerr(pd, int32(mode)) if err != 0 { return err } } return 0 } func netpollblock(pd \\\\*pollDesc, mode int32, waitio bool) bool { gpp := &amp;pd.rg if mode == 'w' { gpp = &amp;pd.wg } // set the gpp semaphore to WAIT // 首先将轮询状态设置为pdWait // 为什么要使用for呢？因为casuintptr使用了自旋锁 // 为什么使用自旋锁就要加for循环呢？ for { old := \\\\*gpp if old == pdReady { \\\\*gpp = 0 return true } if old != 0 { gothrow(\\"netpollblock: double wait\\") } // 将socket轮询相关的状态设置为pdWait if casuintptr(gpp, 0, pdWait) { break } } // 如果未出错将该协程挂起，解锁函数是netpollblockcommit if waitio || netpollcheckerr(pd, mode) == 0 { f := netpollblockcommit gopark(\\\\*\\\\*(\\\\*\\\\*unsafe.Pointer)(unsafe.Pointer(&amp;f)), unsafe.Pointer(gpp), \\"IO wait\\") } // 可能是被挂起的协程被唤醒 // 或者由于某些原因该协程压根未被挂起 // 获取其当前状态记录在old中 old := xchguintptr(gpp, 0) if old &gt; pdWait { gothrow(\\"netpollblock: corrupted state\\") } return old == pdReady }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}`);export{d as comp,c as data};
