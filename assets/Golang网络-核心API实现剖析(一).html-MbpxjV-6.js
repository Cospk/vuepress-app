import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as i}from"./app-DIJDtupu.js";const l={};function t(r,e){return i(),n("div",null,e[0]||(e[0]=[a(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>这一章节我们将详细描述网络关键API的实现，主要包括Listen、Accept、Read、Write等。 另外，为了突出关键流程，我们选择忽略所有的错误。这样可以使得代码看起来更为简单。 而且我们只关注tcp协议实现，udp和unix socket不是我们关心的。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## **Listen**</span></span>
<span class="line"><span></span></span>
<span class="line"><span>\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>text<br> func Listen(net, laddr string) (Listener, error) {</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>la, err := resolveAddr(&quot;listen&quot;, net, laddr, noDeadline) ...... switch la := la.toAddr().(type) { case \\*TCPAddr: l, err = ListenTCP(net, la) case \\*UnixAddr: ...... } ...... }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 对于tcp协议，返回的的是TCPListener func ListenTCP(net string, laddr \\*TCPAddr) (\\*TCPListener, error) { ...... fd, err := internetSocket(net, laddr, nil, noDeadline, syscall.SOCK\\_STREAM, 0, &quot;listen&quot;) ...... return \\&amp;TCPListener{fd}, nil }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func internetSocket(net string, laddr, raddr sockaddr, deadline time.Time, sotype, proto int, mode string) (fd \\*netFD, err error) { ...... return socket(net, family, sotype, proto, ipv6only, laddr, raddr, deadline) }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func socket(net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, deadline time.Time) (fd \\*netFD, err error) { // 创建底层socket，设置属性为O\\_NONBLOCK s, err := sysSocket(family, sotype, proto) ...... setDefaultSockopts(s, family, sotype, ipv6only) // 创建新netFD结构 fd, err = newFD(s, family, sotype, net) ...... if laddr != nil &amp;&amp; raddr == nil { switch sotype { case syscall.SOCK\\_STREAM, syscall.SOCK\\_SEQPACKET: // 调用底层listen监听创建的套接字 fd.listenStream(laddr, listenerBacklog) return fd, nil case syscall.SOCK\\_DGRAM: ...... } }\\</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 最终调用该函数来创建一个socket // 并且将socket属性设置为O\\_NONBLOCK func sysSocket(family, sotype, proto int) (int, error) { syscall.ForkLock.RLock() s, err := syscall.Socket(family, sotype, proto) if err == nil { syscall.CloseOnExec(s) } syscall.ForkLock.RUnlock() if err != nil { return -1, err } if err = syscall.SetNonblock(s, true); err != nil { syscall.Close(s) return -1, err } return s, nil }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func (fd \\*netFD) listenStream(laddr sockaddr, backlog int) error { if err := setDefaultListenerSockopts(fd.sysfd) if lsa, err := laddr.sockaddr(fd.family); err != nil { return err } else if lsa != nil { // Bind绑定至该socket if err := syscall.Bind(fd.sysfd, lsa); err != nil { return os.NewSyscallError(&quot;bind&quot;, err) } } // 监听该socket if err := syscall.Listen(fd.sysfd, backlog); // 这里非常关键：初始化socket与异步IO相关的内容 if err := fd.init(); err != nil { return err } lsa, \\_ := syscall.Getsockname(fd.sysfd) fd.setAddr(fd.addrFunc()(lsa), nil) return nil }</span></span>
<span class="line"><span>\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3)]))}const o=s(l,[["render",t],["__file","Golang网络-核心API实现剖析(一).html.vue"]]),c=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90(%E4%B8%80).html","title":"\\"\\"Golang网络:核心API实现剖析(一)\\"\\"","lang":"zh-CN","frontmatter":{"title":"\\"\\"Golang网络:核心API实现剖析(一)\\"\\"","source_url":"https://studygolang.com/articles/11868","category":"Go原理教程","description":"text func Listen(net, laddr string) (Listener, error) {","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90(%E4%B8%80).html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"\\"\\"Golang网络:核心API实现剖析(一)\\"\\""}],["meta",{"property":"og:description","content":"text func Listen(net, laddr string) (Listener, error) {"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\\\\\"\\\\\\"Golang网络:核心API实现剖析(一)\\\\\\"\\\\\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":1.54,"words":461},"filePathRelative":"golang/原理/theory/Golang网络-核心API实现剖析(一).md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>这一章节我们将详细描述网络关键API的实现，主要包括Listen、Accept、Read、Write等。 另外，为了突出关键流程，我们选择忽略所有的错误。这样可以使得代码看起来更为简单。 而且我们只关注tcp协议实现，udp和unix socket不是我们关心的。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>## **Listen**</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>`</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{o as comp,c as data};
