import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as n}from"./app-DIJDtupu.js";const r={};function s(o,e){return n(),i("div",null,e[0]||(e[0]=[a('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在比较C++和Go的时候，通常会说到Go不支持继承和多态，但通过组合和接口实现了类似的语言特性。总结一下Go不支持的原因：(1) 首先struct是值类型，赋值和传参都会复制全部内容。struct的内存布局跟C几乎一致，没有任何附加的object信息，比如指向虚函数表的指针。(2)其次Go不支持隐式的类型转换，因此用基类的指针指向子类会编译错误。 &gt; **Go程序抽象的基本原则**依赖于接口而不是实现，优先使用组合而不是继承。 ## [](#struct的方法调用 &quot;struct的方法调用&quot;)struct的方法调用 对象的方法调用相当于普通函数调用的语法糖。Value方法的调用`m.Value()`等价于`func Value(m M)` 即把**对象实例m**作为函数调用的第一个实参压栈，这时m称为**receiver**。通过实例或实例的指针其实都可以调用所有方法，区别是复制给函数的receiver不同。 &gt; 通过实例m调用Value时，以及通过指针p调用Value时，receiver是m和\\*p，即复制的是m实例本身。因此receiver是m实例的副本，他们地址不同。通过实例m调用Pointer时，以及通过指针p调用Pointer时，复制的是都是\\&amp;m和p，即复制的都是指向m的指针，返回的都是m实例的地址。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type M struct { a int } func (m M) Value() string {return fmt.Sprintf(&quot;Value: %p\\\\n&quot;, &amp;m)} func (m \\*M) Pointer() string {return fmt.Sprintf(&quot;Pointer: %p\\\\n&quot;, m)} var m M p := &amp;m // p is address of m 0x2101ef018 m.Value() // value(m) return 0x2101ef028 m.Pointer() // value(&amp;m) return 0x2101ef018 p.Value() // value(\\*p) return 0x2101ef030 p.Pointer() // value(p) return 0x2101ef018</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果想在方法中修改对象的值只能用pointer receiver，对象较大时避免拷贝也要用pointer receiver。 ### [](#方法集理解 &quot;方法集理解&quot;)方法集理解 上面例子中通过实例m和p都可以调用全部方法，由编译器自动转换。在很多go的语法书里有方法集的概念。类型T方法集包含全部receiver T方法，类型\\*T包含全部receiver T和\\*T的方法。这句话一直不理解，既然通过实例和指针可以访问T和\\*T的所有方法，那方法集的意义是什么。 &gt; 定义在M类型的方法除了通过实例和实例指针访问，还可以通过`method expression`的方式调用。这时Pointer对M类型就是不可见的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go (M).Value(m) // valid (M).Pointer(m) // invalid M does not have Pointer (\\*M).Value(&amp;m) // valid (\\*M).Pointer(&amp;m) // valid</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>再解释一下method value的receiver复制的问题。这里u.Test返回的类型类似于闭包返回的FuncVal类型，也就是`FuncVal{method_address, receiver_copy}`对象。因此下面例子中mValue中已经包含了实例u的副本。当然如果Test方法的receiver是\\*User，结果将不一样。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go u := User{1} // User{Id int} mValue := u.Test // func(s User) Test() {fmt.Println(s.Id)} u.Id = 2 u.Test() // output: 2 mValue() // output: 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="匿名字段与组合-匿名字段与组合-匿名字段与组合-go没有继承-但是有结构体嵌入。当一个类型t被匿名的嵌入另一类型m时-t的方法也就会拷贝到m的方法表当中。这时根据方法集的规则-如果m包含的是-t-则m包含t与-t上所有的方法。-通过匿名字段-go实现了类似继承的复用能力-并且可以在m上定义相同的方法名实现-override-。-interface接口实现-interface接口实现-interface接口实现-go的interface是一种内置类型-属于动态风格的-duck-typing-类型。接口作为方法签名的集合-任何类型的方法集中只要拥有与之对应的全部方法-就表示它实现了该接口。-interface底层结构-interface底层结构-interface底层结构-interface是一个结构体-包含两个成员。根据interface是否包含方法-底层又分为两个结构体。eface主要是保存了类型信息-以后总结反射时具体讲-这里先总结带方法的iface。结构体定义在-runtime2-go-显然iface由两部分组成-data域保存元数据-tab描述接口。" tabindex="-1"><a class="header-anchor" href="#匿名字段与组合-匿名字段与组合-匿名字段与组合-go没有继承-但是有结构体嵌入。当一个类型t被匿名的嵌入另一类型m时-t的方法也就会拷贝到m的方法表当中。这时根据方法集的规则-如果m包含的是-t-则m包含t与-t上所有的方法。-通过匿名字段-go实现了类似继承的复用能力-并且可以在m上定义相同的方法名实现-override-。-interface接口实现-interface接口实现-interface接口实现-go的interface是一种内置类型-属于动态风格的-duck-typing-类型。接口作为方法签名的集合-任何类型的方法集中只要拥有与之对应的全部方法-就表示它实现了该接口。-interface底层结构-interface底层结构-interface底层结构-interface是一个结构体-包含两个成员。根据interface是否包含方法-底层又分为两个结构体。eface主要是保存了类型信息-以后总结反射时具体讲-这里先总结带方法的iface。结构体定义在-runtime2-go-显然iface由两部分组成-data域保存元数据-tab描述接口。"><span>[](#匿名字段与组合 &quot;匿名字段与组合&quot;)匿名字段与组合 Go没有继承，但是有结构体嵌入。当一个类型T被匿名的嵌入另一类型M时，T的方法也就会拷贝到M的方法表当中。这时根据方法集的规则，如果M包含的是\\*T，则M包含T与\\*T上所有的方法。 &gt; 通过匿名字段，Go实现了类似继承的复用能力，并且可以在M上定义相同的方法名实现**override**。 ## [](#interface接口实现 &quot;interface接口实现&quot;)interface接口实现 Go的interface是一种内置类型，属于动态风格的**duck-typing**类型。接口作为方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法，就表示它实现了该接口。 ### [](#interface底层结构 &quot;interface底层结构&quot;)interface底层结构 interface是一个结构体，包含两个成员。根据interface是否包含方法，底层又分为两个结构体。eface主要是保存了类型信息，以后总结反射时具体讲，这里先总结带方法的iface。结构体定义在`runtime2.go`显然iface由两部分组成，data域保存元数据，tab描述接口。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type eface struct { \\_type \\*\\_type data unsafe.Pointer } type iface struct { tab \\*itab data unsafe.Pointer }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type itab struct { inter \\*interfacetype // 保存该接口的方法签名 \\_type \\*\\_type // 保存动态类型的type类型信息 link \\*itab // 可能有嵌套的itab bad int32 unused int32 fun \\[1\\]uintptr // 保存动态类型对应的实现 } type interfacetype struct { type \\_type mhdr \\[\\]imethod }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为了理解iface的数据结构，找到一个[唐老鸭接口](<a href="https://juejin.im/entry/59a6284df265da24921b3e36" target="_blank" rel="noopener noreferrer">https://juejin.im/entry/59a6284df265da24921b3e36</a>)接口的例子，通过gdb看看iface的数据到底是什么。首先`dd=&amp;DonalDuck{}`这个类型的方法集包括`MakeFun Walking Speaking` 它实现了**Duck**和**Actor**两个接口。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type Duck interface { GaGaSpeaking() OfficialWalking() } type Actor interface { MakeFun() } type DonaldDuck struct { height uint name string } func (dd \\*DonaldDuck) GaGaSpeaking() { fmt.Println(&quot;DonaldDuck gaga&quot;) } func (dd \\*DonaldDuck) OfficialWalking() { fmt.Println(&quot;DonaldDuck walk&quot;) } func (dd \\*DonaldDuck) MakeFun() { fmt.Println(&quot;DonaldDuck make fun&quot;) } func main() { dd := &amp;DonaldDuck{10, &quot;tang lao ya&quot;} var duck Duck = dd var actor Actor = dd duck.GaGaSpeaking() actor.MakeFun() dd.OfficialWalking() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以看出来当dd赋值给接口Duck后，接口duck的**data域**保存的地址就是dd对象指向的地址。**tab域**的inter字段里保存了实现这个接口的两个**方法声明**，其中name保存了方法的名字。**tab域**的func指针指向了具体实现，即这个符号对应的代码段`.text`地址。 ![](<a href="https://ninokop.github.io/2017/10/29/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3/gdb.png" target="_blank" rel="noopener noreferrer">https://ninokop.github.io/2017/10/29/Go-方法调用与接口/gdb.png</a>) &gt; 具体T类型到Iface的转换涉及到3个内容的复制 (1) iface的tab域的func字段保存T类型的方法集，即对tab域inter声明的方法的实现。(2) iface的data域指针指向用于赋值的对象的副本。(3) iface的tab域的\\_type字段保存T类型的\\_type。 ![](<a href="https://ninokop.github.io/2017/10/29/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3/itab.png" target="_blank" rel="noopener noreferrer">https://ninokop.github.io/2017/10/29/Go-方法调用与接口/itab.png</a>) ### [](#编译期检测 &quot;编译期检测&quot;)编译期检测 当T类型没有实现I接口中所有方法时，从T到I的赋值将抛出`TypeAssertionError`编译错误。检查的方法在函数additab当中，即查看T类型的**\\_type**方法表**uncommentType**是否包含了I接口**interfacetype**中所有的**imethod**，同时将T类型对方法的实现拷贝到tab的**func**指向的表中。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type \\_type struct { size uintptr ptrdata uintptr // size of memory prefix holding all pointers hash uint32 \\_unused uint8 align uint8 fieldalign uint8 kind uint8 alg \\*typeAlg gcdata \\*byte \\_string \\*string x \\*uncommontype ptrto \\*\\_type zero \\*byte // ptr to the zero value for this type } type uncommontype struct { name \\*string pkgpath \\*string mhdr \\[\\]method }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="三张方法表的区别-三张方法表的区别-三张方法表的区别-1-每个-具体t类型type-结构对应的方法表是-uncommontype-类型的方法集都在这里。reflect包中的method和methodbyname方法都是通过查询这张表实现的。表中每一项都是-method-。" tabindex="-1"><a class="header-anchor" href="#三张方法表的区别-三张方法表的区别-三张方法表的区别-1-每个-具体t类型type-结构对应的方法表是-uncommontype-类型的方法集都在这里。reflect包中的method和methodbyname方法都是通过查询这张表实现的。表中每一项都是-method-。"><span>[](#三张方法表的区别 &quot;三张方法表的区别&quot;)三张方法表的区别 1\\) 每个**具体T类型type**结构对应的方法表是`uncommontype`，类型的方法集都在这里。reflect包中的Method和MethodByName方法都是通过查询这张表实现的。表中每一项都是`method`。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type method struct { name \\*string pkgpath \\*string mtyp \\*\\_type typ \\*\\_type ifn unsafe.Pointer tfn unsafe.Pointer }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>2\\) itab的**interfacetype**域是一张方法表，它声明了接口所有的方法，每一项都是`imethod`，可见它`没有实现只有声明`。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go type imethod struct { name \\*string pkgpath \\*string \\_type \\*type }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>3\\) itab的**func**域也是一张方法表，表中每一项是一个函数指针，也就是`只有实现没有声明`。即赋值的时候只是把具体类型的实现，即函数指针拷贝给了itab的func域。 ### [](#运行时-ConvT2I &quot;运行时 ConvT2I&quot;)运行时 ConvT2I [Go-internals](<a href="https://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html" target="_blank" rel="noopener noreferrer">https://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html</a>)分析了go编译器在编译期生成的语法树节点。在T2I的转换时，通过`getitab`产生了中间状态`itab`。并且调用`convT2I`完成了运行时数据**data域**的内存拷贝，以及中间状态itab到**tab域**的赋值。 可以看到`getitab`完成了T类型的方法表的实现地址到tab的fnc\\[0]的赋值。完成`getiab`需要T类型的\\_type信息，以及I接口类型的interfacetype方法表，这些都是编译期提供的。因此接口的动态性和反射的实现都是以编译期为运行时提供的类型信息为基础的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func getitab(inter \\*interfacetype, typ \\*\\_type, canfail bool) \\*itab { .. m = (\\*itab)(persistentalloc(unsafe.Sizeof(itab{})+ uintptr(len(inter.mhdr)-1)\\*ptrSize, 0, &amp;memstats.other\\_sys)) m.inter = inter m.\\_type = typ ... for k := 0; k &lt; ni; k++ { for ; j &lt; nt; j++ { \\*(\\*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun\\[0\\]), uintptr(k)\\*ptrSize)) = t.ifn } goto nextimethod } // didn&#39;t find method if !canfail { panic(&amp;TypeAssertionError{&quot;&quot;, \\*typ.\\_string, \\*inter.typ.\\_string, \\*iname}) } return m }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>最后的`convT2I`存在数据的内存拷贝，可见**data域**是T类型对象的一个拷贝。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func convT2I(t \\*\\_type, inter \\*interfacetype, cache \\*\\*itab, elem unsafe.Pointer, x unsafe.Pointer) (i fInterface) { tab := (\\*itab)(atomicloadp(unsafe.Pointer(cache))) ... if x == nil { x = newobject(t) } typedmemmove(t, x, elem) pi.tab = tab pi.data = x return }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>**总结** 将对象赋值给接口时，编译期检查对象是否实现了接口所有的方法。运行时将对象的数据、类型、实现拷贝到iface接口当中。</p>',23)]))}const l=t(r,[["render",s],["__file","Go-方法调用与接口.html.vue"]]),p=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3.html","title":"Go 方法调用与接口","lang":"zh-CN","frontmatter":{"title":"Go 方法调用与接口","source_url":"https://studygolang.com/articles/11992","category":"Go原理教程","description":"在比较C++和Go的时候，通常会说到Go不支持继承和多态，但通过组合和接口实现了类似的语言特性。总结一下Go不支持的原因：(1) 首先struct是值类型，赋值和传参都会复制全部内容。struct的内存布局跟C几乎一致，没有任何附加的object信息，比如指向虚函数表的指针。(2)其次Go不支持隐式的类型转换，因此用基类的指针指向子类会编译错误。 > ...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 方法调用与接口"}],["meta",{"property":"og:description","content":"在比较C++和Go的时候，通常会说到Go不支持继承和多态，但通过组合和接口实现了类似的语言特性。总结一下Go不支持的原因：(1) 首先struct是值类型，赋值和传参都会复制全部内容。struct的内存布局跟C几乎一致，没有任何附加的object信息，比如指向虚函数表的指针。(2)其次Go不支持隐式的类型转换，因此用基类的指针指向子类会编译错误。 > ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 方法调用与接口\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"[](#匿名字段与组合 \\"匿名字段与组合\\")匿名字段与组合 Go没有继承，但是有结构体嵌入。当一个类型T被匿名的嵌入另一类型M时，T的方法也就会拷贝到M的方法表当中。这时根据方法集的规则，如果M包含的是\\\\*T，则M包含T与\\\\*T上所有的方法。 > 通过匿名字段，Go实现了类似继承的复用能力，并且可以在M上定义相同的方法名实现**override**。 ## [](#interface接口实现 \\"interface接口实现\\")interface接口实现 Go的interface是一种内置类型，属于动态风格的**duck-typing**类型。接口作为方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法，就表示它实现了该接口。 ### [](#interface底层结构 \\"interface底层结构\\")interface底层结构 interface是一个结构体，包含两个成员。根据interface是否包含方法，底层又分为两个结构体。eface主要是保存了类型信息，以后总结反射时具体讲，这里先总结带方法的iface。结构体定义在`runtime2.go`显然iface由两部分组成，data域保存元数据，tab描述接口。","slug":"匿名字段与组合-匿名字段与组合-匿名字段与组合-go没有继承-但是有结构体嵌入。当一个类型t被匿名的嵌入另一类型m时-t的方法也就会拷贝到m的方法表当中。这时根据方法集的规则-如果m包含的是-t-则m包含t与-t上所有的方法。-通过匿名字段-go实现了类似继承的复用能力-并且可以在m上定义相同的方法名实现-override-。-interface接口实现-interface接口实现-interface接口实现-go的interface是一种内置类型-属于动态风格的-duck-typing-类型。接口作为方法签名的集合-任何类型的方法集中只要拥有与之对应的全部方法-就表示它实现了该接口。-interface底层结构-interface底层结构-interface底层结构-interface是一个结构体-包含两个成员。根据interface是否包含方法-底层又分为两个结构体。eface主要是保存了类型信息-以后总结反射时具体讲-这里先总结带方法的iface。结构体定义在-runtime2-go-显然iface由两部分组成-data域保存元数据-tab描述接口。","link":"#匿名字段与组合-匿名字段与组合-匿名字段与组合-go没有继承-但是有结构体嵌入。当一个类型t被匿名的嵌入另一类型m时-t的方法也就会拷贝到m的方法表当中。这时根据方法集的规则-如果m包含的是-t-则m包含t与-t上所有的方法。-通过匿名字段-go实现了类似继承的复用能力-并且可以在m上定义相同的方法名实现-override-。-interface接口实现-interface接口实现-interface接口实现-go的interface是一种内置类型-属于动态风格的-duck-typing-类型。接口作为方法签名的集合-任何类型的方法集中只要拥有与之对应的全部方法-就表示它实现了该接口。-interface底层结构-interface底层结构-interface底层结构-interface是一个结构体-包含两个成员。根据interface是否包含方法-底层又分为两个结构体。eface主要是保存了类型信息-以后总结反射时具体讲-这里先总结带方法的iface。结构体定义在-runtime2-go-显然iface由两部分组成-data域保存元数据-tab描述接口。","children":[]},{"level":3,"title":"[](#三张方法表的区别 \\"三张方法表的区别\\")三张方法表的区别 1\\\\) 每个**具体T类型type**结构对应的方法表是`uncommontype`，类型的方法集都在这里。reflect包中的Method和MethodByName方法都是通过查询这张表实现的。表中每一项都是`method`。","slug":"三张方法表的区别-三张方法表的区别-三张方法表的区别-1-每个-具体t类型type-结构对应的方法表是-uncommontype-类型的方法集都在这里。reflect包中的method和methodbyname方法都是通过查询这张表实现的。表中每一项都是-method-。","link":"#三张方法表的区别-三张方法表的区别-三张方法表的区别-1-每个-具体t类型type-结构对应的方法表是-uncommontype-类型的方法集都在这里。reflect包中的method和methodbyname方法都是通过查询这张表实现的。表中每一项都是-method-。","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":7.7,"words":2309},"filePathRelative":"golang/原理/theory/Go-方法调用与接口.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{l as comp,p as data};
