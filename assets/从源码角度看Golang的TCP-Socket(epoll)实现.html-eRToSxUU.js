import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o}from"./app-DIJDtupu.js";const a={};function r(l,e){return o(),n("div",null,e[0]||(e[0]=[i(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span># 从源码角度看Golang的TCP Socket(epoll)实现</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Golang的TCP是基于系统的epoll IO模型进行封装实现，本章从TCP的预备工作到runtime下的实时运行工作原理进行分析。仅关注linux系统下的逻辑。代码版本GO1.12.6。 本章例子中的代码对应详细注释参考：[gosrc1.12.6](<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fthinkboy%2Fgosrc1.12.6" target="_blank" rel="noopener noreferrer">https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fthinkboy%2Fgosrc1.12.6</a>) &gt; 读文章可能并不是最好的读懂源码的办法，读文章只能有个大致概念，最好的办法拿文章是对照源码理解。 --- # 目录 先来个目录方便读者理解文本结构 - 1.[TCP预备工作](#TCP%E9%A2%84%E5%A4%87%E5%B7%A5%E4%BD%9C) - 1.1 [Server端](#Server%E7%AB%AF) - 1.2 [Client端](#Client%E7%AB%AF) - 2.[epoll](#epoll) - 2.1 [如何实现异步非阻塞](#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E) - 2.2 [epoll的创建与事件注册](#epoll%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC) - 2.3 [小结](#%E5%B0%8F%E7%BB%93) - 3.[TCP的超时机制](#TCP%E7%9A%84%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6) # TCP预备工作 ## Server端</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> //TcpServer.go package main import ( &quot;fmt&quot; &quot;net&quot; ) func main() { ln, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil { panic(err) } for { conn, err := ln.Accept() if err != nil { panic(err) } // 每个Client一个Goroutine go handleConnection(conn) } } func handleConnection(conn net.Conn) { defer conn.Close() var body \\[4\\]byte addr := conn.RemoteAddr() for { // 读取客户端消息 \\_, err := conn.Read(body\\[:\\]) if err != nil { break } fmt.Printf(&quot;收到%s消息: %s\\\\n&quot;, addr, string(body\\[:\\])) // 回包 \\_, err = conn.Write(body\\[:\\]) if err != nil { break } fmt.Printf(&quot;发送给%s: %s\\\\n&quot;, addr, string(body\\[:\\])) } fmt.Printf(&quot;与%s断开!\\\\n&quot;, addr) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面是一个简单的TCP Server的例子，代码并不是很多。通过一张图先来看下TCP相关源代码的大致结构。</p>`,4)]))}const p=t(a,[["render",r],["__file","从源码角度看Golang的TCP-Socket(epoll)实现.html.vue"]]),d=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BGolang%E7%9A%84TCP-Socket(epoll)%E5%AE%9E%E7%8E%B0.html","title":"从源码角度看Golang的TCP Socket(epoll)实现","lang":"zh-CN","frontmatter":{"title":"从源码角度看Golang的TCP Socket(epoll)实现","source_url":"https://studygolang.com/articles/22460","category":"Go原理教程","description":"Golang的TCP是基于系统的epoll IO模型进行封装实现，本章从TCP的预备工作到runtime下的实时运行工作原理进行分析。仅关注linux系统下的逻辑。代码版本GO1.12.6。 本章例子中的代码对应详细注释参考：[gosrc1.12.6](https://links.jianshu.com/go?to=https%3A%2F%2Fgith...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BGolang%E7%9A%84TCP-Socket(epoll)%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"从源码角度看Golang的TCP Socket(epoll)实现"}],["meta",{"property":"og:description","content":"Golang的TCP是基于系统的epoll IO模型进行封装实现，本章从TCP的预备工作到runtime下的实时运行工作原理进行分析。仅关注linux系统下的逻辑。代码版本GO1.12.6。 本章例子中的代码对应详细注释参考：[gosrc1.12.6](https://links.jianshu.com/go?to=https%3A%2F%2Fgith..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"从源码角度看Golang的TCP Socket(epoll)实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":1.55,"words":465},"filePathRelative":"golang/原理/theory/从源码角度看Golang的TCP-Socket(epoll)实现.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span># 从源码角度看Golang的TCP Socket(epoll)实现</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{p as comp,d as data};
