import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as i}from"./app-DIJDtupu.js";const o={};function n(s,e){return i(),a("div",null,e[0]||(e[0]=[t('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>通常C++通过指针引用计数来回收对象，但是这**不能处理循环引用**。为了避免引用计数的缺陷，后来出现了标记清除，分代等垃圾回收算法。Go的垃圾回收官方形容为 **非分代 非紧缩 写屏障 并发标记清理**。标记清理算法的字面解释，就是将可达的内存块进行标记`mark`，最后没有标记的不可达内存块将进行清理`sweep`。 ## [](#三色标记法 &quot;三色标记法&quot;)三色标记法 判断一个对象是不是垃圾需不需要标记，就看是否能从当前栈或全局数据区 直接或间接的引用到这个对象。这个初始的当前goroutine的栈和全局数据区称为GC的root区。扫描从这里开始，通过`markroot`将所有root区域的指针标记为可达，然后沿着这些指针扫描，递归地标记遇到的所有可达对象。因此引出几个问题： &gt; 1. 标记清理能不能与用户代码并发 &gt; 2. 如何获得对象的类型而找到所有可达区域 标记位记录在哪里 &gt; 3. 何时触发标记清理 ### [](#如何并发标记 &quot;如何并发标记&quot;)如何并发标记 标记清扫算法在标记和清理时需要停止所有的goroutine，来保证已经被标记的区域不会被用户修改引用关系，造成清理错误。但是每次GC都要StopTheWorld显然是不能接受的。Go的各个版本为减少STW做了各种努力。从Go1.5开始采用三色标记法实现标记阶段的并发。 - 最开始所有对象都是白色 - 扫描所有可达对象，标记为灰色，放入待处理队列 - 从队列提取灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色 - 写屏障监控对象内存修改，重新标色或是放入队列 完成标记后 对象不是白色就是黑色，清理操作只需要把白色对象回收内存回收就好。 ![](<a href="https://ninokop.github.io/2017/11/09/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Animation%5C_of%5C_tri-color%5C_garbage%5C_collection.gif" target="_blank" rel="noopener noreferrer">https://ninokop.github.io/2017/11/09/Go-垃圾回收/Animation\\_of\\_tri-color\\_garbage\\_collection.gif</a>) **大概理解所谓并发标记，首先是指能够跟用户代码并发的进行，其次是指标记工作不是递归地进行，而是多个goroutine并发的进行**。前者通过write-barrier解决并发问题，后者通过gc-work队列实现非递归地mark可达对象。 #### [](#write-barrier &quot;write-barrier&quot;)write-barrier 用下面这个例子解释并发带来的问题，原文引用自[CMS垃圾回收器原理](<a href="https://github.com/pzxwhc/MineKnowContainer/issues/89" target="_blank" rel="noopener noreferrer">https://github.com/pzxwhc/MineKnowContainer/issues/89</a>)。当从A这个GC root找到引用对象B时，B变灰A变黑。这时用户goroutine执行把A到B的引用改成了A到C的引用，同时B不再引用C。然后GC goroutine又执行，发现B没有引用对象，B变黑。而这时由于A已经变黑完成了扫描，C将当做白色不可达对象被清除。 ![](<a href="https://ninokop.github.io/2017/11/09/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/abc.png" target="_blank" rel="noopener noreferrer">https://ninokop.github.io/2017/11/09/Go-垃圾回收/abc.png</a>) &gt; 解决办法：**引入写屏障**。当发现A已经标记为黑色了，若A又引用C，那么把C变灰入队。这个write\\_barrier是编译器在每一处内存写操作前生成一小段代码来做的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // 写屏障伪代码 write\\_barrier(obj,field,newobj){ if(newobj.mark == FALSE){ newobj.mark = TRUE push(newobj,$mark\\_stack) } \\*field = newobj }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="gc-work-gc-work-gc-work-如何非递归的实现遍历mark可达节点-显然需要一个队列。-这个队列也帮助区分黑色对象和灰色对象-因为标记位只有一个。标记并且在队列中的是灰色对象-标记了但是不在队列中的黑色对象-末标记的是白色对象。" tabindex="-1"><a class="header-anchor" href="#gc-work-gc-work-gc-work-如何非递归的实现遍历mark可达节点-显然需要一个队列。-这个队列也帮助区分黑色对象和灰色对象-因为标记位只有一个。标记并且在队列中的是灰色对象-标记了但是不在队列中的黑色对象-末标记的是白色对象。"><span>[](#gc-work &quot;gc-work&quot;)gc-work 如何非递归的实现遍历mark可达节点，显然需要一个队列。 &gt; 这个队列也帮助区分黑色对象和灰色对象，因为标记位只有一个。标记并且在队列中的是灰色对象，标记了但是不在队列中的黑色对象，末标记的是白色对象。</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go root node queue while(queue is not nil) { dequeue // 节点出队 process // 处理当前节点 child node queue // 子节点入队 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>总结一下并发标记的过程： 1. `gcstart`启动阶段准备了N个`goMarkWorkers`。每个worker都处理以下相同流程。 2. 如果是第一次mark则首先`markroot`将所有root区的指针入队。 3. 从gcw中取节点出对开始扫描处理`scanobject`，节点出队列就是黑色了。 4. 扫描时获取该节点所有子节点的类型信息判断是不是指针，若是指针且并没有被标记则`greyobject`入队。 5. 每个worker都去gcw中拿任务直到为空break。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // 每个markWorker都执行gcDrain这个标记过程 func gcDrain(gcw \\*gcWork, flags gcDrainFlags) { // 如果还没有root区域入队则markroot markroot(gcw, job) if idle &amp;&amp; pollWork() { goto done } // 节点出队 b = gcw.get() scanobject(b, gcw) done: } func scanobject(b uintptr, gcw \\*gcWork) { hbits := heapBitsForAddr(b) s := spanOfUnchecked(b) n := s.elemsize for i = 0; i &lt; n; i += sys.PtrSize { // Find bits for this word. if bits&amp;bitPointer == 0 { continue // not a pointer } .... // Mark the object. if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 { greyobject(obj, b, i, hbits, span, gcw, objIndex) } } gcw.bytesMarked += uint64(n) gcw.scanWork += int64(i) } func greyobject(obj, base, off uintptr, hbits heapBits, span \\*mspan, gcw \\*gcWork, objIndex uintptr) { mbits := span.markBitsForIndex(objIndex) // If marked we have nothing to do. if mbits.isMarked() { return } if !hbits.hasPointers(span.elemsize) { return } gcw.put(obj) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="标记位-标记位-标记位-实现精确地垃圾回收的前提-就是能获得对象区域的类型信息-从而判断是否是指针。如何判断-最后又把可达标记记在哪里-通过堆区arena前面对应的bitmap-。-结构体中不包含指针-其实不需要递归地标记结构体成员。如果没有类型信息只能对所有的结构体成员递归地标记下去。还有如果非指���成员刚好存储的内容对应着合法地址-那这个地址的对象就会碰巧被标记���导致无法回收。-这个bitmap位图区域每个字-32位或64位-会对应4位的标记位。-heapbitsforaddr-可以获取对应堆地址的bitmap位hbits-根据它可以判断是否是指针-如果是指针且之前没有被标记过-则mark当前对象为可达-并且-greayobject-入队-供给其他的markworker来处理。" tabindex="-1"><a class="header-anchor" href="#标记位-标记位-标记位-实现精确地垃圾回收的前提-就是能获得对象区域的类型信息-从而判断是否是指针。如何判断-最后又把可达标记记在哪里-通过堆区arena前面对应的bitmap-。-结构体中不包含指针-其实不需要递归地标记结构体成员。如果没有类型信息只能对所有的结构体成员递归地标记下去。还有如果非指���成员刚好存储的内容对应着合法地址-那这个地址的对象就会碰巧被标记���导致无法回收。-这个bitmap位图区域每个字-32位或64位-会对应4位的标记位。-heapbitsforaddr-可以获取对应堆地址的bitmap位hbits-根据它可以判断是否是指针-如果是指针且之前没有被标记过-则mark当前对象为可达-并且-greayobject-入队-供给其他的markworker来处理。"><span>[](#标记位 &quot;标记位&quot;)标记位 实现精确地垃圾回收的前提，就是能获得对象区域的类型信息，从而判断是否是指针。如何判断，最后又把可达标记记在哪里：**通过堆区arena前面对应的bitmap**。 &gt; 结构体中不包含指针，其实不需要递归地标记结构体成员。如果没有类型信息只能对所有的结构体成员递归地标记下去。还有如果非指���成员刚好存储的内容对应着合法地址，那这个地址的对象就会碰巧被标记���导致无法回收。 这个bitmap位图区域每个字(32位或64位)会对应4位的标记位。`heapBitsForAddr`可以获取对应堆地址的bitmap位hbits，根据它可以判断是否是指针，如果是指针且之前没有被标记过，则mark当前对象为可达，并且`greayObject`入队，供给其他的markWorker来处理。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // 获取b对应的bitmap位图 obj, hbits, span, objIndex := heapBitsForObject(obj, b, i) mbits := span.markBitsForIndex(objIndex) // 判断是否被标记过 已标记或不是指针都不入队 mbits.isMarked() hbits.hasPointers(span.elemsize)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>gc\\_trigger最开始是4MB，next\\_gc初始为4MB，之后每次标记完成时将重新计算动态调整值大小。但gc\\_trigger至少要大于初始的4MB，同时至少要比当前使用的heap大1MB。 &gt; gcmark在每次标记结束后重置阈值大小。当前使用了4MB内存，这时设置gc\\_trigger为2\\*4MB，也就是当内存分配到8MB时会再次触发GC。回收之后内存为5MB，那下一次要达到10MB才会触发GC。这个比例triggerRatio是由gcpercent/100决定的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func gcinit() { \\_ = setGCPercent(readgogc()) memstats.gc\\_trigger = heapminimum memstats.next\\_gc = uint64(float64(memstats.gc\\_trigger) / (1 + gcController.triggerRatio) \\* (1 + float64(gcpercent)/100)) work.startSema = 1 work.markDoneSema = 1 } func gcMark() { memstats.gc\\_trigger = uint64(float64(memstats.heap\\_marked) \\* (1 + gcController.triggerRatio)) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="强制垃圾回收-强制垃圾回收-强制垃圾回收-如果系统启动或短时间内大量分配对象-会将垃圾回收的gc-trigger推高。当服务正常后-活跃对象远小于这个阈值-造成垃圾回收无法触发。这个问题交给sysmon解决。它每隔2分钟force触发gc一次。这个forcegc的goroutine一直park在后台-直到sysmon将它唤醒开始执行gc而不用检查阈值。" tabindex="-1"><a class="header-anchor" href="#强制垃圾回收-强制垃圾回收-强制垃圾回收-如果系统启动或短时间内大量分配对象-会将垃圾回收的gc-trigger推高。当服务正常后-活跃对象远小于这个阈值-造成垃圾回收无法触发。这个问题交给sysmon解决。它每隔2分钟force触发gc一次。这个forcegc的goroutine一直park在后台-直到sysmon将它唤醒开始执行gc而不用检查阈值。"><span>[](#强制垃圾回收 &quot;强制垃圾回收&quot;)强制垃圾回收 如果系统启动或短时间内大量分配对象，会将垃圾回收的gc\\_trigger推高。当服务正常后，活跃对象远小于这个阈值，造成垃圾回收无法触发。这个问题交给sysmon解决。它每隔2分钟force触发GC一次。这个forcegc的goroutine一直park在后台，直到sysmon将它唤醒开始执行gc而不用检查阈值。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // proc.go var forcegcperiod int64 = 2 \\* 60 \\* 1e9 func init() { go forcegchelper()} func sysmon() { lastgc := int64(atomic.Load64(&amp;memstats.last\\_gc)) if gcphase == \\_GCoff &amp;&amp; lastgc != 0 &amp;&amp; unixnow-lastgc &gt; forcegcperiod &amp;&amp; atomic.Load(&amp;forcegc.idle) != 0 { injectglist(forcegc.g) } } func forcegchelper() { for { goparkunlock(&amp;forcegc.lock, &quot;force gc (idle)&quot;, traceEvGoBlock, 1) gcStart(gcBackgroundMode, true) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="标记与清理过程-标记与清理过程-标记与清理过程-这里结合gc-work那一节从头梳理一下gc的启动和流程。下面这个图总结了mark-sweep所有的状态变化。在代码里只有三个gc状态-分别对应这几个阶段。总结两个问题-1-为什么marktermination需要rescan全局指针和栈-。因为mark阶段是跟用户代码并发的-所以有可能栈上都分了新的对象-这些对象通过write-barrier记录下来-在rescan的时候再检查一遍。-2-为什么还需要两个stoptheworld-在gctermination时需要stw不然永远都可能栈上出现新对象。在gc开始之前做准备工作-比如-enable-write-barrier-的时候也要stw。-https-ninokop-github-io-2017-11-09-go-垃圾回收-gc-png-off-gcoff-stack-scan-mark-gcmark-mark-termination-gcmarktermination-goff-to-gmark-goff-to-gmark-goff-to-gmark-gcstart-由每次mallocgc触发-当然要满足gc-trriger等阈值条件才触发。整个启动过程都是stw的-它启动了所有将并发执行标记工作的goroutine-然后进入gcmark状态使能写屏障-启动gccontroller。" tabindex="-1"><a class="header-anchor" href="#标记与清理过程-标记与清理过程-标记与清理过程-这里结合gc-work那一节从头梳理一下gc的启动和流程。下面这个图总结了mark-sweep所有的状态变化。在代码里只有三个gc状态-分别对应这几个阶段。总结两个问题-1-为什么marktermination需要rescan全局指针和栈-。因为mark阶段是跟用户代码并发的-所以有可能栈上都分了新的对象-这些对象通过write-barrier记录下来-在rescan的时候再检查一遍。-2-为什么还需要两个stoptheworld-在gctermination时需要stw不然永远都可能栈上出现新对象。在gc开始之前做准备工作-比如-enable-write-barrier-的时候也要stw。-https-ninokop-github-io-2017-11-09-go-垃圾回收-gc-png-off-gcoff-stack-scan-mark-gcmark-mark-termination-gcmarktermination-goff-to-gmark-goff-to-gmark-goff-to-gmark-gcstart-由每次mallocgc触发-当然要满足gc-trriger等阈值条件才触发。整个启动过程都是stw的-它启动了所有将并发执行标记工作的goroutine-然后进入gcmark状态使能写屏障-启动gccontroller。"><span>[](#标记与清理过程 &quot;标记与清理过程&quot;)标记与清理过程 这里结合gc-work那一节从头梳理一下gc的启动和流程。下面这个图总结了mark-sweep所有的状态变化。在代码里只有三个GC状态，分别对应这几个阶段。总结两个问题： 1. **为什么markTermination需要rescan全局指针和栈**。因为mark阶段是跟用户代码并发的，所以有可能栈上都分了新的对象，这些对象通过write barrier记录下来，在rescan的时候再检查一遍。 2. **为什么还需要两个stopTheWorld** 在GCtermination时需要STW不然永远都可能栈上出现新对象。在GC开始之前做准备工作（比如 enable write barrier）的时候也要STW。 ![](<a href="https://ninokop.github.io/2017/11/09/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/gc.png" target="_blank" rel="noopener noreferrer">https://ninokop.github.io/2017/11/09/Go-垃圾回收/gc.png</a>) &gt; - Off: `_GCoff` &gt; - Stack scan + Mark: `_GCmark` &gt; - Mark termination: \\_GCmarktermination ### [](#Goff-to-Gmark &quot;Goff to Gmark&quot;)Goff to Gmark `gcstart`由每次mallocgc触发，当然要满足gc\\_trriger等阈值条件才触发。整个启动过程都是STW的，它启动了所有将并发执行标记工作的goroutine，然后进入GCMark状态使能写屏障，启动gcController。</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func gcStart(mode gcMode, forceTrigger bool) { // 启动MarkStartWorkers的goroutine if mode == gcBackgroundMode { gcBgMarkStartWorkers() } gcResetMarkState() systemstack(stopTheWorldWithSema) // 完成之前的清理工作 systemstack(func() { finishsweep\\_m() }) // 进入Mark状态 使能写屏障 if mode == gcBackgroundMode { gcController.startCycle() setGCPhase(\\_GCmark) gcBgMarkPrepare() gcMarkRootPrepare() atomic.Store(&amp;gcBlackenEnabled, 1) systemstack(startTheWorldWithSema) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="gmark-gmark-gmark-解释一下gcmarkworker跟gccontroller的关系。gcstart中只是为所有的p都准备好对应的goroutine来做标记。但是他们一开始就gopark住当前g-直到被gccontroller的-findrunnablegcworker-唤醒。-goroutine源码记录-https-ninokop-github-io-2017-11-01-goroutine源码记录-讲了goroutine的过程-m启动后会一直通过schedule查找可执行的g-其中gcworker也是g的来源-但是首先要检查当前状态是不是gmark。如果是就唤醒worker开始标记工作。" tabindex="-1"><a class="header-anchor" href="#gmark-gmark-gmark-解释一下gcmarkworker跟gccontroller的关系。gcstart中只是为所有的p都准备好对应的goroutine来做标记。但是他们一开始就gopark住当前g-直到被gccontroller的-findrunnablegcworker-唤醒。-goroutine源码记录-https-ninokop-github-io-2017-11-01-goroutine源码记录-讲了goroutine的过程-m启动后会一直通过schedule查找可执行的g-其中gcworker也是g的来源-但是首先要检查当前状态是不是gmark。如果是就唤醒worker开始标记工作。"><span>[](#Gmark &quot;Gmark&quot;)Gmark 解释一下gcMarkWorker跟gcController的关系。gcstart中只是为所有的P都准备好对应的goroutine来做标记。但是他们一开始就gopark住当前G，直到被gccontroller的`findRunnableGCWorker`唤醒。[goroutine源码记录](<a href="https://ninokop.github.io/2017/11/01/Goroutine%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">https://ninokop.github.io/2017/11/01/Goroutine源码记录/</a>)讲了goroutine的过程，m启动后会一直通过schedule查找可执行的G，其中gcworker也是G的来源，但是首先要检查当前状态是不是Gmark。如果是就唤醒worker开始标记工作。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func gcBgMarkStartWorkers() { for \\_, p := range &amp;allp { go gcBgMarkWorker(p) notetsleepg(&amp;work.bgMarkReady, -1) noteclear(&amp;work.bgMarkReady) } } func schedule() { ...//schedule优先唤醒markworkerG 但首先gcBlackenEnabled != 0 if gp == nil &amp;&amp; gcBlackenEnabled != 0 { gp = gcController.findRunnableGCWorker(\\_g\\_.m.p.ptr()) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>唤醒后开始进入mark标记工作`gcDrain`。gc-work那一节讲了并发标记的过程，这里不重复。总结来说就是每个worker都去队列中拿节点（黑化节点），然后处理当前节点看有没有指针和没标记的对象，继续入队子节点（灰化节点），直到队列为空再也找不到可达对象。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func gcBgMarkWorker(\\_p\\_ \\*p) { notewakeup(&amp;work.bgMarkReady) for { gopark(func(g \\*g, parkp unsafe.Pointer) bool { }, unsafe.Pointer(park), &quot;GC worker (idle)&quot;, traceEvGoBlock, 0) systemstack(func() { casgstatus(gp, \\_Grunning, \\_Gwaiting) gcDrain(&amp;\\_p\\_.gcw, ...) casgstatus(gp, \\_Gwaiting, \\_Grunning) }) // 标记完成gcMarkDone() if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) { gcMarkDone() } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="gmarktermination-gmarktermination-gmarktermination-mark结束后调用-gcmarkdone-它主要是-stoptheworld-然后进入-gcmarktermination-中的-gcmark-。-大概是做了rescan-root区域的工作-但是看到有博客说go1-8已经没有再rescan了-细节没看懂-代码里看起来却是又重新扫描了一次啊。" tabindex="-1"><a class="header-anchor" href="#gmarktermination-gmarktermination-gmarktermination-mark结束后调用-gcmarkdone-它主要是-stoptheworld-然后进入-gcmarktermination-中的-gcmark-。-大概是做了rescan-root区域的工作-但是看到有博客说go1-8已经没有再rescan了-细节没看懂-代码里看起来却是又重新扫描了一次啊。"><span>[](#Gmarktermination &quot;Gmarktermination&quot;)Gmarktermination mark结束后调用`gcMarkDone`，它主要是`StopTheWorld`然后进入`gcMarkTermination`中的`gcMark`。**大概是做了rescan root区域的工作，但是看到有博客说Go1.8已经没有再rescan了，细节没看懂，代码里看起来却是又重新扫描了一次啊。**</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func gcMarkTermination() { atomic.Store(&amp;gcBlackenEnabled, 0) setGCPhase(\\_GCmarktermination) casgstatus(gp, \\_Grunning, \\_Gwaiting) gp.waitreason = &quot;garbage collection&quot; systemstack(func() { gcMark(startTime) setGCPhase(\\_GCoff) gcSweep(work.mode) }) casgstatus(gp, \\_Gwaiting, \\_Grunning) systemstack(startTheWorldWithSema) } func gcMark(start\\_time int64) { gcMarkRootPrepare() gchelperstart() gcDrain(gcw, gcDrainBlock) gcw.dispose() // gc结束后重置gc\\_trigger等阈值 ... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="gsweep-gsweep-gsweep-有多个地方可以触发sweep-比如gc标记结束会触发gcsweep。如果是并发清除-需要回收从gc-trigger到当前活跃内存的那么多heap区���-唤醒后台的sweep-goroutine。" tabindex="-1"><a class="header-anchor" href="#gsweep-gsweep-gsweep-有多个地方可以触发sweep-比如gc标记结束会触发gcsweep。如果是并发清除-需要回收从gc-trigger到当前活跃内存的那么多heap区���-唤醒后台的sweep-goroutine。"><span>[](#Gsweep &quot;Gsweep&quot;)Gsweep 有多个地方可以触发sweep，比如GC标记结束会触发gcsweep。如果是并发清除，需要回收从gc\\_trigger到当前活跃内存的那么多heap区���，唤醒后台的sweep goroutine。</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func gcSweep(mode gcMode) { lock(&amp;mheap\\_.lock) mheap\\_.sweepgen += 2 mheap\\_.sweepdone = 0 unlock(&amp;mheap\\_.lock) // Background sweep. ready(sweep.g, 0, true) } // 在runtime初始化时进行gcenable func gcenable() { go bgsweep(c) } func bgsweep(c chan int) { goparkunlock(&amp;sweep.lock, &quot;GC sweep wait&quot;, traceEvGoBlock, 1) for { for gosweepone() != ^uintptr(0) { sweep.nbgsweep++ Gosched() } goparkunlock(&amp;sweep.lock, &quot;GC sweep wait&quot;, traceEvGoBlock, 1) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也就是系统初始化的时候开启了后台的bgsweep goroutine。这个G也是一进去就park了，唤醒后执行gosweepone。**seepone的过程大概是：**遍历所有的spans看它的sweepgen是否需要检查，如果要就检查这个mspan里所有的object的bit位看是否需要回收。这个过程可能触发mspan到mcentral的回收，最终可能回收到mheap的freelist当中。在freelist当中的内存再超过一定阈值时间后会被sysmon建议交还给内核。 ## [](#参考文章 &quot;参考文章&quot;)参考文章 [Proposal: Eliminate STW stack re-scanning](<a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener noreferrer">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a>) [go笔记-GC](<a href="http://int64.me/2016/go%E7%AC%94%E8%AE%B0%20-%20GC.html" target="_blank" rel="noopener noreferrer">http://int64.me/2016/go笔记 - GC.html</a>) [go1.5的垃圾回收](<a href="http://www.zenlife.tk/go-gc1.5.md" target="_blank" rel="noopener noreferrer">http://www.zenlife.tk/go-gc1.5.md</a>) [go垃圾回收剖析](<a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener noreferrer">http://legendtkl.com/2017/04/28/golang-gc/</a>)</p>',24)]))}const l=r(o,[["render",n],["__file","Go-垃圾回收.html.vue"]]),k=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html","title":"Go 垃圾回收","lang":"zh-CN","frontmatter":{"title":"Go 垃圾回收","source_url":"https://studygolang.com/articles/11904","category":"Go原理教程","description":"通常C++通过指针引用计数来回收对象，但是这**不能处理循环引用**。为了避免引用计数的缺陷，后来出现了标记清除，分代等垃圾回收算法。Go的垃圾回收官方形容为 **非分代 非紧缩 写屏障 并发标记清理**。标记清理算法的字面解释，就是将可达的内存块进行标记`mark`，最后没有标记的不可达内存块将进行清理`sweep`。 ## [](#三色标记法 \\"三...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go 垃圾回收"}],["meta",{"property":"og:description","content":"通常C++通过指针引用计数来回收对象，但是这**不能处理循环引用**。为了避免引用计数的缺陷，后来出现了标记清除，分代等垃圾回收算法。Go的垃圾回收官方形容为 **非分代 非紧缩 写屏障 并发标记清理**。标记清理算法的字面解释，就是将可达的内存块进行标记`mark`，最后没有标记的不可达内存块将进行清理`sweep`。 ## [](#三色标记法 \\"三..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 垃圾回收\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"[](#标记位 \\"标记位\\")标记位 实现精确地垃圾回收的前提，就是能获得对象区域的类型信息，从而判断是否是指针。如何判断，最后又把可达标记记在哪里：**通过堆区arena前面对应的bitmap**。 > 结构体中不包含指针，其实不需要递归地标记结构体成员。如果没有类型信息只能对所有的结构体成员递归地标记下去。还有如果非指���成员刚好存储的内容对应着合法地址，那这个地址的对象就会碰巧被标记���导致无法回收。 这个bitmap位图区域每个字(32位或64位)会对应4位的标记位。`heapBitsForAddr`可以获取对应堆地址的bitmap位hbits，根据它可以判断是否是指针，如果是指针且之前没有被标记过，则mark当前对象为可达，并且`greayObject`入队，供给其他的markWorker来处理。","slug":"标记位-标记位-标记位-实现精确地垃圾回收的前提-就是能获得对象区域的类型信息-从而判断是否是指针。如何判断-最后又把可达标记记在哪里-通过堆区arena前面对应的bitmap-。-结构体中不包含指针-其实不需要递归地标记结构体成员。如果没有类型信息只能对所有的结构体成员递归地标记下去。还有如果非指���成员刚好存储的内容对应着合法地址-那这个地址的对象就会碰巧被标记���导致无法回收。-这个bitmap位图区域每个字-32位或64位-会对应4位的标记位。-heapbitsforaddr-可以获取对应堆地址的bitmap位hbits-根据它可以判断是否是指针-如果是指针且之前没有被标记过-则mark当前对象为可达-并且-greayobject-入队-供给其他的markworker来处理。","link":"#标记位-标记位-标记位-实现精确地垃圾回收的前提-就是能获得对象区域的类型信息-从而判断是否是指针。如何判断-最后又把可达标记记在哪里-通过堆区arena前面对应的bitmap-。-结构体中不包含指针-其实不需要递归地标记结构体成员。如果没有类型信息只能对所有的结构体成员递归地标记下去。还有如果非指���成员刚好存储的内容对应着合法地址-那这个地址的对象就会碰巧被标记���导致无法回收。-这个bitmap位图区域每个字-32位或64位-会对应4位的标记位。-heapbitsforaddr-可以获取对应堆地址的bitmap位hbits-根据它可以判断是否是指针-如果是指针且之前没有被标记过-则mark当前对象为可达-并且-greayobject-入队-供给其他的markworker来处理。","children":[]},{"level":3,"title":"[](#强制垃圾回收 \\"强制垃圾回收\\")强制垃圾回收 如果系统启动或短时间内大量分配对象，会将垃圾回收的gc\\\\_trigger推高。当服务正常后，活跃对象远小于这个阈值，造成垃圾回收无法触发。这个问题交给sysmon解决。它每隔2分钟force触发GC一次。这个forcegc的goroutine一直park在后台，直到sysmon将它唤醒开始执行gc而不用检查阈值。","slug":"强制垃圾回收-强制垃圾回收-强制垃圾回收-如果系统启动或短时间内大量分配对象-会将垃圾回收的gc-trigger推高。当服务正常后-活跃对象远小于这个阈值-造成垃圾回收无法触发。这个问题交给sysmon解决。它每隔2分钟force触发gc一次。这个forcegc的goroutine一直park在后台-直到sysmon将它唤醒开始执行gc而不用检查阈值。","link":"#强制垃圾回收-强制垃圾回收-强制垃圾回收-如果系统启动或短时间内大量分配对象-会将垃圾回收的gc-trigger推高。当服务正常后-活跃对象远小于这个阈值-造成垃圾回收无法触发。这个问题交给sysmon解决。它每隔2分钟force触发gc一次。这个forcegc的goroutine一直park在后台-直到sysmon将它唤醒开始执行gc而不用检查阈值。","children":[]},{"level":2,"title":"[](#标记与清理过程 \\"标记与清理过程\\")标记与清理过程 这里结合gc-work那一节从头梳理一下gc的启动和流程。下面这个图总结了mark-sweep所有的状态变化。在代码里只有三个GC状态，分别对应这几个阶段。总结两个问题： 1. **为什么markTermination需要rescan全局指针和栈**。因为mark阶段是跟用户代码并发的，所以有可能栈上都分了新的对象，这些对象通过write barrier记录下来，在rescan的时候再检查一遍。 2. **为什么还需要两个stopTheWorld** 在GCtermination时需要STW不然永远都可能栈上出现新对象。在GC开始之前做准备工作（比如 enable write barrier）的时候也要STW。 ![](https://ninokop.github.io/2017/11/09/Go-垃圾回收/gc.png) > - Off: `_GCoff` > - Stack scan + Mark: `_GCmark` > - Mark termination: \\\\_GCmarktermination ### [](#Goff-to-Gmark \\"Goff to Gmark\\")Goff to Gmark `gcstart`由每次mallocgc触发，当然要满足gc\\\\_trriger等阈值条件才触发。整个启动过程都是STW的，它启动了所有将并发执行标记工作的goroutine，然后进入GCMark状态使能写屏障，启动gcController。","slug":"标记与清理过程-标记与清理过程-标记与清理过程-这里结合gc-work那一节从头梳理一下gc的启动和流程。下面这个图总结了mark-sweep所有的状态变化。在代码里只有三个gc状态-分别对应这几个阶段。总结两个问题-1-为什么marktermination需要rescan全局指针和栈-。因为mark阶段是跟用户代码并发的-所以有可能栈上都分了新的对象-这些对象通过write-barrier记录下来-在rescan的时候再检查一遍。-2-为什么还需要两个stoptheworld-在gctermination时需要stw不然永远都可能栈上出现新对象。在gc开始之前做准备工作-比如-enable-write-barrier-的时候也要stw。-https-ninokop-github-io-2017-11-09-go-垃圾回收-gc-png-off-gcoff-stack-scan-mark-gcmark-mark-termination-gcmarktermination-goff-to-gmark-goff-to-gmark-goff-to-gmark-gcstart-由每次mallocgc触发-当然要满足gc-trriger等阈值条件才触发。整个启动过程都是stw的-它启动了所有将并发执行标记工作的goroutine-然后进入gcmark状态使能写屏障-启动gccontroller。","link":"#标记与清理过程-标记与清理过程-标记与清理过程-这里结合gc-work那一节从头梳理一下gc的启动和流程。下面这个图总结了mark-sweep所有的状态变化。在代码里只有三个gc状态-分别对应这几个阶段。总结两个问题-1-为什么marktermination需要rescan全局指针和栈-。因为mark阶段是跟用户代码并发的-所以有可能栈上都分了新的对象-这些对象通过write-barrier记录下来-在rescan的时候再检查一遍。-2-为什么还需要两个stoptheworld-在gctermination时需要stw不然永远都可能栈上出现新对象。在gc开始之前做准备工作-比如-enable-write-barrier-的时候也要stw。-https-ninokop-github-io-2017-11-09-go-垃圾回收-gc-png-off-gcoff-stack-scan-mark-gcmark-mark-termination-gcmarktermination-goff-to-gmark-goff-to-gmark-goff-to-gmark-gcstart-由每次mallocgc触发-当然要满足gc-trriger等阈值条件才触发。整个启动过程都是stw的-它启动了所有将并发执行标记工作的goroutine-然后进入gcmark状态使能写屏障-启动gccontroller。","children":[{"level":3,"title":"[](#Gmark \\"Gmark\\")Gmark 解释一下gcMarkWorker跟gcController的关系。gcstart中只是为所有的P都准备好对应的goroutine来做标记。但是他们一开始就gopark住当前G，直到被gccontroller的`findRunnableGCWorker`唤醒。[goroutine源码记录](https://ninokop.github.io/2017/11/01/Goroutine源码记录/)讲了goroutine的过程，m启动后会一直通过schedule查找可执行的G，其中gcworker也是G的来源，但是首先要检查当前状态是不是Gmark。如果是就唤醒worker开始标记工作。","slug":"gmark-gmark-gmark-解释一下gcmarkworker跟gccontroller的关系。gcstart中只是为所有的p都准备好对应的goroutine来做标记。但是他们一开始就gopark住当前g-直到被gccontroller的-findrunnablegcworker-唤醒。-goroutine源码记录-https-ninokop-github-io-2017-11-01-goroutine源码记录-讲了goroutine的过程-m启动后会一直通过schedule查找可执行的g-其中gcworker也是g的来源-但是首先要检查当前状态是不是gmark。如果是就唤醒worker开始标记工作。","link":"#gmark-gmark-gmark-解释一下gcmarkworker跟gccontroller的关系。gcstart中只是为所有的p都准备好对应的goroutine来做标记。但是他们一开始就gopark住当前g-直到被gccontroller的-findrunnablegcworker-唤醒。-goroutine源码记录-https-ninokop-github-io-2017-11-01-goroutine源码记录-讲了goroutine的过程-m启动后会一直通过schedule查找可执行的g-其中gcworker也是g的来源-但是首先要检查当前状态是不是gmark。如果是就唤醒worker开始标记工作。","children":[]},{"level":3,"title":"[](#Gmarktermination \\"Gmarktermination\\")Gmarktermination mark结束后调用`gcMarkDone`，它主要是`StopTheWorld`然后进入`gcMarkTermination`中的`gcMark`。**大概是做了rescan root区域的工作，但是看到有博客说Go1.8已经没有再rescan了，细节没看懂，代码里看起来却是又重新扫描了一次啊。**","slug":"gmarktermination-gmarktermination-gmarktermination-mark结束后调用-gcmarkdone-它主要是-stoptheworld-然后进入-gcmarktermination-中的-gcmark-。-大概是做了rescan-root区域的工作-但是看到有博客说go1-8已经没有再rescan了-细节没看懂-代码里看起来却是又重新扫描了一次啊。","link":"#gmarktermination-gmarktermination-gmarktermination-mark结束后调用-gcmarkdone-它主要是-stoptheworld-然后进入-gcmarktermination-中的-gcmark-。-大概是做了rescan-root区域的工作-但是看到有博客说go1-8已经没有再rescan了-细节没看懂-代码里看起来却是又重新扫描了一次啊。","children":[]},{"level":3,"title":"[](#Gsweep \\"Gsweep\\")Gsweep 有多个地方可以触发sweep，比如GC标记结束会触发gcsweep。如果是并发清除，需要回收从gc\\\\_trigger到当前活跃内存的那么多heap区���，唤醒后台的sweep goroutine。","slug":"gsweep-gsweep-gsweep-有多个地方可以触发sweep-比如gc标记结束会触发gcsweep。如果是并发清除-需要回收从gc-trigger到当前活跃内存的那么多heap区���-唤醒后台的sweep-goroutine。","link":"#gsweep-gsweep-gsweep-有多个地方可以触发sweep-比如gc标记结束会触发gcsweep。如果是并发清除-需要回收从gc-trigger到当前活跃内存的那么多heap区���-唤醒后台的sweep-goroutine。","children":[]}]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":10.22,"words":3065},"filePathRelative":"golang/原理/theory/Go-垃圾回收.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{l as comp,k as data};
