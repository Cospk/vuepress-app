import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as r,o as i}from"./app-DIJDtupu.js";const n={};function l(a,e){return i(),o("div",null,e[0]||(e[0]=[r('<p>上一篇文章<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/" target="_blank" rel="noopener noreferrer">《Go语言高阶：调度器系列（1）起源》</a>，学goroutine调度器之前的一些背景知识，<strong>这篇文章则是为了对调度器有个宏观的认识，从宏观的3个角度，去看待和理解调度器是什么样子的，但仍然不涉及具体的调度原理</strong>。</p><p>三个角度分别是：</p><ol><li>调度器的宏观组成</li><li>调度器的生命周期</li><li>GMP的可视化感受</li></ol><p>在开始前，先回忆下调度器相关的3个缩写：</p><ul><li><strong>G</strong>: goroutine，每个G都代表1个goroutine</li><li><strong>M</strong>: 工作线程，是Go语言定义出来在用户层面描述系统线程的对象 ，每个M代表一个系统线程</li><li><strong>P</strong>: 处理器，它包含了运行Go代码的资源。</li></ul><p>3者的简要关系是P拥有G，M必须和一个P关联才能运行P拥有的G。</p><h3 id="调度器的功能" tabindex="-1"><a class="header-anchor" href="#调度器的功能"><span><a href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD" title="调度器的功能"></a>调度器的功能</span></a></h3><p><a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/" target="_blank" rel="noopener noreferrer">《Go语言高阶：调度器系列（1）起源》</a>中介绍了协程和线程的关系，协程需要运行在线程之上，线程由CPU进行调度。</p><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p><p>Go的调度器也是经过了多个版本的开发才是现在这个样子的，</p><ul><li>1.0版本发布了最初的、最简单的调度器，是G-M模型，存在4类问题</li><li>1.1版本重新设计，修改为G-P-M模型，奠定当前调度器基本模样</li><li><a href="https://golang.org/doc/go1.2#preemption" target="_blank" rel="noopener noreferrer">1.2版本</a>加入了抢占式调度，防止协程不让出CPU导致其他G饿死</li></ul><blockquote><p>在<code>$GOROOT/src/runtime/proc.go</code>的开头注释中包含了对Scheduler的重要注释，介绍Scheduler的设计曾拒绝过3种方案以及原因，本文不再介绍了，希望你不要忽略为数不多的官方介绍。</p></blockquote><h3 id="scheduler的宏观组成" tabindex="-1"><a class="header-anchor" href="#scheduler的宏观组成"><span><a href="#Scheduler%E7%9A%84%E5%AE%8F%E8%A7%82%E7%BB%84%E6%88%90" title="Scheduler的宏观组成"></a>Scheduler的宏观组成</span></a></h3><p><a href="https://tonybai.com/" target="_blank" rel="noopener noreferrer">Tony Bai</a>在<a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener noreferrer">《也谈goroutine调度器》</a>中的这幅图，展示了goroutine调度器和系统调度器的关系，而不是把二者割裂开来，并且从宏观的角度展示了调度器的重要组成。</p><figure><img src="http://img.lessisbetter.site/2019-03-goroutine-scheduler-model.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>自顶向下是调度器的4个部分：</p><ol><li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li><li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。</li><li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p><h3 id="调度器的生命周期" tabindex="-1"><a class="header-anchor" href="#调度器的生命周期"><span><a href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" title="调度器的生命周期"></a>调度器的生命周期</span></a></h3><p>接下来我们从另外一个宏观角度——生命周期，认识调度器。</p><p>所有的Go程序运行都会经过一个完整的调度器生命周期：从创建到结束。</p><figure><img src="http://img.lessisbetter.site/2019-03-scheduler-lifetime.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>即使下面这段简单的代码：</p><p>复制</p><p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8</p><p>package main</p><p>import &quot;fmt&quot;</p><p>// main.main<br> func main() {<br> fmt.Println(&quot;Hello scheduler&quot;)<br> }</p>',28)]))}const g=t(n,[["render",l],["__file","Go调度器系列（2）宏观看调度器.html.vue"]]),c=JSON.parse('{"path":"/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%E5%AE%8F%E8%A7%82%E7%9C%8B%E8%B0%83%E5%BA%A6%E5%99%A8.html","title":"Go调度器系列（2）宏观看调度器","lang":"zh-CN","frontmatter":{"title":"Go调度器系列（2）宏观看调度器","source_url":"https://studygolang.com/articles/19299","category":"Go原理教程","description":"上一篇文章《Go语言高阶：调度器系列（1）起源》，学goroutine调度器之前的一些背景知识，这篇文章则是为了对调度器有个宏观的认识，从宏观的3个角度，去看待和理解调度器是什么样子的，但仍然不涉及具体的调度原理。 三个角度分别是： 调度器的宏观组成 调度器的生命周期 GMP的可视化感受 在开始前，先回忆下调度器相关的3个缩写： G: goroutin...","head":[["meta",{"property":"og:url","content":"https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%E5%AE%8F%E8%A7%82%E7%9C%8B%E8%B0%83%E5%BA%A6%E5%99%A8.html"}],["meta",{"property":"og:site_name","content":"Golang全栈指南"}],["meta",{"property":"og:title","content":"Go调度器系列（2）宏观看调度器"}],["meta",{"property":"og:description","content":"上一篇文章《Go语言高阶：调度器系列（1）起源》，学goroutine调度器之前的一些背景知识，这篇文章则是为了对调度器有个宏观的认识，从宏观的3个角度，去看待和理解调度器是什么样子的，但仍然不涉及具体的调度原理。 三个角度分别是： 调度器的宏观组成 调度器的生命周期 GMP的可视化感受 在开始前，先回忆下调度器相关的3个缩写： G: goroutin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://img.lessisbetter.site/2019-03-goroutine-scheduler-model.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T12:02:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T12:02:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go调度器系列（2）宏观看调度器\\",\\"image\\":[\\"http://img.lessisbetter.site/2019-03-goroutine-scheduler-model.png\\",\\"http://img.lessisbetter.site/2019-03-scheduler-lifetime.png\\"],\\"dateModified\\":\\"2025-08-27T12:02:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cospk\\",\\"url\\":\\"https://savvygo.cn\\"}]}"]]},"headers":[{"level":3,"title":"调度器的功能","slug":"调度器的功能","link":"#调度器的功能","children":[]},{"level":3,"title":"Scheduler的宏观组成","slug":"scheduler的宏观组成","link":"#scheduler的宏观组成","children":[]},{"level":3,"title":"调度器的生命周期","slug":"调度器的生命周期","link":"#调度器的生命周期","children":[]}],"git":{"createdTime":1756202807000,"updatedTime":1756296158000,"contributors":[{"name":"shiwei","username":"shiwei","email":"xie@gmail.com","commits":2,"url":"https://github.com/shiwei"}]},"readingTime":{"minutes":3.39,"words":1018},"filePathRelative":"golang/原理/theory/Go调度器系列（2）宏观看调度器.md","localizedDate":"2025年8月26日","autoDesc":true,"excerpt":"<p>上一篇文章<a href=\\"http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《Go语言高阶：调度器系列（1）起源》</a>，学goroutine调度器之前的一些背景知识，<strong>这篇文章则是为了对调度器有个宏观的认识，从宏观的3个角度，去看待和理解调度器是什么样子的，但仍然不涉及具体的调度原理</strong>。</p>\\n<p>三个角度分别是：</p>\\n<ol>\\n<li>调度器的宏观组成</li>\\n<li>调度器的生命周期</li>\\n<li>GMP的可视化感受</li>\\n</ol>"}');export{g as comp,c as data};
