<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.66" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%B8%89)-GC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"><meta property="og:site_name" content="Golang全栈指南"><meta property="og:title" content="Golang源码探索(三) GC的实现原理"><meta property="og:description" content="停顿时间的减少意味着"最大响应时间"的缩短, 这也让go更适合编写网络服务程序.\ 这篇文章将通过分析golang的源代码来讲解go中的三色GC的实现原理. 这个系列分析的golang源代码是Google官方的实现的1.9.2版本, 不适用于其他版本和gccgo等其他实现,\ 运行环境是Ubuntu 16.04 LTS 64bit.\ 首先会讲解基础概..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-08-27T12:02:38.000Z"><meta property="article:modified_time" content="2025-08-27T12:02:38.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Golang源码探索(三) GC的实现原理","image":[""],"dateModified":"2025-08-27T12:02:38.000Z","author":[{"@type":"Person","name":"Cospk","url":"https://savvygo.cn"}]}</script><link rel="icon" href="/vuepress-app/favicon.svg"><title>Golang源码探索(三) GC的实现原理 | Golang全栈指南</title><meta name="description" content="停顿时间的减少意味着"最大响应时间"的缩短, 这也让go更适合编写网络服务程序.\ 这篇文章将通过分析golang的源代码来讲解go中的三色GC的实现原理. 这个系列分析的golang源代码是Google官方的实现的1.9.2版本, 不适用于其他版本和gccgo等其他实现,\ 运行环境是Ubuntu 16.04 LTS 64bit.\ 首先会讲解基础概...">
    <link rel="preload" href="/vuepress-app/assets/style-BU0LSV_n.css" as="style"><link rel="stylesheet" href="/vuepress-app/assets/style-BU0LSV_n.css">
    <link rel="modulepreload" href="/vuepress-app/assets/app-DIJDtupu.js"><link rel="modulepreload" href="/vuepress-app/assets/Golang源码探索(三)-GC的实现原理.html-Djtfq-R-.js"><link rel="modulepreload" href="/vuepress-app/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/vuepress-app/assets/index.html-BMYgyfDp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/portfolio.html-4bxlMBYl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.算法.html-CvQ1gy67.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.设计模式.html-oqIrtBe8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.规划.html-BTctlwB6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/git 规范.html-pOzt2Sya.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/git.html-ixPi_0Ze.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/markdown.html-Dy_QlVnL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/好物分享.html-B6NfvEM_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-8AQshAED.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/best-practice-template.html-BLs6dmQM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/reference-template.html-CRcAKI7_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/tutorial-template.html-DD31Wvmc.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/writing-standards.html-CYxaf07f.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-E7qiWZU4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Consul.html-D9i7V0zV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Docker.html-CALiwnXG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/GRPC.html-BDKbTmRI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Jaeger.html-DGQmYk9d.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kong.html-BY9r39zx.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kubernetes.html-rzGxnWd0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Nacos.html-CpWI1heb.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CqzJH2kl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Sentinel.html-QBl6g7n4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BQep9Ms_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-W0IZn2xO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html--HZ9Xv38.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BNzatcUR.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/网络基础.html-53H3D8RM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.use.html-BfZix_tO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.howWork.html-CL03OcGt.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-f8ivuiuF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CxO_qeK1.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-C-Cxe3ur.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/常用包大全.html-BWGXltvN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/01-介绍与安装.html-BLLTtCrI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/02-Hello-World.html-B4m4QWVp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/03-变量.html-DBpH8CZF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/04-类型.html-3lTaKrEX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/05-常量.html-Dem3SKBW.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/06-函数.html-TWV5xDWN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/07-包.html-Bb9b61PO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/08-if-else-语句.html-BKuKh2bl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/09-循环.html-xBYX8gSg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/10-switch-语句.html-DmGE68tD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/11-数组和切片.html-DrrlC8sJ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/12-可变参数函数.html-CVgsTexs.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/13-Maps.html-DcKwMN0L.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/14-字符串.html-D71PugAn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/15-指针.html-BQKNFZz4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/16-结构体.html-BR_npihr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/17-方法.html-Cea2EL0W.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/18-接口.html-5vpBAdeJ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/19-接口.html-IZQZkccS.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/20-并发入门.html-DFCOqalS.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/21-Go-协程.html-C7X86pID.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/22-信道.html-C5SZUNIN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/23-缓冲信道和工作池.html-Dw9yzm21.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/24-Select.html-BZRmoLwg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/25-Mutex.html-DlRLxIO0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/26-结构体取代类.html-Cb0CQeQI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/27-组合取代继承.html-D-1lRcAm.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/28-多态.html-D5cES2MF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/29-Defer.html-BTOlmwqG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/30-错误处理.html--URdZGOa.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/31-自定义错误.html-qjjG4dD1.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/32-panic-和-recover.html-C__hWiny.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/33-函数是一等公民.html-CKtAIjCE.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/34-反射.html-gT_ubIYV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/35-读取文件.html-Dim6lJth.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/36-写入文件.html-DMMy5Akp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-Ce4QncUh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.interface.html-Bcwpxkz_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/10.cgo.html-Cc3IBgZh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/11.pprof.html-B1TBiF-S.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/12.followUp.html-ChgosObn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.generic.html-t9F8JkZ-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/3.reflect.html-CsqwkGQg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/4.types.html-DTz3KnZN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/5.error.html-CYyqf_8g.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/6.file.html-IQGOyJmj.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/7.concurrency.html-DWHb7NV7.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/8.module.html-D1WyiQU-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/9.test.html-BDgM0J0K.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CpG6FWU3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/notes.html-B6gucJy2.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/test.html-D2d8EnW4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.基础语法.html-iIWzYafk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.进阶原理.html-83xh_rnD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-wT1nHTio.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/大厂面试题.html-Dwwv4_YP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/对象池.html-CbIFXFAU.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/极智天下.html-CUbP6xEh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/面试题（答案）.html-DcUI8xsg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Elasticsearch-Go.html-DH3iL3t-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Elasticsearch.html-Dbqk6yba.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MYSQL高级.html-DjU99qc2.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MongoDB-Go.html-LC00SqHY.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MongoDB.html-BsiiWKPF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MySQL-Go.html-BP44ICxm.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MySQL.html-DvFuWdDI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-No9QF5uf.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Redis-Go.html-68Ve0Bms.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Redis.html-COY3AC-z.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/EMQX.html-Z2ULNNu9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kafka1.html-CIwYmfIl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kafka_go.html-BtHi9Ay4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CoyHYM4r.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/RocketMQ.html-DKnvI3P9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/kafka.html-C45XgCVY.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kong.html-CFRTKV3Q.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Nginx.html-DobIArYS.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-C_myC_ON.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Docker-Do.html-CAeX33hD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Docker.html-CrfPN4Ea.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Jenkins.html-D7fd_zxG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kubernetes.html-CiCaNrju.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-D3i7y_nz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/kubernetes-Do.html-Mn8O0iYA.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/casbin.html-CmdXnvo-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.use.html-mGGwb0Xs.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.howWork.html-BPbATKWp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BDiG7Sa9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.use.html-CFS7SGEx.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.howWork.html-CWMWUGai.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-M11fprN-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-KksFQ35C.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Zap.html-cSNtc6K9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/用户认证选型.html-D8ZbBlYF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/监控.html-CblSNQ5X.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.intro.html-BiC5KbBB.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-V-gxjtkQ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/encode.html-DULShIO4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/flag.html-BNP6mLKg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/http.html-Ds7Bn6Dh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/log.html-Bi8nr_fy.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/math.html-BRgtQXkC.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/net.html-Cez-sJPL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/sort.html-B-_PynF9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/strconv.html-D9aq_0ge.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/strings.html-BEBdT1VN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/template.html-CDhZ4T2L.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/time.html-B2s7biyE.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/unicode.html-KfTwaqW3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/unsafe.html-Ck5rncWr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.runtime.html-U_tTe_nE.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.并发.html-B3G74HKx.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.数据结构.html-zwbg06cB.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/3.错误处理.html-CdT9wDTr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/GC-的认识.html-OPEMhhHh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/GO-中的调度：第三部分---并发.html-CDUpX-uL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Channel的实现.html-mcjtDZL8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-GC.html-XyX71R-p.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Hashmap内存布局和实现.html-CEaCfe5Y.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Modules-终极入门.html-Dg9PFqQr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Select的实现.html-B83V5ZdL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Slice与String内存布局和实现.html-DjzVnYMo.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-work-stealing-调度器.html-yoXF58Gm.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-中的垃圾回收：第一部分---基础.html-DtW8VjA8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-内存管理.html-BjEWhmRz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-内存管理之二.html-CR15EHul.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-内存逃逸详细分析.html-DVPlddTO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-函数调用惯例.html-_ZCeAlFf.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-反射与interface拾遗.html-Dbd8kK8e.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-垃圾回收.html-C1kvG1yM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-垃圾回收：第二部分---GC-追踪.html-B0G6QDGf.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-执行追踪器（execution-tracer）.html-9tss-d8y.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-方法调用与接口.html-DErdsZ4B.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-的调度器追踪.html-ekQk2krk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-笔记之如何防止-goroutine-泄露.html-B1dU8GVD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-笔记之如何防止-goroutine-泄露（二）.html-CyBRGTsl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言-Channel-实现原理精要.html-Dk44jpBB.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言-for-和-range-的实现.html-B70zygT9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言数组和切片的原理.html-BL11UMTM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言机制之内存剖析（Language-Mechanics-On-Memory-Profiling）.html-Dr15sYk2.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言机制之栈和指针.html-OIXWOgUo.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言机制之逃逸分析（Language-Mechanics-On-Escape-Analysis）.html-BSwrK1hN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言汇编快速入门.html-DsM55op-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言的内存管理.html-d6UUqBKY.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言编译过程概述.html-DLcEQVB_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-调优技术.html-52kbwzM7.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-逃逸分析的缺陷.html-CMuBeG6r.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-问答之如何阅读-Go-源码.html-D3lneojF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go1.13-defer-的性能是如何提高的？.html-DzeL2P07.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang---调度剖析【第一部分】.html-T60WRdbu.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang---调度剖析【第二部分】.html-DgywT52V.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang-socket数据结构.html-BZRKzByu.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang-如何进行类型检查.html-DjB_4Qzk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程栈初始化.html-Bm7ULxn_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程栈概述.html-BKvkbs6k.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程调度(一)-协程状态.html-BNQjQpr3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程调度二：协程切换原理.html-CH3A2Pa7.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程调度的数据结构.html-CM1oAeM0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang源码探索(一)-编译和调试源码.html-OvSovgtG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang源码探索(二)-协程的实现原理.html-C1ggllGC.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang网络-核心API实现剖析(一).html-MbpxjV-6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang网络-核心API实现剖析二).html-BmNJSqym.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Goroutine浅析.html-gPcMscr4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go内存分配那些事，就这么简单！.html-CY_BAQuP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go语言反射规则---The-Laws-of-Reflection.html-gtslJpvI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go语言高阶：调度器系列（1）起源.html-W5S_pgny.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go语言黑魔法.html-DWMaldmK.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go调度器系列（2）宏观看调度器.html-BUfXps1o.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go调度器系列（3）图解调度原理.html-kLevRq4C.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go调度器系列（4）源码阅读与探索.html-CGkhLWiX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go：Goroutine-与抢占机制.html-DEz2luQA.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Map-在-Go-runtime-中的高效实现（不使用范型）.html-CN1qlXMF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-t221nlib.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/译_-Go-代码诊断工具集合-官方文档.html-D5JYZVD8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/channel的使用及源码解析.html-D-E0EJqW.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang--详解interface和nil.html-D2NnwzvL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang-内存分析-动态追踪.html-D1PgABt6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang-汇编.html-C5JkJXWp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang进阶(八)——隐藏技能go-linkname.html-3Wpc2ByX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/go语言死循环分析.html-BlhVjuG6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/也谈goroutine调度器.html-Db8YaWQ3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/从底层理解-Golang-的-map-实现.html-Cc6H9Gsg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/从源码角度看Golang的TCP-Socket(epoll)实现.html-eRToSxUU.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/从源码讲解-golang-内存分配.html-Cq-0auHr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/使用-pprof-和火焰图调试-golang-应用.html-BUm1tgut.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/关于Go-GC---Rick's-ISMM-keynote.html-DdixLGB9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程栈扩容.html-DWyUpq-d.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程调度时机一：系统调用.html-C-aZ3nPz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程调度时机三：抢占式调度.html-BH2eGRDR.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程调度时机二：Channel读写.html-Dz_tb5Nv.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/可视化-Go-语言中的并发.html-HCljW16V.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go-select语句原理.html-Dztyjg7r.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go内存分配器.html-BWsJxDrt.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go语言内存分配.html-ChUszE5D.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go运行时调度器.html-BkDtbip9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解goroutine调度.html-Dv2bwlc0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/如何定位-golang-进程-hang-死的-bug.html-DCjilOiP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/实战Go内存泄露.html-1TNR3pHn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/弄懂goroutine调度原理.html-2nEHifzV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/指令集架构、机器码与-Go-语言.html-CAFmUQdV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/浅谈-Go-语言-select-的实现原理.html-C52XPpw5.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解-sync.RWMutex：解决读者-写者问题.html-CPGlhi7p.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解Go-1.9-sync.Map.html-DaQ344IU.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解Go-runtime.SetFinalizer原理剖析.html-DhOTa3w1.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解Go-sync.Map原理剖析.html-VrIOj1-G.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解channel：设计_源码.html-oh9QVAot.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入解析-Go-中-Slice-底层实现.html-apCSB3Bz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之-scheduler.html-psf_2qRb.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之Slice.html-CTTj4nep.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之map.html-CtmTnWIX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之关于-interface-的-10-个问题.html-H47yPP0k.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之反射.html-CJDtYFGn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/源码剖析golang中sync.Mutex.html-d55t4S9U.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/理解-Golang-中函数调用的原理.html-C9Ym7Sqh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/理解-Golang-哈希表-Map-的原理.html-LNxTujTg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/用-GODEBUG-看调度跟踪.html-DPvw46lX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/解剖Go语言map底层实现.html-BfSUQpmG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/解析器眼中的-Go-语言.html-sEjiXwkQ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/记一次获得3倍性能的go程序优化实践，及on-cpu-off-cpu火焰图的使用.html-BLt9mJCF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/详尽干货！从源码角度看-Golang-的调度.html-BhvQcjtp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/详解-Golang-中间代码生成.html-BeBBaRGG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/详解Go语言的内存模型及堆的分配管理.html-BNhhPUH_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/谈-Golang-中的字符串和字节数组.html-D10O968i.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/通过-profiling-定位-golang-性能问题---内存篇.html-CBANHs19.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/404.html-DwQc1sng.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BN7RFqTj.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-DJN8LopR.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-Bihu4_9d.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CklNBwjM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CaPKmAAG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-Dhk06VLP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/flowchart-CTwbLKUk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index-izhIXQi-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index-DRWmbcXV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index-B2Pezylg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/mermaid.esm.min-Bf9uIE2x.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/photoswipe.esm-GXRgw7eJ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/giscus-BZxmVUME.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/SearchResult-mpXxa_JZ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/setupDevtools-7MC2TMWH-DpbXT7rC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/vuepress-app/" aria-label="带我回家"><img class="vp-nav-logo light" src="/vuepress-app/log.svg" alt><img class="vp-nav-logo dark" src="/vuepress-app/logDark.svg" alt><span class="vp-site-name hide-in-pad">Golang全栈指南</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/vuepress-app/" aria-label="首页"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="golang"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>golang<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/%E5%9F%BA%E7%A1%80/" aria-label="Go基础"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-eraser" style=""></span><!--]-->Go基础<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/%E8%BF%9B%E9%98%B6/" aria-label="Go进阶"><!--[--><img class="icon" src="/vuepress-app/assets/icon/up.png" alt aria-hidden no-view style=""><!--]-->Go进阶<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/" aria-label="原理"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-gears" style=""></span><!--]-->原理<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/web%E6%A1%86%E6%9E%B6/" aria-label="框架"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-sitemap" style=""></span><!--]-->框架<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/%E9%9D%A2%E8%AF%95/" aria-label="面试"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-feather" style=""></span><!--]-->面试<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="中间件"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-layer-group" style=""></span>中间件<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html" aria-label="MySql"><!--[--><img class="icon" src="/vuepress-app/assets/icon/mysql.png" alt aria-hidden no-view style=""><!--]-->MySql<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html" aria-label="Redis"><!--[--><img class="icon" src="/vuepress-app/assets/icon/redis.png" alt aria-hidden no-view style=""><!--]-->Redis<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB.html" aria-label="MongoDB"><!--[--><img class="icon" src="/vuepress-app/assets/icon/mongodb.png" alt aria-hidden no-view style=""><!--]-->MongoDB<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6/kafka.html" aria-label="kafka"><!--[--><img class="icon" src="/vuepress-app/assets/icon/Kafka.png" alt aria-hidden no-view style=""><!--]-->kafka<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E7%BD%91%E5%85%B3/Nginx.html" aria-label="Nginx"><!--[--><img class="icon" src="/vuepress-app/assets/icon/Nginx.png" alt aria-hidden no-view style=""><!--]-->Nginx<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E8%BF%90%E7%BB%B4/Docker.html" aria-label="Docker"><!--[--><img class="icon" src="/vuepress-app/assets/icon/docker.png" alt aria-hidden no-view style=""><!--]-->Docker<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E8%BF%90%E7%BB%B4/Kubernetes.html" aria-label="Kubernetes"><!--[--><img class="icon" src="/vuepress-app/assets/icon/kubernetes.png" alt aria-hidden no-view style=""><!--]-->Kubernetes<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="架构"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-network-wired" style=""></span>架构<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" aria-label="微服务"><!--[--><img class="icon" src="/vuepress-app/assets/icon/micro.png" alt aria-hidden no-view style=""><!--]-->微服务<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E5%88%86%E5%B8%83%E5%BC%8F/" aria-label="分布式"><!--[--><img class="icon" src="/vuepress-app/assets/icon/kubernetes.png" alt aria-hidden no-view style=""><!--]-->分布式<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E9%AB%98%E5%8F%AF%E7%94%A8/" aria-label="高可用"><!--[--><img class="icon" src="/vuepress-app/assets/icon/available.png" alt aria-hidden no-view style=""><!--]-->高可用<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/" aria-label="领域驱动"><!--[--><img class="icon" src="/vuepress-app/assets/icon/DDD.png" alt aria-hidden no-view style=""><!--]-->领域驱动<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="计算机"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-computer" style=""></span>计算机<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/%E7%BD%91%E7%BB%9C/" aria-label="计算机网络"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-globe" style=""></span><!--]-->计算机网络<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" aria-label="操作系统"><!--[--><img class="icon" src="/vuepress-app/assets/icon/linux.png" alt aria-hidden no-view style=""><!--]-->操作系统<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/0.%E7%AE%97%E6%B3%95.html" aria-label="常用算法"><!--[--><img class="icon" src="/vuepress-app/assets/icon/arithmetic.png" alt aria-hidden no-view style=""><!--]-->常用算法<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/1.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="设计模式"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-ruler" style=""></span><!--]-->设计模式<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="好物分享"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-share-nodes" style=""></span>好物分享<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/share/%E5%A5%BD%E7%89%A9%E5%88%86%E4%BA%AB.html" aria-label="好物分享"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-share-nodes" style=""></span><!--]-->好物分享<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/share/git.html" aria-label="git"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-git-alt" style=""></span><!--]-->git<!----></a></li></ul></button></div></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Cospk" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="slimsearch-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="slimsearch-placeholder">搜索</div><div class="slimsearch-key-hints"><kbd class="slimsearch-key">Ctrl</kbd><kbd class="slimsearch-key">K</kbd></div></button><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-database" style=""></span><span class="vp-sidebar-title">GORM框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-server" style=""></span><span class="vp-sidebar-title">Web框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-gears" style=""></span><span class="vp-sidebar-title">原理</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html" aria-label="常用包和第三方包介绍"><!---->常用包和第三方包介绍<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-gear" style=""></span><span class="vp-sidebar-title">实现原理</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/0.runtime.html" aria-label="Runtime"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->Runtime<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="内置数据结构"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->内置数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/1.%E5%B9%B6%E5%8F%91.html" aria-label="并发"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/3.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html" aria-label="错误"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->错误<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%91_-Go-%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.html" aria-label="&quot;&quot;[译] Go 代码诊断工具集合-官方文档&quot;&quot;"><!---->&quot;&quot;[译] Go 代码诊断工具集合-官方文档&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang--%E8%AF%A6%E8%A7%A3interface%E5%92%8Cnil.html" aria-label="&quot;&quot;golang: 详解interface和nil&quot;&quot;"><!---->&quot;&quot;golang: 详解interface和nil&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6(%E4%B8%80)-%E5%8D%8F%E7%A8%8B%E7%8A%B6%E6%80%81.html" aria-label="&quot;&quot;Golang协程调度(一):协程状态&quot;&quot;"><!---->&quot;&quot;Golang协程调度(一):协程状态&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90(%E4%B8%80).html" aria-label="&quot;&quot;Golang网络:核心API实现剖析(一)&quot;&quot;"><!---->&quot;&quot;Golang网络:核心API实现剖析(一)&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90%E4%BA%8C).html" aria-label="&quot;&quot;Golang网络:核心API实现剖析二)&quot;&quot;"><!---->&quot;&quot;Golang网络:核心API实现剖析二)&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang%E8%BF%9B%E9%98%B6(%E5%85%AB)%E2%80%94%E2%80%94%E9%9A%90%E8%97%8F%E6%8A%80%E8%83%BDgo-linkname.html" aria-label="&quot;&quot;golang进阶(八)——隐藏技能go:linkname&quot;&quot;"><!---->&quot;&quot;golang进阶(八)——隐藏技能go:linkname&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/channel%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html" aria-label="channel的使用及源码解析"><!---->channel的使用及源码解析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/GC-%E7%9A%84%E8%AE%A4%E8%AF%86.html" aria-label="GC 的认识"><!---->GC 的认识<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Channel%E7%9A%84%E5%AE%9E%E7%8E%B0.html" aria-label="Go Channel的实现"><!---->Go Channel的实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-GC.html" aria-label="Go GC"><!---->Go GC<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Hashmap%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0.html" aria-label="Go Hashmap内存布局和实现"><!---->Go Hashmap内存布局和实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Modules-%E7%BB%88%E6%9E%81%E5%85%A5%E9%97%A8.html" aria-label="Go Modules 终极入门"><!---->Go Modules 终极入门<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Select%E7%9A%84%E5%AE%9E%E7%8E%B0.html" aria-label="Go Select的实现"><!---->Go Select的实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Slice%E4%B8%8EString%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0.html" aria-label="Go Slice与String内存布局和实现"><!---->Go Slice与String内存布局和实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-work-stealing-%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="Go work-stealing 调度器"><!---->Go work-stealing 调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86---%E5%9F%BA%E7%A1%80.html" aria-label="Go 中的垃圾回收：第一部分 - 基础"><!---->Go 中的垃圾回收：第一部分 - 基础<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/GO-%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%9A%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86---%E5%B9%B6%E5%8F%91.html" aria-label="GO 中的调度：第三部分 - 并发"><!---->GO 中的调度：第三部分 - 并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" aria-label="Go 内存管理"><!---->Go 内存管理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E4%BA%8C.html" aria-label="Go 内存管理之二"><!---->Go 内存管理之二<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.html" aria-label="Go 内存逃逸详细分析"><!---->Go 内存逃逸详细分析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B.html" aria-label="Go 函数调用惯例"><!---->Go 函数调用惯例<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%8F%8D%E5%B0%84%E4%B8%8Einterface%E6%8B%BE%E9%81%97.html" aria-label="Go 反射与interface拾遗"><!---->Go 反射与interface拾遗<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html" aria-label="Go 垃圾回收"><!---->Go 垃圾回收<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86---GC-%E8%BF%BD%E8%B8%AA.html" aria-label="Go 垃圾回收：第二部分 - GC 追踪"><!---->Go 垃圾回收：第二部分 - GC 追踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E6%89%A7%E8%A1%8C%E8%BF%BD%E8%B8%AA%E5%99%A8%EF%BC%88execution-tracer%EF%BC%89.html" aria-label="Go 执行追踪器（execution tracer）"><!---->Go 执行追踪器（execution tracer）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3.html" aria-label="Go 方法调用与接口"><!---->Go 方法调用与接口<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E8%BF%BD%E8%B8%AA.html" aria-label="Go 的调度器追踪"><!---->Go 的调度器追踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-goroutine-%E6%B3%84%E9%9C%B2.html" aria-label="Go 笔记之如何防止 goroutine 泄露"><!---->Go 笔记之如何防止 goroutine 泄露<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-goroutine-%E6%B3%84%E9%9C%B2%EF%BC%88%E4%BA%8C%EF%BC%89.html" aria-label="Go 笔记之如何防止 goroutine 泄露（二）"><!---->Go 笔记之如何防止 goroutine 泄露（二）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80-Channel-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%B2%BE%E8%A6%81.html" aria-label="Go 语言 Channel 实现原理精要"><!---->Go 语言 Channel 实现原理精要<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80-for-%E5%92%8C-range-%E7%9A%84%E5%AE%9E%E7%8E%B0.html" aria-label="Go 语言 for 和 range 的实现"><!---->Go 语言 for 和 range 的实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%8E%9F%E7%90%86.html" aria-label="Go 语言数组和切片的原理"><!---->Go 语言数组和切片的原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%86%85%E5%AD%98%E5%89%96%E6%9E%90%EF%BC%88Language-Mechanics-On-Memory-Profiling%EF%BC%89.html" aria-label="Go 语言机制之内存剖析（Language Mechanics On Memory Profiling）"><!---->Go 语言机制之内存剖析（Language Mechanics On Memory Profiling）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%A0%88%E5%92%8C%E6%8C%87%E9%92%88.html" aria-label="Go 语言机制之栈和指针"><!---->Go 语言机制之栈和指针<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E4%B9%8B%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%88Language-Mechanics-On-Escape-Analysis%EF%BC%89.html" aria-label="Go 语言机制之逃逸分析（Language Mechanics On Escape Analysis）"><!---->Go 语言机制之逃逸分析（Language Mechanics On Escape Analysis）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html" aria-label="Go 语言汇编快速入门"><!---->Go 语言汇编快速入门<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" aria-label="Go 语言的内存管理"><!---->Go 语言的内存管理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0.html" aria-label="Go 语言编译过程概述"><!---->Go 语言编译过程概述<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%B0%83%E4%BC%98%E6%8A%80%E6%9C%AF.html" aria-label="Go 调优技术"><!---->Go 调优技术<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E7%BC%BA%E9%99%B7.html" aria-label="Go 逃逸分析的缺陷"><!---->Go 逃逸分析的缺陷<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E9%97%AE%E7%AD%94%E4%B9%8B%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB-Go-%E6%BA%90%E7%A0%81.html" aria-label="Go 问答之如何阅读 Go 源码"><!---->Go 问答之如何阅读 Go 源码<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%EF%BC%9AGoroutine-%E4%B8%8E%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6.html" aria-label="Go：Goroutine 与抢占机制"><!---->Go：Goroutine 与抢占机制<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go1.13-defer-%E7%9A%84%E6%80%A7%E8%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%9A%84%EF%BC%9F.html" aria-label="Go1.13 defer 的性能是如何提高的？"><!---->Go1.13 defer 的性能是如何提高的？<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang---%E8%B0%83%E5%BA%A6%E5%89%96%E6%9E%90%E3%80%90%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E3%80%91.html" aria-label="Golang - 调度剖析【第一部分】"><!---->Golang - 调度剖析【第一部分】<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang---%E8%B0%83%E5%BA%A6%E5%89%96%E6%9E%90%E3%80%90%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E3%80%91.html" aria-label="Golang - 调度剖析【第二部分】"><!---->Golang - 调度剖析【第二部分】<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang-socket%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="Golang socket数据结构"><!---->Golang socket数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA.html" aria-label="golang 内存分析/动态追踪"><!---->golang 内存分析/动态追踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.html" aria-label="Golang 如何进行类型检查"><!---->Golang 如何进行类型检查<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang-%E6%B1%87%E7%BC%96.html" aria-label="golang 汇编"><!---->golang 汇编<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96.html" aria-label="Golang协程栈初始化"><!---->Golang协程栈初始化<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E6%A0%88%E6%A6%82%E8%BF%B0.html" aria-label="Golang协程栈概述"><!---->Golang协程栈概述<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%BA%8C%EF%BC%9A%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86.html" aria-label="Golang协程调度二：协程切换原理"><!---->Golang协程调度二：协程切换原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="Golang协程调度的数据结构"><!---->Golang协程调度的数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%B8%80)-%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81.html" aria-label="Golang源码探索(一) 编译和调试源码"><!---->Golang源码探索(一) 编译和调试源码<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%B8%89)-GC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="Golang源码探索(三) GC的实现原理"><!---->Golang源码探索(三) GC的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%BA%8C)-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="Golang源码探索(二) 协程的实现原理"><!---->Golang源码探索(二) 协程的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Goroutine%E6%B5%85%E6%9E%90.html" aria-label="Goroutine浅析"><!---->Goroutine浅析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81.html" aria-label="Go内存分配那些事，就这么简单！"><!---->Go内存分配那些事，就这么简单！<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99---The-Laws-of-Reflection.html" aria-label="Go语言反射规则 - The Laws of Reflection"><!---->Go语言反射规则 - The Laws of Reflection<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/go%E8%AF%AD%E8%A8%80%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%88%86%E6%9E%90.html" aria-label="go语言死循环分析"><!---->go语言死循环分析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E9%98%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E8%B5%B7%E6%BA%90.html" aria-label="Go语言高阶：调度器系列（1）起源"><!---->Go语言高阶：调度器系列（1）起源<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%AF%AD%E8%A8%80%E9%BB%91%E9%AD%94%E6%B3%95.html" aria-label="Go语言黑魔法"><!---->Go语言黑魔法<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%E5%AE%8F%E8%A7%82%E7%9C%8B%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="Go调度器系列（2）宏观看调度器"><!---->Go调度器系列（2）宏观看调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%E5%9B%BE%E8%A7%A3%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86.html" aria-label="Go调度器系列（3）图解调度原理"><!---->Go调度器系列（3）图解调度原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E6%8E%A2%E7%B4%A2.html" aria-label="Go调度器系列（4）源码阅读与探索"><!---->Go调度器系列（4）源码阅读与探索<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Map-%E5%9C%A8-Go-runtime-%E4%B8%AD%E7%9A%84%E9%AB%98%E6%95%88%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9E%8B%EF%BC%89.html" aria-label="Map 在 Go runtime 中的高效实现（不使用范型）"><!---->Map 在 Go runtime 中的高效实现（不使用范型）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%B9%9F%E8%B0%88goroutine%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="也谈goroutine调度器"><!---->也谈goroutine调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3-Golang-%E7%9A%84-map-%E5%AE%9E%E7%8E%B0.html" aria-label="从底层理解 Golang 的 map 实现"><!---->从底层理解 Golang 的 map 实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BGolang%E7%9A%84TCP-Socket(epoll)%E5%AE%9E%E7%8E%B0.html" aria-label="从源码角度看Golang的TCP Socket(epoll)实现"><!---->从源码角度看Golang的TCP Socket(epoll)实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3-golang-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html" aria-label="从源码讲解 golang 内存分配"><!---->从源码讲解 golang 内存分配<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BD%BF%E7%94%A8-pprof-%E5%92%8C%E7%81%AB%E7%84%B0%E5%9B%BE%E8%B0%83%E8%AF%95-golang-%E5%BA%94%E7%94%A8.html" aria-label="使用 pprof 和火焰图调试 golang 应用"><!---->使用 pprof 和火焰图调试 golang 应用<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%85%B3%E4%BA%8EGo-GC---Rick&#39;s-ISMM-keynote.html" aria-label="关于Go GC - Rick&#39;s ISMM keynote"><!---->关于Go GC - Rick&#39;s ISMM keynote<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E6%A0%88%E6%89%A9%E5%AE%B9.html" aria-label="协程栈扩容"><!---->协程栈扩容<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%80%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html" aria-label="协程调度时机一：系统调用"><!---->协程调度时机一：系统调用<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%89%EF%BC%9A%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.html" aria-label="协程调度时机三：抢占式调度"><!---->协程调度时机三：抢占式调度<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%BA%8C%EF%BC%9AChannel%E8%AF%BB%E5%86%99.html" aria-label="协程调度时机二：Channel读写"><!---->协程调度时机二：Channel读写<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8F%AF%E8%A7%86%E5%8C%96-Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91.html" aria-label="可视化 Go 语言中的并发"><!---->可视化 Go 语言中的并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go-select%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86.html" aria-label="图解Go select语句原理"><!---->图解Go select语句原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3goroutine%E8%B0%83%E5%BA%A6.html" aria-label="图解goroutine调度"><!---->图解goroutine调度<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8.html" aria-label="图解Go内存分配器"><!---->图解Go内存分配器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html" aria-label="图解Go语言内存分配"><!---->图解Go语言内存分配<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="图解Go运行时调度器"><!---->图解Go运行时调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D-golang-%E8%BF%9B%E7%A8%8B-hang-%E6%AD%BB%E7%9A%84-bug.html" aria-label="如何定位 golang 进程 hang 死的 bug"><!---->如何定位 golang 进程 hang 死的 bug<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%AE%9E%E6%88%98Go%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html" aria-label="实战Go内存泄露"><!---->实战Go内存泄露<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%BC%84%E6%87%82goroutine%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86.html" aria-label="弄懂goroutine调度原理"><!---->弄懂goroutine调度原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E4%B8%8E-Go-%E8%AF%AD%E8%A8%80.html" aria-label="指令集架构、机器码与 Go 语言"><!---->指令集架构、机器码与 Go 语言<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B5%85%E8%B0%88-Go-%E8%AF%AD%E8%A8%80-select-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="浅谈 Go 语言 select 的实现原理"><!---->浅谈 Go 语言 select 的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-sync.RWMutex%EF%BC%9A%E8%A7%A3%E5%86%B3%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98.html" aria-label="深入理解 sync.RWMutex：解决读者-写者问题"><!---->深入理解 sync.RWMutex：解决读者-写者问题<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3channel%EF%BC%9A%E8%AE%BE%E8%AE%A1_%E6%BA%90%E7%A0%81.html" aria-label="深入理解channel：设计+源码"><!---->深入理解channel：设计+源码<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-1.9-sync.Map.html" aria-label="深入理解Go 1.9 sync.Map"><!---->深入理解Go 1.9 sync.Map<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-runtime.SetFinalizer%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" aria-label="深入理解Go-runtime.SetFinalizer原理剖析"><!---->深入理解Go-runtime.SetFinalizer原理剖析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-sync.Map%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" aria-label="深入理解Go-sync.Map原理剖析"><!---->深入理解Go-sync.Map原理剖析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Go-%E4%B8%AD-Slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html" aria-label="深入解析 Go 中 Slice 底层实现"><!---->深入解析 Go 中 Slice 底层实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B-scheduler.html" aria-label="深度解密Go语言之 scheduler"><!---->深度解密Go语言之 scheduler<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8Bmap.html" aria-label="深度解密Go语言之map"><!---->深度解密Go语言之map<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8BSlice.html" aria-label="深度解密Go语言之Slice"><!---->深度解密Go语言之Slice<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%85%B3%E4%BA%8E-interface-%E7%9A%84-10-%E4%B8%AA%E9%97%AE%E9%A2%98.html" aria-label="深度解密Go语言之关于 interface 的 10 个问题"><!---->深度解密Go语言之关于 interface 的 10 个问题<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8F%8D%E5%B0%84.html" aria-label="深度解密Go语言之反射"><!---->深度解密Go语言之反射<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90golang%E4%B8%ADsync.Mutex.html" aria-label="源码剖析golang中sync.Mutex"><!---->源码剖析golang中sync.Mutex<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E7%90%86%E8%A7%A3-Golang-%E4%B8%AD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86.html" aria-label="理解 Golang 中函数调用的原理"><!---->理解 Golang 中函数调用的原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E7%90%86%E8%A7%A3-Golang-%E5%93%88%E5%B8%8C%E8%A1%A8-Map-%E7%9A%84%E5%8E%9F%E7%90%86.html" aria-label="理解 Golang 哈希表 Map 的原理"><!---->理解 Golang 哈希表 Map 的原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E7%94%A8-GODEBUG-%E7%9C%8B%E8%B0%83%E5%BA%A6%E8%B7%9F%E8%B8%AA.html" aria-label="用 GODEBUG 看调度跟踪"><!---->用 GODEBUG 看调度跟踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%A7%A3%E5%89%96Go%E8%AF%AD%E8%A8%80map%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html" aria-label="解剖Go语言map底层实现"><!---->解剖Go语言map底层实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9C%BC%E4%B8%AD%E7%9A%84-Go-%E8%AF%AD%E8%A8%80.html" aria-label="解析器眼中的 Go 语言"><!---->解析器眼中的 Go 语言<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%BE%973%E5%80%8D%E6%80%A7%E8%83%BD%E7%9A%84go%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%8F%8Aon-cpu-off-cpu%E7%81%AB%E7%84%B0%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8.html" aria-label="记一次获得3倍性能的go程序优化实践，及on-cpu/off-cpu火焰图的使用"><!---->记一次获得3倍性能的go程序优化实践，及on-cpu/off-cpu火焰图的使用<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E5%B0%BD%E5%B9%B2%E8%B4%A7%EF%BC%81%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8B-Golang-%E7%9A%84%E8%B0%83%E5%BA%A6.html" aria-label="详尽干货！从源码角度看 Golang 的调度"><!---->详尽干货！从源码角度看 Golang 的调度<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E8%A7%A3-Golang-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.html" aria-label="详解 Golang 中间代码生成"><!---->详解 Golang 中间代码生成<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%A0%86%E7%9A%84%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86.html" aria-label="详解Go语言的内存模型及堆的分配管理"><!---->详解Go语言的内存模型及堆的分配管理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%B0%88-Golang-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84.html" aria-label="谈 Golang 中的字符串和字节数组"><!---->谈 Golang 中的字符串和字节数组<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E9%80%9A%E8%BF%87-profiling-%E5%AE%9A%E4%BD%8D-golang-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98---%E5%86%85%E5%AD%98%E7%AF%87.html" aria-label="通过 profiling 定位 golang 性能问题 - 内存篇"><!---->通过 profiling 定位 golang 性能问题 - 内存篇<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><span class="vp-sidebar-title">标准库</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-eraser" style=""></span><span class="vp-sidebar-title">基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><img class="icon" src="/vuepress-app/assets/icon/up.png" alt aria-hidden no-view style=""><span class="vp-sidebar-title">进阶</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">面试</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Golang源码探索(三) GC的实现原理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://savvygo.cn" target="_blank" rel="noopener noreferrer">Cospk</a></span><span property="author" content="Cospk"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025年8月26日</span><meta property="datePublished" content="2025-08-26T10:06:47.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 97 分钟</span><meta property="timeRequired" content="PT97M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color2" role>Go原理教程</span><!--]--><meta property="articleSection" content="Go原理教程"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc" vp-toc><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#根对象-在gc的标记阶段首先需要标记的就是-根对象-从根对象开始可到达的所有对象都会被认为是存活的-根对象包含了全局变量-各个g的栈上的变量等-gc会先扫描根对象然后再扫描根对象可到达的所有对象-扫描根对象包含了一系列的工作-它们定义在-https-github-com-golang-go-blob-go1-9-2-src-runtime-mgcmark-go-l54-函数-fixed-roots-特殊的扫描工作-fixedrootfinalizers-扫描析构器队列-fixedrootfreegstacks-释放已中止的g的栈-flush-cache-roots-释放mcache中的所有span-要求stw-data-roots-扫描可读写的全局变量-bss-roots-扫描只读的全局变量-span-roots-扫描各个span中特殊对象-析构器列表-stack-roots-扫描各个g的栈-标记阶段-mark-会做其中的-fixed-roots-data-roots-bss-roots-span-roots-stack-roots-完成标记阶段-mark-termination-会做其中的-fixed-roots-flush-cache-roots-标记队列-gc的标记阶段会使用-标记队列-来确定所有可从根对象到达的对象都已标记-上面提到的-灰色-的对象就是在标记队列中的对象-举例来说-如果当前有-a-b-c-这三个根对象-那么扫描根对象时就会把它们放到标记队列">根对象 在GC的标记阶段首先需要标记的就是&quot;根对象&quot;, 从根对象开始可到达的所有对象都会被认为是存活的.\ 根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.\ 扫描根对象包含了一系列的工作, 它们定义在\[https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54\]函数: - Fixed Roots: 特殊的扫描工作 - fixedRootFinalizers: 扫描析构器队列 - fixedRootFreeGStacks: 释放已中止的G的栈 - Flush Cache Roots: 释放mcache中的所有span, 要求STW - Data Roots: 扫描可读写的全局变量 - BSS Roots: 扫描只读的全局变量 - Span Roots: 扫描各个span中特殊对象(析构器列表) - Stack Roots: 扫描各个G的栈 标记阶段(Mark)会做其中的&quot;Fixed Roots&quot;, &quot;Data Roots&quot;, &quot;BSS Roots&quot;, &quot;Span Roots&quot;, &quot;Stack Roots&quot;.\ 完成标记阶段(Mark Termination)会做其中的&quot;Fixed Roots&quot;, &quot;Flush Cache Roots&quot;. ### 标记队列 GC的标记阶段会使用&quot;标记队列&quot;来确定所有可从根对象到达的对象都已标记, 上面提到的&quot;灰色&quot;的对象就是在标记队列中的对象.\ 举例来说, 如果当前有\[A, B, C]这三个根对象, 那么扫描根对象时就会把它们放到标记队列:</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content" vp-content><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>Golang从1.5开始引入了三色GC, 经过多次改进, 当前的1.9版本的GC停顿时间已经可以做到极短.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>停顿时间的减少意味着&quot;最大响应时间&quot;的缩短, 这也让go更适合编写网络服务程序.\ 这篇文章将通过分析golang的源代码来讲解go中的三色GC的实现原理. 这个系列分析的golang源代码是Google官方的实现的1.9.2版本, 不适用于其他版本和gccgo等其他实现,\ 运行环境是Ubuntu 16.04 LTS 64bit.\ 首先会讲解基础概念, 然后讲解分配器, 再讲解收集器的实现. # 基础概念 ### 内存结构 go在程序启动时会分配一块虚拟内存地址是连续的内存, 结构如下: ![](<a href="https://static.studygolang.com/190818/9d728b7e8e69179ba70c6b47c93d6723.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/9d728b7e8e69179ba70c6b47c93d6723.png</a>) 这一块内存分为了3个区域, 在X64上大小分别是512M, 16G和512G, 它们的作用如下: **arena** arena区域就是我们通常说的**heap**, go从heap分配的内存都在这个区域中. **bitmap** bitmap区域用于表示arena区域中哪些地址保存了对象, 并且对象中哪些地址包含了**指针**.\ bitmap区域中一个byte(8 bit)对应了arena区域中的四个指针大小的内存, 也就是2 bit对应一个指针大小的内存.\ 所以bitmap区域的大小是 512GB / 指针大小(8 byte) / 4 = 16GB. bitmap区域中的一个byte对应arena区域的四个指针大小的内存的结构如下,\ 每一个指针大小的内存都会有两个bit分别表示是否应该继续扫描和是否包含指针: ![](<a href="https://static.studygolang.com/190818/bdf0b18db634aa2ac024c4ad80a7298f.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/bdf0b18db634aa2ac024c4ad80a7298f.png</a>) bitmap中的byte和arena的对应关系从末尾开始, 也就是随着内存分配会向两边扩展: ![](<a href="https://static.studygolang.com/190818/a035316bc5eb3f4d02ad8e5d7b22b486.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/a035316bc5eb3f4d02ad8e5d7b22b486.png</a>) **spans** spans区域用于表示arena区中的某一页(Page)属于哪个span, 什么是span将在下面介绍.\ spans区域中一个指针(8 byte)对应了arena区域中的一页(在go中一页=8KB).\ 所以spans的大小是 512GB / 页大小(8KB) \* 指针大小(8 byte) = 512MB. spans区域的一个指针对应arena区域的一页的结构如下, 和bitmap不一样的是对应关系会从开头开始: ![](<a href="https://static.studygolang.com/190818/d20e5838857911266aadf5925027b384.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/d20e5838857911266aadf5925027b384.png</a>) ### 什么时候从Heap分配对象 很多讲解go的文章和书籍中都提到过, go会自动确定哪些对象应该放在栈上, 哪些对象应该放在堆上.\ 简单的来说, 当一个对象的内容可能在生成该对象的函数结束后被访问, 那么这个对象就会分配在堆上.\ 在堆上分配对象的情况包括: - 返回对象的指针 - 传递了对象的指针到其他函数 - 在闭包中使用了对象并且需要修改对象 - 使用new 在C语言中函数返回在栈上的对象的指针是非常危险的事情, 但在go中却是安全的, 因为这个对象会自动在堆上分配.\ go决定是否使用堆分配对象的过程也叫&quot;逃逸分析&quot;. ### GC Bitmap GC在标记时需要知道哪些地方包含了指针, 例如上面提到的bitmap区域涵盖了arena区域中的指针信息.\ 除此之外, GC还需要知道栈空间上哪些地方包含了指针,\ 因为栈空间不属于arena区域, 栈空间的指针信息将会在**函数信息**里面.\ 另外, GC在分配对象时也需要根据对象的类型设置bitmap区域, 来源的指针信息将会在**类型信息**里面. 总结起来go中有以下的GC Bitmap: - bitmap区域: 涵盖了arena区域, 使用2 bit表示一个指针大小的内存 - 函数信息: 涵盖了函数的栈空间, 使用1 bit表示一个指针大小的内存 (位于stackmap.bytedata) - 类型信息: 在分配对象时会复制到bitmap区域, 使用1 bit表示一个指针大小的内存 (位于\_type.gcdata) ### Span span是用于分配对象的区块, 下图是简单说明了Span的内部结构: ![](<a href="https://static.studygolang.com/190818/169d51d880f1454f6cd5323549107a5b.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/169d51d880f1454f6cd5323549107a5b.png</a>) 通常一个span包含了多个大小相同的元素, 一个元素会保存一个对象, 除非: - span用于保存大对象, 这种情况span只有一个元素 - span用于保存极小对象且不包含指针的对象(tiny object), 这种情况span会用一个元素保存多个对象 span中有一个freeindex标记下一次分配对象时应该开始搜索的地址, 分配后freeindex会增加,\ 在freeindex之前的元素都是已分配的, 在freeindex之后的元素有可能已分配, 也有可能未分配. span每次GC以后都可能会回收掉一些元素, allocBits用于标记哪些元素是已分配的, 哪些元素是未分配的.\ 使用freeindex + allocBits可以在分配时跳过已分配的元素, 把对象设置在未分配的元素中,\ 但因为每次都去访问allocBits效率会比较慢, span中有一个整数型的allocCache用于缓存freeindex开始的bitmap, 缓存的bit值与原值相反. gcmarkBits用于在gc时标记哪些对象存活, **每次gc以后gcmarkBits会变为allocBits**.\ 需要注意的是span结构本身的内存是从系统分配的, 上面提到的spans区域和bitmap区域都只是一个索引. ### Span的类型 span根据大小可以分为67个类型, 如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // class bytes/obj bytes/span objects tail waste max waste // 1 8 8192 1024 0 87.50% // 2 16 8192 512 0 43.75% // 3 32 8192 256 0 46.88% // 4 48 8192 170 32 31.52% // 5 64 8192 128 0 23.44% // 6 80 8192 102 32 19.07% // 7 96 8192 85 32 15.95% // 8 112 8192 73 16 13.56% // 9 128 8192 64 0 11.72% // 10 144 8192 56 128 11.82% // 11 160 8192 51 32 9.73% // 12 176 8192 46 96 9.59% // 13 192 8192 42 128 9.25% // 14 208 8192 39 80 8.12% // 15 224 8192 36 128 8.15% // 16 240 8192 34 32 6.62% // 17 256 8192 32 0 5.86% // 18 288 8192 28 128 12.16% // 19 320 8192 25 192 11.80% // 20 352 8192 23 96 9.88% // 21 384 8192 21 128 9.51% // 22 416 8192 19 288 10.71% // 23 448 8192 18 128 8.37% // 24 480 8192 17 32 6.82% // 25 512 8192 16 0 6.05% // 26 576 8192 14 128 12.33% // 27 640 8192 12 512 15.48% // 28 704 8192 11 448 13.93% // 29 768 8192 10 512 13.94% // 30 896 8192 9 128 15.52% // 31 1024 8192 8 0 12.40% // 32 1152 8192 7 128 12.41% // 33 1280 8192 6 512 15.55% // 34 1408 16384 11 896 14.00% // 35 1536 8192 5 512 14.00% // 36 1792 16384 9 256 15.57% // 37 2048 8192 4 0 12.45% // 38 2304 16384 7 256 12.46% // 39 2688 8192 3 128 15.59% // 40 3072 24576 8 0 12.47% // 41 3200 16384 5 384 6.22% // 42 3456 24576 7 384 8.83% // 43 4096 8192 2 0 15.60% // 44 4864 24576 5 256 16.65% // 45 5376 16384 3 256 10.92% // 46 6144 24576 4 0 12.48% // 47 6528 32768 5 128 6.23% // 48 6784 40960 6 256 4.36% // 49 6912 49152 7 768 3.37% // 50 8192 8192 1 0 15.61% // 51 9472 57344 6 512 14.28% // 52 9728 49152 5 512 3.64% // 53 10240 40960 4 0 4.99% // 54 10880 32768 3 128 6.24% // 55 12288 24576 2 0 11.45% // 56 13568 40960 3 256 9.99% // 57 14336 57344 4 0 5.35% // 58 16384 16384 1 0 12.49% // 59 18432 73728 4 0 11.11% // 60 19072 57344 3 128 3.57% // 61 20480 40960 2 0 6.87% // 62 21760 65536 3 256 6.25% // 63 24576 24576 1 0 11.45% // 64 27264 81920 3 128 10.00% // 65 28672 57344 2 0 4.91% // 66 32768 32768 1 0 12.50%</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以类型(class)为1的span为例,\ span中的元素大小是8 byte, span本身占1页也就是8K, 一共可以保存1024个对象. 在分配对象时, 会根据对象的大小决定使用什么类型的span,\ 例如16 byte的对象会使用span 2, 17 byte的对象会使用span 3, 32 byte的对象会使用span 3.\ 从这个例子也可以看到, 分配17和32 byte的对象都会使用span 3, 也就是说部分大小的对象在分配时会浪费一定的空间. 有人可能会注意到, 上面最大的span的元素大小是32K, 那么分配超过32K的对象会在哪里分配呢?\ 超过32K的对象称为&quot;大对象&quot;, 分配大对象时, 会直接从heap分配一个特殊的span,\ 这个特殊的span的类型(class)是0, 只包含了一个大对象, span的大小由对象的大小决定. 特殊的span加上的66个标准的span, 一共组成��67个span类型. ### Span的位置 在[前一篇](<a href="http://www.cnblogs.com/zkweb/p/7815600.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/zkweb/p/7815600.html</a>)中我提到了P是一个虚拟的资源, 同一时间只能有一个线程访问同一个P, 所以P中的数据不需要锁.\ 为了分配对象时有更好的性能, 各个P中都有span的缓存(也叫mcache), 缓存的结构如下: ![](<a href="https://static.studygolang.com/190818/163e2f7db10c32f015e8cad74d398b72.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/163e2f7db10c32f015e8cad74d398b72.png</a>) 各个P中按span类型的不同, 有67\*2=134个span的缓存, 其中scan和noscan的区别在于,\ 如果对象包含了指针, 分配对象时会使用scan的span,\ 如果对象不包含指针, 分配对象时会使用noscan的span.\ 把span分为scan和noscan的意义在于,\ GC扫描对象的时候对于noscan的span可以不去查看bitmap区域来标记子对象, 这样可以大幅提升标记的效率. 在分配对象时将会从以下的位置获取适合的span用于分配: - 首先从P的缓存(mcache)获取, 如果有缓存的span并且未满则使用, 这个步骤不需要锁 - 然后从全局缓存(mcentral)获取, 如果获取成功则设置到P, 这个步骤需要锁 - 最后从mheap获取, 获取后设置到全局缓存, 这个步骤需要锁 在P中缓存span的做法跟CoreCLR中线程缓存分配上下文(Allocation Context)的做法相似,\ 都可以让分配对象时大部分时候不需要线程锁, 改进分配的性能. # 分配对象的处理 ### 分配对象的流程 go从堆分配对象时会调用newobject函数, 这个函数的流程大致如下: ![](<a href="https://static.studygolang.com/190818/215bb718a4a3ff4285f0ac6077c14dca.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/215bb718a4a3ff4285f0ac6077c14dca.png</a>) 首先会检查GC是否在工作中, 如果GC在工作中并且当前的G分配了一定大小的内存则需要协助GC做一定的工作,\ 这个机制叫GC Assist, 用于防止分配内存太快导致GC回收跟不上的情况发生. 之后会判断是小对象还是大对象, 如果是大对象则直接调用largeAlloc从堆中分配,\ 如果是小对象分3个阶段获取可用的span, 然后从span中分配对象: - 首先从P的缓存(mcache)获取 - 然后从全局缓存(mcentral)获取, 全局缓存中有可用的span的列表 - 最后从mheap获取, mheap中也有span的自由列表, 如果都获取失败则从arena区域分配 这三个阶段的详细结构如下图: ![](<a href="https://static.studygolang.com/190818/34af597a5f6f78b5c0da91bccc3638e0.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/34af597a5f6f78b5c0da91bccc3638e0.png</a>) ### 数据类型的定义 分配对象涉及的数据类型包含: [p](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L450" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L450</a>): 前一篇提到过, P是协程中的用于运行go代码的虚拟资源\ [m](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L383" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L383</a>): 前一篇提到过, M目前代表系统线程\ [g](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L320" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L320</a>): 前一篇提到过, G就是goroutine\ [mspan](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L222" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L222</a>): 用于分配对象的区块\ [mcentral](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L20" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L20</a>): 全局的mspan缓存, 一共有67\*2=134个\ [mheap](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L30" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L30</a>): 用于管理heap的对象, 全局只有一个 ### 源代码分析 go从堆分配对象时会调用[newobject](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L840" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L840</a>)函数, 先从这个函数看起:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // implementation of new builtin // compiler (both frontend and SSA backend) knows the signature // of this function func newobject(typ \*\_type) unsafe.Pointer { return mallocgc(typ.size, typ, true) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[newobject](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L840" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L840</a>)调用了[mallocgc](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L581" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L581</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Allocate an object of size bytes. // Small objects are allocated from the per-P cache&#39;s free lists. // Large objects (&gt; 32 kB) are allocated straight from the heap. func mallocgc(size uintptr, typ \*\_type, needzero bool) unsafe.Pointer { if gcphase == \_GCmarktermination { throw(&quot;mallocgc called with gcphase == \_GCmarktermination&quot;) } if size == 0 { return unsafe.Pointer(&amp;zerobase) } if debug.sbrk != 0 { align := uintptr(16) if typ != nil { align = uintptr(typ.align) } return persistentalloc(size, align, &amp;memstats.other\_sys) } // 判断是否要辅助GC工作 // gcBlackenEnabled在GC的标记阶段会开启 // assistG is the G to charge for this allocation, or nil if // GC is not currently active. var assistG \*g if gcBlackenEnabled != 0 { // Charge the current user G for this allocation. assistG = getg() if assistG.m.curg != nil { assistG = assistG.m.curg } // Charge the allocation against the G. We&#39;ll account // for internal fragmentation at the end of mallocgc. assistG.gcAssistBytes -= int64(size) // 会按分配的大小判断需要协助GC完成多少工作 // 具体的算法将在下面讲解收集器时说明 if assistG.gcAssistBytes &lt; 0 { // This G is in debt. Assist the GC to correct // this before allocating. This must happen // before disabling preemption. gcAssistAlloc(assistG) } } // 增加当前G对应的M的lock计数, 防止这个G被抢占 // Set mp.mallocing to keep from being preempted by GC. mp := acquirem() if mp.mallocing != 0 { throw(&quot;malloc deadlock&quot;) } if mp.gsignal == getg() { throw(&quot;malloc during signal&quot;) } mp.mallocing = 1 shouldhelpgc := false dataSize := size // 获取当前G对应的M对应的P的本地span缓存(mcache) // 因为M在拥有P后会把P的mcache设到M中, 这里返回的是getg().m.mcache c := gomcache() var x unsafe.Pointer noscan := typ == nil || typ.kind&amp;kindNoPointers != 0 // 判断是否小对象, maxSmallSize当前的值是32K if size &lt;= maxSmallSize { // 如果对象不包含指针, 并且对象的大小小于16 bytes, 可以做特殊处理 // 这里是针对非常小的对象的优化, 因为span的元素最小只能是8 byte, 如果对象更小那么很多空间都会被浪费掉 // 非常小的对象可以整合在&quot;class 2 noscan&quot;的元素(大小为16 byte)中 if noscan &amp;&amp; size &lt; maxTinySize { // Tiny allocator. // // Tiny allocator combines several tiny allocation requests // into a single memory block. The resulting memory block // is freed when all subobjects are unreachable. The subobjects // must be noscan (don&#39;t have pointers), this ensures that // the amount of potentially wasted memory is bounded. // // Size of the memory block used for combining (maxTinySize) is tunable. // Current setting is 16 bytes, which relates to 2x worst case memory // wastage (when all but one subobjects are unreachable). // 8 bytes would result in no wastage at all, but provides less // opportunities for combining. // 32 bytes provides more opportunities for combining, // but can lead to 4x worst case wastage. // The best case winning is 8x regardless of block size. // // Objects obtained from tiny allocator must not be freed explicitly. // So when an object will be freed explicitly, we ensure that // its size &gt;= maxTinySize. // // SetFinalizer has a special case for objects potentially coming // from tiny allocator, it such case it allows to set finalizers // for an inner byte of a memory block. // // The main targets of tiny allocator are small strings and // standalone escaping variables. On a json benchmark // the allocator reduces number of allocations by ~12% and // reduces heap size by ~20%. off := c.tinyoffset // Align tiny pointer for required (conservative) alignment. if size&amp;7 == 0 { off = round(off, 8) } else if size&amp;3 == 0 { off = round(off, 4) } else if size&amp;1 == 0 { off = round(off, 2) } if off+size &lt;= maxTinySize &amp;&amp; c.tiny != 0 { // The object fits into existing tiny block. x = unsafe.Pointer(c.tiny + off) c.tinyoffset = off + size c.local\_tinyallocs++ mp.mallocing = 0 releasem(mp) return x } // Allocate a new maxTinySize block. span := c.alloc\[tinySpanClass\] v := nextFreeFast(span) if v == 0 { v, \_, shouldhelpgc = c.nextFree(tinySpanClass) } x = unsafe.Pointer(v) (\*\[2\]uint64)(x)\[0\] = 0 (\*\[2\]uint64)(x)\[1\] = 0 // See if we need to replace the existing tiny block with the new one // based on amount of remaining free space. if size &lt; c.tinyoffset || c.tiny == 0 { c.tiny = uintptr(x) c.tinyoffset = size } size = maxTinySize } else { // 否则按普通的小对象分配 // 首先获取对象的大小应该使用哪个span类型 var sizeclass uint8 if size &lt;= smallSizeMax-8 { sizeclass = size\_to\_class8\[(size+smallSizeDiv-1)/smallSizeDiv\] } else { sizeclass = size\_to\_class128\[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv\] } size = uintptr(class\_to\_size\[sizeclass\]) // 等于sizeclass \* 2 + (noscan ? 1 : 0) spc := makeSpanClass(sizeclass, noscan) span := c.alloc\[spc\] // 尝试快速的从这个span中分配 v := nextFreeFast(span) if v == 0 { // 分配失败, 可能需要从mcentral或者mheap中获取 // 如果从mcentral或者mheap获取了新的span, 则shouldhelpgc会等于true // shouldhelpgc会等于true时会在下面判断是否要触发GC v, span, shouldhelpgc = c.nextFree(spc) } x = unsafe.Pointer(v) if needzero &amp;&amp; span.needzero != 0 { memclrNoHeapPointers(unsafe.Pointer(v), size) } } } else { // 大对象直接从mheap分配, 这里的s是一个特殊的span, 它的class是0 var s \*mspan shouldhelpgc = true systemstack(func() { s = largeAlloc(size, needzero, noscan) }) s.freeindex = 1 s.allocCount = 1 x = unsafe.Pointer(s.base()) size = s.elemsize } // 设置arena对应的bitmap, 记录哪些位置包含了指针, GC会使用bitmap扫描所有可到达的对象 var scanSize uintptr if !noscan { // If allocating a defer+arg block, now that we&#39;ve picked a malloc size // large enough to hold everything, cut the &quot;asked for&quot; size down to // just the defer header, so that the GC bitmap will record the arg block // as containing nothing at all (as if it were unused space at the end of // a malloc block caused by size rounding). // The defer arg areas are scanned as part of scanstack. if typ == deferType { dataSize = unsafe.Sizeof(\_defer{}) } // 这个函数非常的长, 有兴趣的可以看 // https://github.com/golang/go/blob/go1.9.2/src/runtime/mbitmap.go#L855 // 虽然代码很长但是设置的内容跟上面说过的bitmap区域的结构一样 // 根据类型信息设置scan bit跟pointer bit, scan bit成立表示应该继续扫描, pointer bit成立表示该位置是指针 // 需要注意的地方有 // - 如果一个类型只有开头的地方包含指针, 例如\[ptr, ptr, large non-pointer data\] // 那么后面的部分的scan bit将会为0, 这样可以大幅提升标记的效率 // - 第二个slot的scan bit用途比较特殊, 它并不用于标记是否继续scan, 而是标记checkmark // 什么是checkmark // - 因为go的并行GC比较复杂, 为了检查实现是否正确, go需要在有一个检查所有应该被标记的对象是否被标记的机制 // 这个机制就是checkmark, 在开启checkmark时go会在标记阶段的最后停止整个世界然后重新执行一次标记 // 上面的第二个slot的scan bit就是用于标记对象在checkmark标记中是否被标记的 // - 有的人可能会发现第二个slot要求对象最少有两个指针的大小, 那么只有一个指针的大小的对象呢? // 只有一个指针的大小的对象可以分为两种情况 // 对象就是指针, 因为大小刚好是1个指针所以并不需要看bitmap区域, 这时第一个slot就是checkmark // 对象不是指针, 因为有tiny alloc的机制, 不是指针且只有一个指针大小的对象会分配在两个指针的span中 // 这时候也不需要看bitmap区域, 所以和上面一样第一个slot就是checkmark heapBitsSetType(uintptr(x), size, dataSize, typ) if dataSize &gt; typ.size { // Array allocation. If there are any // pointers, GC has to scan to the last // element. if typ.ptrdata != 0 { scanSize = dataSize - typ.size + typ.ptrdata } } else { scanSize = typ.ptrdata } c.local\_scan += scanSize } // 内存屏障, 因为x86和x64的store不会乱序所以这里只是个针对编译器的屏障, 汇编中是ret // Ensure that the stores above that initialize x to // type-safe memory and set the heap bits occur before // the caller can make x observable to the garbage // collector. Otherwise, on weakly ordered machines, // the garbage collector could follow a pointer to x, // but see uninitialized memory or stale heap bits. publicationBarrier() // 如果当前在GC中, 需要立刻标记分配后的对象为&quot;黑色&quot;, 防止它被回收 // Allocate black during GC. // All slots hold nil so no scanning is needed. // This may be racing with GC so do it atomically if there can be // a race marking the bit. if gcphase != \_GCoff { gcmarknewobject(uintptr(x), size, scanSize) } // Race Detector的处理(用于检测线程冲突问题) if raceenabled { racemalloc(x, size) } // Memory Sanitizer的处理(用于检测危险指针等内存问题) if msanenabled { msanmalloc(x, size) } // 重新允许当前的G被抢占 mp.mallocing = 0 releasem(mp) // 除错记录 if debug.allocfreetrace != 0 { tracealloc(x, size, typ) } // Profiler记录 if rate := MemProfileRate; rate &gt; 0 { if size &lt; uintptr(rate) &amp;&amp; int32(size) &lt; c.next\_sample { c.next\_sample -= int32(size) } else { mp := acquirem() profilealloc(mp, x, size) releasem(mp) } } // gcAssistBytes减去&quot;实际分配大小 - 要求分配大小&quot;, 调整到准确值 if assistG != nil { // Account for internal fragmentation in the assist // debt now that we know it. assistG.gcAssistBytes -= int64(size - dataSize) } // 如果之前获取了新的span, 则判断是否需要后台启动GC // 这里的判断逻辑(gcTrigger)会在下面详细说明 if shouldhelpgc { if t := (gcTrigger{kind: gcTriggerHeap}); t.test() { gcStart(gcBackgroundMode, t) } } return x }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来看看如何从span里面分配对象, 首先会调用[nextFreeFast](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L521" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L521</a>)尝试快速分配:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // nextFreeFast returns the next free object if one is quickly available. // Otherwise it returns 0. func nextFreeFast(s \*mspan) gclinkptr { // 获取第一个非0的bit是第几个bit, 也就是哪个元素是未分配的 theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache? // 找到未分配的元素 if theBit &lt; 64 { result := s.freeindex + uintptr(theBit) // 要求索引值小于元素数量 if result &lt; s.nelems { // 下一个freeindex freeidx := result + 1 // 可以被64整除时需要特殊处理(参考nextFree) if freeidx%64 == 0 &amp;&amp; freeidx != s.nelems { return 0 } // 更新freeindex和allocCache(高位都是0, 用尽以后会更新) s.allocCache &gt;&gt;= uint(theBit + 1) s.freeindex = freeidx // 返回元素所在的地址 v := gclinkptr(result\*s.elemsize + s.base()) // 添加已分配的元素计数 s.allocCount++ return v } } return 0 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果在freeindex后无法快速找到未分配的元素, 就需要调用[nextFree](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L546" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L546</a>)做出更复杂的处理:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // nextFree returns the next free object from the cached span if one is available. // Otherwise it refills the cache with a span with an available object and // returns that object along with a flag indicating that this was a heavy // weight allocation. If it is a heavy weight allocation the caller must // determine whether a new GC cycle needs to be started or if the GC is active // whether this goroutine needs to assist the GC. func (c \*mcache) nextFree(spc spanClass) (v gclinkptr, s \*mspan, shouldhelpgc bool) { // 找到下一个freeindex和更新allocCache s = c.alloc\[spc\] shouldhelpgc = false freeIndex := s.nextFreeIndex() // 如果span里面所有元素都已分配, 则需要获取新的span if freeIndex == s.nelems { // The span is full. if uintptr(s.allocCount) != s.nelems { println(&quot;runtime: s.allocCount=&quot;, s.allocCount, &quot;s.nelems=&quot;, s.nelems) throw(&quot;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&quot;) } // 申请新的span systemstack(func() { c.refill(spc) }) // 获取申请后的新的span, 并设置需要检查是否执行GC shouldhelpgc = true s = c.alloc\[spc\] freeIndex = s.nextFreeIndex() } if freeIndex &gt;= s.nelems { throw(&quot;freeIndex is not valid&quot;) } // 返回元素所在的地址 v = gclinkptr(freeIndex\*s.elemsize + s.base()) // 添加已分配的元素计数 s.allocCount++ if uintptr(s.allocCount) &gt; s.nelems { println(&quot;s.allocCount=&quot;, s.allocCount, &quot;s.nelems=&quot;, s.nelems) throw(&quot;s.allocCount &gt; s.nelems&quot;) } return }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果mcache中指定类型的span已满, 就需要调用[refill](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcache.go#L107" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mcache.go#L107</a>)函数申请新的span:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Gets a span that has a free object in it and assigns it // to be the cached span for the given sizeclass. Returns this span. func (c \*mcache) refill(spc spanClass) \*mspan { \_g\_ := getg() // 防止G被抢占 \_g\_.m.locks++ // Return the current cached span to the central lists. s := c.alloc\[spc\] // 确保当前的span所有元素都已分配 if uintptr(s.allocCount) != s.nelems { throw(&quot;refill of span with free space remaining&quot;) } // 设置span的incache属性, 除非是全局使用的空span(也就是mcache里面span指针的默认值) if s != &amp;emptymspan { s.incache = false } // 向mcentral申请一个新的span // Get a new cached span from the central lists. s = mheap\_.central\[spc\].mcentral.cacheSpan() if s == nil { throw(&quot;out of memory&quot;) } if uintptr(s.allocCount) == s.nelems { throw(&quot;span has no free space&quot;) } // 设置新的span到mcache中 c.alloc\[spc\] = s // 允许G被抢占 \_g\_.m.locks-- return s }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>向mcentral申请一个新的span会通过[cacheSpan](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L40" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L40</a>)函数:\ mcentral首先尝试从内部的链表复用原有的span, 如果复用失败则向mheap申请.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Allocate a span to use in an MCache. func (c \*mcentral) cacheSpan() \*mspan { // 让当前G协助一部分的sweep工作 // Deduct credit for this span allocation and sweep if necessary. spanBytes := uintptr(class\_to\_allocnpages\[c.spanclass.sizeclass()\]) \* \_PageSize deductSweepCredit(spanBytes, 0) // 对mcentral上锁, 因为可能会有多个M(P)同时访问 lock(&amp;c.lock) traceDone := false if trace.enabled { traceGCSweepStart() } sg := mheap\_.sweepgen retry: // mcentral里面有两个span的链表 // - nonempty表示确定该span最少有一个未分配的元素 // - empty表示不确定该span最少有一个未分配的元素 // 这里优先查找nonempty的链表 // sweepgen每次GC都会增加2 // - sweepgen == 全局sweepgen, 表示span已经sweep过 // - sweepgen == 全局sweepgen-1, 表示span正在sweep // - sweepgen == 全局sweepgen-2, 表示span等待sweep var s \*mspan for s = c.nonempty.first; s != nil; s = s.next { // 如果span等待sweep, 尝试原子修改sweepgen为全局sweepgen-1 if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) { // 修改成功则把span移到empty链表, sweep它然后跳到havespan c.nonempty.remove(s) c.empty.insertBack(s) unlock(&amp;c.lock) s.sweep(true) goto havespan } // 如果这个span正在被其他线程sweep, 就跳过 if s.sweepgen == sg-1 { // the span is being swept by background sweeper, skip continue } // span已经sweep过 // 因为nonempty链表中的span确定最少有一个未分配的元素, 这里可以直接使用它 // we have a nonempty span that does not require sweeping, allocate from it c.nonempty.remove(s) c.empty.insertBack(s) unlock(&amp;c.lock) goto havespan } // 查找empty的链表 for s = c.empty.first; s != nil; s = s.next { // 如果span等待sweep, 尝试原子修改sweepgen为全局sweepgen-1 if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) { // 把span放到empty链表的最后 // we have an empty span that requires sweeping, // sweep it and see if we can free some space in it c.empty.remove(s) // swept spans are at the end of the list c.empty.insertBack(s) unlock(&amp;c.lock) // 尝试sweep s.sweep(true) // sweep以后还需要检测是否有未分配的对象, 如果有则可以使用它 freeIndex := s.nextFreeIndex() if freeIndex != s.nelems { s.freeindex = freeIndex goto havespan } lock(&amp;c.lock) // the span is still empty after sweep // it is already in the empty list, so just retry goto retry } // 如果这个span正在被其他线程sweep, 就跳过 if s.sweepgen == sg-1 { // the span is being swept by background sweeper, skip continue } // 找不到有未分配对象的span // already swept empty span, // all subsequent ones must also be either swept or in process of sweeping break } if trace.enabled { traceGCSweepDone() traceDone = true } unlock(&amp;c.lock) // 找不到有未分配对象的span, 需要从mheap分配 // 分配完成后加到empty链表中 // Replenish central list if empty. s = c.grow() if s == nil { return nil } lock(&amp;c.lock) c.empty.insertBack(s) unlock(&amp;c.lock) // At this point s is a non-empty span, queued at the end of the empty list, // c is unlocked. havespan: if trace.enabled &amp;&amp; !traceDone { traceGCSweepDone() } // 统计span中未分配的元素数量, 加到mcentral.nmalloc中 // 统计span中未分配的元素总大小, 加到memstats.heap\_live中 cap := int32((s.npages &lt;&lt; \_PageShift) / s.elemsize) n := cap - int32(s.allocCount) if n == 0 || s.freeindex == s.nelems || uintptr(s.allocCount) == s.nelems { throw(&quot;span has no free objects&quot;) } // Assume all objects from this span will be allocated in the // mcache. If it gets uncached, we&#39;ll adjust this. atomic.Xadd64(&amp;c.nmalloc, int64(n)) usedBytes := uintptr(s.allocCount) \* s.elemsize atomic.Xadd64(&amp;memstats.heap\_live, int64(spanBytes)-int64(usedBytes)) // 跟踪处理 if trace.enabled { // heap\_live changed. traceHeapAlloc() } // 如果当前在GC中, 因为heap\_live改变了, 重新调整G辅助标记工作的值 // 详细请参考下面对revise函数的解析 if gcBlackenEnabled != 0 { // heap\_live changed. gcController.revise() } // 设置span的incache属性, 表示span正在mcache中 s.incache = true // 根据freeindex更新allocCache freeByteBase := s.freeindex &amp;^ (64 - 1) whichByte := freeByteBase / 8 // Init alloc bits cache. s.refillAllocCache(whichByte) // Adjust the allocCache so that s.freeindex corresponds to the low bit in // s.allocCache. s.allocCache &gt;&gt;= s.freeindex % 64 return s }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>mcentral向mheap申请一个新的span会使用[grow](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L227" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L227</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // grow allocates a new empty span from the heap and initializes it for c&#39;s size class. func (c \*mcentral) grow() \*mspan { // 根据mcentral的类型计算需要申请的span的大小(除以8K = 有多少页)和可以保存多少个元素 npages := uintptr(class\_to\_allocnpages\[c.spanclass.sizeclass()\]) size := uintptr(class\_to\_size\[c.spanclass.sizeclass()\]) n := (npages &lt;&lt; \_PageShift) / size // 向mheap申请一个新的span, 以页(8K)为单位 s := mheap\_.alloc(npages, c.spanclass, false, true) if s == nil { return nil } p := s.base() s.limit = p + size\*n // 分配并初始化span的allocBits和gcmarkBits heapBitsForSpan(s.base()).initSpan(s) return s }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>mheap分配span的函数是[alloc](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L727" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L727</a>):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func (h \*mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) \*mspan { // 在g0的栈空间中调用alloc\_m函数 // 关于systemstack的说明请看前一篇文章 // Don&#39;t do any operations that lock the heap on the G stack. // It might trigger stack growth, and the stack growth code needs // to be able to allocate heap. var s \*mspan systemstack(func() { s = h.alloc\_m(npage, spanclass, large) }) if s != nil { if needzero &amp;&amp; s.needzero != 0 { memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;\_PageShift) } s.needzero = 0 } return s }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>alloc函数会在g0的栈空间中调用[alloc\_m](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L634" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L634</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Allocate a new span of npage pages from the heap for GC&#39;d memory // and record its size class in the HeapMap and HeapMapCache. func (h \*mheap) alloc\_m(npage uintptr, spanclass spanClass, large bool) \*mspan { \_g\_ := getg() if \_g\_ != \_g\_.m.g0 { throw(&quot;\_mheap\_alloc not on g0 stack&quot;) } // 对mheap上锁, 这里的锁是全局锁 lock(&amp;h.lock) // 为了防止heap增速太快, 在分配n页之前要先sweep和回收n页 // 会先枚举busy列表然后再枚举busyLarge列表进行sweep, 具体参考reclaim和reclaimList函数 // To prevent excessive heap growth, before allocating n pages // we need to sweep and reclaim at least n pages. if h.sweepdone == 0 { // TODO(austin): This tends to sweep a large number of // spans in order to find a few completely free spans // (for example, in the garbage benchmark, this sweeps // ~30x the number of pages its trying to allocate). // If GC kept a bit for whether there were any marks // in a span, we could release these free spans // at the end of GC and eliminate this entirely. if trace.enabled { traceGCSweepStart() } h.reclaim(npage) if trace.enabled { traceGCSweepDone() } } // 把mcache中的本地统计数据加到全局 // transfer stats from cache to global memstats.heap\_scan += uint64(\_g\_.m.mcache.local\_scan) \_g\_.m.mcache.local\_scan = 0 memstats.tinyallocs += uint64(\_g\_.m.mcache.local\_tinyallocs) \_g\_.m.mcache.local\_tinyallocs = 0 // 调用allocSpanLocked分配span, allocSpanLocked函数要求当前已经对mheap上锁 s := h.allocSpanLocked(npage, &amp;memstats.heap\_inuse) if s != nil { // Record span info, because gc needs to be // able to map interior pointer to containing span. // 设置span的sweepgen = 全局sweepgen atomic.Store(&amp;s.sweepgen, h.sweepgen) // 放到全局span列表中, 这里的sweepSpans的长度是2 // sweepSpans\[h.sweepgen/2%2\]保存当前正在使用的span列表 // sweepSpans\[1-h.sweepgen/2%2\]保存等待sweep的span列表 // 因为每次gcsweepgen都会加2, 每次gc这两个列表都会交换 h.sweepSpans\[h.sweepgen/2%2\].push(s) // Add to swept in-use list. // 初始化span成员 s.state = \_MSpanInUse s.allocCount = 0 s.spanclass = spanclass if sizeclass := spanclass.sizeclass(); sizeclass == 0 { s.elemsize = s.npages &lt;&lt; \_PageShift s.divShift = 0 s.divMul = 0 s.divShift2 = 0 s.baseMask = 0 } else { s.elemsize = uintptr(class\_to\_size\[sizeclass\]) m := &amp;class\_to\_divmagic\[sizeclass\] s.divShift = m.shift s.divMul = m.mul s.divShift2 = m.shift2 s.baseMask = m.baseMask } // update stats, sweep lists h.pagesInUse += uint64(npage) // 上面grow函数会传入true, 也就是通过grow调用到这里large会等于true // 添加已分配的span到busy列表, 如果页数超过\_MaxMHeapList(128页=8K\*128=1M)则放到busylarge列表 if large { memstats.heap\_objects++ mheap\_.largealloc += uint64(s.elemsize) mheap\_.nlargealloc++ atomic.Xadd64(&amp;memstats.heap\_live, int64(npage&lt;&lt;\_PageShift)) // Swept spans are at the end of lists. if s.npages &lt; uintptr(len(h.busy)) { h.busy\[s.npages\].insertBack(s) } else { h.busylarge.insertBack(s) } } } // 如果当前在GC中, 因为heap\_live改变了, 重新调整G辅助标记工作的值 // 详细请参考下面对revise函数的解析 // heap\_scan and heap\_live were updated. if gcBlackenEnabled != 0 { gcController.revise() } // 跟踪处理 if trace.enabled { traceHeapAlloc() } // h.spans is accessed concurrently without synchronization // from other threads. Hence, there must be a store/store // barrier here to ensure the writes to h.spans above happen // before the caller can publish a pointer p to an object // allocated from s. As soon as this happens, the garbage // collector running on another processor could read p and // look up s in h.spans. The unlock acts as the barrier to // order these writes. On the read side, the data dependency // between p and the index in h.spans orders the reads. unlock(&amp;h.lock) return s }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>继续查看[allocSpanLocked](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L784" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L784</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Allocates a span of the given size. h must be locked. // The returned span has been removed from the // free list, but its state is still MSpanFree. func (h \*mheap) allocSpanLocked(npage uintptr, stat \*uint64) \*mspan { var list \*mSpanList var s \*mspan // 尝试在mheap中的自由列表分配 // 页数小于\_MaxMHeapList(128页=1M)的自由span都会在free列表中 // 页数大于\_MaxMHeapList的自由span都会在freelarge列表中 // Try in fixed-size lists up to max. for i := int(npage); i &lt; len(h.free); i++ { list = &amp;h.free\[i\] if !list.isEmpty() { s = list.first list.remove(s) goto HaveSpan } } // free列表找不到则查找freelarge列表 // 查找不到就向arena区域申请一个新的span加到freelarge中, 然后再查找freelarge列表 // Best fit in list of large spans. s = h.allocLarge(npage) // allocLarge removed s from h.freelarge for us if s == nil { if !h.grow(npage) { return nil } s = h.allocLarge(npage) if s == nil { return nil } } HaveSpan: // Mark span in use. if s.state != \_MSpanFree { throw(&quot;MHeap\_AllocLocked - MSpan not free&quot;) } if s.npages &lt; npage { throw(&quot;MHeap\_AllocLocked - bad npages&quot;) } // 如果span有已释放(解除虚拟内存和物理内存关系)的页, 提醒这些页会被使用然后更新统计数据 if s.npreleased &gt; 0 { sysUsed(unsafe.Pointer(s.base()), s.npages&lt;&lt;\_PageShift) memstats.heap\_released -= uint64(s.npreleased &lt;&lt; \_PageShift) s.npreleased = 0 } // 如果获取到的span页数比要求的页数多 // 分割剩余的页数到另一个span并且放到自由列表中 if s.npages &gt; npage { // Trim extra and put it back in the heap. t := (\*mspan)(h.spanalloc.alloc()) t.init(s.base()+npage&lt;&lt;\_PageShift, s.npages-npage) s.npages = npage p := (t.base() - h.arena\_start) &gt;&gt; \_PageShift if p &gt; 0 { h.spans\[p-1\] = s } h.spans\[p\] = t h.spans\[p+t.npages-1\] = t t.needzero = s.needzero s.state = \_MSpanManual // prevent coalescing with s t.state = \_MSpanManual h.freeSpanLocked(t, false, false, s.unusedsince) s.state = \_MSpanFree } s.unusedsince = 0 // 设置spans区域, 哪些地址对应哪个mspan对象 p := (s.base() - h.arena\_start) &gt;&gt; \_PageShift for n := uintptr(0); n &lt; npage; n++ { h.spans\[p+n\] = s } // 更新统计数据 \*stat += uint64(npage &lt;&lt; \_PageShift) memstats.heap\_idle -= uint64(npage &lt;&lt; \_PageShift) //println(&quot;spanalloc&quot;, hex(s.start&lt;&lt;\_PageShift)) if s.inList() { throw(&quot;still in list&quot;) } return s }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>继续查看[allocLarge](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L867" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L867</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // allocLarge allocates a span of at least npage pages from the treap of large spans. // Returns nil if no such span currently exists. func (h \*mheap) allocLarge(npage uintptr) \*mspan { // Search treap for smallest span with &gt;= npage pages. return h.freelarge.remove(npage) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>freelarge的类型是mTreap, 调用[remove](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgclarge.go#L205" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgclarge.go#L205</a>)函数会在树里面搜索一个至少npage且在树中的最小的span返回:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // remove searches for, finds, removes from the treap, and returns the smallest // span that can hold npages. If no span has at least npages return nil. // This is slightly more complicated than a simple binary tree search // since if an exact match is not found the next larger node is // returned. // If the last node inspected &gt; npagesKey not holding // a left node (a smaller npages) is the &quot;best fit&quot; node. func (root \*mTreap) remove(npages uintptr) \*mspan { t := root.treap for t != nil { if t.spanKey == nil { throw(&quot;treap node with nil spanKey found&quot;) } if t.npagesKey &lt; npages { t = t.right } else if t.left != nil &amp;&amp; t.left.npagesKey &gt;= npages { t = t.left } else { result := t.spanKey root.removeNode(t) return result } } return nil }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>向arena区域申请新span的函数是mheap类的[grow](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L876" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L876</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Try to add at least npage pages of memory to the heap, // returning whether it worked. // // h must be locked. func (h \*mheap) grow(npage uintptr) bool { // Ask for a big chunk, to reduce the number of mappings // the operating system needs to track; also amortizes // the overhead of an operating system mapping. // Allocate a multiple of 64kB. npage = round(npage, (64&lt;&lt;10)/\_PageSize) ask := npage &lt;&lt; \_PageShift if ask &lt; \_HeapAllocChunk { ask = \_HeapAllocChunk } // 调用mheap.sysAlloc函数申请 v := h.sysAlloc(ask) if v == nil { if ask &gt; npage&lt;&lt;\_PageShift { ask = npage &lt;&lt; \_PageShift v = h.sysAlloc(ask) } if v == nil { print(&quot;runtime: out of memory: cannot allocate &quot;, ask, &quot;-byte block (&quot;, memstats.heap\_sys, &quot; in use)\\n&quot;) return false } } // 创建一个新的span并加到自由列表中 // Create a fake &quot;in use&quot; span and free it, so that the // right coalescing happens. s := (\*mspan)(h.spanalloc.alloc()) s.init(uintptr(v), ask&gt;&gt;\_PageShift) p := (s.base() - h.arena\_start) &gt;&gt; \_PageShift for i := p; i &lt; p+s.npages; i++ { h.spans\[i\] = s } atomic.Store(&amp;s.sweepgen, h.sweepgen) s.state = \_MSpanInUse h.pagesInUse += uint64(s.npages) h.freeSpanLocked(s, false, true, 0) return true }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>继续查看mheap的[sysAlloc](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L401" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L401</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // sysAlloc allocates the next n bytes from the heap arena. The // returned pointer is always \_PageSize aligned and between // h.arena\_start and h.arena\_end. sysAlloc returns nil on failure. // There is no corresponding free function. func (h \*mheap) sysAlloc(n uintptr) unsafe.Pointer { // strandLimit is the maximum number of bytes to strand from // the current arena block. If we would need to strand more // than this, we fall back to sysAlloc&#39;ing just enough for // this allocation. const strandLimit = 16 &lt;&lt; 20 // 如果arena区域当前已提交的区域不足, 则调用sysReserve预留更多的空间, 然后更新arena\_end // sysReserve在linux上调用的是mmap函数 // mmap(v, n, \_PROT\_NONE, \_MAP\_ANON|\_MAP\_PRIVATE, -1, 0) if n &gt; h.arena\_end-h.arena\_alloc { // If we haven&#39;t grown the arena to \_MaxMem yet, try // to reserve some more address space. p\_size := round(n+\_PageSize, 256&lt;&lt;20) new\_end := h.arena\_end + p\_size // Careful: can overflow if h.arena\_end &lt;= new\_end &amp;&amp; new\_end-h.arena\_start-1 &lt;= \_MaxMem { // TODO: It would be bad if part of the arena // is reserved and part is not. var reserved bool p := uintptr(sysReserve(unsafe.Pointer(h.arena\_end), p\_size, &amp;reserved)) if p == 0 { // TODO: Try smaller reservation // growths in case we&#39;re in a crowded // 32-bit address space. goto reservationFailed } // p can be just about anywhere in the address // space, including before arena\_end. if p == h.arena\_end { // The new block is contiguous with // the current block. Extend the // current arena block. h.arena\_end = new\_end h.arena\_reserved = reserved } else if h.arena\_start &lt;= p &amp;&amp; p+p\_size-h.arena\_start-1 &lt;= \_MaxMem &amp;&amp; h.arena\_end-h.arena\_alloc &lt; strandLimit { // We were able to reserve more memory // within the arena space, but it&#39;s // not contiguous with our previous // reservation. It could be before or // after our current arena\_used. // // Keep everything page-aligned. // Our pages are bigger than hardware pages. h.arena\_end = p + p\_size p = round(p, \_PageSize) h.arena\_alloc = p h.arena\_reserved = reserved } else { // We got a mapping, but either // // 1) It&#39;s not in the arena, so we // can&#39;t use it. (This should never // happen on 32-bit.) // // 2) We would need to discard too // much of our current arena block to // use it. // // We haven&#39;t added this allocation to // the stats, so subtract it from a // fake stat (but avoid underflow). // // We&#39;ll fall back to a small sysAlloc. stat := uint64(p\_size) sysFree(unsafe.Pointer(p), p\_size, &amp;stat) } } } // 预留的空间足够时只需要增加arena\_alloc if n &lt;= h.arena\_end-h.arena\_alloc { // Keep taking from our reservation. p := h.arena\_alloc sysMap(unsafe.Pointer(p), n, h.arena\_reserved, &amp;memstats.heap\_sys) h.arena\_alloc += n if h.arena\_alloc &gt; h.arena\_used { h.setArenaUsed(h.arena\_alloc, true) } if p&amp;(\_PageSize-1) != 0 { throw(&quot;misrounded allocation in MHeap\_SysAlloc&quot;) } return unsafe.Pointer(p) } // 预留空间失败后的处理 reservationFailed: // If using 64-bit, our reservation is all we have. if sys.PtrSize != 4 { return nil } // On 32-bit, once the reservation is gone we can // try to get memory at a location chosen by the OS. p\_size := round(n, \_PageSize) + \_PageSize p := uintptr(sysAlloc(p\_size, &amp;memstats.heap\_sys)) if p == 0 { return nil } if p &lt; h.arena\_start || p+p\_size-h.arena\_start &gt; \_MaxMem { // This shouldn&#39;t be possible because \_MaxMem is the // whole address space on 32-bit. top := uint64(h.arena\_start) + \_MaxMem print(&quot;runtime: memory allocated by OS (&quot;, hex(p), &quot;) not in usable range \[&quot;, hex(h.arena\_start), &quot;,&quot;, hex(top), &quot;)\\n&quot;) sysFree(unsafe.Pointer(p), p\_size, &amp;memstats.heap\_sys) return nil } p += -p &amp; (\_PageSize - 1) if p+n &gt; h.arena\_used { h.setArenaUsed(p+n, true) } if p&amp;(\_PageSize-1) != 0 { throw(&quot;misrounded allocation in MHeap\_SysAlloc&quot;) } return unsafe.Pointer(p) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以上就是分配对象的完整流程了, 接下来分析GC标记和回收对象的处理. # 回收对象的处理 ### 回收对象的流程 GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.\ 首先GC有四个阶段, 它们分别是: - Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC - Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收 - Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW) - Sweep: 按标记结果清扫span 下图是比较完整的GC流程, 并按颜色对这四个阶段进行了分类: ![](<a href="https://static.studygolang.com/190818/4a24ec45aa7864707e4e110536259c71.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190818/4a24ec45aa7864707e4e110536259c71.png</a>) 在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.\ 标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.\ 清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒. 目前整个GC流程会进行两次STW(Stop The World), 第一次是Mark阶段的开始, 第二次是Mark Termination阶段.\ 第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).\ 第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).\ 需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.\ 从go 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间. ### GC的触发条件 GC在满足一定条件后会被触发, 触发条件有以下几种: - gcTriggerAlways: 强制触发GC - gcTriggerHeap: 当前分配的内存达到一定值就触发GC - gcTriggerTime: 当一定时间没有执行过GC就触发GC - gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的`runtime.GC()`会使用这个条件 触发条件的判断在gctrigger的[test](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1154" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1154</a>)函数.\ 其中gcTriggerHeap和gcTriggerTime这两个条件是自然触发的, gcTriggerHeap的判断代码如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> return memstats.heap\_live &gt;= memstats.gc\_trigger</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>heap\_live的增加在上面对分配器的代码分析中可以看到, 当值达到gc\_trigger就会触发GC, 那么gc\_trigger是如何决定的?\ gc\_trigger的计算在[gcSetTriggerRatio](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759</a>)函数中, 公式是:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> trigger = uint64(float64(memstats.heap\_marked) \* (1 + triggerRatio))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当前标记存活的大小乘以1+系数triggerRatio, 就是下次出发GC需要的分配量.\ triggerRatio在每次GC后都会调整, 计算triggerRatio的函数是[encCycle](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L542" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L542</a>), 公式是:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> const triggerGain = 0.5 // 目标Heap增长率, 默认是1.0 goalGrowthRatio := float64(gcpercent) / 100 // 实际Heap增长率, 等于总大小/存活大小-1 actualGrowthRatio := float64(memstats.heap\_live)/float64(memstats.heap\_marked) - 1 // GC标记阶段的使用时间(因为endCycle是在Mark Termination阶段调用的) assistDuration := nanotime() - c.markStartTime // GC标记阶段的CPU占用率, 目标值是0.25 utilization := gcGoalUtilization if assistDuration &gt; 0 { // assistTime是G辅助GC标记对象所使用的时间合计 // (nanosecnds spent in mutator assists during this cycle) // 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 \* P的数量) utilization += float64(c.assistTime) / float64(assistDuration\*int64(gomaxprocs)) } // 触发系数偏移值 = 目标增长率 - 原触发系数 - CPU占用率 / 目标CPU占用率 \* (实际增长率 - 原触发系数) // 参数的分析: // 实际增长率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早 // CPU占用率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早 // 原触发系数越大, 触发系数偏移值越小, 小于0时下次触发GC会提早 triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization\*(actualGrowthRatio-memstats.triggerRatio) // 根据偏移值调整触发系数, 每次只调整偏移值的一半(渐进式调整) triggerRatio := memstats.triggerRatio + triggerGain\*triggerError</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>公式中的&quot;目标Heap增长率&quot;可以通过设置环境变量&quot;GOGC&quot;调整, 默认值是100, 增加它的值可以减少GC的触发.\ 设置&quot;GOGC=off&quot;可以彻底关掉GC. gcTriggerTime的判断代码如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> lastgc := int64(atomic.Load64(&amp;memstats.last\_gc\_nanotime)) return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>forcegcperiod的定义是2分钟, 也就是2分钟内没有执行过GC就会强制触发. ### 三色的定义(黑, 灰, 白) 我看过的对三色GC的&quot;三色&quot;这个概念解释的最好的文章就是[这一篇](<a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice" target="_blank" rel="noopener noreferrer">https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice</a>)了, 强烈建议先看这一篇中的讲解.\ &quot;三色&quot;的概念可以简单的理解为: - 黑色: 对象在这次GC中已标记, 且这个对象包含的子对象也已标记 - 灰色: 对象在这次GC中已标记, 但这个对象包含的子对象未标记 - 白色: 对象在这次GC中未标记 在go内部对象并没有保存颜色的属性, 三色只是对它们的状态的描述,\ 白色的对象在它所在的span的gcmarkBits中对应的bit为0,\ 灰色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象在标记队列中,\ 黑色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象已经从标记队列中取出并处理.\ gc完成后, gcmarkBits会移动到allocBits然后重新分配一个全部为0的bitmap, 这样黑色的对象就变为了白色. ### 写屏障(Write Barrier) 因为go支持并行GC, GC的扫描和go代码可以同时运行, 这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树,\ 例如开始扫描时发现根对象A和B, B拥有C的指针, GC先扫描A, 然后B把C的指针交给A, GC再扫描B, 这时C就不会被扫描到.\ 为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier). 启用了写屏障(Write Barrier)后, 当B把C的指针交给A时, GC会认为在这一轮的扫描中C的指针是存活的,\ 即使A可能会在稍后丢掉C, 那么C就在下一轮回收.\ 写屏障只针对指针启用, 而且只在GC的标记阶段启用, 平时会直接把值写入到目标地址. go在1.9开始启用了[混合写屏障(Hybrid Write Barrier)](<a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener noreferrer">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a>), 伪代码如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> writePointer(slot, ptr): shade(\*slot) if any stack is grey: shade(ptr) \*slot = ptr</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>混合写屏障会同时标记指针写入目标的&quot;原指针&quot;和“新指针&quot;. 标记原指针的原因是, 其他运行中的线程有可能会同时把这个指针的值复制到寄存器或者栈上的本地��量,\ 因为**复制指针到寄存器或者栈上的本地变量不会经过写屏障**, 所以有可能会导致指针不被标记, 试想下面的情况:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> \[go\] b = obj \[go\] oldx = nil \[gc\] scan oldx... \[go\] oldx = b.x // 复制b.x到本地变量, 不进过写屏障 \[go\] b.x = ptr // 写屏障应该标记b.x的原值 \[gc\] scan b... 如果写屏障不标记原值, 那么oldx就不会被扫描到.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>标记新指针的原因是, 其他运行中的线程有可能会转移指针的位置, 试想下面的情况:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> \[go\] a = ptr \[go\] b = obj \[gc\] scan b... \[go\] b.x = a // 写屏障应该标记b.x的新值 \[go\] a = nil \[gc\] scan a... 如果写屏障不标记新值, 那么ptr就不会被扫描到.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>混合写屏障可以让GC在并行标记结束后不需要重新扫描各个G的堆栈, 可以减少Mark Termination中的STW时间.\ 除了写屏障外, 在GC的过程中所有新分配的对象都会立刻变为黑色, 在上面的mallocgc函数中可以看到. ### 辅助GC(mutator assist) 为了防止heap增速太快, 在GC执行的过程中如果同时运行的G分配了内存, 那么这个G会被要求辅助GC做一部分的工作.\ 在GC的过程中同时运行的G称为&quot;mutator&quot;, &quot;mutator assist&quot;机制就是G辅助GC做一部分工作的机制. 辅助GC做的工作有两种类型, 一种是标记(Mark), 另一种是清扫(Sweep).\ 辅助标记的触发可以查看上面的mallocgc函数, 触发时G会帮助扫描&quot;工作量&quot;个对象, 工作量的计算公式是:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> debtBytes \* assistWorkPerByte</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>意思是分配的大小乘以系数assistWorkPerByte, assistWorkPerByte的计算在函数[revise](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L497" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L497</a>)中, 公式是:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // 等待扫描的对象数量 = 未扫描的对象数量 - 已扫描的对象数量 scanWorkExpected := int64(memstats.heap\_scan) - c.scanWork if scanWorkExpected &lt; 1000 { scanWorkExpected = 1000 } // 距离触发GC的Heap大小 = 期待触发GC的Heap大小 - 当前的Heap大小 // 注意next\_gc的计算跟gc\_trigger不一样, next\_gc等于heap\_marked \* (1 + gcpercent / 100) heapDistance := int64(memstats.next\_gc) - int64(atomic.Load64(&amp;memstats.heap\_live)) if heapDistance &lt;= 0 { heapDistance = 1 } // 每分配1 byte需要辅助扫描的对象数量 = 等待扫描的对象数量 / 距离触发GC的Heap大小 c.assistWorkPerByte = float64(scanWorkExpected) / float64(heapDistance) c.assistBytesPerWork = float64(heapDistance) / float64(scanWorkExpected)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>和辅助标记不一样的是, 辅助清扫申请新span时才会检查, 而辅助标记是每次分配对象时都会检查.\ 辅助清扫的触发可以看上面的cacheSpan函数, 触发时G会帮助回收&quot;工作量&quot;页的对象, 工作量的计算公式是:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> spanBytes \* sweepPagesPerByte // 不完全相同, 具体看deductSweepCredit函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>意思是分配的大小乘以系数sweepPagesPerByte, sweepPagesPerByte的计算在函数[gcSetTriggerRatio](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759</a>)中, 公式是:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // 当前的Heap大小 heapLiveBasis := atomic.Load64(&amp;memstats.heap\_live) // 距离触发GC的Heap大小 = 下次触发GC的Heap大小 - 当前的Heap大小 heapDistance := int64(trigger) - int64(heapLiveBasis) heapDistance -= 1024 \* 1024 if heapDistance &lt; \_PageSize { heapDistance = \_PageSize } // 已清扫的页数 pagesSwept := atomic.Load64(&amp;mheap\_.pagesSwept) // 未清扫的页数 = 使用中的页数 - 已清扫的页数 sweepDistancePages := int64(mheap\_.pagesInUse) - int64(pagesSwept) if sweepDistancePages &lt;= 0 { mheap\_.sweepPagesPerByte = 0 } else { // 每分配1 byte(的span)需要辅助清扫的页数 = 未清扫的页数 / 距离触发GC的Heap大小 mheap\_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="根对象-在gc的标记阶段首先需要标记的就是-根对象-从根对象开始可到达的所有对象都会被认为是存活的-根对象包含了全局变量-各个g的栈上的变量等-gc会先扫描根对象然后再扫描根对象可到达的所有对象-扫描根对象包含了一系列的工作-它们定义在-https-github-com-golang-go-blob-go1-9-2-src-runtime-mgcmark-go-l54-函数-fixed-roots-特殊的扫描工作-fixedrootfinalizers-扫描析构器队列-fixedrootfreegstacks-释放已中止的g的栈-flush-cache-roots-释放mcache中的所有span-要求stw-data-roots-扫描可读写的全局变量-bss-roots-扫描只读的全局变量-span-roots-扫描各个span中特殊对象-析构器列表-stack-roots-扫描各个g的栈-标记阶段-mark-会做其中的-fixed-roots-data-roots-bss-roots-span-roots-stack-roots-完成标记阶段-mark-termination-会做其中的-fixed-roots-flush-cache-roots-标记队列-gc的标记阶段会使用-标记队列-来确定所有可从根对象到达的对象都已标记-上面提到的-灰色-的对象就是在标记队列中的对象-举例来说-如果当前有-a-b-c-这三个根对象-那么扫描根对象时就会把它们放到标记队列" tabindex="-1"><a class="header-anchor" href="#根对象-在gc的标记阶段首先需要标记的就是-根对象-从根对象开始可到达的所有对象都会被认为是存活的-根对象包含了全局变量-各个g的栈上的变量等-gc会先扫描根对象然后再扫描根对象可到达的所有对象-扫描根对象包含了一系列的工作-它们定义在-https-github-com-golang-go-blob-go1-9-2-src-runtime-mgcmark-go-l54-函数-fixed-roots-特殊的扫描工作-fixedrootfinalizers-扫描析构器队列-fixedrootfreegstacks-释放已中止的g的栈-flush-cache-roots-释放mcache中的所有span-要求stw-data-roots-扫描可读写的全局变量-bss-roots-扫描只读的全局变量-span-roots-扫描各个span中特殊对象-析构器列表-stack-roots-扫描各个g的栈-标记阶段-mark-会做其中的-fixed-roots-data-roots-bss-roots-span-roots-stack-roots-完成标记阶段-mark-termination-会做其中的-fixed-roots-flush-cache-roots-标记队列-gc的标记阶段会使用-标记队列-来确定所有可从根对象到达的对象都已标记-上面提到的-灰色-的对象就是在标记队列中的对象-举例来说-如果当前有-a-b-c-这三个根对象-那么扫描根对象时就会把它们放到标记队列"><span>根对象 在GC的标记阶段首先需要标记的就是&quot;根对象&quot;, 从根对象开始可到达的所有对象都会被认为是存活的.\ 根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.\ 扫描根对象包含了一系列的工作, 它们定义在\[<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54%5C" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54\</a>]函数: - Fixed Roots: 特殊的扫描工作 - fixedRootFinalizers: 扫描析构器队列 - fixedRootFreeGStacks: 释放已中止的G的栈 - Flush Cache Roots: 释放mcache中的所有span, 要求STW - Data Roots: 扫描可读写的全局变量 - BSS Roots: 扫描只读的全局变量 - Span Roots: 扫描各个span中特殊对象(析构器列表) - Stack Roots: 扫描各个G的栈 标记阶段(Mark)会做其中的&quot;Fixed Roots&quot;, &quot;Data Roots&quot;, &quot;BSS Roots&quot;, &quot;Span Roots&quot;, &quot;Stack Roots&quot;.\ 完成标记阶段(Mark Termination)会做其中的&quot;Fixed Roots&quot;, &quot;Flush Cache Roots&quot;. ### 标记队列 GC的标记阶段会使用&quot;标记队列&quot;来确定所有可从根对象到达的对象都已标记, 上面提到的&quot;灰色&quot;的对象就是在标记队列中的对象.\ 举例来说, 如果当前有\[A, B, C]这三个根对象, 那么扫描根对象时就会把它们放到标记队列:</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> work queue: \[A, B, C\]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后台标记任务从标记队列中取出A, 如果A引用了D, 则把D放入标记队列:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> work queue: \[B, C, D\]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后台标记任务从标记队列取出B, 如果B也引用了D, 这时因为D在gcmarkBits中对应的bit已经是1所以会跳过:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> work queue: \[C, D\]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果并行运行的go代码分配了一个对象E, 对象E会被立刻标记, 但不会进入标记队列(因为确定E没有引用其他对象).\ 然后并行运行的go代码把对象F设置给对象E的成员, 写屏障会标记对象F然后把对象F加到运行队列:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> work queue: \[C, D, F\]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后台标记任务从标记队列取出C, 如果C没有引用其他对象, 则不需要处理:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> work queue: \[D, F\]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后台标记任务从标记队列取出D, 如果D引用了X, 则把X放入标记队列:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> work queue: \[F, X\]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后台标记任务从标记队列取出F, 如果F没有引用其他对象, 则不需要处理.\ 后台标记任务从标记队列取出X, 如果X没有引用其他对象, 则不需要处理.\ 最后标记队列为空, 标记完成, 存活的对象有\[A, B, C, D, E, F, X]. 实际的状况会比上面介绍的状况稍微复杂一点.\ 标记队列会分为全局标记队列和各个P的本地标记队列, 这点和协程中的运行队列相似.\ 并且标记队列为空以后, 还需要停止整个世界并禁止写屏障, 然后再次检查是否为空. ### 源代码分析 go触发gc会从[gcStart](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1190" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1190</a>)函数开始:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcStart transitions the GC from \_GCoff to \_GCmark (if // !mode.stwMark) or \_GCmarktermination (if mode.stwMark) by // performing sweep termination and GC initialization. // // This may return without performing this transition in some cases, // such as when called on a system stack or with locks held. func gcStart(mode gcMode, trigger gcTrigger) { // 判断当前G是否可抢占, 不可抢占时不触发GC // Since this is called from malloc and malloc is called in // the guts of a number of libraries that might be holding // locks, don&#39;t attempt to start GC in non-preemptible or // potentially unstable situations. mp := acquirem() if gp := getg(); gp == mp.g0 || mp.locks &gt; 1 || mp.preemptoff != &quot;&quot; { releasem(mp) return } releasem(mp) mp = nil // 并行清扫上一轮GC未清扫的span // Pick up the remaining unswept/not being swept spans concurrently // // This shouldn&#39;t happen if we&#39;re being invoked in background // mode since proportional sweep should have just finished // sweeping everything, but rounding errors, etc, may leave a // few spans unswept. In forced mode, this is necessary since // GC can be forced at any point in the sweeping cycle. // // We check the transition condition continuously here in case // this G gets delayed in to the next GC cycle. for trigger.test() &amp;&amp; gosweepone() != ^uintptr(0) { sweep.nbgsweep++ } // 上锁, 然后重新检查gcTrigger的条件是否成立, 不成立时不触发GC // Perform GC initialization and the sweep termination // transition. semacquire(&amp;work.startSema) // Re-check transition condition under transition lock. if !trigger.test() { semrelease(&amp;work.startSema) return } // 记录是否强制触发, gcTriggerCycle是runtime.GC用的 // For stats, check if this GC was forced by the user. work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle // 判断是否指定了禁止并行GC的参数 // In gcstoptheworld debug mode, upgrade the mode accordingly. // We do this after re-checking the transition condition so // that multiple goroutines that detect the heap trigger don&#39;t // start multiple STW GCs. if mode == gcBackgroundMode { if debug.gcstoptheworld == 1 { mode = gcForceMode } else if debug.gcstoptheworld == 2 { mode = gcForceBlockMode } } // Ok, we&#39;re doing it! Stop everybody else semacquire(&amp;worldsema) // 跟踪处理 if trace.enabled { traceGCStart() } // 启动后台扫描任务(G) if mode == gcBackgroundMode { gcBgMarkStartWorkers() } // 重置标记相关的状态 gcResetMarkState() // 重置参数 work.stwprocs, work.maxprocs = gcprocs(), gomaxprocs work.heap0 = atomic.Load64(&amp;memstats.heap\_live) work.pauseNS = 0 work.mode = mode // 记录开始时间 now := nanotime() work.tSweepTerm = now work.pauseStart = now // 停止所有运行中的G, 并禁止它们运行 systemstack(stopTheWorldWithSema) // !!!!!!!!!!!!!!!! // 世界已停止(STW)... // !!!!!!!!!!!!!!!! // 清扫上一轮GC未清扫的span, 确保上一轮GC已完成 // Finish sweep before we start concurrent scan. systemstack(func() { finishsweep\_m() }) // 清扫sched.sudogcache和sched.deferpool // clearpools before we start the GC. If we wait they memory will not be // reclaimed until the next GC cycle. clearpools() // 增加GC计数 work.cycles++ // 判断是否并行GC模式 if mode == gcBackgroundMode { // Do as much work concurrently as possible // 标记新一轮GC已开始 gcController.startCycle() work.heapGoal = memstats.next\_gc // 设置全局变量中的GC状态为\_GCmark // 然后启用写屏障 // Enter concurrent mark phase and enable // write barriers. // // Because the world is stopped, all Ps will // observe that write barriers are enabled by // the time we start the world and begin // scanning. // // Write barriers must be enabled before assists are // enabled because they must be enabled before // any non-leaf heap objects are marked. Since // allocations are blocked until assists can // happen, we want enable assists as early as // possible. setGCPhase(\_GCmark) // 重置后台标记任务的计数 gcBgMarkPrepare() // Must happen before assist enable. // 计算扫描根对象的任务数量 gcMarkRootPrepare() // 标记所有tiny alloc等待合并的对象 // Mark all active tinyalloc blocks. Since we&#39;re // allocating from these, they need to be black like // other allocations. The alternative is to blacken // the tiny block on every allocation from it, which // would slow down the tiny allocator. gcMarkTinyAllocs() // 启用辅助GC // At this point all Ps have enabled the write // barrier, thus maintaining the no white to // black invariant. Enable mutator assists to // put back-pressure on fast allocating // mutators. atomic.Store(&amp;gcBlackenEnabled, 1) // 记录标记开始的时间 // Assists and workers can start the moment we start // the world. gcController.markStartTime = now // 重新启动世界 // 前面创建的后台标记任务会开始工作, 所有后台标记任务都完成工作后, 进入完成标记阶段 // Concurrent mark. systemstack(startTheWorldWithSema) // !!!!!!!!!!!!!!! // 世界已重新启动... // !!!!!!!!!!!!!!! // 记录停止了多久, 和标记阶段开始的时间 now = nanotime() work.pauseNS += now - work.pauseStart work.tMark = now } else { // 不是并行GC模式 // 记录完成标记阶段开始的时间 t := nanotime() work.tMark, work.tMarkTerm = t, t work.heapGoal = work.heap0 // 跳过标记阶段, 执行完成标记阶段 // 所有标记工作都会在世界已停止的状态执行 // (标记阶段会设置work.markrootDone=true, 如果跳过则它的值是false, 完成标记阶段会执行所有工作) // 完成标记阶段会重新启动世界 // Perform mark termination. This will restart the world. gcMarkTermination(memstats.triggerRatio) } semrelease(&amp;work.startSema) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来一个个分析gcStart调用的函数, 建议配合上面的&quot;回收对象的流程&quot;中的图理解. 函数[gcBgMarkStartWorkers](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1650" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1650</a>)用于启动后台标记任务, 先分别对每个P启动一个:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcBgMarkStartWorkers prepares background mark worker goroutines. // These goroutines will not run until the mark phase, but they must // be started while the work is not stopped and from a regular G // stack. The caller must hold worldsema. func gcBgMarkStartWorkers() { // Background marking is performed by per-P G&#39;s. Ensure that // each P has a background GC G. for \_, p := range &amp;allp { if p == nil || p.status == \_Pdead { break } // 如果已启动则不重复启动 if p.gcBgMarkWorker == 0 { go gcBgMarkWorker(p) // 启动后等待该任务通知信号量bgMarkReady再继续 notetsleepg(&amp;work.bgMarkReady, -1) noteclear(&amp;work.bgMarkReady) } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里虽然为每个P启动了一个后台标记任务, 但是可以同时工作的只有25%, 这个逻辑在协程M获取G时调用的[findRunnableGCWorker](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L657" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L657</a>)中:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // findRunnableGCWorker returns the background mark worker for \_p\_ if it // should be run. This must only be called when gcBlackenEnabled != 0. func (c \*gcControllerState) findRunnableGCWorker(\_p\_ \*p) \*g { if gcBlackenEnabled == 0 { throw(&quot;gcControllerState.findRunnable: blackening not enabled&quot;) } if \_p\_.gcBgMarkWorker == 0 { // The mark worker associated with this P is blocked // performing a mark transition. We can&#39;t run it // because it may be on some other run or wait queue. return nil } if !gcMarkWorkAvailable(\_p\_) { // No work to be done right now. This can happen at // the end of the mark phase when there are still // assists tapering off. Don&#39;t bother running a worker // now because it&#39;ll just return immediately. return nil } // 原子减少对应的值, 如果减少后大于等于0则返回true, 否则返回false decIfPositive := func(ptr \*int64) bool { if \*ptr &gt; 0 { if atomic.Xaddint64(ptr, -1) &gt;= 0 { return true } // We lost a race atomic.Xaddint64(ptr, +1) } return false } // 减少dedicatedMarkWorkersNeeded, 成功时后台标记任务的模式是Dedicated // dedicatedMarkWorkersNeeded是当前P的数量的25%去除小数点 // 详见startCycle函数 if decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) { // This P is now dedicated to marking until the end of // the concurrent mark phase. \_p\_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode } else { // 减少fractionalMarkWorkersNeeded, 成功是后台标记任务的模式是Fractional // 上面的计算如果小数点后有数值(不能够整除)则fractionalMarkWorkersNeeded为1, 否则为0 // 详见startCycle函数 // 举例来说, 4个P时会执行1个Dedicated模式的任务, 5个P时会执行1个Dedicated模式和1个Fractional模式的任务 if !decIfPositive(&amp;c.fractionalMarkWorkersNeeded) { // No more workers are need right now. return nil } // 按Dedicated模式的任务的执行时间判断cpu占用率是否超过预算值, 超过时不启动 // This P has picked the token for the fractional worker. // Is the GC currently under or at the utilization goal? // If so, do more work. // // We used to check whether doing one time slice of work // would remain under the utilization goal, but that has the // effect of delaying work until the mutator has run for // enough time slices to pay for the work. During those time // slices, write barriers are enabled, so the mutator is running slower. // Now instead we do the work whenever we&#39;re under or at the // utilization work and pay for it by letting the mutator run later. // This doesn&#39;t change the overall utilization averages, but it // front loads the GC work so that the GC finishes earlier and // write barriers can be turned off sooner, effectively giving // the mutator a faster machine. // // The old, slower behavior can be restored by setting // gcForcePreemptNS = forcePreemptNS. const gcForcePreemptNS = 0 // TODO(austin): We could fast path this and basically // eliminate contention on c.fractionalMarkWorkersNeeded by // precomputing the minimum time at which it&#39;s worth // next scheduling the fractional worker. Then Ps // don&#39;t have to fight in the window where we&#39;ve // passed that deadline and no one has started the // worker yet. // // TODO(austin): Shorter preemption interval for mark // worker to improve fairness and give this // finer-grained control over schedule? now := nanotime() - gcController.markStartTime then := now + gcForcePreemptNS timeUsed := c.fractionalMarkTime + gcForcePreemptNS if then &gt; 0 &amp;&amp; float64(timeUsed)/float64(then) &gt; c.fractionalUtilizationGoal { // Nope, we&#39;d overshoot the utilization goal atomic.Xaddint64(&amp;c.fractionalMarkWorkersNeeded, +1) return nil } \_p\_.gcMarkWorkerMode = gcMarkWorkerFractionalMode } // 安排后台标记任务执行 // Run the background mark worker gp := \_p\_.gcBgMarkWorker.ptr() casgstatus(gp, \_Gwaiting, \_Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcResetMarkState](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2040" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2040</a>)函数会重置标记相关的状态:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcResetMarkState resets global state prior to marking (concurrent // or STW) and resets the stack scan state of all Gs. // // This is safe to do without the world stopped because any Gs created // during or after this will start out in the reset state. func gcResetMarkState() { // This may be called during a concurrent phase, so make sure // allgs doesn&#39;t change. lock(&amp;allglock) for \_, gp := range allgs { gp.gcscandone = false // set to true in gcphasework gp.gcscanvalid = false // stack has not been scanned gp.gcAssistBytes = 0 } unlock(&amp;allglock) work.bytesMarked = 0 work.initialHeapLive = atomic.Load64(&amp;memstats.heap\_live) work.markrootDone = false }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[stopTheWorldWithSema](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L987" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L987</a>)函数会停止整个世界, 这个函数必须在g0中运行:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // stopTheWorldWithSema is the core implementation of stopTheWorld. // The caller is responsible for acquiring worldsema and disabling // preemption first and then should stopTheWorldWithSema on the system // stack: // // semacquire(&amp;worldsema, 0) // m.preemptoff = &quot;reason&quot; // systemstack(stopTheWorldWithSema) // // When finished, the caller must either call startTheWorld or undo // these three operations separately: // // m.preemptoff = &quot;&quot; // systemstack(startTheWorldWithSema) // semrelease(&amp;worldsema) // // It is allowed to acquire worldsema once and then execute multiple // startTheWorldWithSema/stopTheWorldWithSema pairs. // Other P&#39;s are able to execute between successive calls to // startTheWorldWithSema and stopTheWorldWithSema. // Holding worldsema causes any other goroutines invoking // stopTheWorld to block. func stopTheWorldWithSema() { \_g\_ := getg() // If we hold a lock, then we won&#39;t be able to stop another M // that is blocked trying to acquire the lock. if \_g\_.m.locks &gt; 0 { throw(&quot;stopTheWorld: holding locks&quot;) } lock(&amp;sched.lock) // 需要停止的P数量 sched.stopwait = gomaxprocs // 设置gc等待标记, 调度时看见此标记会进入等待 atomic.Store(&amp;sched.gcwaiting, 1) // 抢占所有运行中的G preemptall() // 停止当前的P // stop current P \_g\_.m.p.ptr().status = \_Pgcstop // Pgcstop is only diagnostic. // 减少需要停止的P数量(当前的P算一个) sched.stopwait-- // 抢占所有在Psyscall状态的P, 防止它们重新参与调度 // try to retake all P&#39;s in Psyscall status for i := 0; i &lt; int(gomaxprocs); i++ { p := allp\[i\] s := p.status if s == \_Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, \_Pgcstop) { if trace.enabled { traceGoSysBlock(p) traceProcStop(p) } p.syscalltick++ sched.stopwait-- } } // 防止所有空闲的P重新参与调度 // stop idle P&#39;s for { p := pidleget() if p == nil { break } p.status = \_Pgcstop sched.stopwait-- } wait := sched.stopwait &gt; 0 unlock(&amp;sched.lock) // 如果仍有需要停止的P, 则等待它们停止 // wait for remaining P&#39;s to stop voluntarily if wait { for { // 循环等待 + 抢占所有运行中的G // wait for 100us, then try to re-preempt in case of any races if notetsleep(&amp;sched.stopnote, 100\*1000) { noteclear(&amp;sched.stopnote) break } preemptall() } } // 逻辑正确性检查 // sanity checks bad := &quot;&quot; if sched.stopwait != 0 { bad = &quot;stopTheWorld: not stopped (stopwait != 0)&quot; } else { for i := 0; i &lt; int(gomaxprocs); i++ { p := allp\[i\] if p.status != \_Pgcstop { bad = &quot;stopTheWorld: not stopped (status != \_Pgcstop)&quot; } } } if atomic.Load(&amp;freezing) != 0 { // Some other thread is panicking. This can cause the // sanity checks above to fail if the panic happens in // the signal handler on a stopped thread. Either way, // we should halt this thread. lock(&amp;deadlock) lock(&amp;deadlock) } if bad != &quot;&quot; { throw(bad) } // 到这里所有运行中的G都会变为待运行, 并且所有的P都不能被M获取 // 也就是说所有的go代码(除了当前的)都会停止运行, 并且不能运行新的go代码 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[finishsweep\_m](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L33" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L33</a>)函数会清扫上一轮GC未清扫的span, 确保上一轮GC已完成:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // finishsweep\_m ensures that all spans are swept. // // The world must be stopped. This ensures there are no sweeps in // progress. // //go:nowritebarrier func finishsweep\_m() { // sweepone会取出一个未sweep的span然后执行sweep // 详细将在下面sweep阶段时分析 // Sweeping must be complete before marking commences, so // sweep any unswept spans. If this is a concurrent GC, there // shouldn&#39;t be any spans left to sweep, so this should finish // instantly. If GC was forced before the concurrent sweep // finished, there may be spans to sweep. for sweepone() != ^uintptr(0) { sweep.npausesweep++ } // 所有span都sweep完成后, 启动一个新的markbit时代 // 这个函数是实现span的gcmarkBits和allocBits的分配和复用的关键, 流程如下 // - span分配gcmarkBits和allocBits // - span完成sweep // - 原allocBits不再被使用 // - gcmarkBits变为allocBits // - 分配新的gcmarkBits // - 开启新的markbit时代 // - span完成sweep, 同上 // - 开启新的markbit时代 // - 2个时代之前的bitmap将不再被使用, 可以复用这些bitmap nextMarkBitArenaEpoch() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[clearpools](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2065" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2065</a>)函数会清理sched.sudogcache和sched.deferpool, 让它们的内存可以被回收:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func clearpools() { // clear sync.Pools if poolcleanup != nil { poolcleanup() } // Clear central sudog cache. // Leave per-P caches alone, they have strictly bounded size. // Disconnect cached list before dropping it on the floor, // so that a dangling ref to one entry does not pin all of them. lock(&amp;sched.sudoglock) var sg, sgnext \*sudog for sg = sched.sudogcache; sg != nil; sg = sgnext { sgnext = sg.next sg.next = nil } sched.sudogcache = nil unlock(&amp;sched.sudoglock) // Clear central defer pools. // Leave per-P pools alone, they have strictly bounded size. lock(&amp;sched.deferlock) for i := range sched.deferpool { // disconnect cached list before dropping it on the floor, // so that a dangling ref to one entry does not pin all of them. var d, dlink \*\_defer for d = sched.deferpool\[i\]; d != nil; d = dlink { dlink = d.link d.link = nil } sched.deferpool\[i\] = nil } unlock(&amp;sched.deferlock) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[startCycle](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L420" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L420</a>)标记开始了新一轮的GC:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // startCycle resets the GC controller&#39;s state and computes estimates // for a new GC cycle. The caller must hold worldsema. func (c \*gcControllerState) startCycle() { c.scanWork = 0 c.bgScanCredit = 0 c.assistTime = 0 c.dedicatedMarkTime = 0 c.fractionalMarkTime = 0 c.idleMarkTime = 0 // 伪装heap\_marked的值如果gc\_trigger的值很小, 防止后面对triggerRatio做出错误的调整 // If this is the first GC cycle or we&#39;re operating on a very // small heap, fake heap\_marked so it looks like gc\_trigger is // the appropriate growth from heap\_marked, even though the // real heap\_marked may not have a meaningful value (on the // first cycle) or may be much smaller (resulting in a large // error response). if memstats.gc\_trigger &lt;= heapminimum { memstats.heap\_marked = uint64(float64(memstats.gc\_trigger) / (1 + memstats.triggerRatio)) } // 重新计算next\_gc, 注意next\_gc的计算跟gc\_trigger不一样 // Re-compute the heap goal for this cycle in case something // changed. This is the same calculation we use elsewhere. memstats.next\_gc = memstats.heap\_marked + memstats.heap\_marked\*uint64(gcpercent)/100 if gcpercent &lt; 0 { memstats.next\_gc = ^uint64(0) } // 确保next\_gc和heap\_live之间最少有1MB // Ensure that the heap goal is at least a little larger than // the current live heap size. This may not be the case if GC // start is delayed or if the allocation that pushed heap\_live // over gc\_trigger is large or if the trigger is really close to // GOGC. Assist is proportional to this distance, so enforce a // minimum distance, even if it means going over the GOGC goal // by a tiny bit. if memstats.next\_gc &lt; memstats.heap\_live+1024\*1024 { memstats.next\_gc = memstats.heap\_live + 1024\*1024 } // 计算可以同时执行的后台标记任务的数量 // dedicatedMarkWorkersNeeded等于P的数量的25%去除小数点 // 如果可以整除则fractionalMarkWorkersNeeded等于0否则等于1 // totalUtilizationGoal是GC所占的P的目标值(例如P一共有5个时目标是1.25个P) // fractionalUtilizationGoal是Fractiona模式的任务所占的P的目标值(例如P一共有5个时目标是0.25个P) // Compute the total mark utilization goal and divide it among // dedicated and fractional workers. totalUtilizationGoal := float64(gomaxprocs) \* gcGoalUtilization c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal) c.fractionalUtilizationGoal = totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded) if c.fractionalUtilizationGoal &gt; 0 { c.fractionalMarkWorkersNeeded = 1 } else { c.fractionalMarkWorkersNeeded = 0 } // 重置P中的辅助GC所用的时间统计 // Clear per-P state for \_, p := range &amp;allp { if p == nil { break } p.gcAssistTime = 0 } // 计算辅助GC的参数 // 参考上面对计算assistWorkPerByte的公式的分析 // Compute initial values for controls that are updated // throughout the cycle. c.revise() if debug.gcpacertrace &gt; 0 { print(&quot;pacer: assist ratio=&quot;, c.assistWorkPerByte, &quot; (scan &quot;, memstats.heap\_scan&gt;&gt;20, &quot; MB in &quot;, work.initialHeapLive&gt;&gt;20, &quot;-&gt;&quot;, memstats.next\_gc&gt;&gt;20, &quot; MB)&quot;, &quot; workers=&quot;, c.dedicatedMarkWorkersNeeded, &quot;+&quot;, c.fractionalMarkWorkersNeeded, &quot;\\n&quot;) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[setGCPhase](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L279" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L279</a>)函数会修改表示当前GC阶段的全局变量和**是否开启写屏障**的全局变量:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> //go:nosplit func setGCPhase(x uint32) { atomic.Store(&amp;gcphase, x) writeBarrier.needed = gcphase == \_GCmark || gcphase == \_GCmarktermination writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcBgMarkPrepare](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1667" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1667</a>)函数会重置后台标记任务的计数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcBgMarkPrepare sets up state for background marking. // Mutator assists must not yet be enabled. func gcBgMarkPrepare() { // Background marking will stop when the work queues are empty // and there are no more workers (note that, since this is // concurrent, this may be a transient state, but mark // termination will clean it up). Between background workers // and assists, we don&#39;t really know how many workers there // will be, so we pretend to have an arbitrarily large number // of workers, almost all of which are &quot;waiting&quot;. While a // worker is working it decrements nwait. If nproc == nwait, // there are no workers. work.nproc = ^uint32(0) work.nwait = ^uint32(0) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcMarkRootPrepare](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54</a>)函数会计算扫描根对象的任务数量:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcMarkRootPrepare queues root scanning jobs (stacks, globals, and // some miscellany) and initializes scanning-related state. // // The caller must have call gcCopySpans(). // // The world must be stopped. // //go:nowritebarrier func gcMarkRootPrepare() { // 释放mcache中的所有span的任务, 只在完成标记阶段(mark termination)中执行 if gcphase == \_GCmarktermination { work.nFlushCacheRoots = int(gomaxprocs) } else { work.nFlushCacheRoots = 0 } // 计算block数量的函数, rootBlockBytes是256KB // Compute how many data and BSS root blocks there are. nBlocks := func(bytes uintptr) int { return int((bytes + rootBlockBytes - 1) / rootBlockBytes) } work.nDataRoots = 0 work.nBSSRoots = 0 // data和bss每一轮GC只扫描一次 // 并行GC中会在后台标记任务中扫描, 完成标记阶段(mark termination)中不扫描 // 非并行GC会在完成标记阶段(mark termination)中扫描 // Only scan globals once per cycle; preferably concurrently. if !work.markrootDone { // 计算扫描可读写的全局变量的任务数量 for \_, datap := range activeModules() { nDataRoots := nBlocks(datap.edata - datap.data) if nDataRoots &gt; work.nDataRoots { work.nDataRoots = nDataRoots } } // 计算扫描只读的全局变量的任务数量 for \_, datap := range activeModules() { nBSSRoots := nBlocks(datap.ebss - datap.bss) if nBSSRoots &gt; work.nBSSRoots { work.nBSSRoots = nBSSRoots } } } // span中的finalizer和各个G的栈每一轮GC只扫描一次 // 同上 if !work.markrootDone { // 计算扫描span中的finalizer的任务数量 // On the first markroot, we need to scan span roots. // In concurrent GC, this happens during concurrent // mark and we depend on addfinalizer to ensure the // above invariants for objects that get finalizers // after concurrent mark. In STW GC, this will happen // during mark termination. // // We&#39;re only interested in scanning the in-use spans, // which will all be swept at this point. More spans // may be added to this list during concurrent GC, but // we only care about spans that were allocated before // this mark phase. work.nSpanRoots = mheap\_.sweepSpans\[mheap\_.sweepgen/2%2\].numBlocks() // 计算扫描各个G的栈的任务数量 // On the first markroot, we need to scan all Gs. Gs // may be created after this point, but it&#39;s okay that // we ignore them because they begin life without any // roots, so there&#39;s nothing to scan, and any roots // they create during the concurrent phase will be // scanned during mark termination. During mark // termination, allglen isn&#39;t changing, so we&#39;ll scan // all Gs. work.nStackRoots = int(atomic.Loaduintptr(&amp;allglen)) } else { // We&#39;ve already scanned span roots and kept the scan // up-to-date during concurrent mark. work.nSpanRoots = 0 // The hybrid barrier ensures that stacks can&#39;t // contain pointers to unmarked objects, so on the // second markroot, there&#39;s no need to scan stacks. work.nStackRoots = 0 if debug.gcrescanstacks &gt; 0 { // Scan stacks anyway for debugging. work.nStackRoots = int(atomic.Loaduintptr(&amp;allglen)) } } // 计算总任务数量 // 后台标记任务会对markrootNext进行原子递增, 来决定做哪个任务 // 这种用数值来实现锁自由队列的办法挺聪明的, 尽管google工程师觉得不好(看后面markroot函数的分析) work.markrootNext = 0 work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcMarkTinyAllocs](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1358" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1358</a>)函数会标记所有tiny alloc等待合并的对象:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcMarkTinyAllocs greys all active tiny alloc blocks. // // The world must be stopped. func gcMarkTinyAllocs() { for \_, p := range &amp;allp { if p == nil || p.status == \_Pdead { break } c := p.mcache if c == nil || c.tiny == 0 { continue } // 标记各个P中的mcache中的tiny // 在上面的mallocgc函数中可以看到tiny是当前等待合并的对象 \_, hbits, span, objIndex := heapBitsForObject(c.tiny, 0, 0) gcw := &amp;p.gcw // 标记一个对象存活, 并把它加到标记队列(该对象变为灰色) greyobject(c.tiny, 0, 0, hbits, span, gcw, objIndex) // gcBlackenPromptly变量表示当前是否禁止本地队列, 如果已禁止则把标记任务flush到全局队列 if gcBlackenPromptly { gcw.dispose() } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[startTheWorldWithSema](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1070" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1070</a>)函数会重新启动世界:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func startTheWorldWithSema() { \_g\_ := getg() // 禁止G被抢占 \_g\_.m.locks++ // disable preemption because it can be holding p in a local var // 判断收到的网络事件(fd可读可写或错误)并添加对应的G到待运行队列 gp := netpoll(false) // non-blocking injectglist(gp) // 判断是否要启动gc helper add := needaddgcproc() lock(&amp;sched.lock) // 如果要求改变gomaxprocs则调整P的数量 // procresize会返回有可运行任务的P的链表 procs := gomaxprocs if newprocs != 0 { procs = newprocs newprocs = 0 } p1 := procresize(procs) // 取消GC等待标记 sched.gcwaiting = 0 // 如果sysmon在等待则唤醒它 if sched.sysmonwait != 0 { sched.sysmonwait = 0 notewakeup(&amp;sched.sysmonnote) } unlock(&amp;sched.lock) // 唤醒有可运行任务的P for p1 != nil { p := p1 p1 = p1.link.ptr() if p.m != 0 { mp := p.m.ptr() p.m = 0 if mp.nextp != 0 { throw(&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;) } mp.nextp.set(p) notewakeup(&amp;mp.park) } else { // Start M to run P. Do not start another M below. newm(nil, p) add = false } } // 如果有空闲的P，并且没有自旋中的M则唤醒或者创建一个M // Wakeup an additional proc in case we have excessive runnable goroutines // in local queues or in the global queue. If we don&#39;t, the proc will park itself. // If we have lots of excessive work, resetspinning will unpark additional procs as necessary. if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 { wakep() } // 启动gc helper if add { // If GC could have used another helper proc, start one now, // in the hope that it will be available next time. // It would have been even better to start it before the collection, // but doing so requires allocating memory, so it&#39;s tricky to // coordinate. This lazy approach works out in practice: // we don&#39;t mind if the first couple gc rounds don&#39;t have quite // the maximum number of procs. newm(mhelpgc, nil) } // 允许G被抢占 \_g\_.m.locks-- // 如果当前G要求被抢占则重新尝试 if \_g\_.m.locks == 0 &amp;&amp; \_g\_.preempt { // restore the preemption request in case we&#39;ve cleared it in newstack \_g\_.stackguard0 = stackPreempt } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>重启世界后各个M会重新开始调度, 调度时会优先使用上面提到的findRunnableGCWorker函数查找任务, 之后就有大约25%的P运行后台标记任务.\ 后台标记任务的函数是[gcBgMarkWorker](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1681" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1681</a>):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func gcBgMarkWorker(\_p\_ \*p) { gp := getg() // 用于休眠后重新获取P的构造体 type parkInfo struct { m muintptr // Release this m on park. attach puintptr // If non-nil, attach to this p on park. } // We pass park to a gopark unlock function, so it can&#39;t be on // the stack (see gopark). Prevent deadlock from recursively // starting GC by disabling preemption. gp.m.preemptoff = &quot;GC worker init&quot; park := new(parkInfo) gp.m.preemptoff = &quot;&quot; // 设置当前的M并禁止抢占 park.m.set(acquirem()) // 设置当前的P(需要关联到的P) park.attach.set(\_p\_) // 通知gcBgMarkStartWorkers可以继续处理 // Inform gcBgMarkStartWorkers that this worker is ready. // After this point, the background mark worker is scheduled // cooperatively by gcController.findRunnable. Hence, it must // never be preempted, as this would put it into \_Grunnable // and put it on a run queue. Instead, when the preempt flag // is set, this puts itself into \_Gwaiting to be woken up by // gcController.findRunnable at the appropriate time. notewakeup(&amp;work.bgMarkReady) for { // 让当前G进入休眠 // Go to sleep until woken by gcController.findRunnable. // We can&#39;t releasem yet since even the call to gopark // may be preempted. gopark(func(g \*g, parkp unsafe.Pointer) bool { park := (\*parkInfo)(parkp) // 重新允许抢占 // The worker G is no longer running, so it&#39;s // now safe to allow preemption. releasem(park.m.ptr()) // 设置关联的P // 把当前的G设到P的gcBgMarkWorker成员, 下次findRunnableGCWorker会使用 // 设置失败时不休眠 // If the worker isn&#39;t attached to its P, // attach now. During initialization and after // a phase change, the worker may have been // running on a different P. As soon as we // attach, the owner P may schedule the // worker, so this must be done after the G is // stopped. if park.attach != 0 { p := park.attach.ptr() park.attach.set(nil) // cas the worker because we may be // racing with a new worker starting // on this P. if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) { // The P got a new worker. // Exit this worker. return false } } return true }, unsafe.Pointer(park), &quot;GC worker (idle)&quot;, traceEvGoBlock, 0) // 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务 // Loop until the P dies and disassociates this // worker (the P may later be reused, in which case // it will get a new worker) or we failed to associate. if \_p\_.gcBgMarkWorker.ptr() != gp { break } // 禁止G被抢占 // Disable preemption so we can use the gcw. If the // scheduler wants to preempt us, we&#39;ll stop draining, // dispose the gcw, and then preempt. park.m.set(acquirem()) if gcBlackenEnabled == 0 { throw(&quot;gcBgMarkWorker: blackening not enabled&quot;) } // 记录开始时间 startTime := nanotime() decnwait := atomic.Xadd(&amp;work.nwait, -1) if decnwait == work.nproc { println(&quot;runtime: work.nwait=&quot;, decnwait, &quot;work.nproc=&quot;, work.nproc) throw(&quot;work.nwait was &gt; work.nproc&quot;) } // 切换到g0运行 systemstack(func() { // 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈) // Mark our goroutine preemptible so its stack // can be scanned. This lets two mark workers // scan each other (otherwise, they would // deadlock). We must not modify anything on // the G stack. However, stack shrinking is // disabled for mark workers, so it is safe to // read from the G stack. casgstatus(gp, \_Grunning, \_Gwaiting) // 判断后台标记任务的模式 switch \_p\_.gcMarkWorkerMode { default: throw(&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;) case gcMarkWorkerDedicatedMode: // 这个模式下P应该专心执行标记 // 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G gcDrain(&amp;\_p\_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit) // 被抢占时把本地运行队列中的所有G都踢到全局运行队列 if gp.preempt { // We were preempted. This is // a useful signal to kick // everything out of the run // queue so it can run // somewhere else. lock(&amp;sched.lock) for { gp, \_ := runqget(\_p\_) if gp == nil { break } globrunqput(gp) } unlock(&amp;sched.lock) } // 继续执行标记, 直到无更多任务, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G // Go back to draining, this time // without preemption. gcDrain(&amp;\_p\_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit) case gcMarkWorkerFractionalMode: // 这个模式下P应该适当执行标记 // 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G gcDrain(&amp;\_p\_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit) case gcMarkWorkerIdleMode: // 这个模式下P只在空闲时执行标记 // 执行标记, 直到被抢占或者达到一定的量, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G gcDrain(&amp;\_p\_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit) } // 恢复G的状态到运行中 casgstatus(gp, \_Gwaiting, \_Grunning) }) // 如果标记了禁止本地标记队列则flush到全局标记队列 // If we are nearing the end of mark, dispose // of the cache promptly. We must do this // before signaling that we&#39;re no longer // working so that other workers can&#39;t observe // no workers and no work while we have this // cached, and before we compute done. if gcBlackenPromptly { \_p\_.gcw.dispose() } // 累加所用时间 // Account for time. duration := nanotime() - startTime switch \_p\_.gcMarkWorkerMode { case gcMarkWorkerDedicatedMode: atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration) atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, 1) case gcMarkWorkerFractionalMode: atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration) atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, 1) case gcMarkWorkerIdleMode: atomic.Xaddint64(&amp;gcController.idleMarkTime, duration) } // Was this the last worker and did we run out // of work? incnwait := atomic.Xadd(&amp;work.nwait, +1) if incnwait &gt; work.nproc { println(&quot;runtime: p.gcMarkWorkerMode=&quot;, \_p\_.gcMarkWorkerMode, &quot;work.nwait=&quot;, incnwait, &quot;work.nproc=&quot;, work.nproc) throw(&quot;work.nwait &gt; work.nproc&quot;) } // 判断是否所有后台标记任务都完成, 并且没有更多的任务 // If this worker reached a background mark completion // point, signal the main GC goroutine. if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) { // 取消和P的关联 // Make this G preemptible and disassociate it // as the worker for this P so // findRunnableGCWorker doesn&#39;t try to // schedule it. \_p\_.gcBgMarkWorker.set(nil) // 允许G被抢占 releasem(park.m.ptr()) // 准备进入完成标记阶段 gcMarkDone() // 休眠之前会重新关联P // 因为上面允许被抢占, 到这里的时候可能就会变成其他P // 如果重新关联P失败则这个任务会结束 // Disable preemption and prepare to reattach // to the P. // // We may be running on a different P at this // point, so we can&#39;t reattach until this G is // parked. park.m.set(acquirem()) park.attach.set(\_p\_) } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcDrain](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L889" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L889</a>)函数用于执行标记:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcDrain scans roots and objects in work buffers, blackening grey // objects until all roots and work buffers have been drained. // // If flags&amp;gcDrainUntilPreempt != 0, gcDrain returns when g.preempt // is set. This implies gcDrainNoBlock. // // If flags&amp;gcDrainIdle != 0, gcDrain returns when there is other work // to do. This implies gcDrainNoBlock. // // If flags&amp;gcDrainNoBlock != 0, gcDrain returns as soon as it is // unable to get more work. Otherwise, it will block until all // blocking calls are blocked in gcDrain. // // If flags&amp;gcDrainFlushBgCredit != 0, gcDrain flushes scan work // credit to gcController.bgScanCredit every gcCreditSlack units of // scan work. // //go:nowritebarrier func gcDrain(gcw \*gcWork, flags gcDrainFlags) { if !writeBarrier.needed { throw(&quot;gcDrain phase incorrect&quot;) } gp := getg().m.curg // 看到抢占标志时是否要返回 preemptible := flags&amp;gcDrainUntilPreempt != 0 // 没有任务时是否要等待任务 blocking := flags&amp;(gcDrainUntilPreempt|gcDrainIdle|gcDrainNoBlock) == 0 // 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G flushBgCredit := flags&amp;gcDrainFlushBgCredit != 0 // 是否只执行一定量的工作 idle := flags&amp;gcDrainIdle != 0 // 记录初始的已扫描数量 initScanWork := gcw.scanWork // 扫描idleCheckThreshold(100000)个对象以后检查是否要返回 // idleCheck is the scan work at which to perform the next // idle check with the scheduler. idleCheck := initScanWork + idleCheckThreshold // 如果根对象未扫描完, 则先扫描根对象 // Drain root marking jobs. if work.markrootNext &lt; work.markrootJobs { // 如果标记了preemptible, 循环直到被抢占 for !(preemptible &amp;&amp; gp.preempt) { // 从根对象扫描队列取出一个值(原子递增) job := atomic.Xadd(&amp;work.markrootNext, +1) - 1 if job &gt;= work.markrootJobs { break } // 执行根对象扫描工作 markroot(gcw, job) // 如果是idle模式并且有其他工作, 则返回 if idle &amp;&amp; pollWork() { goto done } } } // 根对象已经在标记队列中, 消费标记队列 // 如果标记了preemptible, 循环直到被抢占 // Drain heap marking jobs. for !(preemptible &amp;&amp; gp.preempt) { // 如果全局标记队列为空, 把本地标记队列的一部分工作分过去 // (如果wbuf2不为空则移动wbuf2过去, 否则移动wbuf1的一半过去) // Try to keep work available on the global queue. We used to // check if there were waiting workers, but it&#39;s better to // just keep work available than to make workers wait. In the // worst case, we&#39;ll do O(log(\_WorkbufSize)) unnecessary // balances. if work.full == 0 { gcw.balance() } // 从本地标记队列中获取对象, 获取不到则从全局标记队列获取 var b uintptr if blocking { // 阻塞获取 b = gcw.get() } else { // 非阻塞获取 b = gcw.tryGetFast() if b == 0 { b = gcw.tryGet() } } // 获取不到对象, 标记队列已为空, 跳出循环 if b == 0 { // work barrier reached or tryGet failed. break } // 扫描获取到的对象 scanobject(b, gcw) // 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000) // Flush background scan work credit to the global // account if we&#39;ve accumulated enough locally so // mutator assists can draw on it. if gcw.scanWork &gt;= gcCreditSlack { // 把扫描的对象数量添加到全局 atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork) // 减少辅助GC的工作量和唤醒等待中的G if flushBgCredit { gcFlushBgCredit(gcw.scanWork - initScanWork) initScanWork = 0 } idleCheck -= gcw.scanWork gcw.scanWork = 0 // 如果是idle模式且达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环 if idle &amp;&amp; idleCheck &lt;= 0 { idleCheck += idleCheckThreshold if pollWork() { break } } } } // In blocking mode, write barriers are not allowed after this // point because we must preserve the condition that the work // buffers are empty. done: // 把扫描的对象数量添加到全局 // Flush remaining scan work credit. if gcw.scanWork &gt; 0 { atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork) // 减少辅助GC的工作量和唤醒等待中的G if flushBgCredit { gcFlushBgCredit(gcw.scanWork - initScanWork) } gcw.scanWork = 0 } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[markroot](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L178" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L178</a>)函数用于执行根对象扫描工作:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // markroot scans the i&#39;th root. // // Preemption must be disabled (because this uses a gcWork). // // nowritebarrier is only advisory here. // //go:nowritebarrier func markroot(gcw \*gcWork, i uint32) { // 判断取出的数值对应哪种任务 // (google的工程师觉得这种办法可笑) // TODO(austin): This is a bit ridiculous. Compute and store // the bases in gcMarkRootPrepare instead of the counts. baseFlushCache := uint32(fixedRootCount) baseData := baseFlushCache + uint32(work.nFlushCacheRoots) baseBSS := baseData + uint32(work.nDataRoots) baseSpans := baseBSS + uint32(work.nBSSRoots) baseStacks := baseSpans + uint32(work.nSpanRoots) end := baseStacks + uint32(work.nStackRoots) // Note: if you add a case here, please also update heapdump.go:dumproots. switch { // 释放mcache中的所有span, 要求STW case baseFlushCache &lt;= i &amp;&amp; i &lt; baseData: flushmcache(int(i - baseFlushCache)) // 扫描可读写的全局变量 // 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据 case baseData &lt;= i &amp;&amp; i &lt; baseBSS: for \_, datap := range activeModules() { markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-baseData)) } // 扫描只读的全局变量 // 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据 case baseBSS &lt;= i &amp;&amp; i &lt; baseSpans: for \_, datap := range activeModules() { markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-baseBSS)) } // 扫描析构器队列 case i == fixedRootFinalizers: // Only do this once per GC cycle since we don&#39;t call // queuefinalizer during marking. if work.markrootDone { break } for fb := allfin; fb != nil; fb = fb.alllink { cnt := uintptr(atomic.Load(&amp;fb.cnt)) scanblock(uintptr(unsafe.Pointer(&amp;fb.fin\[0\])), cnt\*unsafe.Sizeof(fb.fin\[0\]), &amp;finptrmask\[0\], gcw) } // 释放已中止的G的栈 case i == fixedRootFreeGStacks: // Only do this once per GC cycle; preferably // concurrently. if !work.markrootDone { // Switch to the system stack so we can call // stackfree. systemstack(markrootFreeGStacks) } // 扫描各个span中特殊对象(析构器列表) case baseSpans &lt;= i &amp;&amp; i &lt; baseStacks: // mark MSpan.specials markrootSpans(gcw, int(i-baseSpans)) // 扫描各个G的栈 default: // 获取需要扫描的G // the rest is scanning goroutine stacks var gp \*g if baseStacks &lt;= i &amp;&amp; i &lt; end { gp = allgs\[i-baseStacks\] } else { throw(&quot;markroot: bad index&quot;) } // 记录等待开始的时间 // remember when we&#39;ve first observed the G blocked // needed only to output in traceback status := readgstatus(gp) // We are not in a scan state if (status == \_Gwaiting || status == \_Gsyscall) &amp;&amp; gp.waitsince == 0 { gp.waitsince = work.tstart } // 切换到g0运行(有可能会扫到自己的栈) // scang must be done on the system stack in case // we&#39;re trying to scan our own stack. systemstack(func() { // 判断扫描的栈是否自己的 // If this is a self-scan, put the user G in // \_Gwaiting to prevent self-deadlock. It may // already be in \_Gwaiting if this is a mark // worker or we&#39;re in mark termination. userG := getg().m.curg selfScan := gp == userG &amp;&amp; readgstatus(userG) == \_Grunning // 如果正在扫描自己的栈则切换状态到等待中防止死锁 if selfScan { casgstatus(userG, \_Grunning, \_Gwaiting) userG.waitreason = &quot;garbage collection scan&quot; } // 扫描G的栈 // TODO: scang blocks until gp&#39;s stack has // been scanned, which may take a while for // running goroutines. Consider doing this in // two phases where the first is non-blocking: // we scan the stacks we can and ask running // goroutines to scan themselves; and the // second blocks. scang(gp, gcw) // 如果正在扫描自己的栈则把状态切换回运行中 if selfScan { casgstatus(userG, \_Gwaiting, \_Grunning) } }) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[scang](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L830" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L830</a>)函数负责扫描G的栈:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // scang blocks until gp&#39;s stack has been scanned. // It might be scanned by scang or it might be scanned by the goroutine itself. // Either way, the stack scan has completed when scang returns. func scang(gp \*g, gcw \*gcWork) { // Invariant; we (the caller, markroot for a specific goroutine) own gp.gcscandone. // Nothing is racing with us now, but gcscandone might be set to true left over // from an earlier round of stack scanning (we scan twice per GC). // We use gcscandone to record whether the scan has been done during this round. // 标记扫描未完成 gp.gcscandone = false // See http://golang.org/cl/21503 for justification of the yield delay. const yieldDelay = 10 \* 1000 var nextYield int64 // 循环直到扫描完成 // Endeavor to get gcscandone set to true, // either by doing the stack scan ourselves or by coercing gp to scan itself. // gp.gcscandone can transition from false to true when we&#39;re not looking // (if we asked for preemption), so any time we lock the status using // castogscanstatus we have to double-check that the scan is still not done. loop: for i := 0; !gp.gcscandone; i++ { // 判断G的当前状态 switch s := readgstatus(gp); s { default: dumpgstatus(gp) throw(&quot;stopg: invalid status&quot;) // G已中止, 不需要扫描它 case \_Gdead: // No stack. gp.gcscandone = true break loop // G的栈正在扩展, 下一轮重试 case \_Gcopystack: // Stack being switched. Go around again. // G不是运行中, 首先需要防止它运行 case \_Grunnable, \_Gsyscall, \_Gwaiting: // Claim goroutine by setting scan bit. // Racing with execution or readying of gp. // The scan bit keeps them from running // the goroutine until we&#39;re done. if castogscanstatus(gp, s, s|\_Gscan) { // 原子切换状态成功时扫描它的栈 if !gp.gcscandone { scanstack(gp, gcw) gp.gcscandone = true } // 恢复G的状态, 并跳出循环 restartg(gp) break loop } // G正在扫描它自己, 等待扫描完毕 case \_Gscanwaiting: // newstack is doing a scan for us right now. Wait. // G正在运行 case \_Grunning: // Goroutine running. Try to preempt execution so it can scan itself. // The preemption handler (in newstack) does the actual scan. // 如果已经有抢占请求, 则抢占成功时会帮我们处理 // Optimization: if there is already a pending preemption request // (from the previous loop iteration), don&#39;t bother with the atomics. if gp.preemptscan &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt { break } // 抢占G, 抢占成功时G会扫描它自己 // Ask for preemption and self scan. if castogscanstatus(gp, \_Grunning, \_Gscanrunning) { if !gp.gcscandone { gp.preemptscan = true gp.preempt = true gp.stackguard0 = stackPreempt } casfrom\_Gscanstatus(gp, \_Gscanrunning, \_Grunning) } } // 第一轮休眠10毫秒, 第二轮休眠5毫秒 if i == 0 { nextYield = nanotime() + yieldDelay } if nanotime() &lt; nextYield { procyield(10) } else { osyield() nextYield = nanotime() + yieldDelay/2 } } // 扫描完成, 取消抢占扫描的请求 gp.preemptscan = false // cancel scan request if no longer needed }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>设置preemptscan后, 在抢占G成功时会调用scanstack扫描它自己的栈, 具体代码[在这里](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/stack.go#L1013" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/stack.go#L1013</a>).\ 扫描栈用的函数是[scanstack](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L736" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L736</a>):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // scanstack scans gp&#39;s stack, greying all pointers found on the stack. // // scanstack is marked go:systemstack because it must not be preempted // while using a workbuf. // //go:nowritebarrier //go:systemstack func scanstack(gp \*g, gcw \*gcWork) { if gp.gcscanvalid { return } if readgstatus(gp)&amp;\_Gscan == 0 { print(&quot;runtime:scanstack: gp=&quot;, gp, &quot;, goid=&quot;, gp.goid, &quot;, gp-&gt;atomicstatus=&quot;, hex(readgstatus(gp)), &quot;\\n&quot;) throw(&quot;scanstack - bad status&quot;) } switch readgstatus(gp) &amp;^ \_Gscan { default: print(&quot;runtime: gp=&quot;, gp, &quot;, goid=&quot;, gp.goid, &quot;, gp-&gt;atomicstatus=&quot;, readgstatus(gp), &quot;\\n&quot;) throw(&quot;mark - bad status&quot;) case \_Gdead: return case \_Grunning: print(&quot;runtime: gp=&quot;, gp, &quot;, goid=&quot;, gp.goid, &quot;, gp-&gt;atomicstatus=&quot;, readgstatus(gp), &quot;\\n&quot;) throw(&quot;scanstack: goroutine not stopped&quot;) case \_Grunnable, \_Gsyscall, \_Gwaiting: // ok } if gp == getg() { throw(&quot;can&#39;t scan our own stack&quot;) } mp := gp.m if mp != nil &amp;&amp; mp.helpgc != 0 { throw(&quot;can&#39;t scan gchelper stack&quot;) } // Shrink the stack if not much of it is being used. During // concurrent GC, we can do this during concurrent mark. if !work.markrootDone { shrinkstack(gp) } // Scan the stack. var cache pcvalueCache scanframe := func(frame \*stkframe, unused unsafe.Pointer) bool { // scanframeworker会根据代码地址(pc)获取函数信息 // 然后找到函数信息中的stackmap.bytedata, 它保存了函数的栈上哪些地方有指针 // 再调用scanblock来扫描函数的栈空间, 同时函数的参数也会这样扫描 scanframeworker(frame, &amp;cache, gcw) return true } // 枚举所有调用帧, 分别调用scanframe函数 gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0) // 枚举所有defer的调用帧, 分别调用scanframe函数 tracebackdefers(gp, scanframe, nil) gp.gcscanvalid = true }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[scanblock](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1059" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1059</a>)函数是一个通用的扫描函数, 扫描全局变量和栈空间都会用它, 和scanobject不同的是bitmap需要手动传入:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // scanblock scans b as scanobject would, but using an explicit // pointer bitmap instead of the heap bitmap. // // This is used to scan non-heap roots, so it does not update // gcw.bytesMarked or gcw.scanWork. // //go:nowritebarrier func scanblock(b0, n0 uintptr, ptrmask \*uint8, gcw \*gcWork) { // Use local copies of original parameters, so that a stack trace // due to one of the throws below shows the original block // base and extent. b := b0 n := n0 arena\_start := mheap\_.arena\_start arena\_used := mheap\_.arena\_used // 枚举扫描的地址 for i := uintptr(0); i &lt; n; { // 找到bitmap中对应的byte // Find bits for the next word. bits := uint32(\*addb(ptrmask, i/(sys.PtrSize\*8))) if bits == 0 { i += sys.PtrSize \* 8 continue } // 枚举byte for j := 0; j &lt; 8 &amp;&amp; i &lt; n; j++ { // 如果该地址包含指针 if bits&amp;1 != 0 { // 标记在该地址的对象存活, 并把它加到标记队列(该对象变为灰色) // Same work as in scanobject; see comments there. obj := \*(\*uintptr)(unsafe.Pointer(b + i)) if obj != 0 &amp;&amp; arena\_start &lt;= obj &amp;&amp; obj &lt; arena\_used { // 找到该对象对应的span和bitmap if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 { // 标记一个对象存活, 并把它加到标记队列(该对象变为灰色) greyobject(obj, b, i, hbits, span, gcw, objIndex) } } } // 处理下一个指针下一个bit bits &gt;&gt;= 1 i += sys.PtrSize } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[greyobject](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1216" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1216</a>)用于标记一个对象存活, 并把它加到标记队列(该对象变为灰色):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // obj is the start of an object with mark mbits. // If it isn&#39;t already marked, mark it and enqueue into gcw. // base and off are for debugging only and could be removed. //go:nowritebarrierrec func greyobject(obj, base, off uintptr, hbits heapBits, span \*mspan, gcw \*gcWork, objIndex uintptr) { // obj should be start of allocation, and so must be at least pointer-aligned. if obj&amp;(sys.PtrSize-1) != 0 { throw(&quot;greyobject: obj not pointer-aligned&quot;) } mbits := span.markBitsForIndex(objIndex) if useCheckmark { // checkmark是用于检查是否所有可到达的对象都被正确标记的机制, 仅除错使用 if !mbits.isMarked() { printlock() print(&quot;runtime:greyobject: checkmarks finds unexpected unmarked object obj=&quot;, hex(obj), &quot;\\n&quot;) print(&quot;runtime: found obj at \*(&quot;, hex(base), &quot;+&quot;, hex(off), &quot;)\\n&quot;) // Dump the source (base) object gcDumpObject(&quot;base&quot;, base, off) // Dump the object gcDumpObject(&quot;obj&quot;, obj, ^uintptr(0)) getg().m.traceback = 2 throw(&quot;checkmark found unmarked object&quot;) } if hbits.isCheckmarked(span.elemsize) { return } hbits.setCheckmarked(span.elemsize) if !hbits.isCheckmarked(span.elemsize) { throw(&quot;setCheckmarked and isCheckmarked disagree&quot;) } } else { if debug.gccheckmark &gt; 0 &amp;&amp; span.isFree(objIndex) { print(&quot;runtime: marking free object &quot;, hex(obj), &quot; found at \*(&quot;, hex(base), &quot;+&quot;, hex(off), &quot;)\\n&quot;) gcDumpObject(&quot;base&quot;, base, off) gcDumpObject(&quot;obj&quot;, obj, ^uintptr(0)) getg().m.traceback = 2 throw(&quot;marking free object&quot;) } // 如果对象所在的span中的gcmarkBits对应的bit已经设置为1则可以跳过处理 // If marked we have nothing to do. if mbits.isMarked() { return } // 设置对象所在的span中的gcmarkBits对应的bit为1 // mbits.setMarked() // Avoid extra call overhead with manual inlining. atomic.Or8(mbits.bytep, mbits.mask) // 如果确定对象不包含指针(所在span的类型是noscan), 则不需要把对象放入标记队列 // If this is a noscan object, fast-track it to black // instead of greying it. if span.spanclass.noscan() { gcw.bytesMarked += uint64(span.elemsize) return } } // 把对象放入标记队列 // 先放入本地标记队列, 失败时把���地标记队列中的部分工作转移到全局标记队列, 再放入本地标记队列 // Queue the obj for scanning. The PREFETCH(obj) logic has been removed but // seems like a nice optimization that can be added back in. // There needs to be time between the PREFETCH and the use. // Previously we put the obj in an 8 element buffer that is drained at a rate // to give the PREFETCH time to do its work. // Use of PREFETCHNTA might be more appropriate than PREFETCH if !gcw.putFast(obj) { gcw.put(obj) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>gcDrain函数扫描完根对象, 就会开始消费标记队列, 对从标记队列中取出的对象调用[scanobject](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1098" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1098</a>)函数:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // scanobject scans the object starting at b, adding pointers to gcw. // b must point to the beginning of a heap object or an oblet. // scanobject consults the GC bitmap for the pointer mask and the // spans for the size of the object. // //go:nowritebarrier func scanobject(b uintptr, gcw \*gcWork) { // Note that arena\_used may change concurrently during // scanobject and hence scanobject may encounter a pointer to // a newly allocated heap object that is \*not\* in // \[start,used). It will not mark this object; however, we // know that it was just installed by a mutator, which means // that mutator will execute a write barrier and take care of // marking it. This is even more pronounced on relaxed memory // architectures since we access arena\_used without barriers // or synchronization, but the same logic applies. arena\_start := mheap\_.arena\_start arena\_used := mheap\_.arena\_used // Find the bits for b and the size of the object at b. // // b is either the beginning of an object, in which case this // is the size of the object to scan, or it points to an // oblet, in which case we compute the size to scan below. // 获取对象对应的bitmap hbits := heapBitsForAddr(b) // 获取对象所在的span s := spanOfUnchecked(b) // 获取对象的大小 n := s.elemsize if n == 0 { throw(&quot;scanobject n == 0&quot;) } // 对象大小过大时(maxObletBytes是128KB)需要分割扫描 // 每次最多只扫描128KB if n &gt; maxObletBytes { // Large object. Break into oblets for better // parallelism and lower latency. if b == s.base() { // It&#39;s possible this is a noscan object (not // from greyobject, but from other code // paths), in which case we must \*not\* enqueue // oblets since their bitmaps will be // uninitialized. if s.spanclass.noscan() { // Bypass the whole scan. gcw.bytesMarked += uint64(n) return } // Enqueue the other oblets to scan later. // Some oblets may be in b&#39;s scalar tail, but // these will be marked as &quot;no more pointers&quot;, // so we&#39;ll drop out immediately when we go to // scan those. for oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes { if !gcw.putFast(oblet) { gcw.put(oblet) } } } // Compute the size of the oblet. Since this object // must be a large object, s.base() is the beginning // of the object. n = s.base() + s.elemsize - b if n &gt; maxObletBytes { n = maxObletBytes } } // 扫描对象中的指针 var i uintptr for i = 0; i &lt; n; i += sys.PtrSize { // 获取对应的bit // Find bits for this word. if i != 0 { // Avoid needless hbits.next() on last iteration. hbits = hbits.next() } // Load bits once. See CL 22712 and issue 16973 for discussion. bits := hbits.bits() // 检查scan bit判断是否继续扫描, 注意第二个scan bit是checkmark // During checkmarking, 1-word objects store the checkmark // in the type bit for the one word. The only one-word objects // are pointers, or else they&#39;d be merged with other non-pointer // data into larger allocations. if i != 1\*sys.PtrSize &amp;&amp; bits&amp;bitScan == 0 { break // no more pointers in this object } // 检查pointer bit, 不是指针则继续 if bits&amp;bitPointer == 0 { continue // not a pointer } // 取出指针的值 // Work here is duplicated in scanblock and above. // If you make changes here, make changes there too. obj := \*(\*uintptr)(unsafe.Pointer(b + i)) // 如果指针在arena区域中, 则调用greyobject标记对象并把对象放到标记队列中 // At this point we have extracted the next potential pointer. // Check if it points into heap and not back at the current object. if obj != 0 &amp;&amp; arena\_start &lt;= obj &amp;&amp; obj &lt; arena\_used &amp;&amp; obj-b &gt;= n { // Mark the object. if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 { greyobject(obj, b, i, hbits, span, gcw, objIndex) } } } // 统计扫描过的大小和对象数量 gcw.bytesMarked += uint64(n) gcw.scanWork += int64(i) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在所有后台标记任务都把标记队列消费完毕时, 会执行[gcMarkDone](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1345" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1345</a>)函数准备进入完成标记阶段(mark termination):\ 在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // gcMarkDone transitions the GC from mark 1 to mark 2 and from mark 2 // to mark termination. // // This should be called when all mark work has been drained. In mark // 1, this includes all root marking jobs, global work buffers, and // active work buffers in assists and background workers; however, // work may still be cached in per-P work buffers. In mark 2, per-P // caches are disabled. // // The calling context must be preemptible. // // Note that it is explicitly okay to have write barriers in this // function because completion of concurrent mark is best-effort // anyway. Any work created by write barriers here will be cleaned up // by mark termination. func gcMarkDone() { top: semacquire(&amp;work.markDoneSema) // Re-check transition condition under transition lock. if !(gcphase == \_GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil)) { semrelease(&amp;work.markDoneSema) return } // 暂时禁止启动新的后台标记任务 // Disallow starting new workers so that any remaining workers // in the current mark phase will drain out. // // TODO(austin): Should dedicated workers keep an eye on this // and exit gcDrain promptly? atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, -0xffffffff) atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, -0xffffffff) // 判断本地标记队列是否已禁用 if !gcBlackenPromptly { // 本地标记队列是否未禁用, 禁用然后重新开始后台标记任务 // Transition from mark 1 to mark 2. // // The global work list is empty, but there can still be work // sitting in the per-P work caches. // Flush and disable work caches. // 禁用本地标记队列 // Disallow caching workbufs and indicate that we&#39;re in mark 2. gcBlackenPromptly = true // Prevent completion of mark 2 until we&#39;ve flushed // cached workbufs. atomic.Xadd(&amp;work.nwait, -1) // GC is set up for mark 2. Let Gs blocked on the // transition lock go while we flush caches. semrelease(&amp;work.markDoneSema) // 把所有本地标记队列中的对象都推到全局标记队列 systemstack(func() { // Flush all currently cached workbufs and // ensure all Ps see gcBlackenPromptly. This // also blocks until any remaining mark 1 // workers have exited their loop so we can // start new mark 2 workers. forEachP(func(\_p\_ \*p) { \_p\_.gcw.dispose() }) }) // 除错用 // Check that roots are marked. We should be able to // do this before the forEachP, but based on issue // #16083 there may be a (harmless) race where we can // enter mark 2 while some workers are still scanning // stacks. The forEachP ensures these scans are done. // // TODO(austin): Figure out the race and fix this // properly. gcMarkRootCheck() // 允许启动新的后台标记任务 // Now we can start up mark 2 workers. atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, 0xffffffff) atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, 0xffffffff) // 如果确定没有更多的任务则可以直接跳到函数顶部 // 这样就当作是第二次调用了 incnwait := atomic.Xadd(&amp;work.nwait, +1) if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) { // This loop will make progress because // gcBlackenPromptly is now true, so it won&#39;t // take this same &quot;if&quot; branch. goto top } } else { // 记录完成标记阶段开始的时间和STW开始的时间 // Transition to mark termination. now := nanotime() work.tMarkTerm = now work.pauseStart = now // 禁止G被抢占 getg().m.preemptoff = &quot;gcing&quot; // 停止所有运行中的G, 并禁止它们运行 systemstack(stopTheWorldWithSema) // !!!!!!!!!!!!!!!! // 世界已停止(STW)... // !!!!!!!!!!!!!!!! // The gcphase is \_GCmark, it will transition to \_GCmarktermination // below. The important thing is that the wb remains active until // all marking is complete. This includes writes made by the GC. // 标记对根对象的扫描已完成, 会影响gcMarkRootPrepare中的处理 // Record that one root marking pass has completed. work.markrootDone = true // 禁止辅助GC和后台标记任务的运行 // Disable assists and background workers. We must do // this before waking blocked assists. atomic.Store(&amp;gcBlackenEnabled, 0) // 唤醒所有因为辅助GC而休眠的G // Wake all blocked assists. These will run when we // start the world again. gcWakeAllAssists() // Likewise, release the transition lock. Blocked // workers and assists will run when we start the // world again. semrelease(&amp;work.markDoneSema) // 计算下一次触发gc需要的heap大小 // endCycle depends on all gcWork cache stats being // flushed. This is ensured by mark 2. nextTriggerRatio := gcController.endCycle() // 进入完成标记阶段, 会重新启动世界 // Perform mark termination. This will restart the world. gcMarkTermination(nextTriggerRatio) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcMarkTermination](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1449" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1449</a>)函数会进入完成标记阶段:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func gcMarkTermination(nextTriggerRatio float64) { // World is stopped. // Start marktermination which includes enabling the write barrier. // 禁止辅助GC和后台标记任务的运行 atomic.Store(&amp;gcBlackenEnabled, 0) // 重新允许本地标记队列(下次GC使用) gcBlackenPromptly = false // 设置当前GC阶段到完成标记阶段, 并启用写屏障 setGCPhase(\_GCmarktermination) // 记录开始时间 work.heap1 = memstats.heap\_live startTime := nanotime() // 禁止G被抢占 mp := acquirem() mp.preemptoff = &quot;gcing&quot; \_g\_ := getg() \_g\_.m.traceback = 2 // 设置G的状态为等待中这样它的栈可以被扫描 gp := \_g\_.m.curg casgstatus(gp, \_Grunning, \_Gwaiting) gp.waitreason = &quot;garbage collection&quot; // 切换到g0运行 // Run gc on the g0 stack. We do this so that the g stack // we&#39;re currently running on will no longer change. Cuts // the root set down a bit (g0 stacks are not scanned, and // we don&#39;t need to scan gc&#39;s internal state). We also // need to switch to g0 so we can shrink the stack. systemstack(func() { // 开始STW中的标记 gcMark(startTime) // 必须立刻返回, 因为外面的G的栈有可能被移动, 不能在这之后访问外面的变量 // Must return immediately. // The outer function&#39;s stack may have moved // during gcMark (it shrinks stacks, including the // outer function&#39;s stack), so we must not refer // to any of its variables. Return back to the // non-system stack to pick up the new addresses // before continuing. }) // 重新切换到g0运行 systemstack(func() { work.heap2 = work.bytesMarked // 如果启用了checkmark则执行检查, 检查是否所有可到达的对象都有标记 if debug.gccheckmark &gt; 0 { // Run a full stop-the-world mark using checkmark bits, // to check that we didn&#39;t forget to mark anything during // the concurrent mark process. gcResetMarkState() initCheckmarks() gcMark(startTime) clearCheckmarks() } // 设置当前GC阶段到关闭, 并禁用写屏障 // marking is complete so we can turn the write barrier off setGCPhase(\_GCoff) // 唤醒后台清扫任务, 将在STW结束后开始运行 gcSweep(work.mode) // 除错用 if debug.gctrace &gt; 1 { startTime = nanotime() // The g stacks have been scanned so // they have gcscanvalid==true and gcworkdone==true. // Reset these so that all stacks will be rescanned. gcResetMarkState() finishsweep\_m() // Still in STW but gcphase is \_GCoff, reset to \_GCmarktermination // At this point all objects will be found during the gcMark which // does a complete STW mark and object scan. setGCPhase(\_GCmarktermination) gcMark(startTime) setGCPhase(\_GCoff) // marking is done, turn off wb. gcSweep(work.mode) } }) // 设置G的状态为运行中 \_g\_.m.traceback = 0 casgstatus(gp, \_Gwaiting, \_Grunning) // 跟踪处理 if trace.enabled { traceGCDone() } // all done mp.preemptoff = &quot;&quot; if gcphase != \_GCoff { throw(&quot;gc done but gcphase != \_GCoff&quot;) } // 更新下一次触发gc需要的heap大小(gc\_trigger) // Update GC trigger and pacing for the next cycle. gcSetTriggerRatio(nextTriggerRatio) // 更新用时记录 // Update timing memstats now := nanotime() sec, nsec, \_ := time\_now() unixNow := sec\*1e9 + int64(nsec) work.pauseNS += now - work.pauseStart work.tEnd = now atomic.Store64(&amp;memstats.last\_gc\_unix, uint64(unixNow)) // must be Unix time to make sense to user atomic.Store64(&amp;memstats.last\_gc\_nanotime, uint64(now)) // monotonic time for us memstats.pause\_ns\[memstats.numgc%uint32(len(memstats.pause\_ns))\] = uint64(work.pauseNS) memstats.pause\_end\[memstats.numgc%uint32(len(memstats.pause\_end))\] = uint64(unixNow) memstats.pause\_total\_ns += uint64(work.pauseNS) // 更新所用cpu记录 // Update work.totaltime. sweepTermCpu := int64(work.stwprocs) \* (work.tMark - work.tSweepTerm) // We report idle marking time below, but omit it from the // overall utilization here since it&#39;s &quot;free&quot;. markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime markTermCpu := int64(work.stwprocs) \* (work.tEnd - work.tMarkTerm) cycleCpu := sweepTermCpu + markCpu + markTermCpu work.totaltime += cycleCpu // Compute overall GC CPU utilization. totalCpu := sched.totaltime + (now-sched.procresizetime)\*int64(gomaxprocs) memstats.gc\_cpu\_fraction = float64(work.totaltime) / float64(totalCpu) // 重置清扫状态 // Reset sweep state. sweep.nbgsweep = 0 sweep.npausesweep = 0 // 统计强制开始GC的次数 if work.userForced { memstats.numforcedgc++ } // 统计执行GC的次数然后唤醒等待清扫的G // Bump GC cycle count and wake goroutines waiting on sweep. lock(&amp;work.sweepWaiters.lock) memstats.numgc++ injectglist(work.sweepWaiters.head.ptr()) work.sweepWaiters.head = 0 unlock(&amp;work.sweepWaiters.lock) // 性能统计用 // Finish the current heap profiling cycle and start a new // heap profiling cycle. We do this before starting the world // so events don&#39;t leak into the wrong cycle. mProf\_NextCycle() // 重新启动世界 systemstack(startTheWorldWithSema) // !!!!!!!!!!!!!!! // 世界已重新启动... // !!!!!!!!!!!!!!! // 性能统计用 // Flush the heap profile so we can start a new cycle next GC. // This is relatively expensive, so we don&#39;t do it with the // world stopped. mProf\_Flush() // 移动标记队列使用的缓冲区到自由列表, 使得它们可以被回收 // Prepare workbufs for freeing by the sweeper. We do this // asynchronously because it can take non-trivial time. prepareFreeWorkbufs() // 释放未使用的栈 // Free stack spans. This must be done between GC cycles. systemstack(freeStackSpans) // 除错用 // Print gctrace before dropping worldsema. As soon as we drop // worldsema another cycle could start and smash the stats // we&#39;re trying to print. if debug.gctrace &gt; 0 { util := int(memstats.gc\_cpu\_fraction \* 100) var sbuf \[24\]byte printlock() print(&quot;gc &quot;, memstats.numgc, &quot; @&quot;, string(itoaDiv(sbuf\[:\], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), &quot;s &quot;, util, &quot;%: &quot;) prev := work.tSweepTerm for i, ns := range \[\]int64{work.tMark, work.tMarkTerm, work.tEnd} { if i != 0 { print(&quot;+&quot;) } print(string(fmtNSAsMS(sbuf\[:\], uint64(ns-prev)))) prev = ns } print(&quot; ms clock, &quot;) for i, ns := range \[\]int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} { if i == 2 || i == 3 { // Separate mark time components with /. print(&quot;/&quot;) } else if i != 0 { print(&quot;+&quot;) } print(string(fmtNSAsMS(sbuf\[:\], uint64(ns)))) } print(&quot; ms cpu, &quot;, work.heap0&gt;&gt;20, &quot;-&gt;&quot;, work.heap1&gt;&gt;20, &quot;-&gt;&quot;, work.heap2&gt;&gt;20, &quot; MB, &quot;, work.heapGoal&gt;&gt;20, &quot; MB goal, &quot;, work.maxprocs, &quot; P&quot;) if work.userForced { print(&quot; (forced)&quot;) } print(&quot;\\n&quot;) printunlock() } semrelease(&amp;worldsema) // Careful: another GC cycle may start now. // 重新允许当前的G被抢占 releasem(mp) mp = nil // 如果是并行GC, 让当前M继续运行(会回到gcBgMarkWorker然后休眠) // 如果不是并行GC, 则让当前M开始调度 // now that gc is done, kick off finalizer thread if needed if !concurrentSweep { // give the queued finalizers, if any, a chance to run Gosched() } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcSweep](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1987" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1987</a>)函数会唤醒后台清扫任务:\ 后台清扫任务会在程序启动时调用的[gcenable](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L214" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L214</a>)函数中启动.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func gcSweep(mode gcMode) { if gcphase != \_GCoff { throw(&quot;gcSweep being done but phase is not GCoff&quot;) } // 增加sweepgen, 这样sweepSpans中两个队列角色会交换, 所有span都会变为&quot;待清扫&quot;的span lock(&amp;mheap\_.lock) mheap\_.sweepgen += 2 mheap\_.sweepdone = 0 if mheap\_.sweepSpans\[mheap\_.sweepgen/2%2\].index != 0 { // We should have drained this list during the last // sweep phase. We certainly need to start this phase // with an empty swept list. throw(&quot;non-empty swept list&quot;) } mheap\_.pagesSwept = 0 unlock(&amp;mheap\_.lock) // 如果非并行GC则在这里完成所有工作(STW中) if !\_ConcurrentSweep || mode == gcForceBlockMode { // Special case synchronous sweep. // Record that no proportional sweeping has to happen. lock(&amp;mheap\_.lock) mheap\_.sweepPagesPerByte = 0 unlock(&amp;mheap\_.lock) // Sweep all spans eagerly. for sweepone() != ^uintptr(0) { sweep.npausesweep++ } // Free workbufs eagerly. prepareFreeWorkbufs() for freeSomeWbufs(false) { } // All &quot;free&quot; events for this mark/sweep cycle have // now happened, so we can make this profile cycle // available immediately. mProf\_NextCycle() mProf\_Flush() return } // 唤醒后台清扫任务 // Background sweep. lock(&amp;sweep.lock) if sweep.parked { sweep.parked = false ready(sweep.g, 0, true) } unlock(&amp;sweep.lock) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后台清扫任务的函数是[bgsweep](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L46" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L46</a>):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func bgsweep(c chan int) { sweep.g = getg() // 等待唤醒 lock(&amp;sweep.lock) sweep.parked = true c &lt;- 1 goparkunlock(&amp;sweep.lock, &quot;GC sweep wait&quot;, traceEvGoBlock, 1) // 循环清扫 for { // 清扫一个span, 然后进入调度(一次只做少量工作) for gosweepone() != ^uintptr(0) { sweep.nbgsweep++ Gosched() } // 释放一些未使用的标记队列缓冲区到heap for freeSomeWbufs(true) { Gosched() } // 如果清扫未完成则继续循环 lock(&amp;sweep.lock) if !gosweepdone() { // This can happen if a GC runs between // gosweepone returning ^0 above // and the lock being acquired. unlock(&amp;sweep.lock) continue } // 否则让后台清扫任务进入休眠, 当前M继续调度 sweep.parked = true goparkunlock(&amp;sweep.lock, &quot;GC sweep wait&quot;, traceEvGoBlock, 1) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gosweepone](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L134" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L134</a>)函数会从sweepSpans中取出单个span清扫:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> //go:nowritebarrier func gosweepone() uintptr { var ret uintptr // 切换到g0运行 systemstack(func() { ret = sweepone() }) return ret }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[sweepone](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L78" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L78</a>)函数如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // sweeps one span // returns number of pages returned to heap, or ^uintptr(0) if there is nothing to sweep //go:nowritebarrier func sweepone() uintptr { \_g\_ := getg() sweepRatio := mheap\_.sweepPagesPerByte // For debugging // 禁止G被抢占 // increment locks to ensure that the goroutine is not preempted // in the middle of sweep thus leaving the span in an inconsistent state for next GC \_g\_.m.locks++ // 检查是否已完成清扫 if atomic.Load(&amp;mheap\_.sweepdone) != 0 { \_g\_.m.locks-- return ^uintptr(0) } // 更新同时执行sweep的任务数量 atomic.Xadd(&amp;mheap\_.sweepers, +1) npages := ^uintptr(0) sg := mheap\_.sweepgen for { // 从sweepSpans中取出一个span s := mheap\_.sweepSpans\[1-sg/2%2\].pop() // 全部清扫完毕时跳出循环 if s == nil { atomic.Store(&amp;mheap\_.sweepdone, 1) break } // 其他M已经在清扫这个span时跳过 if s.state != mSpanInUse { // This can happen if direct sweeping already // swept this span, but in that case the sweep // generation should always be up-to-date. if s.sweepgen != sg { print(&quot;runtime: bad span s.state=&quot;, s.state, &quot; s.sweepgen=&quot;, s.sweepgen, &quot; sweepgen=&quot;, sg, &quot;\\n&quot;) throw(&quot;non in-use span in unswept list&quot;) } continue } // 原子增加span的sweepgen, 失败表示其他M已经开始清扫这个span, 跳过 if s.sweepgen != sg-2 || !atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) { continue } // 清扫这个span, 然后跳出循环 npages = s.npages if !s.sweep(false) { // Span is still in-use, so this returned no // pages to the heap and the span needs to // move to the swept in-use list. npages = 0 } break } // 更新同时执行sweep的任务数量 // Decrement the number of active sweepers and if this is the // last one print trace information. if atomic.Xadd(&amp;mheap\_.sweepers, -1) == 0 &amp;&amp; atomic.Load(&amp;mheap\_.sweepdone) != 0 { if debug.gcpacertrace &gt; 0 { print(&quot;pacer: sweep done at heap size &quot;, memstats.heap\_live&gt;&gt;20, &quot;MB; allocated &quot;, (memstats.heap\_live-mheap\_.sweepHeapLiveBasis)&gt;&gt;20, &quot;MB during sweep; swept &quot;, mheap\_.pagesSwept, &quot; pages at &quot;, sweepRatio, &quot; pages/byte\\n&quot;) } } // 允许G被抢占 \_g\_.m.locks-- // 返回清扫的页数 return npages }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>span的[sweep](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L179" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L179</a>)函数用于清扫单个span:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Sweep frees or collects finalizers for blocks not marked in the mark phase. // It clears the mark bits in preparation for the next GC round. // Returns true if the span was returned to heap. // If preserve=true, don&#39;t return it to heap nor relink in MCentral lists; // caller takes care of it. //TODO go:nowritebarrier func (s \*mspan) sweep(preserve bool) bool { // It&#39;s critical that we enter this function with preemption disabled, // GC must not start while we are in the middle of this function. \_g\_ := getg() if \_g\_.m.locks == 0 &amp;&amp; \_g\_.m.mallocing == 0 &amp;&amp; \_g\_ != \_g\_.m.g0 { throw(&quot;MSpan\_Sweep: m is not locked&quot;) } sweepgen := mheap\_.sweepgen if s.state != mSpanInUse || s.sweepgen != sweepgen-1 { print(&quot;MSpan\_Sweep: state=&quot;, s.state, &quot; sweepgen=&quot;, s.sweepgen, &quot; mheap.sweepgen=&quot;, sweepgen, &quot;\\n&quot;) throw(&quot;MSpan\_Sweep: bad span state&quot;) } if trace.enabled { traceGCSweepSpan(s.npages \* \_PageSize) } // 统计已清理的页数 atomic.Xadd64(&amp;mheap\_.pagesSwept, int64(s.npages)) spc := s.spanclass size := s.elemsize res := false c := \_g\_.m.mcache freeToHeap := false // The allocBits indicate which unmarked objects don&#39;t need to be // processed since they were free at the end of the last GC cycle // and were not allocated since then. // If the allocBits index is &gt;= s.freeindex and the bit // is not marked then the object remains unallocated // since the last GC. // This situation is analogous to being on a freelist. // 判断在special中的析构器, 如果对应的对象已经不再存活则标记对象存活防止回收, 然后把析构器移到运行队列 // Unlink &amp; free special records for any objects we&#39;re about to free. // Two complications here: // 1. An object can have both finalizer and profile special records. // In such case we need to queue finalizer for execution, // mark the object as live and preserve the profile special. // 2. A tiny object can have several finalizers setup for different offsets. // If such object is not marked, we need to queue all finalizers at once. // Both 1 and 2 are possible at the same time. specialp := &amp;s.specials special := \*specialp for special != nil { // A finalizer can be set for an inner byte of an object, find object beginning. objIndex := uintptr(special.offset) / size p := s.base() + objIndex\*size mbits := s.markBitsForIndex(objIndex) if !mbits.isMarked() { // This object is not marked and has at least one special record. // Pass 1: see if it has at least one finalizer. hasFin := false endOffset := p - s.base() + size for tmp := special; tmp != nil &amp;&amp; uintptr(tmp.offset) &lt; endOffset; tmp = tmp.next { if tmp.kind == \_KindSpecialFinalizer { // Stop freeing of object if it has a finalizer. mbits.setMarkedNonAtomic() hasFin = true break } } // Pass 2: queue all finalizers \_or\_ handle profile record. for special != nil &amp;&amp; uintptr(special.offset) &lt; endOffset { // Find the exact byte for which the special was setup // (as opposed to object beginning). p := s.base() + uintptr(special.offset) if special.kind == \_KindSpecialFinalizer || !hasFin { // Splice out special record. y := special special = special.next \*specialp = special freespecial(y, unsafe.Pointer(p), size) } else { // This is profile record, but the object has finalizers (so kept alive). // Keep special record. specialp = &amp;special.next special = \*specialp } } } else { // object is still live: keep special record specialp = &amp;special.next special = \*specialp } } // 除错用 if debug.allocfreetrace != 0 || raceenabled || msanenabled { // Find all newly freed objects. This doesn&#39;t have to // efficient; allocfreetrace has massive overhead. mbits := s.markBitsForBase() abits := s.allocBitsForIndex(0) for i := uintptr(0); i &lt; s.nelems; i++ { if !mbits.isMarked() &amp;&amp; (abits.index &lt; s.freeindex || abits.isMarked()) { x := s.base() + i\*s.elemsize if debug.allocfreetrace != 0 { tracefree(unsafe.Pointer(x), size) } if raceenabled { racefree(unsafe.Pointer(x), size) } if msanenabled { msanfree(unsafe.Pointer(x), size) } } mbits.advance() abits.advance() } } // 计算释放的对象数量 // Count the number of free objects in this span. nalloc := uint16(s.countAlloc()) if spc.sizeclass() == 0 &amp;&amp; nalloc == 0 { // 如果span的类型是0(大对象)并且其中的对象已经不存活则释放到heap s.needzero = 1 freeToHeap = true } nfreed := s.allocCount - nalloc if nalloc &gt; s.allocCount { print(&quot;runtime: nelems=&quot;, s.nelems, &quot; nalloc=&quot;, nalloc, &quot; previous allocCount=&quot;, s.allocCount, &quot; nfreed=&quot;, nfreed, &quot;\\n&quot;) throw(&quot;sweep increased allocation count&quot;) } // 设置新的allocCount s.allocCount = nalloc // 判断span是否无未分配的对象 wasempty := s.nextFreeIndex() == s.nelems // 重置freeindex, 下次分配从0开始搜索 s.freeindex = 0 // reset allocation index to start of span. if trace.enabled { getg().m.p.ptr().traceReclaimed += uintptr(nfreed) \* s.elemsize } // gcmarkBits变为新的allocBits // 然后重新分配一块全部为0的gcmarkBits // 下次分配对象时可以根据allocBits得知哪些元素是未分配的 // gcmarkBits becomes the allocBits. // get a fresh cleared gcmarkBits in preparation for next GC s.allocBits = s.gcmarkBits s.gcmarkBits = newMarkBits(s.nelems) // 更新freeindex开始的allocCache // Initialize alloc bits cache. s.refillAllocCache(0) // 如果span中已经无存活的对象则更新sweepgen到最新 // 下面会把span加到mcentral或者mheap // We need to set s.sweepgen = h.sweepgen only when all blocks are swept, // because of the potential for a concurrent free/SetFinalizer. // But we need to set it before we make the span available for allocation // (return it to heap or mcentral), because allocation code assumes that a // span is already swept if available for allocation. if freeToHeap || nfreed == 0 { // The span must be in our exclusive ownership until we update sweepgen, // check for potential races. if s.state != mSpanInUse || s.sweepgen != sweepgen-1 { print(&quot;MSpan\_Sweep: state=&quot;, s.state, &quot; sweepgen=&quot;, s.sweepgen, &quot; mheap.sweepgen=&quot;, sweepgen, &quot;\\n&quot;) throw(&quot;MSpan\_Sweep: bad span state after sweep&quot;) } // Serialization point. // At this point the mark bits are cleared and allocation ready // to go so release the span. atomic.Store(&amp;s.sweepgen, sweepgen) } if nfreed &gt; 0 &amp;&amp; spc.sizeclass() != 0 { // 把span加到mcentral, res等于是否添加成功 c.local\_nsmallfree\[spc.sizeclass()\] += uintptr(nfreed) res = mheap\_.central\[spc\].mcentral.freeSpan(s, preserve, wasempty) // freeSpan会更新sweepgen // MCentral\_FreeSpan updates sweepgen } else if freeToHeap { // 把span释放到mheap // Free large span to heap // NOTE(rsc,dvyukov): The original implementation of efence // in CL 22060046 used SysFree instead of SysFault, so that // the operating system would eventually give the memory // back to us again, so that an efence program could run // longer without running out of memory. Unfortunately, // calling SysFree here without any kind of adjustment of the // heap data structures means that when the memory does // come back to us, we have the wrong metadata for it, either in // the MSpan structures or in the garbage collection bitmap. // Using SysFault here means that the program will run out of // memory fairly quickly in efence mode, but at least it won&#39;t // have mysterious crashes due to confused memory reuse. // It should be possible to switch back to SysFree if we also // implement and then call some kind of MHeap\_DeleteSpan. if debug.efence &gt; 0 { s.limit = 0 // prevent mlookup from finding this span sysFault(unsafe.Pointer(s.base()), size) } else { mheap\_.freeSpan(s, 1) } c.local\_nlargefree++ c.local\_largefree += size res = true } // 如果span未加到mcentral或者未释放到mheap, 则表示span仍在使用 if !res { // 把仍在使用的span加到sweepSpans的&quot;已清扫&quot;队列中 // The span has been swept and is still in-use, so put // it on the swept in-use list. mheap\_.sweepSpans\[sweepgen/2%2\].push(s) } return res }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从bgsweep和前面的分配器可以看出扫描阶段的工作是十分懒惰(lazy)的,\ 实际可能会出现前一阶段的扫描还未完成, 就需要开始新一轮的GC的情况,\ 所以每一轮GC开始之前都需要完成前一轮GC的扫描工作(Sweep Termination阶段). GC的整个流程都分析完毕了, 最后贴上写屏障函数[writebarrierptr](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L202" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L202</a>)的实现:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // NOTE: Really dst \*unsafe.Pointer, src unsafe.Pointer, // but if we do that, Go inserts a write barrier on \*dst = src. //go:nosplit func writebarrierptr(dst \*uintptr, src uintptr) { if writeBarrier.cgo { cgoCheckWriteBarrier(dst, src) } if !writeBarrier.needed { \*dst = src return } if src != 0 &amp;&amp; src &lt; minPhysPageSize { systemstack(func() { print(&quot;runtime: writebarrierptr \*&quot;, dst, &quot; = &quot;, hex(src), &quot;\\n&quot;) throw(&quot;bad pointer in write barrier&quot;) }) } // 标记指针 writebarrierptr\_prewrite1(dst, src) // 设置指针到目标 \*dst = src }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[writebarrierptr\_prewrite1](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L182" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L182</a>)函数如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // writebarrierptr\_prewrite1 invokes a write barrier for \*dst = src // prior to the write happening. // // Write barrier calls must not happen during critical GC and scheduler // related operations. In particular there are times when the GC assumes // that the world is stopped but scheduler related code is still being // executed, dealing with syscalls, dealing with putting gs on runnable // queues and so forth. This code cannot execute write barriers because // the GC might drop them on the floor. Stopping the world involves removing // the p associated with an m. We use the fact that m.p == nil to indicate // that we are in one these critical section and throw if the write is of // a pointer to a heap object. //go:nosplit func writebarrierptr\_prewrite1(dst \*uintptr, src uintptr) { mp := acquirem() if mp.inwb || mp.dying &gt; 0 { releasem(mp) return } systemstack(func() { if mp.p == 0 &amp;&amp; memstats.enablegc &amp;&amp; !mp.inwb &amp;&amp; inheap(src) { throw(&quot;writebarrierptr\_prewrite1 called with mp.p == nil&quot;) } mp.inwb = true gcmarkwb\_m(dst, src) }) mp.inwb = false releasem(mp) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[gcmarkwb\_m](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L142" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L142</a>)函数如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> func gcmarkwb\_m(slot \*uintptr, ptr uintptr) { if writeBarrier.needed { // Note: This turns bad pointer writes into bad // pointer reads, which could be confusing. We avoid // reading from obviously bad pointers, which should // take care of the vast majority of these. We could // patch this up in the signal handler, or use XCHG to // combine the read and the write. Checking inheap is // insufficient since we need to track changes to // roots outside the heap. // // Note: profbuf.go omits a barrier during signal handler // profile logging; that&#39;s safe only because this deletion barrier exists. // If we remove the deletion barrier, we&#39;ll have to work out // a new way to handle the profile logging. if slot1 := uintptr(unsafe.Pointer(slot)); slot1 &gt;= minPhysPageSize { if optr := \*slot; optr != 0 { // 标记旧指针 shade(optr) } } // TODO: Make this conditional on the caller&#39;s stack color. if ptr != 0 &amp;&amp; inheap(ptr) { // 标记新指针 shade(ptr) } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>[shade](<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1200" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1200</a>)函数如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> // Shade the object if it isn&#39;t already. // The object is not nil and known to be in the heap. // Preemption must be disabled. //go:nowritebarrier func shade(b uintptr) { if obj, hbits, span, objIndex := heapBitsForObject(b, 0, 0); obj != 0 { gcw := &amp;getg().m.p.ptr().gcw // 标记一个对象存活, 并把它加到标记队列(该对象变为灰色) greyobject(obj, 0, 0, hbits, span, gcw, objIndex) // 如果标记了禁止本地标记队列则flush到全局标记队列 if gcphase == \_GCmarktermination || gcBlackenPromptly { // Ps aren&#39;t allowed to cache work during mark // termination. gcw.dispose() } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="参考链接-https-github-com-golang-go-https-making-pusher-com-golangs-real-time-gc-in-theory-and-practice-https-github-com-golang-proposal-blob-master-design-17503-eliminate-rescan-md-https-golang-org-s-go15gcpacing-https-golang-org-ref-mem-https-talks-golang-org-2015-go-gc-pdf-https-docs-google-com-document-d-1etua2iomnaq4j81attgt40y4-jr6-idasekg0t0dbr8-edit-heading-h-x4kziklnb8fr-https-go-review-googlesource-com-c-go-21503-http-www-cnblogs-com-diegodu-p-5803202-html-http-legendtkl-com-2017-04-28-golang-gc-https-lengzzz-com-note-gc-in-golang-golang的gc和coreclr的gc对比-因为我之前已经对coreclr的gc做过分析-看-这一篇-http-www-cnblogs-com-zkweb-p-6379080-html-和-这一篇-http-www-cnblogs-com-zkweb-p-6625049-html-这里我可以简单的对比一下coreclr和go的gc实现-coreclr的对象带有类型信息-go的对象不带-而是通过bitmap区域记录哪些地方包含指针-coreclr分配对象的速度明显更快-go分配对象需要查找span和写入bitmap区域-coreclr的收集器需要做的工作比go多很多-coreclr不同大小的对象都会放在一个segment中-只能线性扫描-coreclr判断对象引用要访问类型信息-而go只需要访问bitmap-coreclr清扫时要一个个去标记为自由对象-而go只需要切换allocbits-coreclr的停顿时间比go要长-虽然coreclr支持并行gc-但是没有go彻底-go连扫描根对象都不需要完全停顿-coreclr支持分代gc-虽然full-gc时coreclr的效率不如go-但是coreclr可以在大部分时候只扫描第0和第1代的对象-因为支持分代gc-通常coreclr花在gc上的cpu时间会比go要少-coreclr的分配器和收集器通常比go要高效-也就是说coreclr会有更高的吞吐量-但coreclr的最大停顿时间不如go短-这是因为go的gc整个设计都是为了减少停顿时间-现在分布式计算和横向扩展越来越流行-比起追求单机吞吐量-追求低延迟然后让分布式解决吞吐量问题无疑是更明智的选择-go的设计目标使得它比其他语言都更适合编写网络服务程序-有疑问加站长微信联系-非本文作者-https-static-golangjob-cn-static-img-footer-png-imageview2-2-w-280" tabindex="-1"><a class="header-anchor" href="#参考链接-https-github-com-golang-go-https-making-pusher-com-golangs-real-time-gc-in-theory-and-practice-https-github-com-golang-proposal-blob-master-design-17503-eliminate-rescan-md-https-golang-org-s-go15gcpacing-https-golang-org-ref-mem-https-talks-golang-org-2015-go-gc-pdf-https-docs-google-com-document-d-1etua2iomnaq4j81attgt40y4-jr6-idasekg0t0dbr8-edit-heading-h-x4kziklnb8fr-https-go-review-googlesource-com-c-go-21503-http-www-cnblogs-com-diegodu-p-5803202-html-http-legendtkl-com-2017-04-28-golang-gc-https-lengzzz-com-note-gc-in-golang-golang的gc和coreclr的gc对比-因为我之前已经对coreclr的gc做过分析-看-这一篇-http-www-cnblogs-com-zkweb-p-6379080-html-和-这一篇-http-www-cnblogs-com-zkweb-p-6625049-html-这里我可以简单的对比一下coreclr和go的gc实现-coreclr的对象带有类型信息-go的对象不带-而是通过bitmap区域记录哪些地方包含指针-coreclr分配对象的速度明显更快-go分配对象需要查找span和写入bitmap区域-coreclr的收集器需要做的工作比go多很多-coreclr不同大小的对象都会放在一个segment中-只能线性扫描-coreclr判断对象引用要访问类型信息-而go只需要访问bitmap-coreclr清扫时要一个个去标记为自由对象-而go只需要切换allocbits-coreclr的停顿时间比go要长-虽然coreclr支持并行gc-但是没有go彻底-go连扫描根对象都不需要完全停顿-coreclr支持分代gc-虽然full-gc时coreclr的效率不如go-但是coreclr可以在大部分时候只扫描第0和第1代的对象-因为支持分代gc-通常coreclr花在gc上的cpu时间会比go要少-coreclr的分配器和收集器通常比go要高效-也就是说coreclr会有更高的吞吐量-但coreclr的最大停顿时间不如go短-这是因为go的gc整个设计都是为了减少停顿时间-现在分布式计算和横向扩展越来越流行-比起追求单机吞吐量-追求低延迟然后让分布式解决吞吐量问题无疑是更明智的选择-go的设计目标使得它比其他语言都更适合编写网络服务程序-有疑问加站长微信联系-非本文作者-https-static-golangjob-cn-static-img-footer-png-imageview2-2-w-280"><span>参考链接 <a href="https://github.com/golang/go%5C%5C" target="_blank" rel="noopener noreferrer">https://github.com/golang/go\\</a> <a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice%5C%5C" target="_blank" rel="noopener noreferrer">https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice\\</a> <a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md%5C%5C" target="_blank" rel="noopener noreferrer">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md\\</a> <a href="https://golang.org/s/go15gcpacing%5C%5C" target="_blank" rel="noopener noreferrer">https://golang.org/s/go15gcpacing\\</a> <a href="https://golang.org/ref/mem%5C%5C" target="_blank" rel="noopener noreferrer">https://golang.org/ref/mem\\</a> <a href="https://talks.golang.org/2015/go-gc.pdf%5C%5C" target="_blank" rel="noopener noreferrer">https://talks.golang.org/2015/go-gc.pdf\\</a> <a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4%5C%5C%5C_Jr6%5C%5C%5C_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr%5C%5C" target="_blank" rel="noopener noreferrer">https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4\\\_Jr6\\\_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr\\</a> <a href="https://go-review.googlesource.com/c/go/+/21503%5C%5C" target="_blank" rel="noopener noreferrer">https://go-review.googlesource.com/c/go/+/21503\\</a> <a href="http://www.cnblogs.com/diegodu/p/5803202.html%5C%5C" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/diegodu/p/5803202.html\\</a> <a href="http://legendtkl.com/2017/04/28/golang-gc%5C%5C" target="_blank" rel="noopener noreferrer">http://legendtkl.com/2017/04/28/golang-gc\\</a> <a href="https://lengzzz.com/note/gc-in-golang" target="_blank" rel="noopener noreferrer">https://lengzzz.com/note/gc-in-golang</a> # Golang的GC和CoreCLR的GC对比 因为我之前已经对CoreCLR的GC做过分析(看[这一篇](<a href="http://www.cnblogs.com/zkweb/p/6379080.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/zkweb/p/6379080.html</a>)和[这一篇](<a href="http://www.cnblogs.com/zkweb/p/6625049.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/zkweb/p/6625049.html</a>)), 这里我可以简单的对比一下CoreCLR和GO的GC实现: - CoreCLR的对象带有类型信息, GO的对象不带, 而是通过bitmap区域记录哪些地方包含指针 - CoreCLR分配对象的速度明显更快, GO分配对象需要查找span和写入bitmap区域 - CoreCLR的收集器需要做的工作比GO多很多 - CoreCLR不同大小的对象都会放在一个segment中, 只能线性扫描 - CoreCLR判断对象引用要访问类型信息, 而go只需要访问bitmap - CoreCLR清扫时要一个个去标记为自由对象, 而go只需要切换allocBits - CoreCLR的停顿时间比GO要长 - 虽然CoreCLR支持并行GC, 但是没有GO彻底, GO连扫描根对象都不需要完全停顿 - CoreCLR支持分代GC - 虽然Full GC时CoreCLR的效率不如GO, 但是CoreCLR可以在大部分时候只扫描第0和第1代的对象 - 因为支持分代GC, 通常CoreCLR花在GC上的CPU时间会比GO要少 CoreCLR的分配器和收集器通常比GO要高效, 也就是说CoreCLR会有更高的吞吐量.\ 但CoreCLR的最大停顿时间不如GO短, 这是因为GO的GC整个设计都是为了减少停顿时间. 现在分布式计算和横向扩展越来越流行,\ 比起追求单机吞吐量, 追求低延迟然后让分布式解决吞吐量问题无疑是更明智的选择,\ GO的设计目标使得它比其他语言都更适合编写网络服务程序. --- 有疑问加站长微信联系（非本文作者） ![](<a href="https://static.golangjob.cn/static/img/footer.png?imageView2/2/w/280" target="_blank" rel="noopener noreferrer">https://static.golangjob.cn/static/img/footer.png?imageView2/2/w/280</a>)</span></a></h1></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Cospk/edit/main/src/golang/原理/theory/Golang源码探索(三)-GC的实现原理.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2025/8/27 12:02:38</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: xie@gmail.com">shiwei</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%B8%80)-%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81.html" aria-label="Golang源码探索(一) 编译和调试源码"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Golang源码探索(一) 编译和调试源码</div></a><a class="route-link auto-link next" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%BA%8C)-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="Golang源码探索(二) 协程的实现原理"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Golang源码探索(二) 协程的实现原理<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 Cospk </div></footer></div><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/vuepress-app/assets/app-DIJDtupu.js" defer></script>
  </body>
</html>
