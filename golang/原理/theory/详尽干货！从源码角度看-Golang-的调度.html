<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.66" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://Cospk.github.io/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E5%B0%BD%E5%B9%B2%E8%B4%A7%EF%BC%81%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8B-Golang-%E7%9A%84%E8%B0%83%E5%BA%A6.html"><meta property="og:site_name" content="Golang全栈指南"><meta property="og:title" content="详尽干货！从源码角度看 Golang 的调度"><meta property="og:description" content="![](https://static.studygolang.com/190524/9443f32c3cd6d5088be29c21bc559373.jpg) > 桔妹导读：本章主要从源码角度针对Go调度相关进行分析，从进程的启动，到调度循环分析，再到分析几个常见runtime下的场景可以清晰的了解调度过程。本文仅关注linux系统下的逻辑。代码版本参..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-08-27T12:02:38.000Z"><meta property="article:modified_time" content="2025-08-27T12:02:38.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"详尽干货！从源码角度看 Golang 的调度","image":[""],"dateModified":"2025-08-27T12:02:38.000Z","author":[{"@type":"Person","name":"Cospk","url":"https://savvygo.cn"}]}</script><link rel="icon" href="/vuepress-app/favicon.svg"><title>详尽干货！从源码角度看 Golang 的调度 | Golang全栈指南</title><meta name="description" content="![](https://static.studygolang.com/190524/9443f32c3cd6d5088be29c21bc559373.jpg) > 桔妹导读：本章主要从源码角度针对Go调度相关进行分析，从进程的启动，到调度循环分析，再到分析几个常见runtime下的场景可以清晰的了解调度过程。本文仅关注linux系统下的逻辑。代码版本参...">
    <link rel="preload" href="/vuepress-app/assets/style-BU0LSV_n.css" as="style"><link rel="stylesheet" href="/vuepress-app/assets/style-BU0LSV_n.css">
    <link rel="modulepreload" href="/vuepress-app/assets/app-DIJDtupu.js"><link rel="modulepreload" href="/vuepress-app/assets/详尽干货！从源码角度看-Golang-的调度.html-BhvQcjtp.js"><link rel="modulepreload" href="/vuepress-app/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/vuepress-app/assets/index.html-BMYgyfDp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/portfolio.html-4bxlMBYl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.算法.html-CvQ1gy67.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.设计模式.html-oqIrtBe8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.规划.html-BTctlwB6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/git 规范.html-pOzt2Sya.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/git.html-ixPi_0Ze.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/markdown.html-Dy_QlVnL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/好物分享.html-B6NfvEM_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-8AQshAED.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/best-practice-template.html-BLs6dmQM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/reference-template.html-CRcAKI7_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/tutorial-template.html-DD31Wvmc.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/writing-standards.html-CYxaf07f.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-E7qiWZU4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Consul.html-D9i7V0zV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Docker.html-CALiwnXG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/GRPC.html-BDKbTmRI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Jaeger.html-DGQmYk9d.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kong.html-BY9r39zx.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kubernetes.html-rzGxnWd0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Nacos.html-CpWI1heb.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CqzJH2kl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Sentinel.html-QBl6g7n4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BQep9Ms_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-W0IZn2xO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html--HZ9Xv38.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BNzatcUR.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/网络基础.html-53H3D8RM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.use.html-BfZix_tO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.howWork.html-CL03OcGt.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-f8ivuiuF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CxO_qeK1.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-C-Cxe3ur.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/常用包大全.html-BWGXltvN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/01-介绍与安装.html-BLLTtCrI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/02-Hello-World.html-B4m4QWVp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/03-变量.html-DBpH8CZF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/04-类型.html-3lTaKrEX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/05-常量.html-Dem3SKBW.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/06-函数.html-TWV5xDWN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/07-包.html-Bb9b61PO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/08-if-else-语句.html-BKuKh2bl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/09-循环.html-xBYX8gSg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/10-switch-语句.html-DmGE68tD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/11-数组和切片.html-DrrlC8sJ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/12-可变参数函数.html-CVgsTexs.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/13-Maps.html-DcKwMN0L.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/14-字符串.html-D71PugAn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/15-指针.html-BQKNFZz4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/16-结构体.html-BR_npihr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/17-方法.html-Cea2EL0W.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/18-接口.html-5vpBAdeJ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/19-接口.html-IZQZkccS.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/20-并发入门.html-DFCOqalS.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/21-Go-协程.html-C7X86pID.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/22-信道.html-C5SZUNIN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/23-缓冲信道和工作池.html-Dw9yzm21.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/24-Select.html-BZRmoLwg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/25-Mutex.html-DlRLxIO0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/26-结构体取代类.html-Cb0CQeQI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/27-组合取代继承.html-D-1lRcAm.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/28-多态.html-D5cES2MF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/29-Defer.html-BTOlmwqG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/30-错误处理.html--URdZGOa.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/31-自定义错误.html-qjjG4dD1.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/32-panic-和-recover.html-C__hWiny.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/33-函数是一等公民.html-CKtAIjCE.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/34-反射.html-gT_ubIYV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/35-读取文件.html-Dim6lJth.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/36-写入文件.html-DMMy5Akp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-Ce4QncUh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.interface.html-Bcwpxkz_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/10.cgo.html-Cc3IBgZh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/11.pprof.html-B1TBiF-S.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/12.followUp.html-ChgosObn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.generic.html-t9F8JkZ-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/3.reflect.html-CsqwkGQg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/4.types.html-DTz3KnZN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/5.error.html-CYyqf_8g.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/6.file.html-IQGOyJmj.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/7.concurrency.html-DWHb7NV7.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/8.module.html-D1WyiQU-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/9.test.html-BDgM0J0K.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CpG6FWU3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/notes.html-B6gucJy2.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/test.html-D2d8EnW4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.基础语法.html-iIWzYafk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.进阶原理.html-83xh_rnD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-wT1nHTio.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/大厂面试题.html-Dwwv4_YP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/对象池.html-CbIFXFAU.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/极智天下.html-CUbP6xEh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/面试题（答案）.html-DcUI8xsg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Elasticsearch-Go.html-DH3iL3t-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Elasticsearch.html-Dbqk6yba.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MYSQL高级.html-DjU99qc2.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MongoDB-Go.html-LC00SqHY.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MongoDB.html-BsiiWKPF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MySQL-Go.html-BP44ICxm.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/MySQL.html-DvFuWdDI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-No9QF5uf.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Redis-Go.html-68Ve0Bms.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Redis.html-COY3AC-z.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/EMQX.html-Z2ULNNu9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kafka1.html-CIwYmfIl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kafka_go.html-BtHi9Ay4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CoyHYM4r.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/RocketMQ.html-DKnvI3P9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/kafka.html-C45XgCVY.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kong.html-CFRTKV3Q.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Nginx.html-DobIArYS.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-C_myC_ON.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Docker-Do.html-CAeX33hD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Docker.html-CrfPN4Ea.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Jenkins.html-D7fd_zxG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Kubernetes.html-CiCaNrju.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-D3i7y_nz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/kubernetes-Do.html-Mn8O0iYA.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/casbin.html-CmdXnvo-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.use.html-mGGwb0Xs.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.howWork.html-BPbATKWp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BDiG7Sa9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.use.html-CFS7SGEx.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.howWork.html-CWMWUGai.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-M11fprN-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-KksFQ35C.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Zap.html-cSNtc6K9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/用户认证选型.html-D8ZbBlYF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/监控.html-CblSNQ5X.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.intro.html-BiC5KbBB.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-V-gxjtkQ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/encode.html-DULShIO4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/flag.html-BNP6mLKg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/http.html-Ds7Bn6Dh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/log.html-Bi8nr_fy.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/math.html-BRgtQXkC.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/net.html-Cez-sJPL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/sort.html-B-_PynF9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/strconv.html-D9aq_0ge.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/strings.html-BEBdT1VN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/template.html-CDhZ4T2L.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/time.html-B2s7biyE.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/unicode.html-KfTwaqW3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/unsafe.html-Ck5rncWr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/0.runtime.html-U_tTe_nE.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/1.并发.html-B3G74HKx.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/2.数据结构.html-zwbg06cB.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/3.错误处理.html-CdT9wDTr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/GC-的认识.html-OPEMhhHh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/GO-中的调度：第三部分---并发.html-CDUpX-uL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Channel的实现.html-mcjtDZL8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-GC.html-XyX71R-p.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Hashmap内存布局和实现.html-CEaCfe5Y.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Modules-终极入门.html-Dg9PFqQr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Select的实现.html-B83V5ZdL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-Slice与String内存布局和实现.html-DjzVnYMo.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-work-stealing-调度器.html-yoXF58Gm.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-中的垃圾回收：第一部分---基础.html-DtW8VjA8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-内存管理.html-BjEWhmRz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-内存管理之二.html-CR15EHul.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-内存逃逸详细分析.html-DVPlddTO.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-函数调用惯例.html-_ZCeAlFf.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-反射与interface拾遗.html-Dbd8kK8e.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-垃圾回收.html-C1kvG1yM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-垃圾回收：第二部分---GC-追踪.html-B0G6QDGf.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-执行追踪器（execution-tracer）.html-9tss-d8y.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-方法调用与接口.html-DErdsZ4B.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-的调度器追踪.html-ekQk2krk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-笔记之如何防止-goroutine-泄露.html-B1dU8GVD.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-笔记之如何防止-goroutine-泄露（二）.html-CyBRGTsl.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言-Channel-实现原理精要.html-Dk44jpBB.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言-for-和-range-的实现.html-B70zygT9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言数组和切片的原理.html-BL11UMTM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言机制之内存剖析（Language-Mechanics-On-Memory-Profiling）.html-Dr15sYk2.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言机制之栈和指针.html-OIXWOgUo.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言机制之逃逸分析（Language-Mechanics-On-Escape-Analysis）.html-BSwrK1hN.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言汇编快速入门.html-DsM55op-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言的内存管理.html-d6UUqBKY.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-语言编译过程概述.html-DLcEQVB_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-调优技术.html-52kbwzM7.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-逃逸分析的缺陷.html-CMuBeG6r.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go-问答之如何阅读-Go-源码.html-D3lneojF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go1.13-defer-的性能是如何提高的？.html-DzeL2P07.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang---调度剖析【第一部分】.html-T60WRdbu.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang---调度剖析【第二部分】.html-DgywT52V.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang-socket数据结构.html-BZRKzByu.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang-如何进行类型检查.html-DjB_4Qzk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程栈初始化.html-Bm7ULxn_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程栈概述.html-BKvkbs6k.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程调度(一)-协程状态.html-BNQjQpr3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程调度二：协程切换原理.html-CH3A2Pa7.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang协程调度的数据结构.html-CM1oAeM0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang源码探索(一)-编译和调试源码.html-OvSovgtG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang源码探索(三)-GC的实现原理.html-Djtfq-R-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang源码探索(二)-协程的实现原理.html-C1ggllGC.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang网络-核心API实现剖析(一).html-MbpxjV-6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Golang网络-核心API实现剖析二).html-BmNJSqym.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Goroutine浅析.html-gPcMscr4.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go内存分配那些事，就这么简单！.html-CY_BAQuP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go语言反射规则---The-Laws-of-Reflection.html-gtslJpvI.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go语言高阶：调度器系列（1）起源.html-W5S_pgny.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go语言黑魔法.html-DWMaldmK.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go调度器系列（2）宏观看调度器.html-BUfXps1o.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go调度器系列（3）图解调度原理.html-kLevRq4C.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go调度器系列（4）源码阅读与探索.html-CGkhLWiX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Go：Goroutine-与抢占机制.html-DEz2luQA.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/Map-在-Go-runtime-中的高效实现（不使用范型）.html-CN1qlXMF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-t221nlib.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/译_-Go-代码诊断工具集合-官方文档.html-D5JYZVD8.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/channel的使用及源码解析.html-D-E0EJqW.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang--详解interface和nil.html-D2NnwzvL.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang-内存分析-动态追踪.html-D1PgABt6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang-汇编.html-C5JkJXWp.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/golang进阶(八)——隐藏技能go-linkname.html-3Wpc2ByX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/go语言死循环分析.html-BlhVjuG6.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/也谈goroutine调度器.html-Db8YaWQ3.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/从底层理解-Golang-的-map-实现.html-Cc6H9Gsg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/从源码角度看Golang的TCP-Socket(epoll)实现.html-eRToSxUU.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/从源码讲解-golang-内存分配.html-Cq-0auHr.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/使用-pprof-和火焰图调试-golang-应用.html-BUm1tgut.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/关于Go-GC---Rick's-ISMM-keynote.html-DdixLGB9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程栈扩容.html-DWyUpq-d.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程调度时机一：系统调用.html-C-aZ3nPz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程调度时机三：抢占式调度.html-BH2eGRDR.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/协程调度时机二：Channel读写.html-Dz_tb5Nv.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/可视化-Go-语言中的并发.html-HCljW16V.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go-select语句原理.html-Dztyjg7r.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go内存分配器.html-BWsJxDrt.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go语言内存分配.html-ChUszE5D.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解Go运行时调度器.html-BkDtbip9.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/图解goroutine调度.html-Dv2bwlc0.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/如何定位-golang-进程-hang-死的-bug.html-DCjilOiP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/实战Go内存泄露.html-1TNR3pHn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/弄懂goroutine调度原理.html-2nEHifzV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/指令集架构、机器码与-Go-语言.html-CAFmUQdV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/浅谈-Go-语言-select-的实现原理.html-C52XPpw5.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解-sync.RWMutex：解决读者-写者问题.html-CPGlhi7p.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解Go-1.9-sync.Map.html-DaQ344IU.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解Go-runtime.SetFinalizer原理剖析.html-DhOTa3w1.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解Go-sync.Map原理剖析.html-VrIOj1-G.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入理解channel：设计_源码.html-oh9QVAot.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深入解析-Go-中-Slice-底层实现.html-apCSB3Bz.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之-scheduler.html-psf_2qRb.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之Slice.html-CTTj4nep.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之map.html-CtmTnWIX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之关于-interface-的-10-个问题.html-H47yPP0k.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/深度解密Go语言之反射.html-CJDtYFGn.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/源码剖析golang中sync.Mutex.html-d55t4S9U.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/理解-Golang-中函数调用的原理.html-C9Ym7Sqh.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/理解-Golang-哈希表-Map-的原理.html-LNxTujTg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/用-GODEBUG-看调度跟踪.html-DPvw46lX.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/解剖Go语言map底层实现.html-BfSUQpmG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/解析器眼中的-Go-语言.html-sEjiXwkQ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/记一次获得3倍性能的go程序优化实践，及on-cpu-off-cpu火焰图的使用.html-BLt9mJCF.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/详解-Golang-中间代码生成.html-BeBBaRGG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/详解Go语言的内存模型及堆的分配管理.html-BNhhPUH_.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/谈-Golang-中的字符串和字节数组.html-D10O968i.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/通过-profiling-定位-golang-性能问题---内存篇.html-CBANHs19.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/404.html-DwQc1sng.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-BN7RFqTj.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-DJN8LopR.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-Bihu4_9d.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CklNBwjM.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-CaPKmAAG.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index.html-Dhk06VLP.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/flowchart-CTwbLKUk.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index-izhIXQi-.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index-DRWmbcXV.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/index-B2Pezylg.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/mermaid.esm.min-Bf9uIE2x.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/photoswipe.esm-GXRgw7eJ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/giscus-BZxmVUME.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/SearchResult-mpXxa_JZ.js" as="script"><link rel="prefetch" href="/vuepress-app/assets/setupDevtools-7MC2TMWH-DpbXT7rC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/vuepress-app/" aria-label="带我回家"><img class="vp-nav-logo light" src="/vuepress-app/log.svg" alt><img class="vp-nav-logo dark" src="/vuepress-app/logDark.svg" alt><span class="vp-site-name hide-in-pad">Golang全栈指南</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/vuepress-app/" aria-label="首页"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="golang"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>golang<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/%E5%9F%BA%E7%A1%80/" aria-label="Go基础"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-eraser" style=""></span><!--]-->Go基础<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/%E8%BF%9B%E9%98%B6/" aria-label="Go进阶"><!--[--><img class="icon" src="/vuepress-app/assets/icon/up.png" alt aria-hidden no-view style=""><!--]-->Go进阶<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/" aria-label="原理"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-gears" style=""></span><!--]-->原理<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/web%E6%A1%86%E6%9E%B6/" aria-label="框架"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-sitemap" style=""></span><!--]-->框架<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/golang/%E9%9D%A2%E8%AF%95/" aria-label="面试"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-feather" style=""></span><!--]-->面试<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="中间件"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-layer-group" style=""></span>中间件<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html" aria-label="MySql"><!--[--><img class="icon" src="/vuepress-app/assets/icon/mysql.png" alt aria-hidden no-view style=""><!--]-->MySql<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html" aria-label="Redis"><!--[--><img class="icon" src="/vuepress-app/assets/icon/redis.png" alt aria-hidden no-view style=""><!--]-->Redis<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB.html" aria-label="MongoDB"><!--[--><img class="icon" src="/vuepress-app/assets/icon/mongodb.png" alt aria-hidden no-view style=""><!--]-->MongoDB<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E6%B6%88%E6%81%AF%E7%BB%84%E4%BB%B6/kafka.html" aria-label="kafka"><!--[--><img class="icon" src="/vuepress-app/assets/icon/Kafka.png" alt aria-hidden no-view style=""><!--]-->kafka<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E7%BD%91%E5%85%B3/Nginx.html" aria-label="Nginx"><!--[--><img class="icon" src="/vuepress-app/assets/icon/Nginx.png" alt aria-hidden no-view style=""><!--]-->Nginx<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E8%BF%90%E7%BB%B4/Docker.html" aria-label="Docker"><!--[--><img class="icon" src="/vuepress-app/assets/icon/docker.png" alt aria-hidden no-view style=""><!--]-->Docker<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/middleware/%E8%BF%90%E7%BB%B4/Kubernetes.html" aria-label="Kubernetes"><!--[--><img class="icon" src="/vuepress-app/assets/icon/kubernetes.png" alt aria-hidden no-view style=""><!--]-->Kubernetes<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="架构"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-network-wired" style=""></span>架构<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" aria-label="微服务"><!--[--><img class="icon" src="/vuepress-app/assets/icon/micro.png" alt aria-hidden no-view style=""><!--]-->微服务<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E5%88%86%E5%B8%83%E5%BC%8F/" aria-label="分布式"><!--[--><img class="icon" src="/vuepress-app/assets/icon/kubernetes.png" alt aria-hidden no-view style=""><!--]-->分布式<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E9%AB%98%E5%8F%AF%E7%94%A8/" aria-label="高可用"><!--[--><img class="icon" src="/vuepress-app/assets/icon/available.png" alt aria-hidden no-view style=""><!--]-->高可用<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/framework/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/" aria-label="领域驱动"><!--[--><img class="icon" src="/vuepress-app/assets/icon/DDD.png" alt aria-hidden no-view style=""><!--]-->领域驱动<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="计算机"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-computer" style=""></span>计算机<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/%E7%BD%91%E7%BB%9C/" aria-label="计算机网络"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-globe" style=""></span><!--]-->计算机网络<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" aria-label="操作系统"><!--[--><img class="icon" src="/vuepress-app/assets/icon/linux.png" alt aria-hidden no-view style=""><!--]-->操作系统<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/0.%E7%AE%97%E6%B3%95.html" aria-label="常用算法"><!--[--><img class="icon" src="/vuepress-app/assets/icon/arithmetic.png" alt aria-hidden no-view style=""><!--]-->常用算法<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/computer/1.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="设计模式"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-ruler" style=""></span><!--]-->设计模式<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="好物分享"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-share-nodes" style=""></span>好物分享<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/share/%E5%A5%BD%E7%89%A9%E5%88%86%E4%BA%AB.html" aria-label="好物分享"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-share-nodes" style=""></span><!--]-->好物分享<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/vuepress-app/share/git.html" aria-label="git"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-git-alt" style=""></span><!--]-->git<!----></a></li></ul></button></div></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Cospk" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="slimsearch-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="slimsearch-placeholder">搜索</div><div class="slimsearch-key-hints"><kbd class="slimsearch-key">Ctrl</kbd><kbd class="slimsearch-key">K</kbd></div></button><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-database" style=""></span><span class="vp-sidebar-title">GORM框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-server" style=""></span><span class="vp-sidebar-title">Web框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-gears" style=""></span><span class="vp-sidebar-title">原理</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html" aria-label="常用包和第三方包介绍"><!---->常用包和第三方包介绍<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-gear" style=""></span><span class="vp-sidebar-title">实现原理</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/0.runtime.html" aria-label="Runtime"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->Runtime<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="内置数据结构"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->内置数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/1.%E5%B9%B6%E5%8F%91.html" aria-label="并发"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/3.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html" aria-label="错误"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span><!--]-->错误<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%91_-Go-%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.html" aria-label="&quot;&quot;[译] Go 代码诊断工具集合-官方文档&quot;&quot;"><!---->&quot;&quot;[译] Go 代码诊断工具集合-官方文档&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang--%E8%AF%A6%E8%A7%A3interface%E5%92%8Cnil.html" aria-label="&quot;&quot;golang: 详解interface和nil&quot;&quot;"><!---->&quot;&quot;golang: 详解interface和nil&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6(%E4%B8%80)-%E5%8D%8F%E7%A8%8B%E7%8A%B6%E6%80%81.html" aria-label="&quot;&quot;Golang协程调度(一):协程状态&quot;&quot;"><!---->&quot;&quot;Golang协程调度(一):协程状态&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90(%E4%B8%80).html" aria-label="&quot;&quot;Golang网络:核心API实现剖析(一)&quot;&quot;"><!---->&quot;&quot;Golang网络:核心API实现剖析(一)&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E7%BD%91%E7%BB%9C-%E6%A0%B8%E5%BF%83API%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90%E4%BA%8C).html" aria-label="&quot;&quot;Golang网络:核心API实现剖析二)&quot;&quot;"><!---->&quot;&quot;Golang网络:核心API实现剖析二)&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang%E8%BF%9B%E9%98%B6(%E5%85%AB)%E2%80%94%E2%80%94%E9%9A%90%E8%97%8F%E6%8A%80%E8%83%BDgo-linkname.html" aria-label="&quot;&quot;golang进阶(八)——隐藏技能go:linkname&quot;&quot;"><!---->&quot;&quot;golang进阶(八)——隐藏技能go:linkname&quot;&quot;<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/channel%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html" aria-label="channel的使用及源码解析"><!---->channel的使用及源码解析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/GC-%E7%9A%84%E8%AE%A4%E8%AF%86.html" aria-label="GC 的认识"><!---->GC 的认识<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Channel%E7%9A%84%E5%AE%9E%E7%8E%B0.html" aria-label="Go Channel的实现"><!---->Go Channel的实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-GC.html" aria-label="Go GC"><!---->Go GC<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Hashmap%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0.html" aria-label="Go Hashmap内存布局和实现"><!---->Go Hashmap内存布局和实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Modules-%E7%BB%88%E6%9E%81%E5%85%A5%E9%97%A8.html" aria-label="Go Modules 终极入门"><!---->Go Modules 终极入门<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Select%E7%9A%84%E5%AE%9E%E7%8E%B0.html" aria-label="Go Select的实现"><!---->Go Select的实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-Slice%E4%B8%8EString%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0.html" aria-label="Go Slice与String内存布局和实现"><!---->Go Slice与String内存布局和实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-work-stealing-%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="Go work-stealing 调度器"><!---->Go work-stealing 调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86---%E5%9F%BA%E7%A1%80.html" aria-label="Go 中的垃圾回收：第一部分 - 基础"><!---->Go 中的垃圾回收：第一部分 - 基础<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/GO-%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%9A%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86---%E5%B9%B6%E5%8F%91.html" aria-label="GO 中的调度：第三部分 - 并发"><!---->GO 中的调度：第三部分 - 并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" aria-label="Go 内存管理"><!---->Go 内存管理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E4%BA%8C.html" aria-label="Go 内存管理之二"><!---->Go 内存管理之二<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.html" aria-label="Go 内存逃逸详细分析"><!---->Go 内存逃逸详细分析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B.html" aria-label="Go 函数调用惯例"><!---->Go 函数调用惯例<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%8F%8D%E5%B0%84%E4%B8%8Einterface%E6%8B%BE%E9%81%97.html" aria-label="Go 反射与interface拾遗"><!---->Go 反射与interface拾遗<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html" aria-label="Go 垃圾回收"><!---->Go 垃圾回收<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86---GC-%E8%BF%BD%E8%B8%AA.html" aria-label="Go 垃圾回收：第二部分 - GC 追踪"><!---->Go 垃圾回收：第二部分 - GC 追踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E6%89%A7%E8%A1%8C%E8%BF%BD%E8%B8%AA%E5%99%A8%EF%BC%88execution-tracer%EF%BC%89.html" aria-label="Go 执行追踪器（execution tracer）"><!---->Go 执行追踪器（execution tracer）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3.html" aria-label="Go 方法调用与接口"><!---->Go 方法调用与接口<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E8%BF%BD%E8%B8%AA.html" aria-label="Go 的调度器追踪"><!---->Go 的调度器追踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-goroutine-%E6%B3%84%E9%9C%B2.html" aria-label="Go 笔记之如何防止 goroutine 泄露"><!---->Go 笔记之如何防止 goroutine 泄露<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-goroutine-%E6%B3%84%E9%9C%B2%EF%BC%88%E4%BA%8C%EF%BC%89.html" aria-label="Go 笔记之如何防止 goroutine 泄露（二）"><!---->Go 笔记之如何防止 goroutine 泄露（二）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80-Channel-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%B2%BE%E8%A6%81.html" aria-label="Go 语言 Channel 实现原理精要"><!---->Go 语言 Channel 实现原理精要<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80-for-%E5%92%8C-range-%E7%9A%84%E5%AE%9E%E7%8E%B0.html" aria-label="Go 语言 for 和 range 的实现"><!---->Go 语言 for 和 range 的实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%8E%9F%E7%90%86.html" aria-label="Go 语言数组和切片的原理"><!---->Go 语言数组和切片的原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%86%85%E5%AD%98%E5%89%96%E6%9E%90%EF%BC%88Language-Mechanics-On-Memory-Profiling%EF%BC%89.html" aria-label="Go 语言机制之内存剖析（Language Mechanics On Memory Profiling）"><!---->Go 语言机制之内存剖析（Language Mechanics On Memory Profiling）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%A0%88%E5%92%8C%E6%8C%87%E9%92%88.html" aria-label="Go 语言机制之栈和指针"><!---->Go 语言机制之栈和指针<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E4%B9%8B%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%88Language-Mechanics-On-Escape-Analysis%EF%BC%89.html" aria-label="Go 语言机制之逃逸分析（Language Mechanics On Escape Analysis）"><!---->Go 语言机制之逃逸分析（Language Mechanics On Escape Analysis）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html" aria-label="Go 语言汇编快速入门"><!---->Go 语言汇编快速入门<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" aria-label="Go 语言的内存管理"><!---->Go 语言的内存管理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0.html" aria-label="Go 语言编译过程概述"><!---->Go 语言编译过程概述<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E8%B0%83%E4%BC%98%E6%8A%80%E6%9C%AF.html" aria-label="Go 调优技术"><!---->Go 调优技术<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E7%BC%BA%E9%99%B7.html" aria-label="Go 逃逸分析的缺陷"><!---->Go 逃逸分析的缺陷<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go-%E9%97%AE%E7%AD%94%E4%B9%8B%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB-Go-%E6%BA%90%E7%A0%81.html" aria-label="Go 问答之如何阅读 Go 源码"><!---->Go 问答之如何阅读 Go 源码<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%EF%BC%9AGoroutine-%E4%B8%8E%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6.html" aria-label="Go：Goroutine 与抢占机制"><!---->Go：Goroutine 与抢占机制<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go1.13-defer-%E7%9A%84%E6%80%A7%E8%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%9A%84%EF%BC%9F.html" aria-label="Go1.13 defer 的性能是如何提高的？"><!---->Go1.13 defer 的性能是如何提高的？<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang---%E8%B0%83%E5%BA%A6%E5%89%96%E6%9E%90%E3%80%90%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E3%80%91.html" aria-label="Golang - 调度剖析【第一部分】"><!---->Golang - 调度剖析【第一部分】<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang---%E8%B0%83%E5%BA%A6%E5%89%96%E6%9E%90%E3%80%90%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E3%80%91.html" aria-label="Golang - 调度剖析【第二部分】"><!---->Golang - 调度剖析【第二部分】<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang-socket%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="Golang socket数据结构"><!---->Golang socket数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA.html" aria-label="golang 内存分析/动态追踪"><!---->golang 内存分析/动态追踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.html" aria-label="Golang 如何进行类型检查"><!---->Golang 如何进行类型检查<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/golang-%E6%B1%87%E7%BC%96.html" aria-label="golang 汇编"><!---->golang 汇编<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96.html" aria-label="Golang协程栈初始化"><!---->Golang协程栈初始化<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E6%A0%88%E6%A6%82%E8%BF%B0.html" aria-label="Golang协程栈概述"><!---->Golang协程栈概述<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%BA%8C%EF%BC%9A%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86.html" aria-label="Golang协程调度二：协程切换原理"><!---->Golang协程调度二：协程切换原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="Golang协程调度的数据结构"><!---->Golang协程调度的数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%B8%80)-%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81.html" aria-label="Golang源码探索(一) 编译和调试源码"><!---->Golang源码探索(一) 编译和调试源码<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%B8%89)-GC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="Golang源码探索(三) GC的实现原理"><!---->Golang源码探索(三) GC的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Golang%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2(%E4%BA%8C)-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="Golang源码探索(二) 协程的实现原理"><!---->Golang源码探索(二) 协程的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Goroutine%E6%B5%85%E6%9E%90.html" aria-label="Goroutine浅析"><!---->Goroutine浅析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81.html" aria-label="Go内存分配那些事，就这么简单！"><!---->Go内存分配那些事，就这么简单！<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99---The-Laws-of-Reflection.html" aria-label="Go语言反射规则 - The Laws of Reflection"><!---->Go语言反射规则 - The Laws of Reflection<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/go%E8%AF%AD%E8%A8%80%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%88%86%E6%9E%90.html" aria-label="go语言死循环分析"><!---->go语言死循环分析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E9%98%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E8%B5%B7%E6%BA%90.html" aria-label="Go语言高阶：调度器系列（1）起源"><!---->Go语言高阶：调度器系列（1）起源<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%AF%AD%E8%A8%80%E9%BB%91%E9%AD%94%E6%B3%95.html" aria-label="Go语言黑魔法"><!---->Go语言黑魔法<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%E5%AE%8F%E8%A7%82%E7%9C%8B%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="Go调度器系列（2）宏观看调度器"><!---->Go调度器系列（2）宏观看调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%E5%9B%BE%E8%A7%A3%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86.html" aria-label="Go调度器系列（3）图解调度原理"><!---->Go调度器系列（3）图解调度原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Go%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E6%8E%A2%E7%B4%A2.html" aria-label="Go调度器系列（4）源码阅读与探索"><!---->Go调度器系列（4）源码阅读与探索<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/Map-%E5%9C%A8-Go-runtime-%E4%B8%AD%E7%9A%84%E9%AB%98%E6%95%88%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9E%8B%EF%BC%89.html" aria-label="Map 在 Go runtime 中的高效实现（不使用范型）"><!---->Map 在 Go runtime 中的高效实现（不使用范型）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%B9%9F%E8%B0%88goroutine%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="也谈goroutine调度器"><!---->也谈goroutine调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3-Golang-%E7%9A%84-map-%E5%AE%9E%E7%8E%B0.html" aria-label="从底层理解 Golang 的 map 实现"><!---->从底层理解 Golang 的 map 实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BGolang%E7%9A%84TCP-Socket(epoll)%E5%AE%9E%E7%8E%B0.html" aria-label="从源码角度看Golang的TCP Socket(epoll)实现"><!---->从源码角度看Golang的TCP Socket(epoll)实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3-golang-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html" aria-label="从源码讲解 golang 内存分配"><!---->从源码讲解 golang 内存分配<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E4%BD%BF%E7%94%A8-pprof-%E5%92%8C%E7%81%AB%E7%84%B0%E5%9B%BE%E8%B0%83%E8%AF%95-golang-%E5%BA%94%E7%94%A8.html" aria-label="使用 pprof 和火焰图调试 golang 应用"><!---->使用 pprof 和火焰图调试 golang 应用<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%85%B3%E4%BA%8EGo-GC---Rick&#39;s-ISMM-keynote.html" aria-label="关于Go GC - Rick&#39;s ISMM keynote"><!---->关于Go GC - Rick&#39;s ISMM keynote<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E6%A0%88%E6%89%A9%E5%AE%B9.html" aria-label="协程栈扩容"><!---->协程栈扩容<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%80%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html" aria-label="协程调度时机一：系统调用"><!---->协程调度时机一：系统调用<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%B8%89%EF%BC%9A%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.html" aria-label="协程调度时机三：抢占式调度"><!---->协程调度时机三：抢占式调度<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E4%BA%8C%EF%BC%9AChannel%E8%AF%BB%E5%86%99.html" aria-label="协程调度时机二：Channel读写"><!---->协程调度时机二：Channel读写<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%8F%AF%E8%A7%86%E5%8C%96-Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91.html" aria-label="可视化 Go 语言中的并发"><!---->可视化 Go 语言中的并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go-select%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86.html" aria-label="图解Go select语句原理"><!---->图解Go select语句原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3goroutine%E8%B0%83%E5%BA%A6.html" aria-label="图解goroutine调度"><!---->图解goroutine调度<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8.html" aria-label="图解Go内存分配器"><!---->图解Go内存分配器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html" aria-label="图解Go语言内存分配"><!---->图解Go语言内存分配<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%9B%BE%E8%A7%A3Go%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8.html" aria-label="图解Go运行时调度器"><!---->图解Go运行时调度器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D-golang-%E8%BF%9B%E7%A8%8B-hang-%E6%AD%BB%E7%9A%84-bug.html" aria-label="如何定位 golang 进程 hang 死的 bug"><!---->如何定位 golang 进程 hang 死的 bug<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%AE%9E%E6%88%98Go%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html" aria-label="实战Go内存泄露"><!---->实战Go内存泄露<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E5%BC%84%E6%87%82goroutine%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86.html" aria-label="弄懂goroutine调度原理"><!---->弄懂goroutine调度原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E4%B8%8E-Go-%E8%AF%AD%E8%A8%80.html" aria-label="指令集架构、机器码与 Go 语言"><!---->指令集架构、机器码与 Go 语言<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B5%85%E8%B0%88-Go-%E8%AF%AD%E8%A8%80-select-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="浅谈 Go 语言 select 的实现原理"><!---->浅谈 Go 语言 select 的实现原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-sync.RWMutex%EF%BC%9A%E8%A7%A3%E5%86%B3%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98.html" aria-label="深入理解 sync.RWMutex：解决读者-写者问题"><!---->深入理解 sync.RWMutex：解决读者-写者问题<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3channel%EF%BC%9A%E8%AE%BE%E8%AE%A1_%E6%BA%90%E7%A0%81.html" aria-label="深入理解channel：设计+源码"><!---->深入理解channel：设计+源码<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-1.9-sync.Map.html" aria-label="深入理解Go 1.9 sync.Map"><!---->深入理解Go 1.9 sync.Map<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-runtime.SetFinalizer%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" aria-label="深入理解Go-runtime.SetFinalizer原理剖析"><!---->深入理解Go-runtime.SetFinalizer原理剖析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-sync.Map%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" aria-label="深入理解Go-sync.Map原理剖析"><!---->深入理解Go-sync.Map原理剖析<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Go-%E4%B8%AD-Slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html" aria-label="深入解析 Go 中 Slice 底层实现"><!---->深入解析 Go 中 Slice 底层实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B-scheduler.html" aria-label="深度解密Go语言之 scheduler"><!---->深度解密Go语言之 scheduler<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8Bmap.html" aria-label="深度解密Go语言之map"><!---->深度解密Go语言之map<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8BSlice.html" aria-label="深度解密Go语言之Slice"><!---->深度解密Go语言之Slice<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%85%B3%E4%BA%8E-interface-%E7%9A%84-10-%E4%B8%AA%E9%97%AE%E9%A2%98.html" aria-label="深度解密Go语言之关于 interface 的 10 个问题"><!---->深度解密Go语言之关于 interface 的 10 个问题<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8F%8D%E5%B0%84.html" aria-label="深度解密Go语言之反射"><!---->深度解密Go语言之反射<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90golang%E4%B8%ADsync.Mutex.html" aria-label="源码剖析golang中sync.Mutex"><!---->源码剖析golang中sync.Mutex<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E7%90%86%E8%A7%A3-Golang-%E4%B8%AD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86.html" aria-label="理解 Golang 中函数调用的原理"><!---->理解 Golang 中函数调用的原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E7%90%86%E8%A7%A3-Golang-%E5%93%88%E5%B8%8C%E8%A1%A8-Map-%E7%9A%84%E5%8E%9F%E7%90%86.html" aria-label="理解 Golang 哈希表 Map 的原理"><!---->理解 Golang 哈希表 Map 的原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E7%94%A8-GODEBUG-%E7%9C%8B%E8%B0%83%E5%BA%A6%E8%B7%9F%E8%B8%AA.html" aria-label="用 GODEBUG 看调度跟踪"><!---->用 GODEBUG 看调度跟踪<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%A7%A3%E5%89%96Go%E8%AF%AD%E8%A8%80map%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html" aria-label="解剖Go语言map底层实现"><!---->解剖Go语言map底层实现<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9C%BC%E4%B8%AD%E7%9A%84-Go-%E8%AF%AD%E8%A8%80.html" aria-label="解析器眼中的 Go 语言"><!---->解析器眼中的 Go 语言<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%BE%973%E5%80%8D%E6%80%A7%E8%83%BD%E7%9A%84go%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%8F%8Aon-cpu-off-cpu%E7%81%AB%E7%84%B0%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8.html" aria-label="记一次获得3倍性能的go程序优化实践，及on-cpu/off-cpu火焰图的使用"><!---->记一次获得3倍性能的go程序优化实践，及on-cpu/off-cpu火焰图的使用<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E5%B0%BD%E5%B9%B2%E8%B4%A7%EF%BC%81%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8B-Golang-%E7%9A%84%E8%B0%83%E5%BA%A6.html" aria-label="详尽干货！从源码角度看 Golang 的调度"><!---->详尽干货！从源码角度看 Golang 的调度<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E8%A7%A3-Golang-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.html" aria-label="详解 Golang 中间代码生成"><!---->详解 Golang 中间代码生成<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%A0%86%E7%9A%84%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86.html" aria-label="详解Go语言的内存模型及堆的分配管理"><!---->详解Go语言的内存模型及堆的分配管理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%B0%88-Golang-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84.html" aria-label="谈 Golang 中的字符串和字节数组"><!---->谈 Golang 中的字符串和字节数组<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E9%80%9A%E8%BF%87-profiling-%E5%AE%9A%E4%BD%8D-golang-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98---%E5%86%85%E5%AD%98%E7%AF%87.html" aria-label="通过 profiling 定位 golang 性能问题 - 内存篇"><!---->通过 profiling 定位 golang 性能问题 - 内存篇<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><span class="vp-sidebar-title">标准库</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-eraser" style=""></span><span class="vp-sidebar-title">基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><img class="icon" src="/vuepress-app/assets/icon/up.png" alt aria-hidden no-view style=""><span class="vp-sidebar-title">进阶</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">面试</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->详尽干货！从源码角度看 Golang 的调度</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://savvygo.cn" target="_blank" rel="noopener noreferrer">Cospk</a></span><span property="author" content="Cospk"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025年8月26日</span><meta property="datePublished" content="2025-08-26T10:06:47.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 42 分钟</span><meta property="timeRequired" content="PT42M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color2" role>Go原理教程</span><!--]--><meta property="articleSection" content="Go原理教程"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc" vp-toc><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#runtime-schedinit-sb-调度相关的一些初始化">runtime.schedinit(SB)调度相关的一些初始化</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content" vp-content><p>![](<a href="https://static.studygolang.com/190524/9443f32c3cd6d5088be29c21bc559373.jpg" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/9443f32c3cd6d5088be29c21bc559373.jpg</a>) &gt; 桔妹导读：本章主要从源码角度针对Go调度相关进行分析，从进程的启动，到调度循环分析，再到分析几个常见runtime下的场景可以清晰的了解调度过程。本文仅关注linux系统下的逻辑。代码版本参考 Go1.9.2。 源码备注可以在此找到：<a href="https://github.com/thinkboy/gosrc-reader/tree/master/runtime" target="_blank" rel="noopener noreferrer">https://github.com/thinkboy/gosrc-reader/tree/master/runtime</a> --- ## 阅读索引 1. 简单概念 - 1.1 调度器的三个抽象概念：G、M、P - 1.2 调度的大致轮廓 2. 进程启动时都做了什么 - 2.1 runtime.osinit(SB)方法针对系统环境的初始化 - 2.2 runtime.schedinit(SB)调度相关的一些初始化 - 2.3 runtime·mainPC(SB)启动监控任务 3. 调度循环都做了什么 - 3.1 调度器如何开启调度循环 - 3.2 调度器如何进行调度循环 - 3.3 多个线程下如何调度 4. 调度循环中如何让出 CPU - 4.1 执行完成让出CPU - 4.2 主动让出CPU - 4.3 抢占让出CPU - 4.4 系统调用让出CPU 5. 待执行 G 的来源 - 5.1 go func 创建G - 5.2 epoll来源 6. 看几个主动让出CPU的场景 - 6.1 time.Sleep - 6.2 sync.Mutex - 6.3 channel ## 简单概念 ### 调度器的三个抽象概念：G、M、P - G：代表一个 goroutine，每个 goroutine 都有自己独立的栈存放当前的运行内存及状态。可以把一个 G 当做一个任务。 - M: 代表内核线程(Pthread)，它本身就与一个内核线程进行绑定，goroutine 运行在 M 上。 - P：代表一个处理器，可以认为一个“有运行任务”的P占了一个CPU线程的资源，且只要处于调度的时候就有P。 注：内核线程和 CPU 线程的区别，在系统里可以有上万个内核线程，但 CPU 线程并没有那么多，CPU 线程也就是 Top 命令里看到的 CPU0、CPU1、CPU2......的数量。(Go 语言中文网注释：就是 CPU 核心数，包括超线程的，用 CPU 线程总感觉特别奇怪。） 三者关系大致如下图： ![](<a href="https://static.studygolang.com/190524/73dbfaae9e6fbf94fcbb0f90db56a58e.jpg" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/73dbfaae9e6fbf94fcbb0f90db56a58e.jpg</a>) 图1、图2代表2个有运行任务时的状态。M 与一个内核线程绑定，可运行的 goroutine 列表存放到P里面，然后占用了一个CPU线程来运行。 图3代表没有运行任务时的状态，M 依然与一个内核线程绑定，由于没有运行任务因此不占用 CPU 线程，同时也不占用P。 ### 调度的大致轮廓 ![](<a href="https://static.studygolang.com/190526/6c28ca553fa01ea792c4f73a2133c5e0.png" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190526/6c28ca553fa01ea792c4f73a2133c5e0.png</a>) 图中表述了由 go func 触发的调度。先创建M通过M启动调度循环，然后调度循环过程中获取G来执行，执行过程中遇到图中 running G 后面几个 case 再次进入下一循环。 下面从程序启动、调度循环、G的来��三个角度分析调度的实现。 ## 启动时都做了什么？ 下面先看一段程序启动的代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>asm // runtime/asm\_amd64.s TEXT runtime·rt0\_go(SB),NOSPLIT,$0 ......此处省略N多代码...... ok: // set the per-goroutine and per-mach &quot;registers&quot; get\_tls(BX) // 将 g0 放到 tls(thread local storage)里 LEAQ runtime·g0(SB), CX MOVQ CX, g(BX) LEAQ runtime·m0(SB), AX // save m-&gt;g0 = g0 // 将全局M0与全局G0绑定 MOVQ CX, m\_g0(AX) // save m0 to g0-&gt;m MOVQ AX, g\_m(CX) CLD // convention is D is always left cleared CALL runtime·check(SB) MOVL 16(SP), AX // copy argc MOVL AX, 0(SP) MOVQ 24(SP), AX // copy argv MOVQ AX, 8(SP) CALL runtime·args(SB) // 解析命令行参数 CALL runtime·osinit(SB) // 只初始化了CPU核数 CALL runtime·schedinit(SB) // 内存分配器、栈、P、GC回收器等初始化 // create a new goroutine to start program MOVQ $runtime·mainPC(SB), AX // PUSHQ AX PUSHQ $0 // arg size CALL runtime·newproc(SB) // 创建一个新的G来启动runtime.main POPQ AX POPQ AX // start this M CALL runtime·mstart(SB) // 启动M0,开始等待空闲G,正式进入调度循环 MOVL $0xf1, 0xf1 // crash RET</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在启动过程里主要做了这三个事情(这里只跟调度相关的)： - 初始化固定数量的P - 创建一个新的G来启动 runtime.main, 也就是 runtime 下的 main 方法 - 创建全局 M0、全局 G0，启动 M0 进入第一个调度循环 &gt; M0 是什么？程序里会启动多个 M，第一个启动的叫 M0。 &gt; &gt; G0 是什么？G 分三种，第一种是执行用户任务的叫做 G，第二种执行 runtime 下调度工作的叫G0，每个M都绑定一个G0。第三种则是启动 runtime.main 用到的G。写程序接触到的基本都是第一种 我们按照顺序看是怎么完成上面三个事情的。 ### runtime.osinit(SB)方法针对系统环境的初始化 这里实质只做了一件事情，就是获取 CPU 的线程数，也就是 Top 命令里看到的 CPU0、CPU1、CPU2......的数量。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/os\_linux.go func osinit() { ncpu = getproccount() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="runtime-schedinit-sb-调度相关的一些初始化" tabindex="-1"><a class="header-anchor" href="#runtime-schedinit-sb-调度相关的一些初始化"><span>runtime.schedinit(SB)调度相关的一些初始化</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go // 设置最大M数量 sched.maxmcount = 10000 // 初始化当前M,即全局M0 mcommoninit(\_g\_.m) // 查看应该启动的P数量，默认为cpu core数. // 如果设置了环境变量GOMAXPROCS则以环境变量为准,最大不得超过\_MaxGomaxprocs(1024)个 procs := ncpu if n, ok := atoi32(gogetenv(&quot;GOMAXPROCS&quot;)); ok &amp;&amp; n &gt; 0 { procs = n } if procs &gt; \_MaxGomaxprocs { procs = \_MaxGomaxprocs } // 调整P数量，此时由于是初始化阶段，所以P都是新建的 if procresize(procs) != nil { throw(&quot;unknown runnable goroutine during bootstrap&quot;) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 sched.maxmcount 设置了M最大的数量，而M代表的是系统内核线程，因此可以认为一个进程最大只能启动10000个系统线程。 procresize 初始化P的数量，procs 参数为初始化的数量，而在初始化之前先做数量的判断，默认是 ncpu(与CPU核数相等)。也可以通过环境变量 GOMAXPROCS 来控制P的数量。`_MaxGomaxprocs` 控制了最大的P数量只能是1024。 &gt; 有些人在进程初始化的时候经常用到 runtime.GOMAXPROCS() 方法，其实也是调用的 procresize 方法重新设置了最大 CPU 使用数量。 ### runtime·mainPC(SB) 启动监控任务</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go // The main goroutine. func main() { ...... // 启动后台监控 systemstack(func() { newm(sysmon, nil) }) ...... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 runtime 下会启动一个全程运行的监控任务，该任务用于标记抢占执行过长时间的 G，以及���测 epoll 里面是否有可执行的G。下面会详细说到。 ### 最后 runtime·mstart(SB) 启动调度循环 前面都是各种初始化操作，在这里开启了调度器的第一个调度循环。(这里启动的M就是M0) 下面来围绕G、M、P三个概念介绍 Goroutine 调度循环的运作流程。 ## 调度循环都做了什么 ![](<a href="https://static.studygolang.com/190524/e9558cf1ca499dd5f0894ce77dd6360c.jpg" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/e9558cf1ca499dd5f0894ce77dd6360c.jpg</a>) 图1代表M启动的过程，把M跟一个P绑定在一起。在程序初始化的过程中说到在进程启动的最后一步启动了第一个M(即M0)，这个M从全局的空闲P列表里拿到一个P，然后与其绑定。而P里面有2个管理G的链表(runq 存储等待运行的G列表，gfree 存储空闲的G列表)，M启动后等待可执行的G。 图2代表创建 G 的过程。创建完一个G先扔到当前P的 runq 待运行队列里。在图3的执行过程里，M从绑定的P的 runq 列表里获取一个G来执行。当执行完成后，图4的流程里把 G 扔到 gfree 队列里。注意此时G并没有销毁(只重置了G的栈以及状态)，当再次创建G的时候优先从 gfree 列表里获取，这样就起到了复用G的作用，避免反复与系统交互创建内存。 M 启动后处于一个自循环状态，执行完一个 G 之后继续执行下一个 G，反复上面的图2~图4过程。当第一个 M 正在繁忙而又有新的G需要执行时，会再开启一个 M 来执行。 下面详细看下调度循环的实现。 ### 调度器如何开启调度循环 先看一下 M 的启动过程（M0 启动是个特殊的启动过程，也是第一个启动的 M，由汇编实现的初始化后启动，而后续的 M 创建以及启动则是 Go 代码实现）。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func startm(\_p\_ \*p, spinning bool) { lock(&amp;sched.lock) if \_p\_ == nil { // 从空闲P里获取一个 \_p\_ = pidleget() ...... } // 获取一个空闲的m mp := mget() unlock(&amp;sched.lock) // 如果没有空闲M，则new一个 if mp == nil { var fn func() if spinning { // The caller incremented nmspinning, so set m.spinning in the new M. fn = mspinning } newm(fn, \_p\_) return } ...... // 唤醒M notewakeup(&amp;mp.park) } func newm(fn func(), \_p\_ \*p) { // 创建一个M对象,且与P关联 mp := allocm(\_p\_, fn) // 暂存P mp.nextp.set(\_p\_) mp.sigmask = initSigmask ...... execLock.rlock() // Prevent process clone. // 创建系统内核线程 newosproc(mp, unsafe.Pointer(mp.g0.stack.hi)) execLock.runlock() } // runtime/os\_linux.go func newosproc(mp \*m, stk unsafe.Pointer) { // Disable signals during clone, so that the new thread starts // with signals disabled. It will enable them in minit. var oset sigset sigprocmask(\_SIG\_SETMASK, &amp;sigset\_all, &amp;oset) ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart))) sigprocmask(\_SIG\_SETMASK, &amp;oset, nil) } func allocm(\_p\_ \*p, fn func()) \*m { ...... mp := new(m) mp.mstartfn = fn // 设置启动函数 mcommoninit(mp) // 初始化m // 创建g0 // In case of cgo or Solaris, pthread\_create will make us a stack. // Windows and Plan 9 will layout sched stack on OS stack. if iscgo || GOOS == &quot;solaris&quot; || GOOS == &quot;windows&quot; || GOOS == &quot;plan9&quot; { mp.g0 = malg(-1) } else { mp.g0 = malg(8192 \* sys.StackGuardMultiplier) } // 把新创建的g0与M做关联 mp.g0.m = mp ...... return mp } func mstart() { ...... mstart1() } func mstart1() { ...... // 进入调度循环(阻塞不返回) schedule() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>非 M0 的启动首先从 startm 方法开始启动，要进行调度工作必须有调度处理器 P，因此先从空闲的 P 链表里获取一个 P，在 newm 方法创建一个 M 与 P 绑定。 newm 方法中通过 newosproc 新建一个内核线程，并把内核线程与 M 以及 mstart 方法进行关联，这样内核线程执行时就可以找到 M 并且找到启动调度循环的方法。最后 schedule 启动调度循环 &gt; allocm 方法中创建 M 的同时创建了一个 G 与自己关联，这个 G 就是我们在上面说到的 g0。为什么 M 要关联一个 g0？因为 runtime 下执行一个 G 也需要用到栈空间来完成调度工作，而拥有执行栈的地方只有G，因此需要为每个执行线程里配置一个g0。 ### 调度器如何进行调度循环 调用 schedule 进入调度器的调度循环后，在这个方法里永远不再返回。下面看下实现。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func schedule() { \_g\_ := getg() // 进入gc MarkWorker 工作模式 if gp == nil &amp;&amp; gcBlackenEnabled != 0 { gp = gcController.findRunnableGCWorker(\_g\_.m.p.ptr()) } if gp == nil { // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other. // 每处理n个任务就去全局队列获取G任务,确保公平 if \_g\_.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 { lock(&amp;sched.lock) gp = globrunqget(\_g\_.m.p.ptr(), 1) unlock(&amp;sched.lock) } } // 从P本地获取 if gp == nil { gp, inheritTime = runqget(\_g\_.m.p.ptr()) if gp != nil &amp;&amp; \_g\_.m.spinning { throw(&quot;schedule: spinning with local work&quot;) } } // 从其它地方获取G,如果获取不到则沉睡M，并且阻塞在这里，直到M被再次使用 if gp == nil { gp, inheritTime = findrunnable() // blocks until work is available } ...... // 执行找到的G execute(gp, inheritTime) } // 从P本地获取一个可运行的G func runqget(\_p\_ \*p) (gp \*g, inheritTime bool) { // If there&#39;s a runnext, it&#39;s the next G to run. // 优先从runnext里获取一个G，如果没有则从runq里获取 for { next := \_p\_.runnext if next == 0 { break } if \_p\_.runnext.cas(next, 0) { return next.ptr(), true } } // 从队头获取 for { h := atomic.Load(&amp;\_p\_.runqhead) // load-acquire, synchronize with other consumers t := \_p\_.runqtail if t == h { return nil, false } gp := \_p\_.runq\[h%uint32(len(\_p\_.runq))\].ptr() if atomic.Cas(&amp;\_p\_.runqhead, h, h+1) { // cas-release, commits consume return gp, false } } } // 从其它地方获取G func findrunnable() (gp \*g, inheritTime bool) { ...... // 从本地队列获取 if gp, inheritTime := runqget(\_p\_); gp != nil { return gp, inheritTime } // 全局队列获取 if sched.runqsize != 0 { lock(&amp;sched.lock) gp := globrunqget(\_p\_, 0) unlock(&amp;sched.lock) if gp != nil { return gp, false } } // 从epoll里取 if netpollinited() &amp;&amp; sched.lastpoll != 0 { if gp := netpoll(false); gp != nil { // non-blocking ...... return gp, false } } ...... // 尝试4次从别的P偷 for i := 0; i &lt; 4; i++ { for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() { if sched.gcwaiting != 0 { goto top } stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g // 在这里开始针对P进行偷取操作 if gp := runqsteal(\_p\_, allp\[enum.position()\], stealRunNextG); gp != nil { return gp, false } } } } // 尝试从全局runq中获取G // 在&quot;sched.runqsize/gomaxprocs + 1&quot;、&quot;max&quot;、&quot;len(\_p\_.runq))/2&quot;三个数字中取最小的数字作为获取的G数量 func globrunqget(\_p\_ \*p, max int32) \*g { if sched.runqsize == 0 { return nil } n := sched.runqsize/gomaxprocs + 1 if n &gt; sched.runqsize { n = sched.runqsize } if max &gt; 0 &amp;&amp; n &gt; max { n = max } if n &gt; int32(len(\_p\_.runq))/2 { n = int32(len(\_p\_.runq)) / 2 } sched.runqsize -= n if sched.runqsize == 0 { sched.runqtail = 0 } gp := sched.runqhead.ptr() sched.runqhead = gp.schedlink n-- for ; n &gt; 0; n-- { gp1 := sched.runqhead.ptr() sched.runqhead = gp1.schedlink runqput(\_p\_, gp1, false) // 放到本地P里 } return gp }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>schedule 中首先尝试从 P 本地队列中获取(runqget)一个可执行的 G，如果没有则从其它地方获取(findrunnable)，最终通过 execute 方法执行 G。 runqget 先通过 runnext 拿到待运行 G，没有的话，再从 runq 里面取。 findrunnable 从全局队列、epoll、别的 P 里获取。(后面会扩展分析实现) 在调度的开头处还做了一个小优化：每处理一些任务之后，就优先从全局队列里获取任务，以保障公平性，防止由于每个P里的 G 过多，而全局队列里的任务一直得不到执行机会。 &gt; 这里用到了一个关键方法 getg()，runtime 的代码里大量使用该方法，它由汇编实现，该方法就是获取当前要运行的 G，具体实现不再这里阐述。 ### 多个线程下如何调度 抛出一个问题：每个 P 里面的 G 执行时间是不可控的，如果多个 P 同时在执行，会不会出现有的 P 里面的 G 执行不完，有的 P 里面几乎没有 G 可执行呢？ 这就要从 M 的自循环过程中如何获取 G、归还 G 的行为说起了，先看图： ![](<a href="https://static.studygolang.com/190524/d469b57a53827213f7cd0f4b4e2abf15.jpg" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/d469b57a53827213f7cd0f4b4e2abf15.jpg</a>) 图中可以看出有两种途径：1.借助全局队列 sched.runq 作为中介，本地 P 里的 G 太多的话就放全局里，G 太少的话就从全局取。2.全局列表里没有的话直接从 P1 里偷取(steal)。(更多 M 在执行的话，同样的原理，这里就只拿 2 个来举例) \*\* 第 1 种途径实现如下：\*\*</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func runqput(\_p\_ \*p, gp \*g, next bool) { if randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%2 == 0 { next = false } // 尝试把 G 添加到 P 的 runnext 节点，这里确保runnext只有一个G，如果之前已经有一个G则踢出来放到runq里 if next { retryNext: oldnext := \_p\_.runnext if !\_p\_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } // 把老的g踢出来，在下面放到runq里 gp = oldnext.ptr() } retry: // 如果\_p\_.runq队列不满，则放到队尾就结束了。 // 试想如果不放到队尾而放到队头里会怎样？如果频繁的创建G则可能后面的G总是不被执行，对后面的G不公平 h := atomic.Load(&amp;\_p\_.runqhead) // load-acquire, synchronize with consumers t := \_p\_.runqtail if t-h &lt; uint32(len(\_p\_.runq)) { \_p\_.runq\[t%uint32(len(\_p\_.runq))\].set(gp) atomic.Store(&amp;\_p\_.runqtail, t+1) // store-release, makes the item available for consumption return } //如果队列满了，尝试把G和当前P里的一部分runq放到全局队列 //因为操作全局需要加锁,所以名字里带个slow if runqputslow(\_p\_, gp, h, t) { return } // the queue is not full, now the put above must succeed goto retry } func runqputslow(\_p\_ \*p, gp \*g, h, t uint32) bool { var batch \[len(\_p\_.runq)/2 + 1\]\*g // First, grab a batch from local queue. n := t - h n = n / 2 if n != uint32(len(\_p\_.runq)/2) { throw(&quot;runqputslow: queue is not full&quot;) } // 从runq头部开始取出一半的runq放到临时变量batch里 for i := uint32(0); i &lt; n; i++ { batch\[i\] = \_p\_.runq\[(h+i)%uint32(len(\_p\_.runq))\].ptr() } if !atomic.Cas(&amp;\_p\_.runqhead, h, h+n) { // cas-release, commits consume return false } // 把要put的g也放进batch去 batch\[n\] = gp if randomizeScheduler { for i := uint32(1); i &lt;= n; i++ { j := fastrandn(i + 1) batch\[i\], batch\[j\] = batch\[j\], batch\[i\] } } // 把取出来的一半runq组成链表 for i := uint32(0); i &lt; n; i++ { batch\[i\].schedlink.set(batch\[i+1\]) } // 将一半的runq放到global队列里,一次多转移一些省得转移频繁 lock(&amp;sched.lock) globrunqputbatch(batch\[0\], batch\[n\], int32(n+1)) unlock(&amp;sched.lock) return true } func globrunqputbatch(ghead \*g, gtail \*g, n int32) { gtail.schedlink = 0 if sched.runqtail != 0 { sched.runqtail.ptr().schedlink.set(ghead) } else { sched.runqhead.set(ghead) } sched.runqtail.set(gtail) sched.runqsize += n }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>runqput 方法归还执行完的 G，runq 定义是 runq\[256]guintptr，有固定的长度，因此当前 P 里的待运行 G 超过 256 的时候说明过多了，则执行 runqputslow 方法把一半 G 扔给全局 G 链表，globrunqputbatch 连接全局链表的头尾指针。 但可能别的 P 里面并没有超过 256，就不会放到全局 G 链表里，甚至可能一直维持在不到256个。这就借助第 2 个途径了： \*\* 第 2 种途径实现如下：\*\*</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go // 从其它地方获取G func findrunnable() (gp \*g, inheritTime bool) { ...... // 尝试4次从别的P偷 for i := 0; i &lt; 4; i++ { for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() { if sched.gcwaiting != 0 { goto top } stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g // 在这里开始针对P进行偷取操作 if gp := runqsteal(\_p\_, allp\[enum.position()\], stealRunNextG); gp != nil { return gp, false } } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从别的P里面&quot;偷取&quot;一些 G 过来执行了。runqsteal 方法实现了&quot;偷取&quot;操作。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go // 偷取P2一半到本地运行队列，失败则返回nil func runqsteal(\_p\_, p2 \*p, stealRunNextG bool) \*g { t := \_p\_.runqtail n := runqgrab(p2, &amp;\_p\_.runq, t, stealRunNextG) if n == 0 { return nil } n-- // 返回尾部的一个G gp := \_p\_.runq\[(t+n)%uint32(len(\_p\_.runq))\].ptr() if n == 0 { return gp } h := atomic.Load(&amp;\_p\_.runqhead) // load-acquire, synchronize with consumers if t-h+n &gt;= uint32(len(\_p\_.runq)) { throw(&quot;runqsteal: runq overflow&quot;) } atomic.Store(&amp;\_p\_.runqtail, t+n) // store-release, makes the item available for consumption return gp } // 从P里获取一半的G,放到batch里 func runqgrab(\_p\_ \*p, batch \*\[256\]guintptr, batchHead uint32, stealRunNextG bool) uint32 { for { // 计算一半的数量 h := atomic.Load(&amp;\_p\_.runqhead) // load-acquire, synchronize with other consumers t := atomic.Load(&amp;\_p\_.runqtail) // load-acquire, synchronize with the producer n := t - h n = n - n/2 ...... // 将偷到的任务转移到本地P队列里 for i := uint32(0); i &lt; n; i++ { g := \_p\_.runq\[(h+i)%uint32(len(\_p\_.runq))\] batch\[(batchHead+i)%uint32(len(batch))\] = g } if atomic.Cas(&amp;\_p\_.runqhead, h, h+n) { // cas-release, commits consume return n } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面可以看出从别的 P 里面偷(steal)了一半，这样就足够运行了。有了“偷取”操作也就充分利用了多线程的资源。 ## 调度循环中如何让出 CPU ### 正常完成让出 CPU 绝大多数场景下我们程序都是执行完一个 G，再执行另一个 G，那我们就看下 G 是如何被执行以及执行完如何退出的。 先看 G 如何被执行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func execute(gp \*g, inheritTime bool) { \_g\_ := getg() casgstatus(gp, \_Grunnable, \_Grunning) ...... // 真正的执行G，切换到该G的栈帧上执行（汇编实现） gogo(&amp;gp.sched) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>execute 方法先更改 G 的状态为 `_Grunning` 表示运行中，最终给 gogo 方法做实际的执行操作。而 gogo 方法则是汇编实现。再来看下 gogo 方法的实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>asm // runtime.asm\_amd64.s TEXT runtime·gogo(SB), NOSPLIT, $16-8 MOVQ buf+0(FP), BX // gobuf 把0偏移的8个字节给BX寄存器, gobuf结构的前8个字节就是SP指针 // If ctxt is not nil, invoke deletion barrier before overwriting. MOVQ gobuf\_ctxt(BX), AX // 在把gobuf的ctxt变量给AX寄存器 TESTQ AX, AX // 判断AX寄存器是否为空,传进来gp.sched的��肯定不为空了,因此JZ nilctxt不跳转 JZ nilctxt LEAQ gobuf\_ctxt(BX), AX MOVQ AX, 0(SP) MOVQ $0, 8(SP) CALL runtime·writebarrierptr\_prewrite(SB) MOVQ buf+0(FP), BX nilctxt: // 下面则是函数栈的BP SP指针移动，最后进入到指定的代码区域 MOVQ gobuf\_g(BX), DX MOVQ 0(DX), CX // make sure g != nil get\_tls(CX) MOVQ DX, g(CX) MOVQ gobuf\_sp(BX), SP // restore SP MOVQ gobuf\_ret(BX), AX MOVQ gobuf\_ctxt(BX), DX MOVQ gobuf\_bp(BX), BP MOVQ $0, gobuf\_sp(BX) // clear to help garbage collector MOVQ $0, gobuf\_ret(BX) MOVQ $0, gobuf\_ctxt(BX) MOVQ $0, gobuf\_bp(BX) MOVQ gobuf\_pc(BX), BX // PC指针指向退出时要执行的函数地址 JMP BX // 跳转到执行代码处</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/runtime2.go type gobuf struct { // The offsets of sp, pc, and g are known to (hard-coded in) libmach. // // ctxt is unusual with respect to GC: it may be a // heap-allocated funcval so write require a write barrier, // but gobuf needs to be cleared from assembly. We take // advantage of the fact that the only path that uses a // non-nil ctxt is morestack. As a result, gogo is the only // place where it may not already be nil, so gogo uses an // explicit write barrier. Everywhere else that resets the // gobuf asserts that ctxt is already nil. sp uintptr pc uintptr g guintptr ctxt unsafe.Pointer // this has to be a pointer so that gc scans it ret sys.Uintreg lr uintptr bp uintptr // for GOEXPERIMENT=framepointer }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>gogo 方法传的参数注意是 gp.sched，而这个结构体里可以看到保存了熟悉的函数栈寄存器 SP/PC/BP，能想到是把执行栈传了进去(既然是执行一个 G，当然要把执行栈传进去了)。可以看到在 gogo 函数中实质就只是做了函数栈指针的移动。 这个执行 G 的操作，熟悉函数调用的函数栈的基本原理的人想必有些印象(如果不熟悉请自行搜索)，执行一个 G 其实就是执行函数一样切换到对应的函数栈帧上。 C 语言里栈帧创建的时候有个 IP 寄存器指向&quot;return address&quot;，即主调函数的一条指令的地址，被调函数退出的时候通过该指针回到调用函数里。在 Go 语言里有个 PC 寄存器指向退出函数。那么下 PC 寄存器指向的是哪里？我们回到创建 G 的地方看下代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func newproc1(fn \*funcval, argp \*uint8, narg int32, nret int32, callerpc uintptr) \*g { ...... // 从当前P里面复用一个空闲G newg := gfget(\_p\_) // 如果没有空闲G则新建一个,默认栈大小为\_StackMin=2048 bytes if newg == nil { newg = malg(\_StackMin) casgstatus(newg, \_Gidle, \_Gdead) // 把新创建的G添加到全局allg里 allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack. } ...... newg.sched.sp = sp newg.stktopsp = sp newg.sched.pc = funcPC(goexit) + sys.PCQuantum // 记录当前任务的pc寄存器为goexit方法，用于当执行G结束后找到退出方法，从而再次进入调度循环 // +PCQuantum so that previous instruction is in same function newg.sched.g = guintptr(unsafe.Pointer(newg)) gostartcallfn(&amp;newg.sched, fn) newg.gopc = callerpc newg.startpc = fn.fn ....... return newg }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>代码中可以看到，给 G 的执行环境里的 pc 变量赋值了一个 goexit 的函数地址，也就是说G正常执行完退出时执行的是 goexit 函数。再看下该函数的实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>asm // runtime/asm\_amd64.s // The top-most function running on a goroutine // returns to goexit+PCQuantum. TEXT runtime·goexit(SB),NOSPLIT,$0-0 BYTE $0x90 // NOP CALL runtime·goexit1(SB) // does not return // traceback from goexit1 must hit code range of goexit BYTE $0x90 // NOP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go // G执行结束后回到这里放到P的本地队列里 func goexit1() { if raceenabled { racegoend() } if trace.enabled { traceGoEnd() } // 切换到g0来��放G mcall(goexit0) } // g0下当G执行结束后回到这里放到P的本地队列里 func goexit0(gp \*g) { ...... gfput(\_g\_.m.p.ptr(), gp) schedule() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>代码中切换到了 G0 下执行了 schedule 方法，再次进入了下一轮调度循环。 以上就是正常执行一个 G 并正常退出的实现。 ### 主动让出 CPU 在实际场景中还有一些没有执行完成的 G，而又需要临时停止执行，比如 time.Sleep、IO 阻塞等等，就需要挂起该 G，把 CPU 让出给别人使用。在 runtime 下面有个 gopark 方法，看下实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func gopark(unlockf func(\*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason string, traceEv byte, traceskip int) { mp := acquirem() gp := mp.curg status := readgstatus(gp) if status != \_Grunning &amp;&amp; status != \_Gscanrunning { throw(&quot;gopark: bad g status&quot;) } mp.waitlock = lock mp.waitunlockf = \*(\*unsafe.Pointer)(unsafe.Pointer(&amp;unlockf)) gp.waitreason = reason mp.waittraceev = traceEv mp.waittraceskip = traceskip releasem(mp) // can&#39;t do anything that might move the G between Ms here. // mcall 在M里从当前正在运行的G切换到g0 // park\_m 在切换到的g0下先把传过来的G切换为\_Gwaiting状态挂起该G // 调用回调函数waitunlockf()由外层决定是否等待解锁，返回true则等待解锁不再执行G，返回false则不等待解锁继续执行 mcall(park\_m) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/stubs.go // mcall switches from the g to the g0 stack and invokes fn(g), // where g is the goroutine that made the call. // mcall saves g&#39;s current PC/SP in g-&gt;sched so that it can be restored later. ...... func mcall(fn func(\*g))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func park\_m(gp \*g) { \_g\_ := getg() // 此处获得的是g0,而不是gp if trace.enabled { traceGoPark(\_g\_.m.waittraceev, \_g\_.m.waittraceskip) } casgstatus(gp, \_Grunning, \_Gwaiting) dropg() // 把g0从M的&quot;当前运行&quot;里剥离出来 if \_g\_.m.waitunlockf != nil { fn := \*(\*func(\*g, unsafe.Pointer) bool)(unsafe.Pointer(&amp;\_g\_.m.waitunlockf)) ok := fn(gp, \_g\_.m.waitlock) \_g\_.m.waitunlockf = nil \_g\_.m.waitlock = nil if !ok { // 如果不需要等待解锁，则切换到\_Grunnable状态并直接执行G if trace.enabled { traceGoUnpark(gp, 2) } casgstatus(gp, \_Gwaiting, \_Grunnable) execute(gp, true) // Schedule it back, never returns. } } schedule() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>gopark 是进行调度出让 CPU 资源的方法，里面有个方法 mcall()，注释里这样描述： &gt; 从当前运行的 G 切换到 g0 的运行栈上，然后调用 fn(g)，这里被调用的 G 是调用 mcall 方法时的G。mcall 方法保存当前运行的 G 的 PC/SP 到 `g-&gt;sched` 里，因此该 G 可以在以后被重新恢复执行。 在本章开始介绍初始化过程中有提到 M 创建的时候绑定了一个 g0，调度工作是运行在 g0 的栈上的。mcall 方法通过 g0 先把当前调用的 G 的执行栈暂存到 `g-&gt;sched` 变量里，然后切换到 g0 的执行栈上执行 park\_m。park\_m 方法里把 gp 的状态从 \_Grunning 切换到 \_Gwaiting 表明进入到等待唤醒状态，此时休眠 G 的操作就完成了。接下来既然 G 休眠了，CPU 线程总不能闲下来，在 park\_m 方法里又可以看到 schedule 方法，开始进入到到一轮调度循环了。 &gt; park\_m 方法里还有段小插曲，进入调度循环之前还有个对 waitunlockf 方法的判断，该方法意思是如果解锁不成功则调用 execute 方法继续执行之前的 G，而该方法永远不会 return，也就不会再次进入下一次调度。也就是说给外部一个控制是否要进行下一个调度的选择。 ### 抢占让出 CPU 回想在 runtime.main() 里面有单独启动了一个监控任务，方法是 sysmon。看下该方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func sysmon() { ...... for { // delay参数用于控制for循环的间隔，不至于无限死循环。 // 控制逻辑是前50次每次sleep 20微秒，超过50次则每次翻2倍，直到最大10毫秒 if idle == 0 { // start with 20us sleep... delay = 20 } else if idle &gt; 50 { // start doubling the sleep after 1ms... delay \*= 2 } if delay &gt; 10\*1000 { // up to 10ms delay = 10 \* 1000 } usleep(delay) lastpoll := int64(atomic.Load64(&amp;sched.lastpoll)) now := nanotime() if lastpoll != 0 &amp;&amp; lastpoll+10\*1000\*1000 &lt; now { atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now)) gp := netpoll(false) // non-blocking - returns list of goroutines if gp != nil { ...... incidlelocked(-1) // 把epoll ready的G列表注入到全局runq里 injectglist(gp) incidlelocked(1) } } // retake P&#39;s blocked in syscalls // and preempt long running G&#39;s if retake(now) != 0 { idle = 0 } else { idle++ } ...... } } func retake(now int64) uint32 { n := 0 for i := int32(0); i &lt; gomaxprocs; i++ { \_p\_ := allp\[i\] // 从所有P里面去找 if \_p\_ == nil { continue } pd := &amp;\_p\_.sysmontick s := \_p\_.status if s == \_Psyscall { ...... } else if s == \_Prunning { // 针对正在运行的P // Preempt G if it&#39;s running for too long. t := int64(\_p\_.schedtick) if int64(pd.schedtick) != t { pd.schedtick = uint32(t) pd.schedwhen = now continue } // 如果已经超过forcePreemptNS(10ms)，则抢占 if pd.schedwhen+forcePreemptNS &gt; now { continue } // 抢占P preemptone(\_p\_) } } return uint32(n) } func preemptone(\_p\_ \*p) bool { mp := \_p\_.m.ptr() if mp == nil || mp == getg().m { return false } // 找到当前正在运行的G gp := mp.curg if gp == nil || gp == mp.g0 { return false } // 标记抢占状态 gp.preempt = true // Every call in a go routine checks for stack overflow by // comparing the current stack pointer to gp-&gt;stackguard0. // Setting gp-&gt;stackguard0 to StackPreempt folds // preemption into the normal stack overflow check. // G里面的每一次调用都会比较当前栈指针与 gp-&gt;stackguard0 来检查堆栈溢出 // 设置 gp-&gt;stackguard0 为 StackPreempt 来触发正常的堆栈溢出检测 gp.stackguard0 = stackPreempt return true }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>sysmon() 方法处于无限 for 循环，整个进程的生命周期监控着。retake() 方法每次对所有的 P 遍历检查超过 10ms 的还在运行的 G，如果有超过 10ms 的则通过 preemptone() 进行抢占，但是要注意这里只把 gp.stackguard0 赋值了一个 stackPreempt，并没有做让出 CPU 的操作，因此这里的抢占实质只是一个”标记“抢占。那么真正停止 G 执行的操作在哪里？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/stack.go func newstack(ctxt unsafe.Pointer) { ...... // NOTE: stackguard0 may change underfoot, if another thread // is about to try to preempt gp. Read it just once and use that same // value now and below. // 这里的逻辑是为G的抢占做的判断。 // 判断是否是抢占引发栈扩张，如果 gp.stackguard0 == stackPreempt 则说明是抢占触发的栈扩张 preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt ...... //如果判断可以抢占, 则继续判断是否GC引起的, 如果是则对G的栈空间执行标记处理(扫描根对象)然后继续运行, //如果不是GC引起的则调用gopreempt\_m函数完成抢占. if preempt { ...... // 停止当前运行状态的G,最后放到全局runq里,释放M // 这里会进入schedule循环.阻塞到这里 gopreempt\_m(gp) // never return } ...... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func goschedImpl(gp \*g) { status := readgstatus(gp) if status&amp;^\_Gscan != \_Grunning { dumpgstatus(gp) throw(&quot;bad g status&quot;) } casgstatus(gp, \_Grunning, \_Grunnable) dropg() lock(&amp;sched.lock) globrunqput(gp) unlock(&amp;sched.lock) schedule() }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们都知道 Go 的调度是非抢占式的，要想实现 G 不被长时间，就只能主动触发抢占，而 Go 触发抢占的实际就是在栈扩张的时候，在 newstack 新创建栈空间的时候检测是否有抢占标记(也就是 gp.stackguard0 是否等于 stackPreempt)，如果有则通过 goschedImpl 方法再次进入到熟悉的 schedule 调度循环。 ### 系统调用让出 CPU 我们程序都跑在系统上面，就绕不开与系统的交互。那么当我们的 Go 程序做系统调用的时候，系统的方法不确定会阻塞多久，而我们程序又不知道运行的状态该怎么办？ 在 Go 中并没有直接对系统内核函数调用，而是封装了个 syscall.Syscall 方法，先看下实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // syscall/syscall\_unix.go func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>asm // syscall/asm\_linux\_amd64.s TEXT ·Syscall(SB),NOSPLIT,$0-56 CALL runtime·entersyscall(SB) MOVQ a1+8(FP), DI MOVQ a2+16(FP), SI MOVQ a3+24(FP), DX MOVQ $0, R10 MOVQ $0, R8 MOVQ $0, R9 MOVQ trap+0(FP), AX // syscall entry SYSCALL // 进行系统调用 CMPQ AX, $0xfffffffffffff001 JLS ok MOVQ $-1, r1+32(FP) MOVQ $0, r2+40(FP) NEGQ AX MOVQ AX, err+48(FP) CALL runtime·exitsyscall(SB) RET ok: MOVQ AX, r1+32(FP) MOVQ DX, r2+40(FP) MOVQ $0, err+48(FP) CALL runtime·exitsyscall(SB) RET</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在汇编代码中看出先是执行了 runtime·entersyscall 方法，然后进行系统调用，最后执行了 runtime·exitsyscall(SB)，从字面意思看是进入系统调用之前先执行一些逻辑，退出系统调用之后执行一堆逻辑。看下具体实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func entersyscall(dummy int32) { reentersyscall(getcallerpc(unsafe.Pointer(&amp;dummy)), getcallersp(unsafe.Pointer(&amp;dummy))) } func reentersyscall(pc, sp uintptr) { ...... // Leave SP around for GC and traceback. // 保存执行现场 save(pc, sp) \_g\_.syscallsp = sp \_g\_.syscallpc = pc // 切换到系统调用状态 casgstatus(\_g\_, \_Grunning, \_Gsyscall) ...... // Goroutines must not split stacks in Gsyscall status (it would corrupt g-&gt;sched). // We set \_StackGuard to StackPreempt so that first split stack check calls morestack. // Morestack detects this case and throws. \_g\_.stackguard0 = stackPreempt \_g\_.m.locks-- }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>进入系统调用前先保存执行现场，然后切换到 `_Gsyscall` 状态，最后标记抢占，等待被抢占走。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func exitsyscall(dummy int32) { ...... // Call the scheduler. mcall(exitsyscall0) ...... } func exitsyscall0(gp \*g) { \_g\_ := getg() casgstatus(gp, \_Gsyscall, \_Grunnable) dropg() lock(&amp;sched.lock) // 获取一个空闲的P，如果没有则放到全局队列里，如果有则执行 \_p\_ := pidleget() if \_p\_ == nil { globrunqput(gp) // 如果没有P就放到全局队列里,等待有资源时执行 } else if atomic.Load(&amp;sched.sysmonwait) != 0 { atomic.Store(&amp;sched.sysmonwait, 0) notewakeup(&amp;sched.sysmonnote) } unlock(&amp;sched.lock) if \_p\_ != nil { acquirep(\_p\_) execute(gp, false) // Never returns. // 如果找到空闲的P则直接执行 } if \_g\_.m.lockedg != nil { // Wait until another thread schedules gp and so m again. stoplockedm() execute(gp, false) // Never returns. } stopm() schedule() // Never returns. // 没有P资源执行，就继续下一轮调度循环 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>系统调用退出时，切到 G0 下把 G 状态切回来，如果有可执行的 P 则直接执行，如果没有则放到全局队列里，等待调度，最后又看到了熟悉的 schedule 进入下一轮调度循环。 ## 待执行 G 的来源 ### gofunc 创建G 当开启一个 Goroutine 的时候用到 go func() ���样的语法，在 runtime 下其实调用的就是 newproc 方法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func newproc(siz int32, fn \*funcval) { argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize) pc := getcallerpc(unsafe.Pointer(&amp;siz)) systemstack(func() { newproc1(fn, (\*uint8)(argp), siz, 0, pc) }) } func newproc1(fn \*funcval, argp \*uint8, narg int32, nret int32, callerpc uintptr) \*g { ...... \_p\_ := \_g\_.m.p.ptr() // 从当前P里面复用一个空闲G newg := gfget(\_p\_) // 如果没有空闲G则新建一个,默认栈大小为 \_StackMin=2048 bytes if newg == nil { newg = malg(\_StackMin) casgstatus(newg, \_Gidle, \_Gdead) // 把新创建的G添加到全局allg里 allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack. } ...... if isSystemGoroutine(newg) { atomic.Xadd(&amp;sched.ngsys, +1) } newg.gcscanvalid = false casgstatus(newg, \_Gdead, \_Grunnable) // 把G放到P里的待运行队列，第三参数设置为true，表示要放到runnext里，作为优先要执行的G runqput(\_p\_, newg, true) // 如果有其它空闲P则尝试唤醒某个M来执行 // 如果有M处于自璇等待P或G状态，放弃。 // NOTE: sched.nmspinning!=0说明正在有M被唤醒，这里判断sched.nmspinnin==0时才进入wakep是防止同时唤醒多个M if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &amp;&amp; mainStarted { wakep() } ...... return newg }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>newproc1 方法中 gfget 先从空闲的 G 列表获取一个 G 对象，没有则创建一个新的 G 对象，然后 runqput 放到当前 P 待运行队列里。 ### epoll 来源 回想上面分析抢占以及多线程下如何调度时都见到一个 netpoll 方法，这个方法就是从系统内核获取已经有数据的时间，然后映射到对应的 G 标记 ready。下面看实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func netpoll(block bool) \*g { ...... var events \[128\]epollevent retry: n := epollwait(epfd, &amp;events\[0\], int32(len(events)), waitms) if n &lt; 0 { if n != -\_EINTR { println(&quot;runtime: epollwait on fd&quot;, epfd, &quot;failed with&quot;, -n) throw(&quot;runtime: netpoll failed&quot;) } goto retry } var gp guintptr for i := int32(0); i &lt; n; i++ { ev := &amp;events\[i\] if ev.events == 0 { continue } var mode int32 if ev.events&amp;(\_EPOLLIN|\_EPOLLRDHUP|\_EPOLLHUP|\_EPOLLERR) != 0 { mode += &#39;r&#39; } if ev.events&amp;(\_EPOLLOUT|\_EPOLLHUP|\_EPOLLERR) != 0 { mode += &#39;w&#39; } if mode != 0 { pd := \*(\*\*pollDesc)(unsafe.Pointer(&amp;ev.data)) netpollready(&amp;gp, pd, mode) } } if block &amp;&amp; gp == 0 { goto retry } return gp.ptr() } func netpollready(gpp \*guintptr, pd \*pollDesc, mode int32) { var rg, wg guintptr if mode == &#39;r&#39; || mode == &#39;r&#39;+&#39;w&#39; { rg.set(netpollunblock(pd, &#39;r&#39;, true)) } if mode == &#39;w&#39; || mode == &#39;r&#39;+&#39;w&#39; { wg.set(netpollunblock(pd, &#39;w&#39;, true)) } if rg != 0 { rg.ptr().schedlink = \*gpp \*gpp = rg } if wg != 0 { wg.ptr().schedlink = \*gpp \*gpp = wg } } // 解锁pd wait状态,标记为pdReady，并返回 func netpollunblock(pd \*pollDesc, mode int32, ioready bool) \*g { gpp := &amp;pd.rg if mode == &#39;w&#39; { gpp = &amp;pd.wg } for { old := \*gpp if old == pdReady { return nil } if old == 0 &amp;&amp; !ioready { // Only set READY for ioready. runtime\_pollWait // will check for timeout/cancel before waiting. return nil } var new uintptr if ioready { new = pdReady } // 变量pd.rg在netpollblock的时候已经指向了运行pd的G,因此old其实指向G的指针，而不是pdWait等等的状态指针了 if atomic.Casuintptr(gpp, old, new) { if old == pdReady || old == pdWait { old = 0 } return (\*g)(unsafe.Pointer(old)) } } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>首先 epollwait 从内核获取到一批 event，也就拿到了有收到就绪的 FD。netpoll 的返回值是一�� G 链表，在该方法里只是把要被唤醒的 G标记 ready，然后交给外部处理，例如 sysmon 中的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func sysmon() { ...... for { ...... lastpoll := int64(atomic.Load64(&amp;sched.lastpoll)) now := nanotime() if lastpoll != 0 &amp;&amp; lastpoll+10\*1000\*1000 &lt; now { atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now)) gp := netpoll(false) // non-blocking - returns list of goroutines if gp != nil { ...... incidlelocked(-1) // 把epoll ready的G列表注入到全局runq里 injectglist(gp) incidlelocked(1) } } ...... } } // 把G列表注入到全局runq里 func injectglist(glist \*g) { ...... lock(&amp;sched.lock) var n int for n = 0; glist != nil; n++ { gp := glist glist = gp.schedlink.ptr() casgstatus(gp, \_Gwaiting, \_Grunnable) globrunqput(gp) } ...... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>netpoll 返回的链表交给了 injectglist，然后其实是放到了全局 rung 队列中，等待被调度。 &gt; epoll 内容较多，本章主要围绕调度的话题讨论，在这里就不展开分析。 ## 看几个主动让出 CPU 的场景 ### time.Sleep 当代码中调用 time.Sleep 的时候我们是要 black 住程序不再继续往下执行，此时该 goroutine 不会做其他事情了，理应把 CPU 资源释放出来，下面看下实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/time.go func timeSleep(ns int64) { if ns &lt;= 0 { return } t := getg().timer if t == nil { t = new(timer) getg().timer = t } \*t = timer{} // 每个定时任务都创建一个timer t.when = nanotime() + ns t.f = goroutineReady // 记录唤醒该G的方法,唤醒时通过该方法执行唤醒 t.arg = getg() // 把timer与当前G关联,时间到了唤醒时通过该参数找到所在的G lock(&amp;timers.lock) addtimerLocked(t) // 把timer添加到最小堆里 goparkunlock(&amp;timers.lock, &quot;sleep&quot;, traceEvGoSleep, 2) // 切到G0让出CPU,进入休眠 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func goparkunlock(lock \*mutex, reason string, traceEv byte, traceskip int) { gopark(parkunlock\_c, unsafe.Pointer(lock), reason, traceEv, traceskip) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>timeSleep 函数里通过 addtimerLocked 把定时器加入到 timer 管理器（timer 通过最小堆的数据结构存放每个定时器，在这不做详细说明）后，再通过 goparkunlock 实现把当前 G 休眠，这里看到了上面提到的 gopark 方法进行调度循环的上下文切换。 上面介绍的是一个 G 如何进入到休眠状态的过程，该例子是个定时器，当时间到了的话，当前 G 就要被唤醒继续执行了。下面就介绍下唤醒的流程。 返回到最开始 timeSleep 方法里在进入调度方法之前有一个 addtimerLocked 方法，看下这个方法做了什么。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/time.go func addtimerLocked(t \*timer) { // when must never be negative; otherwise timerproc will overflow // during its delta calculation and never expire other runtime timers. if t.when &lt; 0 { t.when = 1&lt;&lt;63 - 1 } t.i = len(timers.t) timers.t = append(timers.t, t) //将当前timer添加到timer管理器里 siftupTimer(t.i) ...... // 如果没有启动timer管理定时器，则启动。timerproc只会启动一次，即全局timer管理器 if !timers.created { timers.created = true go timerproc() } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/time.go // Timerproc runs the time-driven events. // It sleeps until the next event in the timers heap. // If addtimer inserts a new earlier event, it wakes timerproc early. func timerproc() { timers.gp = getg() for { lock(&amp;timers.lock) timers.sleeping = false now := nanotime() delta := int64(-1) for { if len(timers.t) == 0 { delta = -1 break } t := timers.t\[0\] delta = t.when - now if delta &gt; 0 { break } if t.period &gt; 0 { // leave in heap but adjust next time to fire t.when += t.period \* (1 + -delta/t.period) siftdownTimer(0) } else { // remove from heap last := len(timers.t) - 1 if last &gt; 0 { timers.t\[0\] = timers.t\[last\] timers.t\[0\].i = 0 } timers.t\[last\] = nil timers.t = timers.t\[:last\] if last &gt; 0 { siftdownTimer(0) } t.i = -1 // mark as removed } f := t.f arg := t.arg seq := t.seq unlock(&amp;timers.lock) if raceenabled { raceacquire(unsafe.Pointer(t)) } f(arg, seq) lock(&amp;timers.lock) } ...... } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 addtimerLocked 方法的最下面有个逻辑在运行期间开启了 &quot;全局时间事件驱动器&quot; timerproc，该方法会全程遍历最小堆，寻找最早进入 timer 管理器的定时器，然后唤醒。它是怎么找到要唤醒哪个G的？回头看下 timeSleep 方法里把当时正在执行的 G 以及唤醒方法 goroutineReady 带到了每个定时器里，而在 timerproc 则通过找到期的定时器执行 f(arg, seq) 即通过 goroutineReady 方法唤醒。方法调用过程: `goroutineReady() -&gt; ready()`</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/time.go func goroutineReady(arg interface{}, seq uintptr) { goready(arg.(\*g), 0) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/proc.go func goready(gp \*g, traceskip int) { systemstack(func() { ready(gp, traceskip, true) }) } // Mark gp ready to run. func ready(gp \*g, traceskip int, next bool) { if trace.enabled { traceGoUnpark(gp, traceskip) } status := readgstatus(gp) // Mark runnable. \_g\_ := getg() \_g\_.m.locks++ // disable preemption because it can be holding p in a local var if status&amp;^\_Gscan != \_Gwaiting { dumpgstatus(gp) throw(&quot;bad g-&gt;status in ready&quot;) } // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq casgstatus(gp, \_Gwaiting, \_Grunnable) runqput(\_g\_.m.p.ptr(), gp, next) ...... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在上面的方法里可以看到先把休眠的 G 从 `_Gwaiting` 切换到 `_Grunnable` 状态，表明已经可运行。然后通过 runqput 方法把 G 放到 P 的待运行队列里，就进入到调度器的调度循环里了。 **总结：** time.Sleep 想要进入阻塞(休眠)状态，其实是通过 gopark 方法给自己标记个 `_Gwaiting` 状态，然后把自己所占用的 CPU 线程资源给释放出来，继续执行调度任务，调度其它的 G 来运行。而唤醒是通过把 G 更改回 `_Grunnable` 状态后，然后把 G 放入到 P 的待运行队列里等待执行。通过这点还可以看出休眠中的 G 其实并不占用 CPU 资源，最多是占用内存，是个很轻量级的阻塞。 ### Mutex</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // sync/mutex.go func (m \*Mutex) Lock() { // Fast path: grab unlocked mutex. // 首先尝试抢锁，如果抢到则直接返回,并标记mutexLocked状态 if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for { // Don&#39;t spin in starvation mode, ownership is handed off to waiters // so we won&#39;t be able to acquire the mutex anyway. // 尝试自璇,但有如下几个条件跳过自璇,这里的自璇是用户态自璇,基本lock的cpu消耗都耗到这里了 // 1.不在饥饿模式自璇 // 2.超过4次循环，则不再自璇. (runtime\_canSpin里面) // 3.全部P空闲时，不自璇.(runtime\_canSpin里面) // 4.当前P里无运行G时，不自璇.(runtime\_canSpin里面) if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime\_canSpin(iter) { // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp; atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) { awoke = true } runtime\_doSpin() // doSpin其实就是用户态自璇30次 iter++ old = m.state continue } ...... if atomic.CompareAndSwapInt32(&amp;m.state, old, new) { ...... runtime\_SemacquireMutex(&amp;m.sema, queueLifo) // 这里会再次自璇几次,然后最后切换到g0把G标记\_Gwaiting状态阻塞在这里 starving = starving || runtime\_nanotime()-waitStartTime &gt; starvationThresholdNs // 如果锁等了1毫秒才被唤醒，才会标记为饥饿模式 old = m.state ...... } else { old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/sema.go func sync\_runtime\_Semacquire(addr \*uint32) { semacquire1(addr, false, semaBlockProfile) } func semacquire1(addr \*uint32, lifo bool, profile semaProfileFlags) { ...... for { ...... // Any semrelease after the cansemacquire knows we&#39;re waiting // (we set nwait above), so go to sleep. root.queue(addr, s, lifo) // 把当前锁的信息存起来以便以后唤醒时找到当前G,G是在queue里面获取的。 goparkunlock(&amp;root.lock, &quot;semacquire&quot;, traceEvGoBlockSync, 4) // 进行休眠，然后阻塞在这里 if s.ticket != 0 || cansemacquire(addr) { break } } } // queue adds s to the blocked goroutines in semaRoot. func (root \*semaRoot) queue(addr \*uint32, s \*sudog, lifo bool) { s.g = getg() // 这里记录了当前的G，以便唤醒的时候找到要被唤醒的G s.elem = unsafe.Pointer(addr) s.next = nil s.prev = nil var last \*sudog pt := &amp;root.treap for t := \*pt; t != nil; t = \*pt { ...... last = t if uintptr(unsafe.Pointer(addr)) &lt; uintptr(t.elem) { pt = &amp;t.prev } else { pt = &amp;t.next } } ......</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Mutex.Lock 方法通过调用 runtime\_SemacquireMutex 最终还是调用 goparkunlock 实现把 G 进入到休眠状态。在进入休眠之前先把自己加入到队列里 `root.queue(addr, s, lifo)`，在 queue 方法里，记录了当前的 G，以便以后找到并唤醒。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // sync/mutex.go func (m \*Mutex) Unlock() { ...... if new&amp;mutexStarving == 0 { // 如果不是饥饿模式 old := new for { ...... if atomic.CompareAndSwapInt32(&amp;m.state, old, new) { runtime\_Semrelease(&amp;m.sema, false) // 唤醒锁 return } old = m.state } } else { // Starving mode: handoff mutex ownership to the next waiter. // Note: mutexLocked is not set, the waiter will set it after wakeup. // But mutex is still considered locked if mutexStarving is set, // so new coming goroutines won&#39;t acquire it. runtime\_Semrelease(&amp;m.sema, true) // 唤醒锁 } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/sema.go func sync\_runtime\_Semrelease(addr \*uint32, handoff bool) { semrelease1(addr, handoff) } func semrelease1(addr \*uint32, handoff bool) { root := semroot(addr) s, t0 := root.dequeue(addr) if s != nil { atomic.Xadd(&amp;root.nwait, -1) } ...... if s != nil { // May be slow, so unlock first ...... readyWithTime(s, 5) } } func readyWithTime(s \*sudog, traceskip int) { if s.releasetime != 0 { s.releasetime = cputicks() } goready(s.g, traceskip) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Mutex.Unlock 方法通过调用 runtime\_Semrelease 最终还是调用 goready 实现把 G 唤醒。 ### channel</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go // runtime/chan.go func chansend(c \*hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 寻找一个等待中的receiver，直接把值传给这个receiver，绕过下面channel buffer， // 避免从sender buffer-&gt;chan buffer-&gt;receiver buffer，而是直接sender buffer-&gt;receiver buffer，仍然做了内存copy if sg := c.recvq.dequeue(); sg != nil { send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3) return true } // 如果没有receiver等待: // 如果当前chan里的元素个数小于环形队列大小(也就是chan还没满),则把内存拷贝到channel buffer里，然后直接返回。 // 注意dataqsiz是允许为0的，当为0时，也不存在该if里面的内存copy if c.qcount &lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) // 获取即将要写入的chan buffer的指针地址 if raceenabled { raceacquire(qp) racerelease(qp) } // 把元素内存拷贝进去. // 注意这里产生了一次内存copy,也就是说如果没有receiver的话，就一定会产生内存拷贝 typedmemmove(c.elemtype, qp, ep) c.sendx++ // 发送索引+1 if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ // 队列元素计数器+1 unlock(&amp;c.lock) return true } if !block { // 如果是非阻塞的，到这里就可以结束了 unlock(&amp;c.lock) return false } // ########下面是进入阻塞模式的如何实现阻塞的处理逻辑 // Block on the channel. Some receiver will complete our operation for us. // 把元素相关信息、当前的G信息打包到一个sudog里，然后扔进send队列 gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil mysg.g = gp // 把当前G也扔进sudog里,用于别人唤醒该G的时候找到该G mysg.selectdone = nil mysg.c = c gp.waiting = mysg // 记录当前G正在等待的sudog gp.param = nil c.sendq.enqueue(mysg) // 切换到g0，把当前G切换到\_Gwaiting状态，然后唤醒lock. // 此时当前G被阻塞了,P就继续执行其它G去了. goparkunlock(&amp;c.lock, &quot;chan send&quot;, traceEvGoBlockSend, 3) ...... return true } func send(c \*hchan, sg \*sudog, ep unsafe.Pointer, unlockf func(), skip int) { ...... gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当给一个 chan 发送消息的时候，实质触发的方法是 chansend。在该方法里不是先进入休眠状态。 1）如果此时有接收者接收这个 chan 的消息则直接把数据通过 send 方法扔给接收者，并唤醒接收者的 G，然后当前 G 则继续执行。 2）如果没有接收者，就把数据 copy 到 chan 的临时内存里，且内存没有满就继续执行当前 G。 3）如果没有接收者且 chan 满了，依然是通过 goparkunlock 方法进入休眠。在休眠前把当前的 G 相关信息存到队列（sendq）以便有接收者接收数据的时候唤醒当前 G。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>go func chanrecv(c \*hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ...... if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender&#39;s value to the tail of the queue (both map to // the same buffer slot because the queue is full). // 寻找一个正在等待的sender // 如果buffer size是0，则尝试直接从sender获取(这种情况是在环形队列长度(dataqsiz)为0的时候出现) // 否则(buffer full的时候)从队列head接收，并且帮助sender在队列满时的阻塞的元素信息拷贝到队列里，然后将sender的G状态切换为\_Grunning,这样sender就不阻塞了。 recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3) return true, true } // 如果有数据则从channel buffer里获取数据后返回(此时环形队列长度dataqsiz!=0) if c.qcount &gt; 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) // 获取即将要读取的chan buffer的指针地址 if raceenabled { raceacquire(qp) racerelease(qp) } if ep != nil { typedmemmove(c.elemtype, ep, qp) // copy元素数��内存到channel buffer } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(&amp;c.lock) return true, true } if !block { unlock(&amp;c.lock) return false, false } // ##########下面是无任何数据准备把当前G切换为\_Gwaiting状态的逻辑 // no sender available: block on this channel. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.selectdone = nil mysg.c = c gp.param = nil c.recvq.enqueue(mysg) // 释放了锁，然后把当前G切换为\_Gwaiting状态，阻塞在这里等待有数据进来被唤醒 goparkunlock(&amp;c.lock, &quot;chan receive&quot;, traceEvGoBlockRecv, 3) ...... return true, !closed } func recv(c \*hchan, sg \*sudog, ep unsafe.Pointer, unlockf func(), skip int) { ...... sg.elem = nil gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>chanrecv 方法是在 chan 接收者的地方调用的方法。 1）如果有发送者被休眠，则取出数据然后唤醒发送者，当前接收者的 G 拿到数据继续执行。 2）如果没有等待的发送者就看下有没有发送的数据还没被接收，有的话就直接取出数据然后返回，当前接收者的 G 拿到数据继续执行。（注意：这里取的数据不是正在等待的 sender 的数据，而是从 chan 的开头的内存取，如果是 sender 的数据则读出来的数据顺序就乱了） 3）如果既没有发送者，chan 里也没数据，就通过 goparkunlock 进行休眠，在休眠之前把当前的 G 相关信息存到 recvq 里面，以便有数据时找到要唤醒的 G。 ## END ![](<a href="https://static.studygolang.com/190524/8912fc230b8db334779b59d2e661c1e6.png?imageView2/2/w/380" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/8912fc230b8db334779b59d2e661c1e6.png?imageView2/2/w/380</a>) ![](<a href="https://static.studygolang.com/190524/70079b9818d863e3f410a46dc0880b2d.png?imageView2/2/w/380" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/70079b9818d863e3f410a46dc0880b2d.png?imageView2/2/w/380</a>) ![](<a href="https://static.studygolang.com/190524/bc212d2d96f7ba929e2a095c187aab70.jpg?imageView2/2/w/380" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/bc212d2d96f7ba929e2a095c187aab70.jpg?imageView2/2/w/380</a>) 刘  丁 | 滴滴 | 资深软件开发工程师 2014年开始接触 Go 语言，Go 及相关生态爱好者。技术栈偏向于网络编程， 技术上执着于拿源码说明问题，拿证据验证结论。17 年加入滴滴基础架构部，负责滴滴物联网平台的研发。 ![](<a href="https://static.studygolang.com/190524/e05fe8d2e0d034bcc5d026bedc0c2193.jpg?imageView2/2/w/380" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/e05fe8d2e0d034bcc5d026bedc0c2193.jpg?imageView2/2/w/380</a>) ![](<a href="https://static.studygolang.com/190524/3268c11c96589d651a53cd6f0a8fe856.gif?imageView2/2/w/380" target="_blank" rel="noopener noreferrer">https://static.studygolang.com/190524/3268c11c96589d651a53cd6f0a8fe856.gif?imageView2/2/w/380</a>)</p></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Cospk/edit/main/src/golang/原理/theory/详尽干货！从源码角度看-Golang-的调度.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2025/8/27 12:02:38</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: xie@gmail.com">shiwei</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%BE%973%E5%80%8D%E6%80%A7%E8%83%BD%E7%9A%84go%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%8F%8Aon-cpu-off-cpu%E7%81%AB%E7%84%B0%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8.html" aria-label="记一次获得3倍性能的go程序优化实践，及on-cpu/off-cpu火焰图的使用"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->记一次获得3倍性能的go程序优化实践，及on-cpu/off-cpu火焰图的使用</div></a><a class="route-link auto-link next" href="/vuepress-app/golang/%E5%8E%9F%E7%90%86/theory/%E8%AF%A6%E8%A7%A3-Golang-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.html" aria-label="详解 Golang 中间代码生成"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">详解 Golang 中间代码生成<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 Cospk </div></footer></div><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/vuepress-app/assets/app-DIJDtupu.js" defer></script>
  </body>
</html>
