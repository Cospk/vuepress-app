---
# 这是文章的标题
title: 面试题（答案）


# 这是侧边栏的顺序
order: 1
# 设置作者
author: xiaoxie
# 设置写作时间
date: 2020-01-01

# 一个页面可以有多个标签
tag:
  - golang

# 此页面会出现在星标文章中
star: true

---

## 腾讯一面

1. 协程池的作用?
2. 内存逃逸分析?
3. go的内存回收什么条件会触发? go的GC能够手动触发吗?
4. channel的底层实现? 有缓冲的,无缓冲的channel, 如果管道已经关闭了, 读取会不会发生错误?
5. 切片使用的时候需要注意什么?
6. go中的参数传递是值传递还是引用传递?
7. defer的执行顺序?
8. 100G的文件, 统计出所有英文字母, 按照字母表顺序输出
9. linux如何分割文件?
10. 接口性能如何优化?
11. 什么情况会全表扫描?
12. 主丛同步的原理? mysql还有什么相关的log文件?
13. 分布式锁的原理?



```sh
1. 协程池的作用?
协程池主要用于控制和复用大量的轻量级线程（协程），从而减少频繁创建和销毁协程的开销。协程池限制了同时运行的协程数量，并根据任务的数量动态调整，防止协程数量过多导致系统资源（如内存）过度消耗。
作用：
资源管理：避免创建过多协程消耗系统资源。
任务调度：将任务按需分配到协程池中的协程中执行，增加并发度。
性能优化：通过复用协程，减少协程创建和销毁的开销。

2. 内存逃逸分析?
内存逃逸分析是 Go 编译器在编译时进行的一项优化技术。它用于分析变量的生命周期，判断一个变量是否逃逸到堆上。
逃逸到堆：当一个变量的引用被返回到函数外部，或者存在多线程的共享情况时，变量会逃逸到堆上，不能使用栈空间进行管理。
优化：通过逃逸分析，Go 编译器可以决定将某些变量分配到栈上而不是堆上，从而减少 GC 的负担，提高性能。

3. Go 的内存回收触发条件及手动触发 GC
内存回收触发条件：
Go 的垃圾回收（GC）基于 标记-清除 算法，主要依赖于 堆内存的分配量 和 可达对象的数量。
当堆内存达到一定的阈值时（即触发垃圾回收），Go 会启动 GC 过程。
另外，GC 还会在内存分配的增量超过一个特定比例时触发。
手动触发 GC：
可以通过 runtime.GC() 来手动触发垃圾回收，通常不推荐这么做，除非有特殊需求（比如在内存泄漏怀疑时排查）。

4. Channel 的底层实现? 有缓冲的、无缓冲的 Channel，管道关闭后的读取行为
底层实现：
Go 的 channel 是通过 环形缓冲区 来实现的。对于无缓冲的 channel（同步 channel），发送操作会阻塞直到另一个 goroutine 进行接收；而对于有缓冲的 channel，发送操作只有在缓冲区已满时才会阻塞。
管道关闭后的读取行为：
无缓冲 channel：如果管道已关闭且所有数据已被读取，后续的接收操作会返回零值，并且不会阻塞。
有缓冲 channel：如果管道已关闭且缓冲区中的数据被消费完，后续接收会返回零值，并且不会阻塞。若缓冲区中仍有数据，接收操作会继续读取数据直到缓冲区为空。

5. 切片使用时需要注意什么?
容量问题：切片有容量和长度的区别，修改切片的长度时，如果超过了容量，会导致新的切片分配内存。
切片扩容：切片扩容时，会分配新的内存，并可能导致指向旧切片的引用失效。
切片的共享内存：切片底层数组是共享的，修改切片元素时可能会影响到其他切片（指向同一底层数组的切片）。
避免内存泄漏：切片扩大时，旧的切片如果不再使用，容易造成内存泄漏。

6. Go 中的参数传递是值传递还是引用传递?
值传递：Go 的函数参数默认是值传递，即传递的是变量的副本。
引用传递：如果传递的是指针，实质上是引用传递，函数内部修改指针所指向的值会影响原始数据。

7. defer 的执行顺序?
执行顺序：defer 语句的执行顺序是 后进先出（LIFO） 的。即当函数执行结束时，所有的 defer 语句会按照定义的顺序逆序执行。
例如：
func example() {
    defer fmt.Println("first")
    defer fmt.Println("second")
}
执行时会先输出 second，再输出 first。

8. 100G 的文件，统计出所有英文字母，按照字母表顺序输出
思路：逐行读取文件，统计每个字母的出现频次，然后按照字母表顺序输出结果。
package main
import (
    "fmt"
    "os"
    "bufio"
    "strings"
)
func main() {
    file, _ := os.Open("bigfile.txt")
    defer file.Close()
    counts := make(map[rune]int)
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Text()
        for _, char := range line {
            if char >= 'a' && char <= 'z' {
                counts[char]++
            }
        }
    }
    if err := scanner.Err(); err != nil {
        fmt.Println(err)
    }
    for letter := 'a'; letter <= 'z'; letter++ {
        fmt.Printf("%c: %d\n", letter, counts[letter])
    }
}

9. Linux 如何分割文件?
可以使用 split 命令来分割大文件。例如：
split -b 10M largefile.txt part_
这将把 largefile.txt 按 10MB 大小分割成多个文件，前缀为 part_。

10. 接口性能如何优化?
避免频繁的类型断言：类型断言的性能较差，尽量避免在性能关键路径中频繁使用。
接口缓存：尽量避免在接口类型的集合中进行频繁的类型转换操作。
具体类型替代接口：在性能敏感的地方，考虑使用具体类型而非接口，以避免接口的额外开销。

11. 什么情况会全表扫描?
没有索引：查询条件没有对应的索引，数据库只能扫描整个表。
不使用索引：查询条件虽然有索引，但由于查询条件设计不合理（比如范围查询），数据库无法利用索引。
强制全表扫描：有时为了避免不合理的索引使用，数据库可能强制执行全表扫描。

12. 主从同步的原理? MySQL 还有什么相关的 log 文件?
主从同步原理：
主服务器将修改写入到二进制日志（binlog），然后从服务器读取 binlog 并执行相应的操作以保持数据一致性。
相关 log 文件：
binlog：记录所有对数据库的修改操作（INSERT、UPDATE、DELETE）。
relay log：从服务器读取并执行的 binlog 内容。
error log：记录 MySQL 启动、停止以及错误信息。
slow query log：记录执行时间较长的 SQL 查询。

13. 分布式锁的原理?
原理：分布式锁用于在多个分布式系统中确保同一时刻只有一个系统或服务能够访问某资源。常见的实现方式包括：
基于数据库的锁：通过数据库表记录锁状态，其他节点通过查询锁表来竞争资源。
基于 Redis 的锁：使用 Redis 的 SETNX 命令或者 Redlock 算法来实现分布式锁。
基于 Zookeeper 的锁：通过创建临时有序节点来实现分布式锁。
```









## 腾讯二面

**项目拷打15分钟**

1. Kafka的消息丢失和消息重复消费。
2. Kafka和Rabbitmq的区别在哪？（架构、推和拉）
3. 拉的模式有什么好处（控制消费速度）
4. 使用分布式锁的过程中应用挂了？
5. 优雅启停+defer
6. 使用过期时间+自动续期
7. 对象存储和文件存储的主要区别是什么？
8. 分片上传是怎么实现的（文件合并hash一致性校验，引出文件秒传）
9. 邮箱验证码功能怎么实现的。（redis+邮箱组件）
10. jwt的格式。加密算法、内容、过期时间
11. 讲一下defer的原理
12. 讲一下map的底层结构
13. map中hash冲突怎么解决（链表、红黑树）
14. 讲一下go性能调优的案例（pprof，线程日志）
15. 通过线程日志延伸出，怎么看一个线程在线程日志里是卡在循环还是事件等待？
16. 线程日志上面会有标记。
17. 讲一下mysql的事务隔离级别？
18. 解释一下什么是可重复读？
19. 事务实现的底层原理？
20. Redis持久化机制（RDB，AOF）
21. 为什么持久化的时候是fork子进程处理
22. 讲一下docker实现容器的基本原理
23. 用过其他容器运行时吗
24. K8s有哪些组件？

```sh
1. Kafka的消息丢失和消息重复消费
消息丢失：
生产者端丢失：可能发生在 Kafka 的生产者在消息成功发送前失败，且没有开启足够的重试机制（如设置 acks=all）。
消费者端丢失：消费者读取了消息并处理完，但处理未完成时发生故障，且未提交消费进度。
解决方案：开启生产者的重试机制，使用合适的消费者提交策略（例如“手动提交”偏移量）。
消息重复消费：

消费者多次消费同一条消息。发生的原因包括消费者重复读取已提交的消息、偏移量的回退或系统重启。
解决方案：使用“幂等生产者”特性和“精确一次”语义，消费者记录偏移量并保证幂等消费。

2. Kafka和RabbitMQ的区别（架构、推和拉）
Kafka：
架构：Kafka 是分布式流平台，支持高吞吐量的日志存储和消息传递。数据是以日志的形式存储到磁盘上的，消费者按需读取。
拉模式：消费者定期从 Kafka 中拉取消息。适合高吞吐量的场景。
顺序消费：消息顺序保证在单个分区内。
RabbitMQ：
架构：RabbitMQ 是传统的消息队列系统，基于 AMQP 协议，支持消息的路由、发布-订阅和工作队列模式。
推模式：消费者从 RabbitMQ 中推送消息。适合需要实时消息传递的场景。
消息路由：支持复杂的路由规则，适合多种消息传递模式。

3. 拉模式的好处（控制消费速度）
控制消费速度：消费者控制从消息队列拉取消息的频率和速度，而不是被推送控制。可以根据系统负载调整消费速率，避免消息堆积。
高效利用资源：拉模式让消费者可以主动请求数据，控制资源的分配，避免系统过载。

4. 使用分布式锁的过程中应用挂了？
问题：应用崩溃或挂起时，分布式锁可能未释放，导致其他服务无法获取锁，出现死锁。
解决方案：
超时设置：为分布式锁设置过期时间，确保在应用崩溃时锁会自动释放。
看门狗机制：应用持有锁时，定期刷新锁的有效期。

5. 优雅启停+defer
优雅启动：确保服务初始化完成后再开始处理请求，通常需要等待外部依赖（如数据库、缓存等）就绪。
优雅停机：确保正在处理的请求完成后再关闭服务，避免中断。
使用 defer 关闭资源、解除注册服务等清理工作：
func main() {
    defer cleanup()
    startServer()
}

6. 使用过期时间+自动续期
过期时间：对于缓存或锁，设置过期时间防止资源无限占用。
自动续期：在资源还需要占用时，自动延长过期时间。常用于分布式锁，避免在操作过程中锁被释放。
实现方法：定时器定期检查并延长过期时间，或者采用 Redis 的 expire 命令。

7. 对象存储和文件存储的主要区别是什么？
文件存储：传统的文件系统（如 NFS、SAN），文件存储以目录树的结构组织，适合存储大量的小文件。
对象存储：对象存储（如 AWS S3）是以对象的形式存储数据，没有目录结构。每个对象有一个唯一的标识符，适合存储大文件，具有高扩展性和持久性。

8. 分片上传是怎么实现的（文件合并、hash一致性校验，引出文件秒传）
分片上传：大文件分成多个小块（片段），每个片段单独上传，上传完毕后服务器将这些片段合并为一个完整的文件。
哈希一致性校验：上传每个分片时，计算哈希值并校验数据一致性，确保文件没有丢失或损坏。
文件秒传：通过文件的哈希值，检测文件是否已经上传过，如果上传过则跳过上传过程，直接返回。

9. 邮箱验证码功能怎么实现的（Redis+邮箱组件）
流程：
生成验证码并发送到用户邮箱。
将验证码存储到 Redis，并设置过期时间（如 5 分钟）。
用户提交验证码时，先从 Redis 中获取验证，并与用户输入的验证码进行对比。
使用 邮件发送组件（如 SendGrid, SMTP）发送验证码邮件，Redis 缓存验证码用于快速验证。

10. JWT的格式。加密算法、内容、过期时间
格式：JWT 由三部分组成：头部（header）、载荷（payload）、签名（signature）。
头部：通常包含 alg（加密算法）和 typ（token 类型）信息。
载荷：包含声明（如 sub、exp 等）。
签名：用密钥对头部和载荷进行加密，确保数据未被篡改。
加密算法：通常使用 HS256（HMAC SHA-256）或 RS256（RSA）等。
过期时间：通过 exp 字段设置 JWT 的过期时间。

11. 讲一下defer的原理
原理：defer 语句会延迟函数调用直到外围函数返回时执行，且会按照 LIFO（后进先出）顺序执行。
在调用 defer 时，传入的参数会在 defer 执行时计算（而不是在声明时计算）。

12. 讲一下map的底层结构
底层实现：Go 中的 map 是基于哈希表实现的。
哈希表的桶（bucket）存储数据，使用哈希函数将键映射到桶中。桶内的数据以链表的形式存储，若有多个相同哈希值的数据，会出现哈希冲突。

13. map中hash冲突怎么解决（链表、红黑树）
链表：传统的哈希冲突解决方式，通过在同一个桶中使用链表来存储多个具有相同哈希值的元素。
红黑树：Go 1.18 版本以后，当一个桶中的元素过多时，哈希冲突会通过红黑树进行解决，以减少查找时间复杂度。

14. 讲一下go性能调优的案例（pprof，线程日志）
pprof：使用 Go 的 pprof 包来收集和分析性能数据，如 CPU、内存、goroutine 等。
示例：go tool pprof 用于分析 CPU 和内存的性能瓶颈。
线程日志：查看 goroutine 在某时刻的状态，可以帮助定位死锁、卡住的 goroutine 等问题。

15. 通过线程日志延伸出，怎么看一个线程在线程日志里是卡在循环还是事件等待？
卡在循环：线程日志中，看到 goroutine 一直在执行某一函数的相同代码行，且没有其他阻塞操作。
事件等待：线程日志中，goroutine 会显示在某个 select 或 chan 操作上，表明它正在等待事件。

16. 线程日志上面会有标记
线程日志中的标记通常指示每个 goroutine 的状态，常见的标记包括 running、waiting、sleeping 等，用于帮助分析线程的行为。

17. 讲一下 MySQL 的事务隔离级别
隔离级别：
READ UNCOMMITTED：允许脏读（读取未提交事务的数据）。
READ COMMITTED：不允许脏读，但可能出现不可重复读。
REPEATABLE READ：不允许脏读和不可重复读，但可能出现幻读。
```







## 腾讯一面（校招）

1. map怎么去做并发安全
2. 外层的协程能捕获子协程的panic吗？
3. panic都会被捕获吗？哪些panic不会捕获？
4. slice和数组的区别？底层结构？
5. go哪些内置类型是并发安全的？
6. go的结构体可以嵌套组合吗？
7. 两个结构体可以等值比较吗？
8. 你如何理解interface类型
9. 1.18版本后interface有什么增强？
10. interface可以进行等值比较吗？
11. 说说逃逸分析
12. channel有缓冲和无缓冲的区别
13. map并发访问会怎么样?这个异常可以捕获吗？
14. GMP模型
15. GMP模型中什么时候把G放全局队列？
16. go的gc
17. gc扫描是并发的吗？
18. gc中的根对象是什么？
19. 项目中etcd用来干什么的？
20. mysql索引B＋T
21. 索引的优缺点
22. redis用来做什么的?
23. 用户信息怎么存的？都走缓存吗？
24. redis过期淘汰策略



```sh
1. map怎么做并发安全
Go 原生的 map 是不并发安全的，在多个 goroutine 中并发读写会导致程序崩溃或不确定行为。
解决方案：
使用 sync.Mutex 或 sync.RWMutex 来加锁同步访问。
使用 sync.Map，Go 提供的并发安全的 map，适合在多个 goroutine 中共享。
代码示例：
var mu sync.Mutex
var m = make(map[string]int)

func safeMapAccess(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}

2. 外层的协程能捕获子协程的 panic 吗？
外层协程无法捕获子协程的 panic。Go 的 panic 是局部的，只在发生 panic 的 goroutine 中生效。
如果你想捕获子协程的 panic，需要在子协程内使用 defer 和 recover 来处理。
示例：
go func() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("Something went wrong!")
}()

3. panic都会被捕获吗？哪些panic不会捕获？
panic 会在程序的调用栈中逐层向上冒泡，直到有 defer 和 recover 捕获到为止。
不能捕获的 panic：
如果在 main 函数中发生的 panic，并且没有 defer 捕获，程序会直接退出。
如果在协程外层没有 defer 或者 recover，则也无法捕获。
如果 panic 发生在 goroutine 启动过程中，外层的主线程无法捕获。

4. slice和数组的区别？底层结构？
数组是固定长度的类型，一旦定义后长度不可改变，大小为编译时已知，不能动态扩展。
切片 (slice) 是对数组的抽象，提供了动态扩展的能力，底层是一个指向数组的指针，切片的长度和容量是可以动态变化的。
底层结构：

数组：连续的内存块，长度固定。
切片：包含指针（指向底层数组）、长度和容量。切片指向的是数组的一部分，可以动态增长。

5. Go哪些内置类型是并发安全的？
sync.Map：Go 1.9 引入，专为并发设计的 map 类型，适合并发读写。
atomic 包中的原子操作：如 atomic.Int32、atomic.Int64 等。
Channel（只要操作是同步的，无论有无缓冲，channel 在单个操作时是并发安全的）。

6. Go的结构体可以嵌套组合吗？
可以，Go 支持结构体的嵌套（组合），允许一个结构体作为另一个结构体的字段。
示例：
type Address struct {
    Street string
    City   string
}

type Person struct {
    Name    string
    Address // 匿名字段，自动嵌套
}

7. 两个结构体可以等值比较吗？
可以，Go 支持结构体的比较，只要结构体中的所有字段都可以比较。
不能比较的情况：
包含无法比较的类型（如 func、map、slice）的结构体不能比较。
示例：
type Person struct {
    Name string
    Age  int
}
p1 := Person{Name: "Alice", Age: 30}
p2 := Person{Name: "Alice", Age: 30}
fmt.Println(p1 == p2)  // true

8. 你如何理解interface类型
接口（interface）是 Go 中的一个类型，代表一组方法的集合。类型可以实现接口，而不需要显式声明。接口是 Go 的核心特性之一，它使得 Go 支持多态。
示例：
type Speaker interface {
    Speak() string
}

type Person struct { Name string }
func (p Person) Speak() string { return "Hello, " + p.Name }

var s Speaker = Person{"Alice"}  // 隐式实现
fmt.Println(s.Speak())  // 输出 "Hello, Alice"

9. 1.18版本后interface有什么增强？
Go 1.18 引入了类型参数（泛型），使得接口支持类型参数化。这允许你在接口中使用泛型类型，提高了灵活性和可复用性。
另外，type parameters 可以用于接口中作为类型约束。
示例：
type Adder[T any] interface {
    Add(a, b T) T
}

10. interface可以进行等值比较吗？
可以，但有一些限制：
接口值是比较的对象时，接口内部的类型和值都必须相同。
接口值为 nil 的时候需要特别注意，nil 接口与非 nil 接口是不同的。

11. 说说逃逸分析
逃逸分析是 Go 编译器的一项优化，用来确定一个变量是否需要分配到堆上。
栈分配：如果一个变量仅在函数内部使用并且不逃逸到函数外部，则可以分配到栈上。
堆分配：如果一个变量的地址会在函数外部使用，或者在多个 goroutine 中共享，则需要分配到堆上。

12. channel有缓冲和无缓冲的区别
无缓冲 channel：发送操作会阻塞，直到接收方准备好接收数据。适用于同步任务。
有缓冲 channel：有固定大小的缓冲区，发送方只有在缓冲区满时才会阻塞，接收方只有在缓冲区为空时才会阻塞。适用于解耦任务。

13. map并发访问会怎么样?这个异常可以捕获吗？
如果多个 goroutine 同时读写一个普通的 map，会导致程序崩溃。Go 本身没有提供机制来捕获这类错误，因此必须通过加锁来保证并发安全。

14. GMP模型
GMP（Goroutine、Scheduler、Processor）是 Go 的运行时调度模型。
G：goroutine，是 Go 中的轻量级线程。
M：机器线程，实际执行任务的操作系统线程。
P：处理器，是执行 goroutine 的上下文。每个 P 可以处理多个 G。
GMP 调度的目标是提高性能，避免过多的线程创建开销。

15. GMP模型中什么时候把G放全局队列？
如果当前 P 上没有可执行的 G（goroutine），则 G 会被放到全局队列（Gqueue）等待分配到其它 P 上去执行。

16. Go的GC
Go 使用 标记-清除算法进行垃圾回收。GC 会在后台自动进行，通过标记活动对象并清除不再引用的对象来回收内存。

Go 1.5+ 引入了并发 GC，通过分代收集和并发标记/清除来减少停顿时间。

17. GC扫描是并发的吗？
是的，Go 的 GC 是并发的。它在后台并发地进行垃圾回收，尽量避免长时间停顿应用。GC 会通过 三色标记算法，并结合 并发标记 来提高回收效率。
18. GC中的根对象是什么？
根对象是垃圾回收的起始点，包括：
活跃的 goroutine 栈
全局变量
本地变量（如果它们在堆上分配）

19. 项目中etcd用来干什么的？
etcd 是一个分布式的键值存储系统，通常用于存储配置数据、服务发现、分布式锁等。它的强一致性和高可用性使其成为分布式系统中常用的基础设施组件。

20. MySQL索引B＋T
B+树是一种平衡的树数据结构，是 MySQL 默认的索引结构。它有以下特点：
所有值都在叶子节点，叶子节点形成一个链表。
内部节点只存储键，用于索引查找。

21. 索引的优缺点
优点：
提高查询效率，特别是对于范围查询和排序。
可以加速数据的检索操作。
缺点：
占用更多的内存。
插入、更新、删除操作较慢，因为需要更新索引。

22. Redis用来做什么的？
Redis 是一个高性能的键值对存储系统，通常用来做缓存、消息队列、会话存储、排行榜等。

23. 用户信息怎么存的？都走缓存吗？
通常用户信息存储在数据库中，缓存用于存储常用数据和提高访问速度。大部分场景下，缓存优先，通过缓存减少数据库负载。

24. Redis过期淘汰策略
LRU：最近最少使用淘汰。
TTL：设置过期时间，时间到期自动删除。
LFU：最不常用淘汰策略。
```



## 腾讯二面（校招）

1. 会什么语言？
2. tcp和udp的本质区别
3. tcp可靠通信怎么实现的
4. 说一说拥塞控制
5. 滑动窗口的作用
6. 什么是粘包，怎么解决
7. 堆和栈有什么区别
8. 进程的进程空间是怎么样的？
9. 进程，线程，协程的区别
10. 链表额线性表的区别
11. 有序双向链表如何高效查询？
12. kafka如何实现高吞吐的？
13. 介绍最近的项目
14. 缓存击穿，雪崩，穿透



```sh
1. 会什么语言？
用户专注于 Golang 开发，也可能有其他编程语言的知识和经验，具体可以进一步确认。
2. TCP和UDP的本质区别
TCP（传输控制协议）是一种面向连接的协议，提供可靠的数据传输。它保证数据的顺序和完整性，使用 三次握手 建立连接，并在数据传输中进行重传、校验和流量控制。
UDP（用户数据报协议）是无连接的协议，传输时不保证数据的顺序或完整性，适用于对实时性要求较高的场景，如视频流、在线游戏等。
3. TCP可靠通信怎么实现的
可靠性通过以下几种机制实现：
三次握手：确保连接的双方都能确认彼此的存在。
数据重传：丢失的数据包会通过重传机制重新发送。
序列号：通过序列号保证数据包的顺序。
校验和：每个数据包都会进行校验，确保数据的完整性。
确认应答（ACK）：接收方确认接收到数据后发送 ACK 信号。
流量控制：通过滑动窗口机制控制发送方的发送速率。
4. 说一说拥塞控制
拥塞控制是为了避免网络中出现过多的流量，导致网络拥塞或崩溃。TCP 使用以下几种策略：
慢启动：初始时发送速度较慢，每次成功的包确认后，增加发送速率。
拥塞避免：当检测到网络拥塞时，降低发送速率。
快速重传：在丢包时迅速重传，而不是等待超时。
快速恢复：丢包后，恢复发送速率的过程。
5. 滑动窗口的作用
滑动窗口机制主要用于流量控制，限制发送方的发送速率。接收方会向发送方告知自己可以接收的数据量，发送方根据接收方的反馈调整发送的数据量。窗口的大小可以动态调整，以适应当前网络状态。
6. 什么是粘包，怎么解决
粘包指的是在 TCP 通信中，由于数据包的边界不明确，多个包被一起发送到接收端，导致接收方无法正确区分数据包的边界。
解决办法：
固定长度包：发送数据包时固定每个包的长度。
分隔符：在数据包之间添加特定的分隔符，接收端根据分隔符识别包边界。
长度字段：每个包前面加上表示数据包长度的字段。
7. 堆和栈有什么区别
栈：由操作系统自动管理，用于存储局部变量、函数调用等。栈内存分配和回收速度快，但容量有限。
堆：用于动态分配内存，程序员需要手动管理（在一些语言中是由垃圾回收机制来管理）。堆内存的管理更灵活，容量大，但性能较栈慢。
8. 进程的进程空间是怎么样的？
进程空间是每个进程独立的内存区域，通常包括：
代码段：存储程序代码。
数据段：存储程序运行时使用的全局变量、静态变量。
堆：动态分配内存区域。
栈：存储函数调用相关的局部变量和控制信息。
内核空间：操作系统内核使用的内存空间。
9. 进程，线程，协程的区别
进程是操作系统分配资源的最小单位，每个进程拥有独立的内存空间。
线程是进程中的执行单元，共享进程的内存空间。线程之间的通信相对简单，但线程切换开销较大。
协程是比线程更轻量的执行单元，它们共享线程的栈内存，并由程序调度器管理。协程切换开销小，适用于大量并发任务。
10. 链表和线性表的区别
链表是一个由节点组成的数据结构，每个节点包含数据和指向下一个节点的指针。链表的插入和删除操作时间复杂度为 O(1)，但随机访问效率差。
线性表是一个数据元素按顺序排列的数据结构，包括数组和链表。链表是线性表的一种实现形式。
11. 有序双向链表如何高效查询？
有序双向链表可以通过从头或尾部查找来提高查询效率，通常会使用指针来遍历链表。对于高效查询，可以通过二分查找（在某些情况下）或引入索引等机制来优化查询速度。
12. Kafka如何实现高吞吐的？
Kafka 高吞吐的实现依赖于以下几个关键因素：
顺序写入：Kafka 优化了磁盘的顺序写入操作，相比随机写入，顺序写入可以极大提高吞吐量。
消息压缩：通过压缩消息（如使用 Snappy、LZ4 等算法），减少了网络和磁盘的负载。
分区和副本机制：Kafka 通过将消息分区，并利用副本保证高可用，且可以实现数据的并行处理和存储。
批量处理：Kafka 支持将多个消息打包成一个批量发送，提高了网络吞吐。
13. 介绍最近的项目
最近的项目涉及到 Golang 和 Kubernetes，主要是开发和部署后端微服务，使用 Kafka 做消息队列，解决了高并发数据处理的问题。
14. 缓存击穿，雪崩，穿透
缓存击穿：缓存中的某个热点数据失效，导致大量请求直接打到数据库上，造成数据库压力过大。
解决方法：使用互斥锁、请求合并、设置合理的缓存过期时间。
缓存雪崩：大量缓存同时失效，导致大量请求直接访问数据库，可能导致数据库崩溃。
解决方法：缓存的过期时间错开，使用预热策略。
缓存穿透：查询一个不存在的数据，缓存和数据库都没有，导致每次查询都去数据库查询。
解决方法：对不存在的数据设置一个较短的缓存时间，或者缓存空数据。
```





## 腾讯三面（校招）

1. 项目中比较有挑战性的事？
2. 什么是伪随机？
3. c＋＋里面的继承和虚函数，抽象封装，和go的interface有什么区别？
4. 为什么go不是传统意义上的面向对象语言？
5. c＋＋多重继承可能导致循环继承，go用interface实现有这种问题吗？
6. 单例模式？什么情况用饿汉模式，什么时候用懒汉模式？
7. 表的主键用什么类型的字段？用字符串不可以吗？
8. 消息队列是什么?
9. 有了解过其他消息队列吗？
10. kafka你们是怎么部署的呢？
11. 能说一说你们怎么使用devops的吗？
12. 不用kafka可以吗？
13. ES是干什么的？
14. 前后端通信用的什么协议？
15. grpc相比http的优势在什么地方呢？



```sh
1. 项目中比较有挑战性的事？
项目中比较具有挑战性的部分通常是如何优化高并发的数据处理和网络通信。在某个项目中，我们使用 Kafka 作为消息队列时，需要确保消息的顺序和高吞吐量，同时要处理 Kafka 的 消费者负载均衡 和 消息重复消费 问题，这需要做大量的性能测试和容错处理。
2. 什么是伪随机？
伪随机是指由算法生成的随机数，它看起来是随机的，但实际上是可预测的。伪随机数的生成通常依赖于初始种子（种子不同，生成的伪随机数也不同）。常见的伪随机生成算法有 线性同余法 和 梅森旋转算法。
3. C++里面的继承和虚函数，抽象封装，和 Go 的 interface 有什么区别？
C++的继承和虚函数：
C++ 支持类的继承，使用虚函数（virtual）来实现多态。基类的虚函数可以在派生类中被重写，并通过基类指针或引用进行动态绑定。
Go的接口：
Go 不支持传统的继承，而是通过接口来实现多态。类型不需要显式声明实现了某个接口，Go 会自动检测类型是否实现了接口的所有方法。
区别：
C++ 采用静态继承和虚函数机制，而 Go 更加灵活，接口实现是隐式的，不需要继承关系。
C++ 允许多重继承，而 Go 通过组合和接口避免了多重继承的问题。
4. 为什么Go不是传统意义上的面向对象语言？
Go 并不完全符合传统面向对象语言（如 Java 或 C++）的定义，原因包括：
没有类：Go 使用结构体和接口来代替类的功能。
没有继承：Go 不支持类的继承，而是通过组合和接口来实现代码重用。
没有访问控制：Go 的成员字段首字母大小写决定了其访问权限，但没有类似 private 或 protected 的明确访问修饰符。
5. C++多重继承可能导致循环继承，Go用interface实现有这种问题吗？
C++多重继承问题：C++ 中的多重继承可能导致循环继承或菱形继承问题，产生二义性。C++ 通过虚拟继承来解决这个问题。
Go中的接口：Go 不支持多重继承，因此不会出现循环继承的问题。Go 的接口实现是隐式的，避免了继承链上的复杂性和问题。
6. 单例模式？什么情况用饿汉模式，什么时候用懒汉模式？
单例模式：确保某个类只有一个实例，并提供全局访问点。
饿汉模式：在类加载时就创建实例，线程安全，但可能会浪费资源。
懒汉模式：在第一次需要时创建实例，适用于实例化开销较大或资源密集型对象的情况。
使用饿汉模式：当你能确定类的实例化不依赖外部条件，且加载时没有性能问题时。
使用懒汉模式：当实例化较为昂贵或初始化过程依赖外部条件时。
7. 表的主键用什么类型的字段？用字符串不可以吗？
通常情况下，主键字段使用 整数类型（如 int、bigint）因为其具有较高的性能和存储效率。字符串虽然可以作为主键，但会增加存储空间和查询开销。对于需要全局唯一标识符的情况，可以使用 UUID。
8. 消息队列是什么？
消息队列是一种通信机制，允许不同系统或不同组件之间异步地传递消息。消息队列可以解耦系统，提供更高的可扩展性和容错能力。常见的消息队列系统有 RabbitMQ、Kafka、ActiveMQ。
9. 有了解过其他消息队列吗？
是的，除了 Kafka，我们还使用过 RabbitMQ、RocketMQ 等消息队列系统。每种消息队列都有其特点：
RabbitMQ：基于 AMQP 协议，支持复杂的路由和消息确认，适合高可靠性场景。
RocketMQ：阿里开源的消息队列，提供高吞吐量和低延迟的能力，适用于大规模分布式系统。
10. Kafka你们是怎么部署的呢？
Kafka 通常部署在多个节点上以实现高可用性。我们会部署一个 Kafka 集群，通过 Zookeeper 管理集群的元数据。为了确保高吞吐量和容错性，会将消息进行 分区，并在不同节点之间 副本。
11. 能说一说你们怎么使用 DevOps 吗？
我们使用 DevOps 来自动化软件开发和运维流程，包括：
CI/CD：通过 Jenkins、GitLab CI 或 GitHub Actions 实现自动化构建、测试和部署。
容器化：使用 Docker 来打包应用程序，确保开发和生产环境的一致性。
Kubernetes：使用 Kubernetes 部署和管理容器化应用，实现自动化的扩展、负载均衡和高可用性。
监控：通过 Prometheus 和 Grafana 进行系统监控，并结合 ELK Stack（Elasticsearch、Logstash、Kibana）进行日志分析。
12. 不用 Kafka 可以吗？
当然可以，消息队列并非必需。如果业务场景中没有分布式系统、异步消息处理、解耦需求等，那么可以不使用 Kafka，转而使用传统的 数据库 或 HTTP 请求 等机制。但对于高吞吐量、分布式环境下，Kafka 能提供很好的性能和可靠性。
13. ES是干什么的？
Elasticsearch (ES) 是一个开源的全文搜索和分析引擎，适用于实时搜索和分析大规模数据。它广泛应用于日志分析、网站搜索、数据挖掘等场景。
14. 前后端通信用的什么协议？
我们通常使用 HTTP/HTTPS 协议进行前后端通信，前端通过 RESTful API 或 GraphQL 与后端进行数据交换。在某些实时性要求较高的场景下，使用 WebSocket 来实现双向通信。
15. gRPC相比HTTP的优势在什么地方呢？
gRPC 相比传统的 HTTP/REST 在以下几个方面具有优势：
性能：gRPC 基于 Protocol Buffers 进行高效的序列化，性能比 JSON 更高。
双向通信：gRPC 支持双向流，允许客户端和服务器之间进行实时通信。
强类型：gRPC 使用 IDL （接口定义语言）来定义服务，具有强类型，易于生成客户端和服务端代码。
跨语言支持：gRPC 支持多种编程语言，可以轻松实现跨语言通信。
```





## 腾讯QQ一面

1. 自我介绍
2. 算法：20有效括号，240搜索二维矩阵Ⅱ
3. 项目在运行了吗？数据表的设计？简单画一下
4. 数据库外键关联不同表吗？
5. 抢单的设计是怎么做的？
6. Redis里缓存了所有悬赏的订单？
7. 怎样防止多人抢单？没有很理解递减是怎么实现的
8. 悬赏下单的用户？
9. 为什么有订单数量的概念？
10. 如果Redis抢单成功但是后面的逻辑失败怎么办？即发消息队列的失败了会怎么样？会出现什么问题？
11. 上述问题有没有什么解决办法？
12. 直接用Mysql实现多人抢单可以吗？
13. 使用Mysql的话有没有不通过数量控制的方案？
14. 上个问题相对更优雅的解决方案，如根据订单状态
15. QPS提升3倍，为什么只提升了3倍？所有服务搭载在个人机上，提升比较小，这样测试是不合理的
16. 点赞是怎么设计的？点赞的底层逻辑怎么存的？
17. 评论怎么设计的？
18. 评论可以折叠吗？只有一个层级？
19. 如果你考虑针对评论进行回复的话，他可能的数据表结构是怎样的？
20. 设计完成以后怎么查这些不同层级的评论？
21. 所以其实实现不同层级的评论只需要一个表就行了，只不过子评论要记录其对应的主评论的id
22. Go了解的多不多？
23. Java的集合大概讲一讲
24. ArrayList的底层怎么实现，数据结构怎么样，扩容策略是怎样的
25. HashMap的底层实现呢，Hash冲突怎么处理的？扩容策略？加载因子多大？为什么是0.75
26. Java的垃圾收集机制
27. 新生代老年代是怎么划分的？
28. 网络相关的HTTP了解的不多吗？Get和Post的区别？
29. 登录请求的话用什么请求？用Get会有什么问题
30. 从浏览器输入个网址到显示页面的过程
31. TCP和UDP的区别？
32. 操作系统相关的了解吗？
33. Redis常用的数据结构有哪些？如果要实现一个排行榜，用什么数据结构？
34. 如果实现分布式锁呢？什么命令？setnx
35. Redis实现简易的布隆过滤器是怎么实现的？
36. Redis常见的穿透击穿雪崩问题？
37. 击穿的解决方案
38. 逻辑过期的话怎么更新呢？逻辑过期的时间点有很多请求过来，是不是都会去数据库请求更新数据？
39. Redis的过期淘汰策略
40. Redis过期数据的删除策略？
41. Mysql的索引通常是怎么划分的？从数据结构上可以划分为哪些索引？是指这些索引数据结构不一样，比如InnoDB的？MyISAM的？哈希的？
42. 聚簇索引和非聚簇索引的区别？
43. 数据和索引放一起的优点
44. 什么是回表？
45. Mysql事务的隔离级别
46. 未提交读有什么问题？
47. 什么是不可重复读？什么是幻读？
48. 反问

```sh
1. 自我介绍
我是一个专注于 Go 语言的后端开发工程师，拥有丰富的 Golang 开发经验，涉及的领域包括微服务架构、容器化部署、消息队列等。除了 Go 语言，我也有一定的前端开发、数据库设计和 DevOps 实践经验。
2. 算法：20有效括号，240搜索二维矩阵Ⅱ
20. 有效括号：通过栈来实现，逐个检查括号的匹配情况。遇到左括号就入栈，遇到右括号就从栈中弹出并检查是否匹配。
240. 搜索二维矩阵Ⅱ：可以利用从右上角开始的查找方式，逐步排除无效区域，时间复杂度为 O(m+n)，其中 m 和 n 分别是矩阵的行和列。
3. 项目在运行了吗？数据表的设计？简单画一下
如果需要设计数据库表，通常会根据业务需求进行设计，保证数据的完整性和查询效率。例如设计一个“订单表”包括订单ID、用户ID、商品ID、订单状态等字段。
4. 数据库外键关联不同表吗？
是的，数据库中的外键用于在不同表之间建立关联，确保数据的完整性。外键约束确保子表中的数据引用主表中的有效数据。
5. 抢单的设计是怎么做的？
抢单的设计可以使用 Redis 来实现原子操作。例如，通过 Redis 锁 或 Redis 的计数器 来限制抢单的数量，并防止并发问题。
6. Redis里缓存了所有悬赏的订单？
是的，通常在高并发的场景下，订单的状态可以缓存到 Redis 中，以减少数据库的查询压力。
7. 怎样防止多人抢单？没有很理解递减是怎么实现的
防止多人抢单可以通过 Redis 原子递减操作（如 DECR 或 DECRBY 命令）来实现。每次抢单时，数量会递减，确保抢单者不会超过上限。
8. 悬赏下单的用户？
悬赏下单的用户是指发起订单请求的用户。订单信息通常会包括用户ID、商品ID、订单金额等字段。
9. 为什么有订单数量的概念？
订单数量通常用于跟踪订单的状态和处理数量。例如，可以防止订单数量超过实际可处理数量，保证订单的正常流转。
10. 如果Redis抢单成功但是后面的逻辑失败怎么办？即发消息队列的失败了会怎么样？会出现什么问题？
如果 Redis 中抢单成功后，消息队列发送失败，可能会导致订单状态不一致。常见的问题是订单的状态已更新，但消息未成功投递到其他服务，可能导致订单未被正确处理。
11. 上述问题有没有什么解决办法？
可以使用 事务 或 补偿机制 来处理这种情况。例如，可以使用消息队列的重试机制，或将失败的消息存入死信队列（DLQ）以便后续处理。
12. 直接用MySQL实现多人抢单可以吗？
使用 MySQL 实现多人抢单是可以的，但可能会面临性能瓶颈，特别是在高并发情况下。MySQL 的 锁机制 可以确保数据的一致性，但会影响性能，尤其是当抢单数量较大时。
13. 使用MySQL的话有没有不通过数量控制的方案？
不通过数量控制的方案可以使用 订单状态 来控制。例如，抢单后直接将订单的状态更新为“已抢”，并且保证后续逻辑中不会对该订单进行二次抢占。
14. 上个问题相对更优雅的解决方案，如根据订单状态
更优雅的解决方案是使用 订单状态 来控制，例如将订单状态设置为“未抢”、“已抢”或“已完成”，并在每次请求时检查订单状态，避免重复抢单。
15. QPS提升3倍，为什么只提升了3倍？所有服务搭载在个人机上，提升比较小，这样测试是不合理的
这个问题表明可能存在 瓶颈，例如网络带宽、CPU 或内存资源的限制。个人机器上运行多个服务可能导致资源竞争，性能提升受限。应该在分布式环境下进行测试，以获得更准确的性能结果。
16. 点赞是怎么设计的？点赞的底层逻辑怎么存的？
点赞功能一般使用 Redis 或 MySQL 存储，具体实现方式可以是：
使用 计数器（如 Redis 的 INCR 命令）来统计点赞数。
使用 Redis 哈希表来记录每个用户对某个对象的点赞状态。
17. 评论怎么设计的？
评论通常可以设计为一个独立的表，字段包括：评论ID、用户ID、评论内容、时间戳、评论对象ID（如商品ID或帖子ID）等。
18. 评论可以折叠吗？只有一个层级？
评论可以设计成 多层级，支持折叠和展开。可以通过设置评论的父评论ID来支持树形结构。
19. 如果你考虑针对评论进行回复的话，他可能的数据表结构是怎样的？
回复评论的数据表结构可以包括：评论ID、父评论ID、用户ID、评论内容、时间戳等。父评论ID 用来关联主评论，形成树形结构。
20. 设计完成以后怎么查这些不同层级的评论？
查询评论时，可以使用 递归查询（如果使用 SQL）或通过 树形结构 来查询评论和回复。
21. 所以其实实现不同层级的评论只需要一个表就行了，只不过子评论要记录其对应的主评论的id
是的，使用一个表即可实现多层级评论。子评论通过记录父评论ID 来关联主评论。
22. Go了解的多不多？
是的，我有丰富的 Go 语言开发经验，熟悉其并发编程模型、内存管理和性能优化。
23. Java的集合大概讲一讲
Java 集合框架包括：
List（如 ArrayList、LinkedList）：有序集合，允许重复元素。
Set（如 HashSet、TreeSet）：无序集合，不允许重复元素。
Map（如 HashMap、TreeMap）：键值对集合，键唯一，值可重复。
24. ArrayList的底层怎么实现，数据结构怎么样，扩容策略是怎样的
ArrayList 使用动态数组实现，初始容量为 10。当容量不足时，数组会 扩容，通常是原容量的 1.5 倍。
25. HashMap的底层实现呢，Hash冲突怎么处理的？扩容策略？加载因子多大？为什么是0.75
HashMap 使用数组 + 链表或红黑树实现。哈希冲突通过链表法或树化法解决。扩容策略：当填充因子超过 0.75 时，HashMap 会扩容为原来的两倍。
26. Java的垃圾收集机制
Java 垃圾收集机制基于 分代收集，将堆内存分为 年轻代 和 老年代。年轻代使用 Minor GC，老年代使用 Major GC。
27. 新生代老年代是怎么划分的？
新生代用于存储新创建的对象，老年代存储长时间存活的对象。大部分对象在新生代被回收，只有少部分存活对象晋升到老年代。
28. 网络相关的HTTP了解的不多吗？Get和Post的区别？
GET 用于请求数据，参数暴露在 URL 中；POST 用于提交数据，数据放在请求体中。POST 比 GET 更安全、数据量也较大。
29. 登录请求的话用什么请求？用Get会有什么问题
登录请求应该使用 POST，因为登录信息（如密码）需要保护，GET 会将敏感信息暴露在 URL 中。
30. 从浏览器输入个网址到显示页面的过程
过程包括：DNS 解析 -> TCP 连接 -> 发送 HTTP 请求 -> 服务器响应 -> 浏览器渲染页面。
```







## 腾讯QQ二面（电话面）

1. 自我介绍
2. Golang协程与线程的区别
3. 专业问题
4. 中间漏了几个问题
5. Redis缓存击穿解决方案在项目中是否用过，用在什么地方
6. 检查到key过期了，都请求数据库不就击穿了吗
7. 怎么加锁
8. 这个锁放在本地吗？内存里面吗？
9. MySQL支持的最大并发数
10. Redis支持的最大并发数
11. 算法：文件里面有20亿个整数，找到前1000个最大的，要求时间复杂度尽可能低
12. 上述算法时间复杂度多少
13. 项目背景
14. Jmter压测的哪个接口
15. QPS
16. 具体是怎么优化的呢
17. 压测后qps提升了3倍，瓶颈在哪个地方，为什么不能再多了
18. 阿里云用的是Cos服务是吧
19. 订单超卖是什么意思
20. 项目大概多少人参与
21. 这个服务有几个系统
22. 这个项目是用来给自己学校的吗？还是各个学校通用的项目？
23. 这个项目打通了学校里面的账号体系了吗？
24. 反问



```sh
1. Golang协程与线程的区别
协程是轻量级的执行单元，由 Go 运行时调度。协程的创建和销毁开销小，可以通过 go 关键字并发执行。
线程是操作系统的执行单元，由操作系统调度。线程比协程更重，切换代价较大。
区别：
协程的开销远小于线程，通常可以创建成千上万的协程。
线程由操作系统管理，协程由 Go 运行时调度。
2. 专业问题
具体问题可以根据需要详细提问，通常涉及到技术架构、系统设计、性能优化等领域。
3. 中间漏了几个问题
你可以补充或提醒漏掉的问题，我会继续回答。
4. Redis缓存击穿解决方案在项目中是否用过，用在什么地方
解决方案：
设置 互斥锁（如 Redis 的 SETNX）防止多个请求同时访问数据库。
使用 标记失效时间，让请求只有在缓存失效时才去数据库查询。
应用场景：
在高并发的场景下，如商品详情页缓存中，如果商品信息过期，多个请求会同时访问数据库，我们可以用 Redis 锁来避免多次查询。
5. 检查到key过期了，都请求数据库不就击穿了吗
为避免击穿，可以使用 缓存穿透 和 缓存预加载 的策略。
例如，设置一个 合理的过期时间 和 过期后的重新加载，并在缓存数据过期前提前加载。
6. 怎么加锁
在多线程环境下，可以使用以下方式加锁：
互斥锁：使用 sync.Mutex 锁定共享资源，确保同一时刻只有一个 goroutine 可以访问该资源。
读写锁：使用 sync.RWMutex 实现多个读线程并行，写线程独占。
7. 这个锁放在本地吗？内存里面吗？
锁通常是放在内存中，如 内存锁 (sync.Mutex) 用于保护内存中的共享资源。
分布式锁（如 Redis）用于在多台服务器上同步操作。
8. MySQL支持的最大并发数
MySQL 的最大并发数与 max_connections 配置项有关，默认值通常是 151，但可以通过配置增加，理论上 MySQL 可以支持上千并发连接。
9. Redis支持的最大并发数
Redis 的最大并发数与其配置的硬件资源（CPU、内存）有关，通常可以处理数万到数十万的并发请求，具体取决于服务器的性能和配置。
10. 算法：文件里面有20亿个整数，找到前1000个最大的，要求时间复杂度尽可能低
使用 最小堆（Min-Heap）来存储前1000个最大的整数。遍历所有数据，每次与堆顶元素比较，若大于堆顶，则替换堆顶元素并调整堆。
时间复杂度：O(n log k)，其中 n 是文件中的整数数量，k 是前1000个最大的数。
11. 上述算法时间复杂度多少
时间复杂度为 O(n log k)，其中：
n 是整数数量（20亿）。
k 是前1000个最大的数。
12. 项目背景
项目背景可以根据具体的业务需求和目标来定，通常包括目标用户群、项目功能、技术栈等。
13. JMeter压测的哪个接口
JMeter 通常用于压测 API 接口，具体测试的接口可能包括：登录、查询、下单等高并发操作。
14. QPS
QPS（Queries per Second）是衡量每秒查询次数的指标，通常用于评估系统的吞吐量。
15. 具体是怎么优化的呢
优化方式：
数据库优化：如增加索引、优化查询。
缓存：使用 Redis 缓存热点数据。
并发控制：减少锁竞争，使用分布式锁。
异步处理：将耗时操作异步化，如消息队列。
16. 压测后qps提升了3倍，瓶颈在哪个地方，为什么不能再多了
压测后，QPS提升3倍说明系统已接近瓶颈，可能瓶颈在：
数据库性能：数据库成为瓶颈，可能由于查询、连接数限制、IO 等原因。
网络带宽：网络带宽不足，无法承载更多的请求。
硬件资源：CPU、内存等硬件资源达到了极限。
17. 阿里云用的是Cos服务是吧
阿里云提供的是 OSS（对象存储服务），而 COS（Cloud Object Storage）是腾讯云的对象存储服务。
18. 订单超卖是什么意思
订单超卖指的是在库存不足的情况下，系统仍然允许用户下单，导致最终库存不足，无法满足订单需求。
19. 项目大概多少人参与
项目团队的规模通常取决于项目的复杂度，一般中型项目的团队规模在 5~20人 之间。
20. 这个服务有几个系统
通常一个项目会包含多个子系统，如用户系统、订单系统、支付系统等，具体数量视业务需求而定。
21. 这个项目是用来给自己学校的吗？还是各个学校通用的项目？
项目的目标用户群体可以是特定学校，也可以是多个学校通用。具体需求可根据业务情况而定。
22. 这个项目打通了学校里面的账号体系了吗？
如果涉及到多个学校，通常会有统一的账号体系（如 SSO 单点登录）来打通不同系统间的用户身份认证。
```





## 腾讯云智

### 一面

1. 自我介绍
2. 第一个项目是实习项目吗
3. 你在里面负责的部分
4. 用户悬赏下单的业务流程讲一下
5. RabbitMQ写库失败了会怎么处理
6. Redis的数据与数据库里的数据是怎么保持一致的
7. 什么时候写库什么时候写Redis，数据库中有库存吗
8. Redis是在哪部署的
9. Redis用的哪种数据类型，项目中Redis哪些地方用了
10. SpringCache依赖Redis，那用的是什么数据类型
11. 登录注册是怎么实现的
12. 什么是JWT
13. 鉴权是怎么做的
14. 退出登录是怎么实现的
15. 简易短视频都负责什么？登录注册是怎么实现的
16. TCP的三次握手和四次挥手的过程
17. Time wait的作用是什么
18. 断开连接是客户端发起还是服务端发起？服务端可以断开吗？
19. HTTP和HTTPS的区别
20. HTTPS是怎么加密的了解吗
21. Session，Cookie，token的区别
22. Session是在哪存的
23. 进程线程协程这三个的区别
24. CPU调度是哪个
25. 数据库事务的隔离级别
26. 什么是幻读
27. MySQL主键索引和普通索引的区别
28. 怎么避免回表操作
29. 索引失效的场景
30. B树和B+树的区别
31. 如何实现一个HashMap（HashMap的底层结构以及一些扩容操作）
32. HashMap和ConcurrentHashMap的区别
33. 深拷贝和浅拷贝的区别
34. 说一说使用逻辑过期解决缓存击穿问题
35. key逻辑过期后，与数据库的一致性怎么保证
36. 缓存穿透问题及解决方案
37. ThreadLocal实现线程信息隔离说一下
38. 用户登录以后，再请求其他接口，这时是同一个线程吗？
39. 不把用户id放到threadlocal可以吗？
40. 算法题

```sh
1. RabbitMQ写库失败了会怎么处理
在写库失败时，RabbitMQ通常会采取以下几种措施：
消息重试机制：通过设置 死信队列（DLX）和消息重试机制，RabbitMQ 会在写库失败后将消息放入死信队列，并定期重新尝试。
事务或补偿机制：如果操作数据库的事务回滚，可能会触发 补偿机制 来修复失败操作，确保系统的一致性。
2. Redis的数据与数据库里的数据是怎么保持一致的
缓存更新策略：
写入时更新：每次数据写入数据库时，同时更新缓存。
定期同步：使用定时任务定期从数据库同步数据到 Redis。
异步同步：通过消息队列触发，保证缓存和数据库的一致性。
3. 什么时候写库什么时候写Redis，数据库中有库存吗
写库时：主要负责保存持久化的数据，比如用户的交易数据、订单信息等，数据会直接写入数据库。
写Redis时：用于存储频繁读取的数据，比如缓存热点数据（如用户信息、商品信息、库存等）。
库存：通常库存存储在数据库中，但为了减少数据库压力，可以在 Redis 中使用 缓存库存，并且通过定期同步和一致性控制来确保数据一致。
4. Redis是在哪部署的
Redis 可以部署在 本地服务器、容器化环境、云服务等不同的环境中。部署时通常使用 主从复制 或 集群模式 来提高可用性和扩展性。
5. Redis用的哪种数据类型，项目中Redis哪些地方用了
常用数据类型：
字符串：用于存储简单的缓存数据。
哈希：适合存储对象数据，如用户信息。
列表、集合：适用于任务队列、排行榜等应用。
有序集合：用于存储需要排序的集合，如排行榜。
应用场景：
存储用户信息、商品详情、热点查询数据等。
6. SpringCache依赖Redis，那用的是什么数据类型
Spring Cache 使用 Redis 作为缓存时，通常会使用 字符串 类型来缓存数据。但也可以根据需要，使用 哈希 或 列表 等数据类型。
7. 登录注册是怎么实现的
登录：用户提供用户名和密码，系统验证密码是否正确，若正确则生成一个 JWT 或 Session ID，将其返回给客户端，客户端存储在 Cookie 或 LocalStorage 中。
注册：用户填写信息后，系统验证信息的合法性，若合法，则将用户信息写入数据库，并生成初始密码或通过其他方式激活账户。
8. 什么是JWT
JWT（JSON Web Token）是一种用于认证和信息交换的开放标准。它通过 头部、载荷、签名 组成，常用于无状态的身份验证和信息传输。
9. 鉴权是怎么做的
用户通过 用户名和密码 登录后，系统会生成一个 JWT 或 Session ID，客户端将该令牌存储在 Cookie 或 LocalStorage 中，后续的请求会携带该令牌，服务器验证令牌的有效性来完成鉴权。
10. 退出登录是怎么实现的
客户端：删除存储在 Cookie 或 LocalStorage 中的令牌。
服务器：在使用 JWT 时，通常不需要主动删除令牌，只要令牌过期即可；若使用 Session，服务器会清除 Session 数据。
11. 简易短视频都负责什么？登录注册是怎么实现的
功能：
视频上传、播放、评论、点赞、分享、搜索等。
用户注册、登录、视频发布、评论和社交功能。
登录注册：使用邮箱或手机号注册，用户通过邮箱验证码或短信验证码进行注册，登录时使用 JWT 进行身份验证。
12. TCP的三次握手和四次挥手的过程
三次握手：
客户端发送 SYN 请求，表示请求建立连接。
服务器回复 SYN-ACK，表示同意连接。
客户端发送 ACK 确认，连接建立完成。
四次挥手：
客户端发送 FIN 请求，表示数据发送完毕。
服务器回复 ACK 确认，表示准备关闭连接。
服务器发送 FIN 请求，表示数据发送完毕。
客户端回复 ACK 确认，连接关闭。
13. Time wait的作用是什么
Time Wait 是在四次挥手后的最后状态，确保客户端接收到服务器的 ACK。它的作用是确保在最后的 ACK 被正确接收，防止由于延迟的 TCP 包 导致数据冲突。
14. 断开连接是客户端发起还是服务端发起？服务端可以断开吗？
连接的断开可以由客户端或服务端发起，通常服务端可以主动关闭连接。在应用层中，服务端主动关闭连接通常出现在长连接场景中。
15. HTTP和HTTPS的区别
HTTP：超文本传输协议，数据以明文传输。
HTTPS：HTTP的安全版，通过 SSL/TLS 协议加密传输，保证数据的安全性和完整性。
16. HTTPS是怎么加密的了解吗
HTTPS加密：通过 SSL/TLS 协议对数据进行加密，分为三部分：
对称加密：用于加密数据传输。
非对称加密：用于加密对称加密的密钥交换。
数字证书：验证服务器身份，防止中间人攻击。
17. Session，Cookie，token的区别
Session：服务器端保存会话信息，每个客户端有一个唯一的 Session ID。
Cookie：客户端存储信息，常用于保存 Session ID 或其他小数据。
Token：用于身份验证的令牌，如 JWT，常存储在客户端，携带用户的身份信息。
18. Session是在哪存的
Session 通常存储在 服务器端的内存 或 数据库 中，客户端存储一个 Session ID，用于标识用户。
19. 进程线程协程这三个的区别
进程：操作系统资源分配的最小单位。
线程：进程中的执行单元，共享进程资源。
协程：比线程更加轻量级的执行单元，协程通过调度器管理并发执行。
20. CPU调度是哪个
CPU调度是操作系统中的核心任务，决定哪一个进程或线程获得CPU资源。
21. 数据库事务的隔离级别
READ UNCOMMITTED：读取未提交数据。
READ COMMITTED：读取已提交数据。
REPEATABLE READ：保证读取的数据不会发生变化，但可能会有幻读。
SERIALIZABLE：完全隔离，事务顺序执行。
22. 什么是幻读
幻读是指事务在读取数据时，由于其他事务的插入，导致原本不存在的数据变得可见。
23. MySQL主键索引和普通索引的区别
主键索引：主键索引是 唯一的，并且 不可为空，它是数据表的聚簇索引，数据存储顺序与索引顺序一致。
普通索引：普通索引是非聚簇索引，数据存储顺序与索引顺序无关。
24. 怎么避免回表操作
使用 覆盖索引：查询字段全部包含在索引中，避免回表。
25. 索引失效的场景
使用 OR、LIKE（开头含 %）等，或者 函数 和 类型转换 等，会导致索引失效。
26. B树和B+树的区别
B树：每个节点可以有多个子节点，数据存储在叶子节点和内部节点中。
B+树：所有数据存储在叶子节点中，内部节点仅作为索引，适合范围查询。
27. 如何实现一个HashMap（HashMap的底层结构以及一些扩容操作）
HashMap 使用数组和链表/红黑树结合的方式存储数据。通过 哈希函数 将键映射到数组的索引位置，冲突的键会以链表的形式存储。扩容时，哈希表大小翻倍，且重新计算哈希值。
28. HashMap和ConcurrentHashMap的区别
HashMap 是 非线程安全 的。
ConcurrentHashMap 使用分段锁技术（或更先进的技术）来实现高效的线程安全。
29. 深拷贝和浅拷贝的区别
浅拷贝：只拷贝对象的引用，原对象和拷贝对象共享引用的资源。
深拷贝：拷贝对象及其所有的引用对象，避免引用共享。
30. 使用逻辑过期解决缓存击穿问题
逻辑过期：将缓存设置为一定的逻辑过期时间，在缓存过期时，不立即删除，而是由后台异步更新缓存。
31. key逻辑过期后，与数据库的一致性怎么保证
可以使用 缓存预热 或 后台定时同步，在缓存过期时，不会直接从数据库获取，而是通过异步更新来保证一致性。
32. 缓存穿透问题及解决方案
缓存穿透：缓存和数据库都没有数据，导致每次都查询数据库。
解决方案：使用 布隆过滤器 检查是否存在该数据，避免无效查询。
33. ThreadLocal实现线程信息隔离说一下
ThreadLocal 是每个线程独立拥有自己的变量副本，确保每个线程不会互相影响。
34. 用户登录以后，再请求其他接口，这时是同一个线程吗？
通常情况下，HTTP 请求是 无状态的，每个请求可能由不同的线程处理。
35. 不把用户id放到threadlocal可以吗？
可以，但使用 ThreadLocal 可以让每个线程独立存储数据，避免在多线程环境下频繁传递用户ID，提高性能。
```







### 二面

1. 自我介绍
2. 挑一个项目聊一下
3. 第一版方案为什么会超卖呢
4. Redis中的库存还没有递减完成，出现了比如OOM的情况，数据库怎么获得已经抢成功的数据？
5. 数据库和缓存数据一致性的问题
6. 如果数据库更新完成了，但是删除缓存时没有成功，这时会怎么办
7. 项目有实际需求吗？还是找的课题
8. RabbitMQ在项目里是干嘛用的？
9. 抢单的人怎么知道要查哪个key呢？
10. 具体压测的数据
11. 简易短视频是怎样的项目
12. 反问

## 腾讯

### 某不知名组一面（电话面）

1. 简单的自我介绍
2. Java判断相等使用==和使用equals的区别
3. Java里面接口和抽象类的区别，属性、方法、继承限制等方面回答
4. 详细介绍下项目用户注册和登录的流程
5. 密码存到数据库中是用的哪种方式进行的加密
6. 不加盐的问题
7. 登录成功以后返回的什么数据
8. 返回的token是怎么生成的
9. token里面包含了什么信息
10. 客户端和后台通信走什么协议
11. 对于HTTP协议有多少了解
12. Redis提供了哪些基础的数据类型
13. 这些数据类型底层是基于什么数据结构实现的
14. 使用Redis做性能优化具体是怎么做的
15. 对Linux操作系统熟悉吗
16. 项目后台不是部署在Linux上的吗
17. 反问



```sh
1. 第一版方案为什么会超卖呢
超卖问题通常发生在并发访问时，多个请求几乎同时抢购库存，且库存数据更新没有及时同步，导致系统无法保证库存的正确性。可能原因包括：
Redis库存没有及时更新：多个用户几乎同时读取缓存，导致它们看到相同的库存量，进而导致超卖。
数据库库存更新的延迟：在高并发的情况下，缓存和数据库之间的同步可能会滞后。
没有合适的锁机制：没有保证在更新库存时的排他性，多个请求并发地修改库存数据。
2. Redis中的库存还没有递减完成，出现了比如OOM的情况，数据库怎么获得已经抢成功的数据？
OOM（内存溢出）：如果 Redis 在库存递减过程中遇到内存不足，可以采用如下措施：
持久化到数据库：在每次库存更新时，除了更新 Redis，也同步更新数据库，防止内存问题导致数据丢失。
补偿机制：在库存更新过程中，如果出现 Redis OOM 或其他异常，系统可以通过 事务 或 消息队列 来确保数据的可靠性，将未能正确更新的数据进行补偿。
乐观锁：使用数据库的 乐观锁 或 悲观锁 机制，确保数据一致性。
3. 数据库和缓存数据一致性的问题
缓存与数据库一致性是分布式系统中的一个经典问题，常见的解决方案包括：
双写策略：每次更新数据库时，也更新缓存。但这种方式容易导致缓存与数据库之间的数据不一致。
缓存预热/回源策略：当缓存失效时，直接回源到数据库，重新加载数据到缓存。
延迟删除缓存：修改数据库后，不立即删除缓存，而是等到缓存过期时再删除。
消息队列：使用消息队列来确保数据库和缓存的同步更新，例如通过消息通知来更新缓存。
4. 如果数据库更新完成了，但是删除缓存时没有成功，这时会怎么办
缓存不一致问题：如果数据库更新成功但缓存删除失败，可以采取以下措施：
异步删除缓存：删除缓存操作可以异步执行，确保数据库更新成功后，延迟删除缓存操作，以减少缓存不一致的时间窗口。
定期扫描缓存：可以设置定时任务或后台进程，定期检查缓存与数据库的同步情况，若发现不一致，主动去同步。
事务机制：在一些场景下，可以使用事务机制或消息队列的 最终一致性 来处理缓存与数据库的不一致问题。
5. 项目有实际需求吗？还是找的课题
项目通常会有实际需求，尤其是解决高并发的业务场景，比如抢单、库存管理等。然而，如果这是一个课题，可能是为了研究特定技术（如分布式缓存、一致性、消息队列等）在实际业务中的应用。
6. RabbitMQ在项目里是干嘛用的？
RabbitMQ 在项目中通常用于：
异步处理：将某些耗时操作（如发送通知、邮件、数据处理等）放入消息队列，由消费者异步处理，避免阻塞主流程。
解耦：通过消息队列的方式解耦不同模块之间的依赖，提升系统的可维护性和扩展性。
流量削峰：在高并发的场景下，使用 RabbitMQ 来缓解瞬时流量的压力，确保系统稳定运行。
7. 抢单的人怎么知道要查哪个key呢？
Redis中的库存数据通常是基于商品的唯一标识来存储的，比如 product:{productId}:stock，当用户请求抢单时，系统会基于商品ID生成特定的 Redis key，所有用户都通过相同的 key 来操作库存数据。通过 hash key 和 field，可以保证每个商品的库存数据唯一且易于管理。
8. 具体压测的数据
压测数据通常会包含以下几项：
QPS（每秒请求数）：系统每秒钟能够处理多少请求。
响应时间：每个请求的平均响应时间，通常以毫秒为单位。
TPS（每秒事务数）：系统每秒能处理多少个事务。
系统资源使用情况：CPU、内存、磁盘等资源的占用情况。
并发用户数：在特定时间段内能够支持的最大并发用户数。
吞吐量：系统处理的总数据量。
9. 简易短视频是怎样的项目
简易短视频项目：通常包括以下几个核心模块：
用户系统：用户注册、登录、认证、个人资料管理等。
视频上传与处理：用户上传视频文件，系统进行视频格式转换、压缩等处理。
视频播放：前端播放视频，支持快进、暂停、加载等基本功能。
评论与互动：用户可以对视频进行评论、点赞、转发等操作。
社交功能：用户可以关注其他用户、推荐视频等。
数据存储与分发：使用分布式存储方案（如对象存储）存储视频文件，并通过CDN加速分发。
```





### 二面

1. 自我介绍
2. 对面介绍自己的组，问可以接受Go语言吗？
3. 算法：53最大子数组和，239滑动窗口最大值，136只出现一次的数字
4. 进程和线程是怎么理解的？
5. 协程是什么意思？这三者对比一下
6. 在设计程序的时候如何抉择呢？比如应该用多进程的方式还是单进程多线程的方式？
7. 线程池中的核心参数
8. 线程池的执行流程
9. 开发过程中用过线程池吗？线程池的这几个参数是如何确定的？
10. 为什么是n+1和2n和？
11. 你的项目你认为是CPU密集型还是IO密集型
12. 项目v2要上线了，项目v1中还有任务在线程池中，这个时候要怎么办呢？【回答的shutdown和shutdownNow的区别，使用shutdown，等待任务队列里的任务执行完再关闭v1版本的项目】
13. 线程的超时时间设置
14. 你的项目的请求上限是多少？上限多少是右哪些因素决定的？
15. springBoot可以调吗，让他的上限多一些
16. Java中的反射解决的问题？使用的场景？
17. C/C++不支持反射，了解过为什么有些语言持支反射有些不支持反射吗？有什么编程语言的特性决定了他可以用反射吗？
18. Java中如何判断一个对象可以被回收了？
19. 判断对象是不是被引用标记了，扫一遍的时间可能会非常长，如何来优化它或者现有的机制是如何做的？
20. 如何入手MySQL的优化？看Explain的什么内容？
21. 索引的底层数据结构是什么样子？
22. B+树为什么比较合适？为什么不用二叉树？红黑树？B树？
23. MySQL里开启了两个事务，第一个事务插入一条记录并返回了id，此时这个事务还没有提交，第二个事务可以查询到id为2的记录吗？什么隔离级别可以查到，什么隔离级别查不到？
24. Redis是单线程的为什么比较快？【内存，多线程切换，IO多路复用，Redis的数据结构】
25. 怎么理解IO多路复用？相对于什么IO多路复用性能更高
26. git的合并的命令？git merge 和 git rebase 用过吗？
27. 假设一个场景：我合入了一个版本，其他同学在之后也合入了三四个版本，这个时候发现我合入的版本有bug，需要把这个撤回，要怎么做呢？
28. 反问



```sh

1. 算法：53最大子数组和，239滑动窗口最大值，136只出现一次的数字
53. 最大子数组和：问题要求找出数组中和最大的连续子数组，使用动态规划来解决。设 dp[i] 为以第 i 个元素结尾的最大子数组和。公式为：

css
复制代码
dp[i] = max(nums[i], dp[i-1] + nums[i])
结果为 dp 数组中的最大值。

239. 滑动窗口最大值：使用双端队列（deque）存储滑动窗口中的最大元素的索引，确保队列中的元素按降序排列。每次窗口移动时，更新队列。

136. 只出现一次的数字：使用异或运算的特性：相同的数字异或结果为零，任何数字与零异或结果是该数字本身。将数组中的所有元素异或，最终结果即为只出现一次的数字。

2. 进程和线程是怎么理解的？
进程：是操作系统分配资源的基本单位，每个进程拥有独立的内存空间。
线程：是进程中的执行单元，同一个进程中的线程共享内存空间和资源。线程是 CPU 调度的最小单位。
3. 协程是什么意思？这三者对比一下
协程：是一种轻量级的线程，调度由程序员控制，通常在一个线程内运行多个协程。与线程相比，协程更轻便，创建和销毁的开销更小。
进程与线程的区别在于资源的独立性，协程则通过单线程来实现多任务，优于传统的多线程。
对比：

进程：资源独立，开销大，互相隔离。
线程：共享进程资源，开销较小，调度依赖操作系统。
协程：轻量级线程，调度由程序员控制，不依赖操作系统，适用于 I/O 密集型任务。
4. 在设计程序的时候如何抉择呢？比如应该用多进程的方式还是单进程多线程的方式？
多进程适合 CPU 密集型 任务，因为它能有效利用多核 CPU，每个进程独立执行，避免了 GIL（全局解释器锁）的问题。
单进程多线程适合 I/O 密集型 任务，减少上下文切换和内存开销，同时可以通过线程池控制并发量。
5. 线程池中的核心参数
核心线程数：线程池中始终保持的线程数量。
最大线程数：线程池中可以创建的最大线程数。
线程存活时间：非核心线程在空闲时最大存活时间。
队列长度：任务队列的长度，用于缓存等待执行的任务。
拒绝策略：当线程池已满且队列也满时的处理方式，如抛出异常、丢弃任务等。
6. 线程池的执行流程
当任务提交到线程池时，线程池首先判断是否有空闲线程处理该任务。如果没有且当前线程池中的线程数小于最大线程数，则创建新线程执行任务。如果线程池已达到最大线程数，则任务将被放入任务队列，等待执行。
7. 开发过程中用过线程池吗？线程池的这几个参数是如何确定的？
线程池的核心参数根据任务的特性来调整：
核心线程数：根据并发量、任务的响应时间和硬件资源来调整。对于 I/O 密集型任务，核心线程数可以设置较大。
最大线程数：根据系统的 CPU 核数和可用资源决定，避免过多线程造成 CPU 或内存的压力。
队列长度：根据系统的处理能力和任务的大小来决定，长队列有助于平滑流量，但可能增加延迟。
8. 为什么是 n+1 和 2n 和？
这个问题可能涉及到计算机算法的复杂度。一般来说，n+1 是常数时间复杂度的一部分，2n 通常是指某些问题的双倍处理时间，或者是递归分治法中的两个子问题。
9. 你的项目你认为是CPU密集型还是IO密集型？
CPU 密集型：涉及大量的计算操作，如加密、数据分析、图像处理等。
I/O 密集型：涉及大量的磁盘操作或网络操作，如 Web 服务、数据库操作、文件传输等。我的项目大多数是 I/O 密集型，因为涉及到大量的数据库操作和网络请求。
10. 项目 v2 要上线了，项目 v1 中还有任务在线程池中，这个时候要怎么办呢？【回答的 shutdown 和 shutdownNow 的区别，使用 shutdown，等待任务队列里的任务执行完再关闭 v1 版本的项目】
shutdown：调用 shutdown() 方法后，线程池不再接受新的任务，但会继续执行已经提交的任务，直到队列中的任务执行完毕。
shutdownNow：调用 shutdownNow() 会立即尝试停止所有正在执行的任务，未执行的任务会被丢弃。
在 v2 上线之前，使用 shutdown 方法可以优雅地结束 v1 项目中的任务，确保在平滑过渡期间不丢失任何任务。

11. 线程的超时时间设置
线程池中的线程有一个 存活时间，即线程在空闲时保持的最大时间。通过设置超时时间，能够避免线程池中大量空闲线程占用资源，从而优化性能。可以通过 ThreadPoolExecutor 中的 setKeepAliveTime 方法来设置。
12. 你的项目的请求上限是多少？上限多少是由哪些因素决定的？
请求上限通常是由以下几个因素决定的：
硬件资源：服务器的 CPU、内存、磁盘 I/O 能力。
数据库性能：数据库的吞吐量和并发能力。
网络带宽：网络带宽和延迟限制。
应用程序的优化：应用代码的效率和缓存的使用。
14. Java中的反射解决的问题？使用的场景？
反射允许程序在运行时动态地加载类、获取类信息、创建对象、调用方法、访问字段等。使用场景：
插件化框架：动态加载类。
依赖注入：如 Spring 框架，通过反射实现 Bean 的自动注入。
对象序列化与反序列化。
15. C/C++不支持反射，了解过为什么有些语言支持反射而有些不支持反射吗？
反射是动态语言的一大特性。支持反射的语言（如 Java、Python、Go）通常提供了运行时类型信息和反射 API，允许程序在运行时获取类型、方法等信息。而 C/C++ 这种静态语言，不提供运行时类型信息，因此无法直接支持反射。需要在编译时知道类型信息。
16. Java中如何判断一个对象可以被回收了？
垃圾回收器通过 引用计数 或 可达性分析 来判断一个对象是否可以回收。对象的引用计数为零或从根对象不可达时，认为该对象可以被回收。
17. 判断对象是不是被引用标记了，扫一遍的时间可能会非常长，如何来优化它或者现有的机制是如何做的？
标记-清除算法 是垃圾回收的常用算法，现有的优化方法包括：
分代回收：将对象分为年轻代和老年代，针对不同年龄的对象采用不同的回收策略。
增量回收：将回收工作分成多个小步骤，避免一次性回收导致的长时间停顿。
18. 如何入手MySQL的优化？看Explain的什么内容？
通过 EXPLAIN 分析 SQL 查询的执行计划，关键点包括：
类型（type）：查询的访问类型，ALL 是最差的，表示全表扫描。
可能的键（possible_keys）：查询时可使用的索引。
实际使用的键（key）：实际使用的索引。
行数（rows）：扫描的行数，
```









## 腾讯音乐

### （一）开场

1. 面试官介绍岗位

- 岗位为腾讯音乐 - 全民K歌 - 国际版 - 直播歌房后台研发工程师，主要负责直播相关功能，开发语言为Go和C++。

1. 关于求职者基本情况

- 要求5分钟以内的自我介绍。
- 被问到所在公司技术团队裁撤后为何会留下自己。
- 岗位base深圳能否接受。

### （二）项目相关

1. 系统重构 - 数据迁移项目

- 微服务相关
- 如何理解微服务，为什么微服务能提升系统可拓展性。
- 微服务相比于单体服务的缺点。
- 服务间通信成本指的是什么，成本体现在哪。
- 数据库迁移原因与成本评估
- 把数据库从MongoDB迁移到MySQL的原因。
- 如何评估迁移异构数据库（MongoDB到MySQL）的成本，是否仅考虑成熟度和被接受程度，因为迁移涉及数据同步工作量巨大。
- 技术选型相关
- 如果采用最终一致性方案，MySQL支持事务而MongoDB不支持事务，有什么原因不使用最终一致性方案。
- 数据同步与异常处理
- 迁移过程中数据同步怎么做（新数据库写MySQL，写脚本迁移Mongo数据到MySQL）。
- 业务要读写新旧数据时怎么办。
- 迁移比较暴力，如何发现数据异常，异构数据库迁移时如何保证每条数据正常迁移到MySQL。
- 唯一键场景下（Mongo已有数据，切换到MySQL写时可能重复写入）的处理。

1. 优化服务器项目

- 分布式缓存实现
- 优化服务器引入分布式缓存技术（具体是Redis），如何实现的。
- 缓存与数据库一致性
- 如何保证Redis缓存和数据库的数据一致性（回答缓存先写数据库后写存在问题）。
- 写缓存成功数据库失败时缓存是否为脏数据。
- 先写数据库成功再写Redis，缓存更新失败怎么办，如何知道何时将数据库数据同步到缓存及同步的做法。
- 缓存是否有过期时间机制，有没有不过期一直生效的情况，有过期的话多久过期。
- 缓存同时过期会有什么问题以及如何解决。

1. 数据抓取业务项目

- Kafka相关
- Kafka在业务中的角色。
- 业务为什么要经过Kafka这一层，账号量有多大。
- 定时任务可分散执行时间，Kafka在这种情况下削峰意义不大，是否有其他考虑使用Kafka的因素。
- 防止账号丢失已有确认机制，当作下游处理失败重新触发即可，为何还需要Kafka。

1. 抖音微信小游戏归因业务项目

- Token缓存相关
- 微信小游戏的token存于sync.map（服务内存），为何使用服务内存而不使用Redis或其他外部缓存方案。
- 用户量相关，当有一定数量实例和用户量时这种方案是否有缺陷（此处存在理解偏差导致回答失误）。

### （三）Go和MySQL

1. MySQL中索引如何实现，为什么MySQL里不使用B树。
2. 切片如何实现
3. Go里并发读写map会出现问题，如何解决
4. Go里的sort排序如何实现
5. 协程和线程的区别，线程开销大的原因，协程有上下文切换为何线程消耗更多CPU资源



```sh
1. MySQL中索引如何实现，为什么MySQL里不使用B树？
MySQL中的索引实现：

InnoDB 默认使用 B+ 树（而不是传统的 B 树）来实现索引。B+ 树的所有叶子节点都在同一层次，并且通过链表相连，保证了更高的查询效率。
MyISAM 存储引擎使用的是 B 树，但它在处理大数据量时的效率低于 B+ 树。
B树与B+树的区别：

在 B 树中，节点存储数据和指向子节点的指针，而 B+ 树中，非叶子节点只存储索引信息，所有实际数据都保存在叶子节点中。这使得 B+ 树的范围查询（例如 BETWEEN）更加高效，因为叶子节点通过链表连接，范围查询时只需要在叶子节点之间跳转。
为什么MySQL使用B+树：B+树的最大优势在于它能提高范围查询的效率，且因为所有数据都在叶子节点，因此数据的访问更加有序，便于高效扫描。
2. 切片如何实现
Go 中的切片实现：

切片是对数组的一种抽象，它是动态的，不像数组那样大小固定。切片包含了三个主要部分：
指针：指向底层数组的起始位置。
长度：切片中元素的数量。
容量：从切片的起始位置到底层数组的结尾部分的元素数量。
当切片扩展时，如果切片的长度超出其容量，Go 会重新分配一个更大的底层数组，并将切片的内容复制到新的数组中。

3. Go里并发读写map会出现问题，如何解决
问题：Go中的 map 是非并发安全的，意味着如果多个 goroutine 同时读写同一个 map，可能会导致数据竞争、崩溃或错误的结果。

解决方法：

使用 sync.Mutex 或 sync.RWMutex 来加锁保护 map。Mutex 可以在读写操作时进行互斥锁定，确保同一时刻只有一个 goroutine 访问 map。
使用 sync.Map，Go 1.9 引入了并发安全的 sync.Map，它适用于多个 goroutine 同时访问的场景。
示例：

go
复制代码
var m = make(map[string]int)
var mu sync.Mutex

// 写操作
mu.Lock()
m["key"] = 42
mu.Unlock()

// 读操作
mu.Lock()
value := m["key"]
mu.Unlock()
4. Go里的sort排序如何实现
Go 提供了 sort 包来进行排序，最常用的排序方法是通过实现 sort.Interface 来定义排序规则。sort.Interface 包含三个方法：

Len()：返回集合的元素数量。
Less(i, j int) bool：比较集合中的第 i 和第 j 个元素。
Swap(i, j int)：交换集合中的第 i 和第 j 个元素。
通过实现这三个方法，Go 会使用 堆排序、归并排序 或 快速排序 等算法来完成排序。

示例：

go
复制代码
type ByLength []string

func (s ByLength) Len() int {
    return len(s)
}

func (s ByLength) Less(i, j int) bool {
    return len(s[i]) < len(s[j])
}

func (s ByLength) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

func main() {
    strs := []string{"dog", "cat", "fish", "bird"}
    sort.Sort(ByLength(strs))
    fmt.Println(strs) // [dog cat fish bird]
}
5. 协程和线程的区别，线程开销大的原因，协程有上下文切换为何线程消耗更多CPU资源
协程与线程的区别：

线程：操作系统调度的基本单位，通常由操作系统内核管理。线程在执行时需要独立的堆栈，调度切换的开销较大。
协程：是用户级别的线程，调度由程序自己管理，不依赖操作系统。协程通常在同一个线程中运行，它比线程更轻量，切换的开销较小。
线程开销大的原因：

线程需要独立的内存栈空间。
线程的创建和销毁比协程要慢。
线程切换时，需要保存和恢复大量的上下文信息，涉及的系统调用和调度开销较大。
协程有上下文切换为何线程消耗更多CPU资源：

线程 的上下文切换涉及保存和恢复整个线程的状态（如寄存器、栈等），并且操作系统内核需要进行调度，这些操作需要消耗更多的 CPU 资源。
协程 切换时只需要保存最少的状态（通常是堆栈指针），因为它们是轻量级的，且由程序而非操作系统调度，所以不会有那么大的开销。
总结：

协程的优点在于其轻量性，减少了操作系统调度的开销，特别适合大量 I/O 密集型任务。
线程在需要利用多核 CPU 或执行 CPU 密集型任务时更有优势，但线程的开销更大。
```





### （四）算法与反问

1. 算法手撕
2. 反问

## 腾讯互娱 一面/Go

- Go的接口作用，用处，实现
- 空struct用途，会不会分配内存
- Go原生支持默认参数或可选参数吗，如何实现
- Go defer执行顺序
- 协程，协程间信息如何同步
- Go GMP
- 性能开销大原因
  - GM
  - GMP
  - go生成一个协程，此时放在P中还是M中
  - G阻塞，M、P如何
- 操作系统中大端编码、小端编码
- TCP、UDP
- - 三次握手、四次挥手
  - 为什么挥手是四次，会不会合并
  - 流量控制
- Redis项目中使用（主数据库还是缓存）
- Redis与MySQL数据如何同步
- MySQL索引建立原则
- Explain，字段
- Redis持久化方式
- Redis过期删除策略
- Redis高可用设计
- - 主从复制方式，模式
- kafka业务使用
- Redis常用数据结构
- - zset使用场景，具体实现
- 部署方式，k8s部署（相关概念）
- Go性能优化方式
- - 请求耗时过长，有无使用到链路观测
- 单链表判断有没有环
- 玩家积分排序topN实现算法
- 项目中遇到的困难较高的场景
- 微服务r如何理解，有何问题
- - 服务端崩溃检测



```sh
1. Go的接口作用，用处，实现
作用：Go的接口（interface）是一种抽象类型，它定义了一个对象的行为，但不关心具体的实现。接口在Go中主要用于实现多态和解耦。通过接口，Go可以处理不同类型的对象，只要它们实现了接口规定的方法。

用处：

解耦合：接口允许不同模块之间没有直接的依赖，只需要依赖接口而不关心具体的实现。
多态：通过接口，函数可以接收不同类型的值，只要它们实现了相同的接口方法。
替代传统面向对象语言中的继承：Go没有传统的继承机制，接口则提供了类似于多态和抽象的功能。
实现：

Go的接口是隐式实现的，也就是说，不需要显示声明某个类型实现了某个接口，只要类型实现了接口的所有方法，就自动实现了该接口。
go
复制代码
type Animal interface {
    Speak() string
}

type Dog struct {}

func (d Dog) Speak() string {
    return "Woof"
}

func main() {
    var a Animal
    a = Dog{}
    fmt.Println(a.Speak()) // Output: Woof
}
2. 空struct用途，会不会分配内存
空结构体（struct{}）在Go中是一个零占用的类型，它没有任何字段，占用的内存为0字节。空结构体通常用于以下场景：

信号量：空结构体作为信号量标志，例如，通道中发送空结构体来传递信号。
占位符：用于表示某种逻辑上的存在，但不需要占用实际内存。
会不会分配内存：空结构体不会占用内存，因为它没有任何字段。它通常用于表示某些标记或信号，且被广泛用于map的键类型或通道的值类型。

go
复制代码
type MySignal struct{}
var m map[int]MySignal
m = make(map[int]MySignal)
3. Go原生支持默认参数或可选参数吗，如何实现
Go没有原生支持默认参数或可选参数，但可以通过以下方法实现：

变长参数（...）：通过变长参数（类似数组或切片）可以接受可选参数，然后在函数内根据参数的数量进行判断，手动实现默认值。
函数重载的模拟：通过创建多个同名但参数不同的函数来模拟不同的参数组合。
示例：

go
复制代码
func greet(name string, greeting string) string {
    if greeting == "" {
        greeting = "Hello"
    }
    return greeting + ", " + name
}
4. Go defer执行顺序
Go中的 defer 语句会在函数退出时按 后进先出（LIFO） 的顺序执行，即最后声明的 defer 最先执行。

示例：

go
复制代码
func test() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    fmt.Println("Third")
}

// 输出：
// Third
// Second
// First
5. 协程，协程间信息如何同步
协程：是Go中比线程更轻量的执行单元，由Go的运行时调度系统管理。

协程间信息同步：

通道（Channel）：Go中通过 channel 实现协程间的通信和同步，协程可以通过通道传递数据来协调工作。
WaitGroup：用于等待多个协程执行完毕。
Mutex：用于保护共享资源，防止竞态条件。
示例（使用通道进行同步）：

go
复制代码
ch := make(chan int)

go func() {
    ch <- 1
}()

result := <-ch
fmt.Println(result) // 输出 1
6. Go GMP
Go的 GMP 模型（Goroutine, Machine, Processor）是Go的调度模型：

G：Goroutine，一个轻量级的线程。
M：Machine，操作系统线程。
P：Processor，Go运行时的执行上下文，表示一个逻辑CPU。
调度过程：

Go运行时根据P的数量来决定运行多少个goroutine。如果P的数量很少，M就能运行多个goroutine，尽可能利用CPU资源。
7. 性能开销大原因
GM (Goroutine, Machine, Processor)：

GM模型的调度：每个goroutine在P上执行。G阻塞时，M和P如何调度新的G。
GM开销原因：

Goroutine 调度和上下文切换比线程轻量，但仍然需要一定的开销（例如栈分配和调度）。
M 是操作系统线程，在处理 I/O 操作时可能导致阻塞。
P 是逻辑CPU的映射，一个P通常对应一个操作系统线程，如果P不足，调度会受到影响。
8. 操作系统中大端编码、小端编码
大端编码（Big-endian）：将数据的高位字节存储在低地址中，低位字节存储在高地址中。

小端编码（Little-endian）：将数据的低位字节存储在低地址中，高位字节存储在高地址中。

示例： 对于一个16位整数 0x1234：

大端：12 34（高位在前）
小端：34 12（低位在前）
9. TCP、UDP
TCP：面向连接的、可靠的、流式协议，保证数据传输的顺序和完整性。使用三次握手建立连接，四次挥手关闭连接。 UDP：无连接、不可靠的协议，传输数据时不保证顺序或可靠性。

三次握手：

SYN：客户端发送连接请求。
SYN-ACK：服务器确认连接请求。
ACK：客户端确认服务器响应，连接建立。
四次挥手：

FIN：客户端发送关闭连接的请求。
ACK：服务器确认关闭连接。
FIN：服务器发送关闭连接请求。
ACK：客户端确认，连接关闭。
流量控制：

TCP 使用滑动窗口进行流量控制，保证发送方不会超出接收方的接收能力。
10. Redis项目中使用（主数据库还是缓存）
在项目中，Redis通常作为缓存系统来使用，存储频繁访问的数据以减少数据库查询压力。也可以用于会话存储、消息队列等场景。

11. Redis与MySQL数据如何同步
Redis与MySQL的数据同步通常是通过以下几种方式实现：

应用层控制：在应用程序中，操作Redis之前先更新MySQL，或在MySQL更新后更新Redis。
异步同步：通过消息队列（如Kafka）异步同步Redis与MySQL的变化。
定时同步：定期将MySQL的数据同步到Redis中。
12. MySQL索引建立原则
选择性高：对于字段选择性高（唯一值多）的列，创建索引更有效。
频繁查询的列：经常用作查询条件的列，尤其是WHERE、JOIN和ORDER BY中使用的列，应建立索引。
避免过多索引：虽然索引能加速查询，但会增加插入、删除、更新的开销。
13. Explain，字段
EXPLAIN 语句用于显示 MySQL 查询优化器的执行计划，帮助分析查询的执行效率。EXPLAIN 的字段包括：

id：查询的顺序。
select_type：查询类型，如 SIMPLE（简单查询）、PRIMARY（主查询）等。
table：涉及的表。
type：连接类型，如 ALL、index、range 等，越优的类型越有助于查询优化。
possible_keys：查询可能使用的索引。
key：实际使用的索引。
rows：扫描的行数。
14. Redis持久化方式
RDB (Redis DataBase)：快照持久化，将内存中的数据定期保存到磁盘。
AOF (Append Only File)：逐条记录写入操作到日志文件，能够提供更高的持久化保证。
混合模式：同时使用RDB和AOF，提供更好的持久化和恢复能力。
15. Redis过期删除策略
惰性删除：当访问某个键时，检查是否过期，如果过期则删除。
定期删除：定期扫描所有过期键，并删除它们。
16. Redis高可用设计
主从复制：主节点负责读写，多个从节点同步主节点的数据，用于读写分离和容错。
哨兵模式：Redis Sentinel 监控主从节点，自动进行故障转移。
17. Kafka业务使用
Kafka 作为消息队列，在业务中通常用于日志收集、事件驱动架构、异步任务处理等场景。

18. Redis常用数据结构
String：最基本的数据类型。
Hash：适用于存储对象。
List：双端队列，用于实现生产者消费者模式。
Set：无序集合。
ZSet：有序集合，用于排名和计数。
19. zset使用场景，具体实现
使用场景：排行榜、计数器等需要排序的场景。
实现：内部使用跳表（skip list）实现，支持按分数进行排序。
```







## 腾讯外包 /后端开发/一面

- 1. 自我介绍
  2. go开发几年（1年半）
  3. 熟悉到什么程度（增删改查不是问题）
  4. map是否安全（不安全）
  5. 为什么不安全
  6. slice的底层结构
  7. apendslice会安全吗
  8. automatic有用过（用过+1-1）
  9. 说一下什么是原子性（要么成功要么失败）
  10. 怎么做有一个有序的排序（结构里搞个切片，然后用sort排序）
  11. mysql主从同步机制（不会）
  12. redis常用数据结构（string、list、hash、set、zset、bitmap）
  13. 有序列表的底层结构（不会，跳表）
  14. 常用的索引数据结构（哈希、b+树、二叉树）
  15. 微服务的服务发现（客户端服务、服务端服务）
  16. 怎么感知服务集群的变化（服务注册中心、轮询服务健康、监控系统）
  17. 注册中心如何感知服务的变化(心跳推送？触发机制之类的）
  18. 会不会k8s（不会）







## 字节跳动

1. 介绍一下业务表的字段
2. 定时任务刷新字段, 是怎么实现的?
3. 分布式锁? 分布式死锁如何解决? 看门狗机制? 如何避免当前线程加的锁, 被其它线程解锁?
4. 乐观锁和悲观锁的区别? 写多读少的情况, 应该使用乐观锁还是悲观锁?
5. 分布式场景下, 如何实现乐观锁?
6. kafka的幂等性? 如何避免消息被重复消费?
7. 两个线程, 同时向mysql中插入一条数据?
8. kafka如何保证消息不丢失
9. sql优化场景:

```sql
select id,name,balance from account where update_time > '2020-09-19' limit 100000, 10
```

该语句为什么查询慢? 有什么优化思路?

1. 算法题: 子集



```sh
1. 介绍一下业务表的字段
业务表字段设计应根据业务需求来进行，典型的字段可能包括：

主键字段：通常是ID字段，作为表中记录的唯一标识（通常使用自增ID或UUID）。
创建时间（created_at）：记录创建时间，用于追踪数据的生命周期。
更新时间（updated_at）：记录最后更新时间，便于进行数据同步或检查变化。
状态字段（status）：用于表示业务实体的当前状态（如“已支付”、“待处理”等）。
业务数据字段：与业务逻辑相关的字段，比如用户信息表可能包含user_id、user_name等字段，订单表可能包含order_number、product_id等字段。
外键字段：如果数据表与其他表相关联，外键字段可能用于表示表间的关系。
例子：

sql
复制代码
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    order_number VARCHAR(50),
    total DECIMAL(10, 2),
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
2. 定时任务刷新字段，是怎么实现的?
定时任务刷新字段通常是通过定时任务调度工具（如 Cron、Quartz、GoCron）来定期执行SQL更新操作或调用接口。

数据库更新：可以创建一个后台服务，每隔固定时间运行SQL语句来更新字段，如更新时间、标记字段等。
示例（MySQL）：

sql
复制代码
UPDATE orders SET status = 'expired' WHERE status = 'pending' AND update_time < NOW() - INTERVAL 1 DAY;
定时任务：可以使用框架（如Go的time.Tick，Java的ScheduledExecutorService，或Quartz）来定期执行任务。
3. 分布式锁? 分布式死锁如何解决? 看门狗机制? 如何避免当前线程加的锁, 被其它线程解锁?
分布式锁：在分布式系统中，为了确保多个节点/实例间的协作，避免并发冲突，需要使用分布式锁来控制资源访问。

常见实现：Redis（SETNX、RedLock）、Zookeeper等。
分布式死锁：多个节点可能会互相等待对方释放锁，从而导致死锁。

解决方案：可以设置锁的过期时间（例如Redis的SETNX设置EX参数），超时自动释放锁；使用看门狗机制。
看门狗机制：设置一个定时器，定期刷新锁的有效期，防止锁被提前释放，避免因业务执行时间较长而被误释放。

如何避免锁被解锁：

锁的获取与释放应该由同一个线程负责，锁的释放通过唯一标识来防止其它线程解锁。
在Redis中，可以存储唯一标识（如UUID），并在释放锁时检查标识是否匹配，确保只有获取锁的线程才能释放。
4. 乐观锁和悲观锁的区别? 写多读少的情况, 应该使用乐观锁还是悲观锁?
乐观锁：假设数据在操作期间不会发生冲突，适合冲突较少的场景。通过版本号或时间戳机制来控制并发修改，冲突时会重试。适用于读多写少的场景。

示例：在每次更新时，检查数据库中的版本号是否匹配，如果不匹配，则认为发生了冲突。
悲观锁：假设数据会发生冲突，因此会在操作期间锁住数据。适合冲突较多的场景。通过数据库的行锁、表锁等方式实现。适用于写多读少的场景。

写多读少的情况下，应使用悲观锁，因为这种情况下数据修改较多，使用乐观锁可能会频繁触发重试机制，降低性能。

5. 分布式场景下, 如何实现乐观锁?
分布式场景下的乐观锁一般会依赖外部系统来实现版本控制。常见方式包括：

版本号控制：每次修改时，检查版本号，只有版本号匹配才允许修改，版本号不匹配则认为数据冲突，触发重试机制。
时间戳机制：通过检查更新时间戳，判断数据是否已经被修改，避免修改过时的数据。
Redis等存储系统：通过使用SETNX或RedLock等分布式锁来控制并发，或者通过更新操作时验证版本号、时间戳等条件。
6. Kafka的幂等性? 如何避免消息被重复消费?
Kafka的幂等性：Kafka自2.0版本支持幂等性，生产者可以通过配置acks=all和enable.idempotence=true来确保消息的生产是幂等的，即不会出现重复消息。
避免消息重复消费：
幂等消费者：消费者可以在处理消息时，记录消息的唯一标识（如消息ID），如果相同的消息再次消费，跳过重复的处理。
消息去重：可以使用数据库的唯一约束、Redis缓存等方式来保证消息的幂等性。
7. 两个线程, 同时向MySQL中插入一条数据?
如果两个线程同时向MySQL插入相同的数据，并且没有任何约束（如唯一键、事务等），可能会导致：

重复数据：两条记录会插入到数据库中，尽管它们可能是相同的。
解决方法：通过使用唯一索引、事务控制、乐观锁或悲观锁来防止冲突。
例如，使用唯一索引：

sql
复制代码
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE
);
8. Kafka如何保证消息不丢失
Kafka通过以下几种方式来保证消息不丢失：

复制：Kafka的每个主题都有多个副本，数据会在多个节点上进行复制，以保证节点故障时数据不丢失。
持久化：消息默认持久化到磁盘，即使在节点重启后也可以恢复。
ACK机制：可以设置生产者的acks参数，确保消息写入到Kafka时得到确认。
acks=1：只有主节点确认。
acks=all：所有副本节点确认。
9. SQL优化场景
该查询慢的原因可能是：

全表扫描：没有合适的索引导致MySQL扫描了大量记录。
Limit位置不对：在LIMIT之前做了较大的数据过滤，导致OFFSET跳过大量数据，效率较低。
优化思路：

加索引：在update_time列上加索引，确保查询可以通过索引快速定位。
避免大偏移量：尽量避免LIMIT 100000, 10这种查询，特别是在数据量大的情况下。可以通过分页查询来解决此问题，或者利用主键ID范围分页。
优化后的查询：

sql
复制代码
SELECT id, name, balance FROM account
WHERE update_time > '2020-09-19'
AND id > ?   -- 使用主键ID分页
ORDER BY id
LIMIT 10;
10. 算法题：子集
题目要求找到一个集合的所有子集。

解法：可以用回溯算法或位运算来求解。

回溯算法：

go
复制代码
func subsets(nums []int) [][]int {
    result := [][]int{}
    var backtrack func(start int, current []int)
    backtrack = func(start int, current []int) {
        result = append(result, append([]int(nil), current...))
        for i := start; i < len(nums); i++ {
            backtrack(i+1, append(current, nums[i]))
        }
    }
    backtrack(0, []int{})
    return result
}
位运算： 每个元素都有两种状态，选中或不选中，因此可以利用位运算来生成所有子集。

go
复制代码
func subsets(nums []int) [][]int {
    n := len(nums)
    result := [][]int{}
    for i := 0; i < (1 << n); i++ {
        subset := []int{}
        for j := 0; j < n; j++ {
            if i&(1<<j) != 0 {
                subset = append(subset, nums[j])
            }
        }
        result = append(result, subset)
    }
    return result
}
```





## 字节一面（技术）

1. make和new的区别？
2. mutex锁有几种模式？
3. 讲一下GMP调度模型
4. 两道语法纠错题（牛客上可以多刷一下）并解释为什么
5. 一道算法爬楼梯
6. 一道编程题：有100个并发线程，需要控制最多只有10个执行（有缓冲channel实现）并解释思路
7. 知道哪些设计者模式？



```sh

1. make和new的区别？
new：用于分配内存，并返回指向类型的指针。默认值为零值。例如：

go
复制代码
var p *int
p = new(int)  // p指向一个类型为int的零值（即0）的内存
new(T)返回一个指向类型T的指针，内存已分配但初始化为零值。

make：只用于切片、映射和通道（slice, map, chan）。make初始化这些类型并返回引用，而不是指针。make分配内存并为对象初始化值，而new只是分配内存。例如：

go
复制代码
m := make(map[string]int)  // 创建并初始化一个map
总结：

new(T)返回类型为*T的指针，初始化为零值。
make(T, size)返回类型为T的引用（不是指针），并初始化为合适的结构。
2. mutex锁有几种模式？
在Go语言中，sync.Mutex是常用的互斥锁类型。其主要模式包括：

锁定模式（Lock）：线程对资源加锁，确保其他线程不能访问这段资源。使用mutex.Lock()进行加锁，直到执行mutex.Unlock()释放锁。

解锁模式（Unlock）：当不再需要访问共享资源时，释放锁，允许其他线程访问该资源。

重入锁：sync.Mutex本身不支持重入锁（即同一线程在已经加锁的情况下不能再次加锁），如果一个线程试图对同一个mutex加锁，可能会导致死锁。

锁等待（TryLock）：sync.Mutex本身没有提供直接的TryLock()方法，但可以通过channel和自定义逻辑模拟非阻塞的锁。

3. 讲一下GMP调度模型
Go语言的调度模型是基于Goroutine、M（机器），P（处理器）模型的。

G（Goroutine）：每一个轻量级线程都是一个G。Go的并发编程是基于Goroutine的，它比操作系统线程更轻量，因此可以创建大量的Goroutine。

M（Machine）：M表示操作系统线程，Go运行时的线程池负责管理操作系统的线程。每个M对应一个操作系统线程。

P（Processor）：P是Go调度器的抽象，用于执行Goroutine。每个P拥有一个本地队列，存放着准备好执行的Goroutine。P的数量可以通过runtime.GOMAXPROCS()来设置。

调度模型的工作流程：

一个Goroutine会被分配到一个P，P会将其交给M执行。M可以在多个P上调度执行。
Go调度器会自动选择一个M与P组合来运行Goroutine。
如果一个P没有工作要做，Go调度器会尝试从其他P的队列中偷取Goroutine来执行。
GMP调度流程的优点：

高效的调度使得Go能够高效地运行大量并发任务。
M与P的解耦，使得Go能够在不同机器和线程上高效地运行。
4. 两道语法纠错题（牛客上可以多刷一下）并解释为什么
问题1：
错误代码：

go
复制代码
var a = [3]int{1, 2, 3}
var b = []int{4, 5, 6}
b = append(a, b...)
解释：数组a是一个固定长度的数组，而切片b是动态大小的，不能直接将数组a与切片b拼接。应该将数组a转换为切片类型来执行：

go
复制代码
b = append(a[:], b...)  // a[:] 是将数组 a 转换为切片
问题2：
错误代码：

go
复制代码
var arr = []int{1, 2, 3, 4}
arr[5] = 10
解释：arr[5] = 10试图访问arr的索引5，但切片arr的最大索引为3（长度为4）。越界访问会导致运行时错误。正确做法是：

go
复制代码
arr = append(arr, 10)  // 使用append扩展切片
5. 一道算法爬楼梯
问题描述：假设你正在爬楼梯，每次可以爬1步或2步。给定一个整数n，表示楼梯的总阶数，求有多少种方法可以爬到楼顶。

解法：这个问题实际上是斐波那契数列问题。爬到第n阶，可以从第n-1阶爬1步或从第n-2阶爬2步。因此，f(n) = f(n-1) + f(n-2)。

代码实现：

go
复制代码
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    a, b := 1, 2
    for i := 3; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
6. 一道编程题：有100个并发线程，需要控制最多只有10个执行（有缓冲channel实现）并解释思路
问题描述：有100个并发线程，每次最多允许10个线程同时执行。

解决思路：

使用一个有缓冲区的channel来控制并发量。channel的缓冲区大小限制了同时能够处理的Goroutine数量。
每当一个线程执行时，向channel中发送一个信号，控制执行的数量。
代码实现：

go
复制代码
package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup
    ch := make(chan struct{}, 10) // 控制并发，最多允许10个线程同时执行

    for i := 1; i <= 100; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            ch <- struct{}{}  // 向channel发送信号，锁定一个位置
            fmt.Printf("Processing task %d\n", i)
            <-ch  // 完成任务后释放信号
        }(i)
    }

    wg.Wait()
}
解释：

ch := make(chan struct{}, 10)：创建一个容量为10的缓冲channel，确保每次最多只有10个Goroutine可以执行。
ch <- struct{}{}：每个Goroutine执行时向channel发送一个信号，占用一个位置。
<-ch：任务完成后，从channel中取出一个信号，释放一个位置。
7. 知道哪些设计模式？
常见的设计模式包括：

==创建型模式：==

单例模式：确保一个类只有一个实例，并提供一个全局访问点。
工厂方法模式：定义一个接口用于创建对象，但让子类决定实例化哪个类。
抽象工厂模式：提供一个创建一系列相关或互相依赖对象的接口，而无需指定具体类。
建造者模式：使用多个简单的对象一步步构建成一个复杂的对象。
原型模式：通过复制现有对象来创建新对象，而不是通过构造。

结构型模式：

适配器模式：将一个类的接口转换成客户端期望的接口，使得两个不兼容的接口能够合作。
桥接模式：将抽象部分与实现部分分离，使它们可以独立变化。
装饰器模式：动态地给一个对象添加额外的职责。
外观模式：为复杂的子系统提供一个简单的接口。
享元模式：通过共享相同的对象来节省内存，适用于大量相似对象。
代理模式：为其他对象提供一种代理以控制对这个对象的访问。

行为型模式：

策略模式：定义一系列算法，把它们一个个封装起来，并使它们可以互相替换。
观察者模式：当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。
状态模式：允许一个对象在其内部状态改变时改变其行为。
模板方法模式：定义一个操作中的算法框架，允许子类为一个或多个步骤提供具体实现。
命令模式：将请求封装为一个对象，从而使你能够使用不同的请求、队列或日志请求。
责任链模式：使多个对象有机会处理请求，避免了请求的发送者与接收者之间的耦合。
这些设计模式可以帮助我们写出更加清晰、可维护、可扩展的代码。
```





## 字节二面（技术+人事）

**技术：**

1. 讲一下一个系统访问的整个链路过程
2. K8s有哪些组件？
3. 怎么把node里的pod暴露给外面使用？
4. 我对监控的理解，怎么判断一个系统是否已经挂调了？
5. 如果让你对系统进行一个巡检，你会怎么做？
6. 举例数据库巡检
7. 用过云产品吗？讲一下你对公有云的理解
8. 用过OPEN AI吗？你一般怎么使用？

**人事：**

1. 从技术上和工作上上一家公司对你有什么成长？
2. 在工作中和技术上学到哪些技能？举例说明
3. 离职原因，未来职业规划



```sh
技术相关
讲一下一个系统访问的整个链路过程

客户端发起请求，通过 DNS 查询获取目标服务器 IP 地址。
请求通过网络传输到目标服务器，通常是通过负载均衡器进行流量分发。
请求被路由到后端应用服务器，进行业务逻辑处理。
如果需要数据库操作，应用服务器会查询数据库，数据库返回数据。
数据返回给应用服务器，再通过负载均衡器返回给客户端。
系统日志和监控数据在过程中也会被记录和分析，以便优化和故障排查。
K8s有哪些组件？

Master组件：API Server、Controller Manager、Scheduler、etcd。
Node组件：Kubelet、Kube Proxy、Container Runtime（如Docker、containerd）。
其他组件：Ingress Controller、CoreDNS等。
怎么把node里的pod暴露给外面使用？

使用 Service 类型为 LoadBalancer 或 NodePort，可以将 Pod 暴露给外部网络。
LoadBalancer 类型适用于云环境，自动分配外部 IP。
NodePort 类型在集群节点上分配一个端口，外部通过该端口访问。
我对监控的理解，怎么判断一个系统是否已经挂掉了？

监控主要是通过收集系统指标（如 CPU、内存、磁盘、网络等）和应用指标（如请求量、响应时间、错误率等）来评估系统健康状态。
如果系统出现服务宕机、响应超时、或指标异常（如 CPU 使用率过高、内存泄漏等），可以认为系统出现故障。
如果让你对系统进行一个巡检，你会怎么做？

检查系统日志：查看错误日志、警告信息、异常堆栈等。
资源使用情况：检查 CPU、内存、磁盘和网络使用情况，查看是否有异常。
依赖服务状态：检查数据库、缓存、消息队列等依赖服务是否正常运行。
监控和报警配置：确保监控系统正常运行，报警阈值合理。
数据库巡检：检查慢查询日志、表的健康状态、索引和数据一致性。
举例数据库巡检

查询性能：检查慢查询日志，优化慢查询 SQL。
索引优化：检查索引的使用情况，确保常用查询有合适的索引。
数据库表状态：检查表的碎片，定期进行表的优化。
数据库备份：确认备份是否完整、是否定期进行，并且备份可恢复。
用过云产品吗？讲一下你对公有云的理解

公有云提供了弹性的计算、存储和网络资源，通常按需付费，能够根据业务需求进行扩展。
公有云提供了高可用、容灾、负载均衡等功能，且不需要用户自己管理基础设施，简化了运维。
常见的云服务商有 AWS、Azure、Google Cloud、阿里云、腾讯云等。
用过 OpenAI 吗？你一般怎么使用？

是的，OpenAI 提供了强大的语言模型，常用于自然语言处理任务，如文本生成、翻译、问答、内容创作等。
通常使用 OpenAI 进行对话生成，代码自动补全，数据分析等，帮助提高工作效率。
人事相关
从技术上和工作上上一家公司对你有什么成长？

在上一家公司，我主要接触了高并发、高可用系统的架构设计与实现，提升了我的系统设计和架构能力。
深入了解了 Kubernetes 和容器化的实践，掌握了微服务架构、CI/CD等现代化开发流程。
参与了多个性能优化和问题排查项目，增强了我在高压场景下的调试和解决问题的能力。
在工作中和技术上学到哪些技能？举例说明

学会了如何设计分布式系统，包括数据库分片、消息队列、缓存等技术栈。
深入理解了微服务架构，特别是在服务发现、API网关、负载均衡等方面的实际应用。
在性能优化方面，学到了通过日志分析、压力测试、代码优化来提升系统性能。
离职原因，未来职业规划

离职的原因是希望寻找更具挑战性的项目，提升自己的技术深度，尤其是在云计算、人工智能和大规模分布式系统方面的能力。
未来的职业规划是向架构师方向发展，特别是在云原生架构、微服务设计和高可用系统方面积累更多经验。
```





## 字节

1. 自我介绍
2. 选择一个项目或者需求详细介绍一下
3. 代码题，输出什么内容

```stylus
package main

import (
    "encoding/json"
    "fmt"
)

func main() {
    jsonStr := `{"id":321789788912372911233,"name":"John","age":30,"city":"New York"}`
    var person map[string]interface{}
    json.Unmarshal([]byte(jsonStr), &person)
    person["married"] = true
    person["children"] = []string{"Tom", "Jerry"}
    fmt.Println(person)
    jsonB,_ := json.Marshal(person)
    fmt.Println(string(jsonB))
}
```

1. tcp 拥塞控制算法
2. mvcc 底层实现原理
3. 在有些实际生产中会将默认隔离级别调整至读提交，为什么，有什么好处
4. mysql 怎么实现乐观锁和悲观锁
5. 一条 sql 语句，匹配到了一条语句，会加什么锁，锁表还是锁行
6. es 里面是怎么实现分页的，分页有哪几种方式
7. 算法题 力扣 42 接雨水



```sh
自我介绍
我是一个专注于后端开发的工程师，主要使用 Golang 开发高性能、高并发的系统，熟悉常见的技术栈，如 MySQL、Redis、Kafka 等。近年来，特别关注微服务架构和容器化部署，了解 Kubernetes 和 DevOps 流程。

选择一个项目或需求详细介绍一下
我曾经参与过一个基于微服务的电商平台项目。在这个项目中，我们使用了 Golang 实现后端服务，前后端分离，利用 Kubernetes 部署和管理容器化的服务。项目的核心需求是实现高并发的订单处理系统，通过消息队列（Kafka）进行解耦，并使用 Redis 缓存来提高响应速度。为了保证系统的高可用性，我们设计了分布式锁来确保数据一致性。

代码题输出解释

go
复制代码
package main

import (
    "encoding/json"
    "fmt"
)

func main() {
    jsonStr := `{"id":321789788912372911233,"name":"John","age":30,"city":"New York"}`
    var person map[string]interface{}
    json.Unmarshal([]byte(jsonStr), &person)
    person["married"] = true
    person["children"] = []string{"Tom", "Jerry"}
    fmt.Println(person)
    jsonB,_ := json.Marshal(person)
    fmt.Println(string(jsonB))
}
输出解释

第一行输出：
person 是一个 map[string]interface{}，通过 json.Unmarshal 将 JSON 字符串解析为 map 类型。添加了 married 和 children 字段后，打印出的 map 包含这些新增字段。

输出：

json
复制代码
map[age:30 children:[Tom Jerry] city:New York id:321789788912372911233 married:true name:John]
第二行输出：
使用 json.Marshal 将 map 转换回 JSON 字符串。注意字段的顺序不会保证，与原始输入 JSON 字符串的顺序不同，但数据内容是相同的。

输出：

json
复制代码
{"id":321789788912372911233,"name":"John","age":30,"city":"New York","married":true,"children":["Tom","Jerry"]}
其他技术相关问题回答：
TCP 拥塞控制算法
TCP 拥塞控制是通过以下四个算法实现的：慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快重传（Fast Retransmit）、快恢复（Fast Recovery）。慢启动用于避免开始时网络过载，拥塞避免用于平稳增长窗口大小，快重传和快恢复则用于丢包后的恢复。

MVCC 底层实现原理
MVCC（多版本并发控制）通过为每个数据库操作提供一个版本号（或时间戳）来实现并发控制。当多个事务修改同一数据时，数据库会创建不同版本的数据，允许事务在其视图下读取数据的旧版本，而不会干扰其他事务。

调整隔离级别为读提交的原因
读提交（Read Committed）可以防止脏读，但允许不可重复读。生产环境中，为了提高性能和减少死锁的发生，很多系统会将隔离级别设置为读提交。在某些情况下，读提交能满足业务需求，避免了较高的性能开销。

MySQL 实现乐观锁和悲观锁

乐观锁：通常通过版本号或时间戳实现，事务开始时不加锁，提交时检查数据是否被其他事务修改。如果没有修改，则提交成功，否则重试。
悲观锁：通过数据库提供的锁机制（如 FOR UPDATE）来实现，事务会在读取数据时加锁，直到事务结束。
SQL语句加锁问题
对于查询操作，若没有明确指定锁类型（如 FOR UPDATE），MySQL 默认不会加锁。加锁通常是在修改数据时进行的，比如 INSERT、UPDATE 或 DELETE，这些操作默认会加行级锁。

Elasticsearch 分页实现方式
Elasticsearch 提供了多种分页方式：

from/size：常见的分页方式，通过指定 from 和 size 来控制查询的起始位置和返回记录数。
search_after：适用于深分页，避免了 from/size 的性能瓶颈，通常与排序结合使用。
算法题：力扣 42 接雨水
该题目需要计算下雨后能够积水的总量。解法通常使用双指针方法，维护两个指针从两端向中间移动，计算当前位置的最大可容积水量，最终得到积水的总量。
```





## 美团 一面

1. 自我介绍
2. leetcode141 环形链表，判断是否有环路
3. 延申leetcode142 环形链表2，找到入口位置
4. 判断一个sql（左右模糊查询）能否命中索引
5. 为什么左右模糊不能命中索引
6. 如何优化这个sql（左右模糊查询）
7. 全文索引底层怎么实现的
8. 建立分词后，如何进行快速的模糊检索
9. 分词用的什么数据结构
10. 跳表的时间复杂度，哈希表呢
11. 哈希表有什么问题
12. 说一下MySQL的索引
13. 什么是聚簇索引、非聚簇索引
14. 事务隔离级别
15. InnoDB如何实现可重复读
16. 死锁是什么，如何解决死锁
17. 拷打项目
18. 你觉得科研中什么能力比较重要（解决问题能力、系统设计能力、学习能力和技术使用能力、沟通协作能力）

## 美团 二面

1. 自我介绍
2. 拷打项目
3. socket、TCP/IP 的关系
4. 输入 url 的到浏览器显示网页的过程
5. 反问

## 美团

1. Go中Map的数据结构?扩容机制?key为什么是无序的?
2. 简述-下rune类型
3. 什么是协程泄露?
4. select 底层数据结构和一些特性?
5. 对已经关闭的的chan进行读写，会怎么样?为什么?
6. 除了加Mutex锁以外还有哪些方式安全读写共享变量?
7. 互斥锁正常模式和饥饿模式的区别 ?
8. 原子操作和锁的区别 ?
9. 一条select语句的执行流程?
10. CHAR 和 VARCHAR的区别?
11. MYISAM和INNODB的不同?
12. binlog的工作模式有哪些?
13. 持久化机制?各自的优缺点?
14. 怎么理解Redis事务?

## 美团

1. 自我介绍
2. 项目做完了吗？背景是什么？项目初期的背景调研是怎么做的？现在这个系统做到哪一步了？
3. 用户下单用户派送的优劣了解过吗？怎么管理？
4. 项目里面遇到的最大的难题是什么？为什么？
5. 为什么使用乐观锁？你了解乐观锁的使用场景和实现逻辑吗？
6. 乐观锁怎么实现的你了解吗？
7. 了解悲观锁吗？
8. 最开始有没有考虑乐观锁的适用场景和悲观锁的适用场景？
9. 乐观锁会不会导致频繁的冲突啊？这种情况下和悲观锁谁的性能更好一些呢？
10. 关于 Redis 的递减特性你了解哪些？
11. 关于 Redis 的指令还用到过其他哪些呢？
12. setnx 的原理你知道吗？
13. 有个场景你了解吗：锁获取后程序退出了，这样锁永远不会释放，导致死锁
14. 看你简历里说比较了解集合，对集合的了解简单说一下
15. 怎样判断内存是否需要回收？（对象死亡的判断方法？）
16. 可达性分析是如何对对象进行标记的？三色标记法了解吗？
17. 垃圾回收的过程（针对某一个具体的垃圾收集器 CMS 或 G1）
18. 清除的过程呢？
19. 标记清除算法的优点和缺点？
20. CMS 标记阶段比较长，如果产生了过多的浮动垃圾，有可能会出现回收赶不上分配的情况，从而导致 GC 失败，这种要怎么解决？
21. CMS 和 G1 的比对了解吗？为什么废除了 CMS？
22. G1 怎么做到指定具体的垃圾清除时间的？
23. 线程的生命周期你了解吗？
24. 每个状态之间怎么流转的你了解吗？

## 饿了么

### 一面

1. 自我介绍
2. Java面向对象的三个特性，什么是多态
3. 双亲委派机制
4. HashMap在JDK1.7以前有线程不安全，怎么个情况
5. 保证线程安全用什么Map
6. ConcurrentHashMap是怎样的
7. 线程池用过吗？核心参数以及有啥作用
8. 使用线程池有什么好处
9. 悲观锁和乐观锁是怎么样子的
10. Java中怎么实现悲观锁和乐观锁
11. HTTP和HTTPS的区别，加密过程是怎样的
12. TCP的粘包是怎样的现象
13. Cookie和session的区别
14. 用户登录之后怎么找到对应的Session的呢
15. 两个项目哪个有挑战一点，挑一个讲一讲
16. 平时做项目或科研会遇到什么困难，遇到困难一般自己解决吗
17. 最近有了解一些新的技术或者看一些技术书籍之类的吗
18. 算法题：反转链表
19. 其他的offer
20. 之后有往上海发展的打算吗
21. 反问

## 阿里巴巴

### 数字零售技术部-ERP技术一面（电话面）

1. 自我介绍
2. 项目背景？
3. 你觉得项目难点是哪些？
4. 第一版是怎么实现的？为什么会出现超卖问题？
5. 记录抢单结果的表是怎么设计的？
6. 这张表的索引和其他的约束是怎么做的？
7. 乐观锁为什么不是加在抢单关系表而是在订单表里的？
8. 你现在数据库的设计上似乎有些问题
9. 你们的订单允许取消吗？
10. 如果要取消的话应该怎么设计呢？
11. 简易短视频做了哪些东西
12. 用户登录的处理流程是怎么个样子
13. 接收登录请求是HTTP吗
14. HTTP里面登录的状态保持是怎么做的？
15. 怎么判断JWT的合法性
16. JWT里面保持了哪些东西？数据结构大概是什么样子？
17. JWT和普通的Session的方式有什么区别？
18. session的方式了解过吗？
19. 使用JWT要实现一个状态只能一个设备登录，这应该怎么做呢？
20. 怎么设置JWT的校验不通过呢？
21. JWT对于登录数量有要求的就很痛苦
22. Java的双亲委派，为什么要这么设计呢？
23. 类如果重复加载会有什么问题呢？
24. 有遇到过非双亲委派模型的场景吗？
25. 类加载的过程一般会做哪些事情？每一步具体都在做些什么呢？
26. 对JVM的调优有了解过吗？
27. 说说你对Redis的了解
28. bitmap是个什么样的东西
29. 项目里的Redis是怎么用的？
30. 抢单为什么会有库存数量
31. 使用Redis防止超卖的流程是怎样的，会不会有并发的问题？
32. 递减是怎么操作的？
33. 这样会不会有问题，递减完成时的并发判断库存大小的时候出问题，因为递减和判断不是原子性的
34. ThreadLocal的作用
35. 什么样的情况下会使用ThreadLocal？
36. 后面怎么使用的？
37. 这么设计（使用ThreadLocal）的原因？目前来说ThreadLocal是能不用就不用的
38. 内部起个线程池，这时能拿到ThreadLocal的内容吗？
39. SpringCache和Redis有什么区别？（考虑业务上的合理性）
40. MySQL有哪些储存引擎了解吗？有什么区别
41. 聚簇索引和非聚簇索引有什么区别？
42. 回表的优化了解过吗？
43. 为什么不要使用select * 呢？
44. 没有被索引覆盖是什么？
45. 什么是索引下推
46. 反问

### 二面（电话面）

1. 自我介绍
2. 这里面比较有挑战的是哪个系统
3. 在Redis里怎么做库存的扣减
4. 怎么保证是不超卖的呢
5. 面试官举了个例子表示对Redis递减防止超卖的不理解
6. HashMap底层是什么数据结构组成的
7. 红黑树有什么好处
8. 28个元素放到HashMap里面，那么HashMap初始化的容量为多少比较好
9. 初始化了一个固定线程数的线程池，线程数是5个，把6个任务扔进去，线程池怎么处理
10. MySQL有个表，里面四个字段有abc三个字段，d是主键，我要查询ab，条件是bc，这时怎么设计索引
11. 什么是回表
12. 假设还是这个表，数据量很大，这时要做分页，每页100条，你怎么设计这个查询语句
13. 子查询怎么设计
14. 比如要查第10000页，你会怎么写这个sql
15. 用过limit查询吗
16. 项目里Redis防止超卖的方案，Redis就类似一个锁了
17. 解释缓存穿透和缓存雪崩
18. 上述情况的解决方案
19. 刷新视频时系统会推荐20条用户没看过的视频，这时怎么设计会让性能更优呢

> 考虑位图或者布隆过滤器，使用二进制数组来保存视频，实现筛选没看过的视频

1. 笔试题：输出每个url最多的访问次数（类似华子实习笔试第一题，但是简单一些）
2. 反问

## 阿里

1. 分别介绍一下MySOL、ES、Mongo数据库各自的特点以及适合的使用场景是什么?
2. 倒排索引了解吗?
3. ES的分页功能有什么特性?
4. ES的分词检索?
5. Kafka与Zookeeper是什么关系?
6. 多个同样的消息被发送到Kafka如何控制他们只消费一个?
7. 什么是Kafka的羊群效应 ?
8. Redis相比Memcached有哪些优势?
9. 阐述缓存穿透?怎么解决?
10. 什么是bigkey?会有什么影响?

## 阿里外包/一面

1. 自我介绍
2. 遇到过高并发？（网站大访问量用redis缓存，表单做提交）
3. 进程、线程、协程（随便说说）
4. go的协程设置原理（说了gmp模型）
5. go的锁,用到什么锁（mutex、rwmutex）
6. 锁怎么实现的，有没有看过源码（莫得）
7. innodb和myisam区别（事务支持、查询速度、表文件结构、外键支持、innodb有主键，查询效率高）
8. 为什么查询效率高（叶子节点存储索引和数据，避免回表二次查询）
9. mysql优化（说了分表和覆盖索引）
10. explain关注的字段（命中索引、可能命中索引、全表扫描、用到覆盖索引）
11. redis和kafka的区别（说了redis和kafka的特点）
12. 用过k8s吗（没）
13. mysql的版本控制（说了mvcc，以及怎么实现的）
14. 前期用php?(公司转型）
15. php和go哪个好用（说了go协程用起来方便，php的麻烦一点，编译型语言，安全比php明文安全）
16. goroutine+channel依次输出小猫小狗100次（设置猫狗channel，先读猫channel输出，狗输出的时候先读猫channel来保证顺序，没说好这一块）
17. map怎么用？线程安全？怎么扩容？（不是安全的，用sync.map安全，说了双倍扩容）
18. 怎么解决他的哈希冲突？（重新扩容、哈希函数重新生成）
19. 设计模式（说了单例模式、策略模式）
20. php用什么框架（tp、laravel）
21. laravel的依赖注入

## 蚂蚁

### 工具开发一面（电话面）

1. 自我介绍
2. 项目背景
3. JMeter做了压测，压测是怎么设计的
4. 500压测线程的设置和服务器以及JVM的规格和设置有什么关系吗
5. 优化了50%，那么优化点主要体现在哪里呢
6. RabbitMQ在写DB时如果出现了异常，导致了数据不一致，有什么补偿的机制吗
7. 在线程池中线程复用的情况下，ThreadLocal会不会有什么问题
8. 代码里面会是什么时机做ThreadLocal的remove呢
9. 在使用AOP的时候，对于接口会有一些规范的要求吗？比如方法签名中的参数会不会有一些规范？
10. 如果要依赖一些参数做做一些权限的控制的话，对于参数的规范会有一些怎样的考虑
11. 具体讲一下使用逻辑过期方案解决Redis的缓存击穿问题
12. 这个跟Redis里面看门狗的机制有什么区别吗
13. 如果内存不够大了会选择使用什么方案来解决呢（逻辑过期不让缓存过期）
14. 如果是要开一个线程来同步数据库从而解决逻辑过期的话，新开的线程与其他读取缓存的线程之间的协作关系怎么处理呢
15. JDK的类库里面有没有了解到可以做线程之间协作关系的
16. 除了synchronized还有其他更加灵活的方案吗？
17. 怎么理解乐观锁和悲观锁的
18. 怎么考量用乐观锁还是悲观锁的？
19. 项目中有没有遇到JVM相关的问题，比如内存溢出等问题
20. 万一有OOM或者线程卡住了，我们排查的手段和步骤是怎么样的？
21. 在设置JVM参数的时候，考虑机器有4G的内存，那我设置会有什么样的原则吗
22. 对自己职业的预期，更偏向算法还是更偏向工程
23. 互联网+的比赛做的是什么？控制平衡还是视觉识别
24. 对于具象智能有什么想法吗
25. 算法题：使用多线程统计一个文件中不同的词出现的次数，记不清了
26. 反问

### 工具开发二面（电话面）

1. 自我介绍
2. 这三个项目的时间顺序
3. 项目背景
4. Java的list有哪些以及他们的区别和原理
5. HashMap和HashTable的区别
6. 一个类在JVM的生命周期，按照这个说一下类的加载过程
7. 验证这个阶段会加载到JVM的内存结构的哪个部分去
8. 用过命令去打过jar包吗
9. 介绍双亲委派机制
10. 有自己写一个类加载器吗
11. 知道可以拓展类加载器吗
12. 说一下对于AOP和IOC的理解
13. AOP的实际的应用有哪些
14. SpringBoot你常用的注解有哪些
15. 有了解过注解的原理吗？注解的本质是什么
16. Spring里面有很多SDK，你常用的有哪些？比如MyBatis
17. 这块原理有了解过吗
18. 这里有没有对哪一块比较熟悉并且研究过原理的
19. 设计模式有了解过吗
20. 数据库索引的原理了解吗
21. 讲一下你对b+树的理解
22. 项目中有遇到过一些慢sql的情况吗
23. 除了explain还有其他定位慢sql的方式吗
24. 一般是什么原因会导致慢sql
25. 介绍项目中Redis是怎么用的
26. Redis是单线程还是多线程的
27. Redis的持久化有了解过吗
28. 有没有了解过Redis的集群
29. 数据库这块除了MySQL有没有了解过Mongo
30. Redis里面的事务原理有了解过吗
31. Redis的缓存穿透、雪崩怎么解决
32. shell这一块有了解吗
33. 大模型这块有了解过相关的技术或者产品吗
34. transform有了解过吗
35. 你觉得你过去做的最有挑战的事是什么
36. 你觉得你成就感最大的事情是什么
37. 自己的性格有测过吗MBTI
38. 对base地有要求吗
39. 手头有其他offer吗？对蚂蚁这边的意向怎样
40. 反问

### 工具开发三面

1. 自我介绍
2. 论文的层次，参加的比赛，专利
3. 介绍实验室的科研项目
4. 已经拿到的offer，base选择
5. 为什么不继续科研方向
6. 参加过开源项目吗？github有账号吗
7. 为什么没有参加实习
8. 项目的收获
9. 项目收获比较大的地方
10. 反问

## 百度

1.GMP模型?

2.协程创建后如何调度?

> 先进入p的私有队列, 如果满了, 进入全局队列

3.context的结构和用法

4.一次url的请求过程?

5.请求到达项目服务器后的调用链路

6.nginx是否为单例的.

7.算法: 两数相除

8.平时mysql优化的案例?

9.in, exist的使用

10.联合索引

11.binlog日志

12.分布式事务: 下游两个db使用redis, 需要更新这两个不同的db, 如何自己实现最终一致性

13.两阶段提交, 三阶段提交?

## 百度后端研发工程师

1. 自我介绍
2. 操作系统处理死锁的方法
3. 操作系统内存管理的方法
4. Redis持久化
5. Memcache知道吗
6. 使用shell统计文件中top3的ip地址
7. 磁盘满了写不进去，排查命令
8. 找出文件夹中最大的几个文件，命令是什么
9. 说-下ES和Redis的区别
10. 编程题
    //Go两个goroutine交替打印1-10
    //G1 1
    //G2 2
    //G1 3
    //G2 4
    //..
    //G1 9
    //G2 10

## 京东 golang

### 一面 60min

- 讲一下项目
- go语言的掌握程度
- 数据结构
- - 空间利用率提高，但是发生冲突的可能性也增大了
  - go语言的map
  - 拉链法的优缺点
  - 拉链法如何优化
  - 负载因子调到1会有什么后果

数据库

- 数据库索引有哪些

- ql建表

  ```sh
  设计一张字生表：表需求是可以记录学生姓名、出生日明、手机 号、是否在读。邮箱。家庭地址、生表现评价 常见查询条件为姓名、出生日期、手机号、是否在读
  ```

- 这个表有什么缺陷

- 新加一个学号字段要考虑什么

- 数据库四大特性

- innodb默认隔离级别

- rr是怎么实现的

网络

- tcp三次握手
- ip位于哪层？icmp位于哪层？ping命令位于哪层？
- telnet是什么操作？位于哪层？
- https加密过程 (这个我不太清楚 如果有大佬知道 麻烦评论区指点一下)

### 二面 35mn

- 二面面试官："看你简历感觉你对go的接触程度不是特别深 你需要在接下来的过程中说服我"
- 对哪些语言比较熟悉
- 为什么很多大厂都用go
- 说一说对slice的认识
- slice如何做深拷贝

数据库

- 如何避免回表
- 标识性差的字段一定不能做索引列吗？
- 标识性差的字段为什么不能用来做索引列？
- b和b+树的区别
- mysql默认隔离级别
- rr如何解决不可重复读

## 京东

### 一面

1. 算法题：leetcode16.最接近的三数之和，leetcode234.回文链表，leetcode72.编辑距离
2. 自我介绍
3. 前面两个项目是自己发起的还是什么契机去做这个项目的
4. ThreadLocal怎样保证其线程安全
5. 怎样保证多线程来使用他？？
6. 如果主线程中有信息，其他线程怎么获取主线程中的信息
7. 项目中Redis哪些地方用到了
8. Redis的哪些操作有原子性
9. 除了递减指令还有哪些指令具有原子性呢
10. 两个项目里面你觉得那部分是有技术难点的
11. 超卖问题还有什么别的解决方案呢
12. 如果是两个应用都要写数据库，加锁怎么解决超卖问题呢
13. 聊一聊乐观锁和悲观锁
14. 两种锁各自的应用场景
15. ArrayList和LinkedList说一说吧
16. String类可以被继承吗？为什么？
17. JVM的组成部分
18. 说一说使用的垃圾回收器
19. G1垃圾回收期和CMS的改进或者说不一样的地方
20. G1的分区，有哪些区（堆的分区）
21. G1的清除算法
22. 什么情况下会产生full GC
23. 原空间是用来做什么的？
24. TCP的四次挥手是怎么样的
25. 为什么要等待
26. 有没有主动去了解过一些新的技术？
27. 从大学到现在做的最有成就感的事情
28. 第三个项目是主导地位？可以安排别人的工作
29. 你觉得你的优势是什么
30. 学习成绩怎么样
31. 反问

### 二面

1. 自我介绍，介绍一个项目
2. 这两个项目是自己开发的还是给公司做的
3. 哪个项目是自己承担的更多
4. 超卖问题是怎么发现的，解决思路，怎么找到的方案
5. 网上的成熟方案你觉得有没有更好的方案或者现有的方案有没有什么问题
6. Redis失效后怎么保证与数据库中数据的一致性
7. Redis持久化可以解决这种突发的情况吗？这个没有调研过吗
8. 一般去哪里找这些解决方案，不同地方有什么倾向性吗
9. 做的这两个项目里面比较大的收获是什么
10. 这个项目后面会继续做吗
11. 自己对未来一两年的规划是怎样的
12. 行业或者技术方向会有考虑吗
13. 为什么是Java和Go呢
14. 当前行业的语言都了解过哪些
15. 你觉得自己的最大的优势是什么
16. 反问

## 京东一面 （30min ）

### 微服务中间件开发部门

1. 自我介绍
2. 实习项目中确保结果准确性
3. 实习项目上游数据有问题怎么办
4. Golang new 和make的区别
5. 为什么多协程优化，不使用协程呢？
6. 实习项目过程中还有什么可以优化的地方
7. 微服务的优势，为什么用微服务
8. 怎么确保线程安全
9. 信号量和锁的区别
10. 你有什么问题吗？

## PDD 一面/Java

- MySQL
- - 提交了怎么样的事务有可能导致死锁
  - 怎样用？什么情况使用
  - 数据同步怎么实现
  - 使用null作为条件查询问题
  - 最左前缀原则
  - 索引下推、索引覆盖
  - join原理实现
  - 索引设计讲究/原则
  - 聚簇索引
  - InnoDB为什么建议用自增整数作为主键
  - MySQL内存磁盘同步机制
  - 数据页在内存中是完整的数据吗？
  - 分库分表
  - MySQL主从架构
  - MySQL什么时候会死锁
  - 表中有业务主键、逻辑删除标志，逻辑删除后又插入同样的一条记录，平衡业务主键和逻辑删除的问题
- 项目工程
- - 业务背景
  - 系统QPS
  - 项目中算法如何使用
  - 项目中的架构设计有何问题
  - 业务修改后 MySQL、Redis数据如何更新
  - 如何进行数据持久化
  - 哪一部分占比较高
  - 如何重新设计MySQL、Redis架构
  - 设计模式（工程上使用）
  - 单体应用多层异常处理原则（异常管理原则）
  - Redis、MySQL配合使用，如何确保数据一致性
  - 项目介绍
  - 系统故障问题、如何解决
  - 服务器部署情况
  - 代码迭代过程中防止代码腐化
  - 关注的业务指标

## PDD服务端开发

1. 自我介绍
2. 项目的各种细节
3. 服务发现一般可以怎么做!
4. InnoDB 引擎的特性
5. MySQL 数据库支持高并发的读写，设计上有哪些可以用的方案?
6. 了解哪些缓存淘汰策略?
7. go 的 defer 机制
8. go 的 map 是有序还是无序?为什么?
9. GET、POST 区别
10. HTTP 是无状态的，如何做到有状态?(cookie session)
11. HTTPS 过程
12. 算法题:

- LRU
- LeetCode 62 不同路径

## 酷狗音乐

### 一面

1. mysql存储引擎?
2. mysql隔离级别? 分别解决了什么问题?
3. 2pc, 3pc 算法
4. 10亿个数据获取前100个最大数据?
5. 单个表到达多大要进行拆分? 为什么需要拆表?
6. redis哪些使用场景?
7. 服务的熔断降级?
8. 平时如何提升和学习?
9. TCP和UDP可以绑定同一个端口吗?
10. linux如何查看cpu, 内存负载?
11. 进程间通信有哪些方式?
12. redis的数据类型?
13. redis和mysql的一致性问题?

### 二面

1. 项目中涉及到哪些监控? prometheus
2. 队列出现消息积压, 如何处理?
3. 消息幂等性?
4. 一个sql语句, 已经建立了索引, 但是突然查询很慢, 如何排查?
5. 索引失效场景?
6. mysql如何解决的幻读?

> select ... for update: 保证当前事务中查询的范围加锁, 不被其它事务修改

1. 做索引优化, 如何减少回表次数--索引下推

> 索引下推: 指将上层(服务层)负责的事情, 交给下层(引擎层)处理.
>
> 不使用索引下推: 根据索引中的主键值, 定位并读取完整的行记录, 然后将记录交给server层去检测该记录是否满足where条件
>
> 使用索引下推: 获取索引, 判断索引是否符合条件范围, 如果满足, 再进行对应的回表查询获取主键, 如果不满足, 直接过滤掉

1. 分布式事务, 二阶段提交, 三阶段提交的区别?
2. linux查看网络io的命令? netstat
3. 如果出现大量time-wait状态, 如何处理?
4. 网络的拥塞控制?

## b站外包/go开发/一面

1. 自我介绍
2. 在百度什么级别？t几？（没有技术级别，当时忘记自己是什么级别了，说了个m，然后他说m是经理hhh）
3. 怎么设计一个api的（没答好，已读乱回）
4. 怎么去防那个ddos（redis限流+nginx层做处理，最后还是花钱买服务）
5. 怎么部署那个安全拦截服务的（领导买了，在控制台做的服务，点点点）
6. cdn的理解（加快访问速度之类的，问我还有没有别的，我说没有）
7. 负载均衡怎么做的（领导在控制台点点点）
8. 说项目没难度（我说是，不像b站外包用到这么多技术）
9. 分表是怎么分的

## b站外包

1. 旋转数组
2. mysql索引相关。

- B+树有什么特点？
- 为什么不用B树（查询的速度差不多，因为b+树数据都在叶子节点）。
- 非聚簇索引和聚簇索引的区别。
- 索引为什么要用id不用字符

1. Linux相关命令和场景
2. docker和k8s

## 360 一面

1. 协程池的作用?
2. 内存逃逸分析?
3. go的内存回收什么条件会触发? go的GC能够手动触发吗?
4. channel的底层实现? 有缓冲的,无缓冲的channel, 如果管道已经关闭了, 读取会不会发生错误?
5. 切片使用的时候需要注意什么?
6. go中的参数传递是值传递还是引用传递?
7. defer的执行顺序?
8. 100G的文件, 统计出所有英文字母, 按照字母表顺序输出
9. linux如何分割文件?
10. 接口性能如何优化?
11. 什么情况会全表扫描?
12. 主丛同步的原理? mysql还有什么相关的log文件?
13. 分布式锁的原理?

## 360 二面

1. 自我介绍
2. 实现LRU算法
3. 这个lru算法用在生产环境会出现什么问题
4. 如果十万个线程同时put，会出现什么问题
5. 如何控制并发，加什么锁，读写锁还是互斥锁
6. 进程、线程、协程
7. 程序从加载到运行的过程
8. 为什么线程消耗比协程大，具体体现在哪些方面
9. 生产中哪些服务用的 进程、线程，为什么要这么做，有什么好处（今天第二次问到）
10. nginx master-worker进程、进程与redis 进程、线程
11. 数据库事务，隔离级别
12. 各个隔离级别怎么实现的，原理
13. RR能解决幻读吗，为什么
14. MVCC
15. 数据库中的锁
16. 乐观锁、悲观锁适用于什么情况，并发，读多写少
17. 分布式锁
18. zookeeper、mysql、redis 、etcd 怎么实现分布式锁，各有什么优缺点，生产中一般用那个
19. zookeeper原理，怎么保持高可用
20. tcp三次握手、四次挥手
21. timewait、closewait出现，怎么处理
22. tcp调优相关参数
23. 拥塞控制算法、滑动窗口、零窗口报文
24. http1.0 - http3.0 改进，优缺点

## 360 三面

1. 说说 Linux 常用操作，ps 是干嘛的
2. Go map 为什么是无序的？
3. MySQL 索引分类，索引的优点和缺点
4. 分库分表
5. Cookie 和 Session 的区别和应用，分布式 Session 的实现
6. TCP三次握手/四次挥手
7. Redis 的数据类型及其数据结构，Bitmap 是什么
8. Redis 的雪崩效应 ，是什么，怎么解决
9. 线程，进程，协程区别
10. 算法：用 Go 手撕快速排序

## 好未来

1. 为什么要自己实现大顶堆? 大顶堆和小顶堆的使用场景?
2. 如何利用堆, 获取第k大的元素? 堆如何删除某一个特定的节点? 大顶堆如何转换为一个小顶堆?
3. 引入mq, 实现异步提速, 如何理解?
4. 协程池使用的是第三方包吗? 如果自己实现一个协程池, 描述你的思路?
5. recover能捕获到其它协程的panic吗?
6. 说一下对grpc的理解? grpc互相调用, 如何实现互相的权限验证和授权?
7. http2.0 的tsl三次握手过程?
8. grpc中, 如果客户端需要向服务端发送大文件, 如何实现? (使用客户端流模式)
9. http2.0的相关特性? 其中的多路复用为了解决什么问题? (解决对头阻塞问题)
10. grpc中的deadLine和timeout, 应该怎么用? grpc的流控是如何处理的? 滑动窗口控制发送和接收速速率?
11. go-zero中的服务熔断和限流是怎么做的?
12. 以下两个代码片段输出的结果:

```go
func test()  int {
    result := 1 
    defer func() {
        result++
    }
  
    return 0
}

func test() (result int) {
    result = 1 
    defer func() {
         result++
    }

    return 0
}
```

- 

## 深信服

1. slice原理 底层数据机构
2. map 原理 底层数据结构 _ a.扩容机制
   b.并发会导致什么问题？为什么？
   c. Map的key是有顺序的？为什么？
   d. 能否实现map key的序
3. Go垃圾回收，算法 三色标记是哪三色，分别代表什么？
4. 堆和栈区别？内存何时分配在栈上？何时分配在堆上？
5. 如何保证缓存一致性？
6. redis 有哪些数据结构？常见用途
7. 虚拟机和docker区别
   Docker 底层原理 通过什么实现
8. 二叉树前序中序后序遍历怎么回事？
9. 写代码实现两个协程交替打印100以内数字
10. Mysql如何优化慢查询
11. Shell命令考察
    a.如何判断一台服务器还是活的
    B. 给一个文本文件 取出其中特定的列数据 然后排序
12. kafka如何保证消息不丢失
13. udp报文头部有哪些字段？

## 北京贝壳外包

1. 自我介绍

2. 项目拷打

3. Redis 跟 MySQL 以及 Kafka 之间是什么关系?

4. Kafka partion的概念

5. Kafka 偏移量

6. 比如说有你在线上发现一条慢SQL，你怎么分析它?

7. 索引的最左前缀原则是什么意思?a>1and b=1andc=1,你看这个能命中这个索引吗?

8. Redis 常见的数据结构?他们的应用场景?

9. zset 你一般在什么场景下会用?底层的数据结构是什么?

10. JWT 是什么东西?

11. 协程了解吗?和线程对比

12. 一道算法题

    ```sh
     找到具有最大和的连续子数组，并返回该子数组
    ```

13. 编程颖

    ```sh
     用两个协程，两个channel分别接收1，2，并打印
    ```

## 网易外包/Go后端开发

### 一面

1. 自我介绍
2. mysql查询慢是什么原因（没索引、表数据量大、死锁）
3. mysql插入慢什么原因（表数据量大，sql语句多，表索引量大）
4. 抽奖逻辑是怎么样的
5. 怎么实现用户登录
6. 用户登录安全有了解过吗（乱说一通）
7. redis击穿
8. redis穿透
9. redis其他数据结构有用过吗？hmap、zet
10. 短信发送失败怎么处理的（记录发送状态+重试机制）

### 二面

1. 自我介绍
2. cms系统0-1开发的？（开源框架二次开发）
3. 做了哪些功能（栏目、文章、配置、模型管理之类的）
4. 登录的过程说一下
5. session登录有什么弊端，怎么改（多台服务器拿不到session，用redis做缓存）
6. 客户端拿着token，你是怎么通过token获取客户的信息（校验token，获取token作为key的信息）
7. 有没有难一点的功能，说一下（没有，单体项目量不大，只是业务复杂度的难，技术上的难点没有）
8. 用户信息怎么做加密，token怎么生成之类的（md5+拼接指定的key或者之类的）
9. 200个券码，发送客户，怎么设计？（分布式锁，数据库唯一索引兜底）
10. 还可以怎么优化（redis布隆过滤器，避免大量重复请求，处理逻辑做幂等方案）【睡不着想起来还可以做mysql的乐观锁，数据做缓存预热，减轻数据库请求压力】
11. 长连接做成短连接，怎么设计，怎么做到短连接唯一（说了和自己的 短信生成方法（用户id活动id，二进制），php的uuid，时间戳，uuid截取？引用第三方库之类的）
12. 面试官说要短的，要唯一的，答不出来

## 面经详解跳转链接

[腾讯校招面经详解](https://link.segmentfault.com/?enc=m40zIos8oLZX3f%2Bq0l9NaA%3D%3D.u4mDsDE4CTUOUxAKS94TQ5XAqBe8F20slXVp705XwsY7gz7HyckFdnDnMy5bELKntaYsBBO1H2W3raHdevMixl7s8l7VtTWQehOWvWYCX8YZ4XK6UikWl1Y1HsBtEQVl2AxrhR%2F5Nx1DUGGZX02AxfsdtWFPOAWu7Xf72Vl%2BSjWXLrsklir1HQkQhnV4a7%2BqE4TytI8fZsDPDlPzdRJerQb9Sk%2BcYnytBHZobIwzejsGdi7%2BsjMCvhDaoqq6vAbokeQ79pKSyi0xH19ZgBDgy4YB6LnA%2BcUZNmD503eQkfcprGuRzhz4a8WelnOEb%2F8o)

[腾讯互娱面经详解](https://link.segmentfault.com/?enc=8jrz71ri32jZ00BrXZEGrg%3D%3D.nc9rDqU%2BKKLgoaarp3yYJfFlJ2oFMOcmkNDEqOaqSRKDkiZbQlmHwcbveDMAcdUai08oJ9hPNU5v5uo21YDb%2BX9GXUdtAZtwUF1yY0vlriyAMSb47nCOfbPnsHUjMSou8VmawtC%2FkUGG1y%2BLKH0yfJb6dwiVbeR7hxilDVzD2O1dgwy8NWf5keqrO2U3wNvJLN%2Fx%2BezKAeEceoftm5RHiR2xBHjWkOZJMsiKOe%2F%2FELRqoPK1vnHT%2FCYFUPup8c%2FR6nWzlA%2FsPtkrVQCehrlJ722IUoXEzf%2FHlCUwFrHW24gN%2FDc0USnink4B0o%2B%2F6Zek)

[腾讯后台秋招面经详解](https://link.segmentfault.com/?enc=yodkuUfB7SgnRF%2Flx9d9PQ%3D%3D.rvbA2ETJrUTz8rmiSy6k1y3IFb%2BLFJGff%2BjFPzTmecIpn4GQnFMEWZJvao9pPFGUp61GnXnH12lSI7wjPJ392ozza8mny5TVAKGPtqvAtcRRQHUHnkL%2BgAZpWPRnoGfsYS8xH8ktWVI2ic9B%2FbkF9Fk6bUw8EI1Bvlr3FPTQMYCrZGyIZyUSldR4pUcudYIDVMiTE%2Bx5DOkadEOFKGLcmdI4DVgNsn4xB65GBuv7%2FaFW3DIe3uYHtSQg2R474kysSKIngZnkPoz0O88Qf6qZnEFrMl8gzfg%2BEcrleZj0PNH7rPupvo8epawdjhlSM%2Bn6)

[腾讯面经详解](https://link.segmentfault.com/?enc=se5Dd3FsHt1vEoIXKfcuYw%3D%3D.JGSG6kkfzMe67LqDqpXuuNiKS0J%2BQTyxfdQ2QAP%2BGQ3Exx960qg7d%2Fis6Y%2FfbfDzinKk80doEXlWxi8rdSb9MZixEjdYSzOiqdq6MWkssT3LsVrywoBadWLYb4RiG3HgZN8HHe4JoRYoUZipj4RhrMp4meQvF7eYu1rDBABGAeps9yt%2ByxC8GlypUITFoQ8YmUarAZC4B9qyRVW5D1i21GepRYLSEUp4VUVpB9QRgLTmLSg5xJ0DPQlP1nJbcGj%2FNWgxk0up%2FESQbac4sudVRTkc0OGS7MGAZgVWk027ZIPtjPiopuL8EQTjo8FvCD0u)

[好未来面经详解](https://link.segmentfault.com/?enc=SeI%2Ft%2BRThRpiR4EkYJPNBw%3D%3D.5uQYKKSMkU9sZ5wGTc2Zd%2F7KtL4Es18jQT53wIKz%2BaUDLnTdGe7UAa1AAGRM4MM28CxNsdwXdlB0eHXq%2FQnkMn9X4DRtYVoth7abZDSHflsVwO%2BSbMRiKyeEiAyAqHKBaXSnW4s%2F1VKzl6GXPMrU%2BKhtvaMh%2FoAoGEug0EXpR5n1B9yUrLMIppw%2FCqiNOYl4xCmmaKttVyTyaK2c5jsLxydjxo9jEe6mgGVsUm1%2FwyMeDL9IkKwoaQmInJ5zNYoQn01oXju2jqxg98nxM8FVfv2VTeiITfrE%2B3QtleDEdqEPVmf%2FOHOBnWmMNwZl76nU)

[PDD面经详解](https://link.segmentfault.com/?enc=fJzzym3aJ3SIUR9Dm0lPVg%3D%3D.ca4oKX5xDplE8SijtdL2wmP76sTPVCcko%2FMza4feOJUWtgZuOlQMcjgT3%2Bgtvl6cJZacb8fm1io0ZnuiagQZcff46vTQqaqWrKKltzCLlXo32iD%2ByoQwx5CBDOahf8%2Fax2PKanNqq4D5rfBofj28my4LmUohTfHQ3Y2Tvb4InYZY8CNysBx3XSerFc3kh8%2BvInAOlep7FDHGUYitdV%2B%2F5r4CF7DJ4ETiXAffI29TWk%2F1KdsAyzO4IzDo5A2pNEuHTdTmg%2BhkqJlA9XaHAbBOcBjaS1%2B%2BuOGGp10PnOuWsj7gUvrJ0sgJbvSh3QkChQKG)

[PDD服务端开发面经详解](https://link.segmentfault.com/?enc=UDU2TowfwVkVoe3Ua%2FEkUA%3D%3D.oE2PoIbZCD2WMWVlIdtH4bLQtfZh0PO6Ix%2B5mPnAmlCyb8dUMRj8Tfk7jL0cVdXes8eo38MMfmc1Tc4qmCkSUXZDQSdEd%2BkF1sUjLNSmctgpHXRzwDJB3mdU%2BnZEe4RUQPQjjShxtECXzymA%2FhrnEXhO6Rox9bi65XLmu5r0G%2F00r0Is0amzQi5EjXR8pm6Pnj0QLnksRYo1zLB4W4Ee9IpUX57AxB6I22fMiWdN5g9b6OR95oN1oxqdKVOvxGvq447JD4gGuY5WUkKprukjJDE7bAyw9uMwJ6%2BrXSAYl2aek2O9Z%2FudvgXpxyMNbShU)

[百度面经详解](https://link.segmentfault.com/?enc=TMbiKP0BnRyIOSUIjiZxqg%3D%3D.3LwqRRhsF2eaBff8gI14t4JzwXOCZxMN2Zd6mGV46D%2BJMTeA%2B6NKC%2Fy45PJN%2F1tVCULZDgZ0GvV2YtiLakMeE4fa0Y09J1us5FIxC6ZV9dAAhBfNZ8a7%2BIt68Rk%2FiuoyIelYexAostPoyJu1YWqTNy3P9xLhuF0e6b%2FOlPcmX3Ig8CJMzwhPdwpf0y3itvFkKXMoH7Pnn5N9CHwRgnRcDaSP0f0%2Fov%2Fd1pT1eR%2BRjcoByK9VJ2ItGfxXNIjcBzOjSFgD5JFRxfEmyRoMHBczQUGrd4%2F5R%2BwzQNj1d0anUYU7UYMIkb0NvueqM%2BT8%2B0yp)

[百度面经详解2](https://link.segmentfault.com/?enc=lzDmKK7zRXV1kJhAWrcIpQ%3D%3D.%2F12bLO%2BsLeLvsxa05cPtsEWfdwfmXp7KFiMPeQ8Q9ViTkNQoXml1Ih5lCCeOSmXybt1mzU9eebvzJJlrR9RFIMHQKZ6FJ509wkzYbsSKWWRWKDPxf0zvGk2swp2yAWNVSAK2zrv6iA7pIdT5kZ35qoUJCQsHtEyOPSInPvJ%2FuSYQCWduwlNAgjZybC8GPfGHTwRB2pVbYg2T7xn4%2Fqo%2FhjFMPAsB2ILXjRXc0SAsntF77sgagEF6F9GfrRxjIiltvUJWdXLQoOvlr6KyPrcb9NoWTYTv4woFjB827B5YkiK8YC3qPXOsqQ7Xq0rJJfwb)

[百度面经详解3](https://link.segmentfault.com/?enc=r%2BtH03YZPzMOybeQab244Q%3D%3D.QhI%2Fbuh%2F0Yhu%2FXk1YsriWFVp%2BrPUNU34Qvvrt%2B52FagJAyYXMXJi8sViT3UphX8DY5s%2BgwiGfhtGN%2BMMLviHj0uZzsy0KGaNMfB5cYhNSatXA4ZccBEzANDZRbzn8AYnQQDI89V%2BmoGvlYM8%2BGd8PWSL4dw4UPdpY7QC0NRjEQKza4wdVO9gQCw8bWIdANLBFKPTem3ib9HgmHMG0dJ0c2BHWqltiDnMqD8N7o7EZy53V8rXKM4JuE9dsxDU7j0NbCLj%2FKGZQ9imiKs4ooIY04c4bNpcBnq28WDxiv%2BrrAJKiFhVn67v%2FFg734rHHYKw)

[阿里校招面经详解](https://link.segmentfault.com/?enc=cZDQ9rW88yG3Q9BjVKwh%2Fg%3D%3D.mWnEXqwxjYsZsNcodHFwJDX4jh7%2BIXdJG3GKDcs0lnHWw%2B%2FQU%2BrPwitEBawHsa5i8hStq9KaO1gePaqMzhWgjFNDXuXdICx2sqq1Q39F3cJCGPI2cXNKf4Fdrb1y6FJkPA7ukxT44368lp84GQBhPIwNd6D6xACXhiY%2B74diGoLHskxBF4YK9DSKumrsj8w6n5f%2FQW2ZzUuP%2BOp0GEyt9FFpdrX99Uei8DgJGVYnqUrSIrA1z0tl7JRn7lBJJ7ouw8DKdL%2BQLhrXIdUSr7R4Z8htX0OOejE%2FwnFl0W5kqIY7wh6MylpdGj6tMGsmESny)

[阿里社招面经详解](https://link.segmentfault.com/?enc=hmvPwOR0qdTfcVo%2F3iBEJA%3D%3D.YTDXog%2BD9fc5UoH2lNcQBghy4uuiNKTtpis6HPZOi73Bev6NPUv%2FD2H6BsSeMvnVDZCKprA6U7eGeIPwGqcZZ%2B2NqCwIFe525gL9kr7EAiCM82ryp%2FbdP8nJ%2FKl0fqHIAhSUUHswng0NKxSVDwoDW0S78yV2ucSFKKJjGjJcAhf5xQhpeqfm%2Fb9WQ2n0Zkxrhr4d5mIyeO127q2SoYWCptBpnv7ip%2FNSH3OWcUub9ZKSu7HtVdPSxtZ3hWhqQXkwEfvULK0NfMMeb9rjkt2RgXUZC4qtEHkHO6a2W1Mq4z3HGR9vsPTeK1YLwlUeg5J5)

[贝壳外包面经详解](https://link.segmentfault.com/?enc=JizVzoULI%2Bz9XtZvSH8Esw%3D%3D.gPB%2FgB97RaQuDwceGPac2ozLE07lzXHQ7XywMs4bc25UOFEjG8Gd%2FbT%2FeaKjwkkKClctdB2nxpl%2BKYDcXoJ4xo0jNSFqTLIY8qv9Z1gDhtkGcec9AVHm0p7zmhjR0eq3z%2FjltFq1DpSh%2BAuE3yREn1kHREL2VYbShJf7UJwnEKcuettKFSFG69KjpC%2FAq%2FEwfCjw27n4fc7IHuJ98kLwwljr0Y%2BlDIFbM8G8SYmxVn0PxjyCcpWcP6qP%2FlV48QX4dQrQZaheDY7NMZKw0lCsw0h5rU8fhR6CAM1Smv8FBwRSmahlYTbQfeKhhkPfaiUR)

[字节跳动面经详解](https://link.segmentfault.com/?enc=23zP6sIn25AZQ3NIe25HAA%3D%3D.tEZpElZu2G6OIJdWeaZr925UgGV242AplWokHcEuJExulQ4NWAOQFVRySRU82Ynp2pgIqRA0O9SEKvoovJgbfU87SWQY6KVfDCX3TsgRXHsP6FZ%2BplqTQsNKCahdO%2BQ6V%2FxFzu%2FGheYcSRXHVzfZ7toq9t3%2FUZUY3R5GnuDyNv8VKz0qiX6F1J%2BEkjZeLhqBmYI9VmhhcpQJhFqMGbfi698Nmmg%2BC5FieuN9GFWcNjW2jc%2BQazEK7kElIXpYFGj3UFtkpal7ATRHotxIyrQhnYLH1A4s4j16G6vMXF4Yf2FNpN4ogrAORx5Uy9vipRHI)

[字节跳动面经详解2](https://link.segmentfault.com/?enc=T%2F107pU14EKJEJ1XF9uzQg%3D%3D.aSXcob3XAavDp8fwvgxDCBrt%2BcoBaShoDBX9pYRF9825rgf9ouhepAg9mP2hFMUROSqunqaSeigOstlMQpQygea2rVJNxONonL4m3N90FHR7La%2BXc0XFW%2FTLn%2B%2Fjjdxvcab3ry42wOo40RQK0HTWk01%2F%2FeclbCOfIF6plNzaW1Ux9ENdd615mTvFQSrIpDZxoZML%2FRx8qBOi3jGqGs2GgDaTPb9o1TF147FUSBilgOrMbF29qQT8aj3nzj8rp8Ge3nNyhnCCxYZwzVxVujHEQnTnQfXkk6ek6C6UVO7jWshC96nw2ocvlKrFswqy2QM8)

[字节跳动面经详解3](https://link.segmentfault.com/?enc=yh4IrhT7yxk54zotFEoYUw%3D%3D.zgC8pLzlvjXmvN%2FDXKD8e84dgsjwbnVlNQGJkqIT7eQuQmaaWBhoizKq4WU8sQCbVL5mSqhWvoVrHwpFUtVbZ4CdYSLylsmpFCZSjiduoOupf44l3F0Xh5chvv6yWaFyEsr9Rmnd%2BpN7VdNb2um7etrM6FtZCq3xROTrk57PEEvNL2CHl15cdz1mPzaQg3xA27ux86fY4vBa9GczJVRpkVGECDvvS3DYOYDPrkXupHHrt9qQZOAi%2BEwpVmhdkFRXjky0uoYVbVah7a0XoieC8R6J5P8KrhQdY1LfP6lT9%2FzSCxm62qmdH%2BiKDBSGkmJH)

[得物面经详解](https://link.segmentfault.com/?enc=WNx4Wql5w3nIGpcS1oQvLA%3D%3D.1HPIL7VCPFiPsVC1q5gybf%2B0XI7gbgHqz%2BMwcYVxtJULvdD31J4Yz71hNUlYoAxFkuXfJv6mVE9hvwf6Sg6evAhfYyuCVjtVo7IKyZDjjfgRx%2FyEnT5PjODtfkmG2GSm9s7%2Bo744KImfzG%2Buaf16ENzz%2FAOB69EW24OFzskpc6vH8b5m6L5TH%2BBnV6JV1qf6xyZ%2FQOuLe3yHS5hcO69FYPDJGo4k27v7bkrE1yzqYjD38X6Vc%2FXfZhQ1Urww9IyoUmp3FpmdCFZ52F04XTAqM%2FBZxbzQdaVT69NK3oWfTTUAiWUq3%2FA9LSMqp3lmygNu)

[美团面经详解](https://link.segmentfault.com/?enc=f8ccO5aJhetp0RKazyPZZQ%3D%3D.gVwIfP5jLHvhyjWgaqa8Thu6QS43Ipa08vC8yrjgNBxyP%2FYxkGHSiKey4ugI1sNCa1ZpapMarIUiUV%2BeW4aEeulv47zb3uqFE1QU6JWUZMcol5kVND1hXWksX1PcF8qMOs%2B6MnXmtBgh9P6PEqiN5y2RjuNRC0XawTGtJFxro%2BWMOb60Vks%2F5RzTSYUqOdkxt6qas5zBTB702wT%2F3zI9epZiEavm6xrbnqgD%2Ba4Cho6CqjJZMtvgBn%2F%2FxCrXTQOve6d9Xcwm9xanMidPX1DdgBS8pQ5BKhx04xM7fD0%2FgVuDUFXRACT6zAAE6D5C7YDv)

[深信服面经详解](https://link.segmentfault.com/?enc=x2WHaz3QK3dQLh3OgVjFeQ%3D%3D.TzsziK4mgk1wWq4EsXXV%2BT7OzkHuYCNMGZUrsgrT5%2FpDMbewqPxzJocRGuNKj2Qfk0Go3G8CKf2yNVuShx5s68ZyJ%2B6Fakt%2BsEyZBTXXicwk2dN9jpp7uAouaioI3S%2FXrcbQA3IkLhE0uWsK3VBeYK5tAmby%2FlnDACOr8kBIAKd7KMomYzF90sbwJHiP1MvtNoJe09vfSYnQl9A4AOk8G7nq2tgVhjCEIJfc8hkBWQjv4D8mhZH1l2Xcgtv09%2BccQbKZ7rsenjsSR2NNsR%2BzmrBL8xYmmFTHASks5osWcG7G6O11nvUthE8aJDftmakm)