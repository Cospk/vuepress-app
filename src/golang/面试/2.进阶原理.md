---
# 这是文章的标题
title: -进阶面试


# 这是侧边栏的顺序
order: 1
# 设置作者
author: xiaoxie
# 设置写作时间
date: 2020-01-01

# 一个页面可以有多个标签
tag:
  - golang

# 此页面会出现在星标文章中
star: true
---



## 面试流程：

1. 自我介绍
2. **聊几道基础八股文:star:**
3. **聊聊项目和进阶八股文**:star2:
4. 场景设计题
5. 写两道代码题



判断是否有戏：

1. 判断面试时间：若是10来分钟直接写代码了，大概率是不满意不想继续聊了

2. 提问：快结束时候，面试官会问有什么想问的？可以提问下面一些问题

   岗位工作内容
   进去具体做啥

   用什么技术栈

   若是面试官详细介绍了，或者说招你进去安排哪些工作就很有机会；若是敷衍几句就不用报太大希望了



# 基础语法

> 语言特点、数据类型及其特点、类型转换



## 语言基础



1. go语言的特性，对比其他语言有上面优势？
2. go开发需要注意什么？
3. go的数据类型是怎么样的？
4. 





### 与其他语⾔相⽐，使⽤ Go 有什么好处？ 



+ 与其他作为学术实验开始的语⾔不同，Go 代码的设计是务实的。每个功能和语法决策都旨在让程序员的⽣活更轻松
+ Golang 针对并发进⾏了优化，并且在规模上运⾏良好
+ 由于单⼀的标准代码格式，Golang 通常被认为⽐其他语⾔更具可读性。
+ ⾃动垃圾收集明显⽐ Java 或 Python 更有效，因为它与程序同时执⾏。  



### Golang开发新⼿常犯的50个错误  



博客地址：https://blog.csdn.net/gezhonglei2007/article/details/52237582



### Golang 使⽤什么数据类型？  

Golang 使⽤以下类型：  

+ String
+ int、float、double
+ Boolean
+ Array  
+ Slice
+ Map
+ Struct  
+ Channel  
+ Pointer 
+ Method    
+ Function 
+ Interface



### Go 程序中的包是什么？  

包 ( **pkg** ) 是 Go ⼯作区中包含 Go 源⽂件或其他包的⽬录。源⽂件中的每个函数、变量和类型都存储在链接包中。每个 Go 源⽂件都属于⼀个包，该包在⽂件顶部使⽤以下命令声明：  

```go
package <packagename>  
```

您可以使⽤以下⽅法导⼊和导出包以重⽤导出的函数或类型： 

```go
import <packagename>  
```

### 变量大小写的区别

> 变量首字母大写是public，全局访问
>
> 变量首字母小写是private，只能包内访问

注意：

我们在定义结构体需要映射的时候必须首字母大写，否则得不到反射信息，无法转为我们需要的类型



### go语言中的值类型和引用类型

> 值类型和引用类型分别有哪些，这个在拷贝赋值有一个深拷贝和浅拷贝问题，初始化方式和使用的问题，数据底层数据结构情况，内存分配。实际使用时候会在new和make函数中需要考虑



#### 值类型

一般是一些**基本数据类型**，然后**传递赋值是直接拷贝数据即深拷贝**，原对象和新对象**不是同一个内存地址**，各自独立

未初始化时总有零值（go默认提供），不存在nil

#### 引用类型

数据类型**底层的话都会使用到指针**，如切片，map，chan等等。传递赋值只是**复制引用（指针）即浅拷贝**，**共享底层数据**，修改这个会影响其他引用

未初始化时为nil，表示无效引用，需要初始化后才能使用



|    **特性**    | **值类型**                                  | **引用类型**                   |
| :------------: | :------------------------------------------ | :----------------------------- |
| **赋值或传参** | 数据复制，彼此独立                          | 共享底层数据，互相影响         |
|  **内存分配**  | 数据存储在栈或堆上                          | 引用存储在栈上，数据存储在堆上 |
|  **常见类型**  | 基本类型（`int`、`float` 等）、数组、结构体 | 切片、映射、通道、接口         |





## 高级语法



1. 实例对象中，make和new的区别是什么？
2. channel使用需要注意什么？
3. Map的底层实现
4. 编程题中的string的一般用法



### new和make有什么区别？

#### new函数

适用所有类型，仅对数据类型**分配内存空间，不进行初始化**；**返回**这个内存的**指针**。

区别：值类型go默认提供零值可直接使用，引用类型没有初始化返回的指针为nil不能直接使用

注意：引用类型使用new不能直接使用会报错



#### make函数

仅用于引用类型，进行**分配内存并完成初始化**操作（初始化底层数据结构），**返回的是**引用类型的**实例**

注意：值类型不能使用make函数编译会报错



### 引用类型如切片，nil切片和空切片有什么不一样？

nil切片和空切片两者指向内存地址是不一样的

+ nil切片：引用数组的指针是**nil（无指向任何实际地址，不可用）**
+ 空切片：引用的数组指针地址是有的，且所有的空切片指向的是同一个地址（特殊的共享内存地址）



### channel的使用注意

说到channel就需要了解设计它是干嘛的？有什么特性？

go经典一句话：不用共享内存来通信，要通过通信来共享内存。这句话也意味着channel是为了解决协程间的通信问题，类似于管道，channel也是并发安全的（由于它的收发数据都是原子性的）



特性

1. 无缓冲：发送和接收操作是同步的，两者必须同步进行

2. 有缓冲：可指定缓冲大小。缓冲满了，发送操作阻塞；缓冲为空，接收操作阻塞

3. 给一个nil的channel发送或接收数据，都会造成永久阻塞，进行关闭操作会直接panic

4. 给关闭的channel发送数据，会引起panic

5. 从已经关闭的channel读取数据，缓冲区为空返回一个零值，有值则正常返回

   





### map的实现

map底层是一个散列表，主要是两个结构体hamp和bmap







### 处理字符串

> 问题1：字符串转byte数组会发生内存拷贝吗？
>
> 问题2：处理字符串包含中文怎么办？

```go
// 问题1 ：严格来说发生类型强转都会发生内存拷贝，但是频繁内存拷贝又有性能问题--解决：使用unsafe包转两者的底层数据类型


// --------------------------------------------------------------------------------------------------

// 问题2：处理中文需要使用到 rune 关键字（底层是int32），rune表示范围更大
func reverse(s string) []rune {
    tem := []rune(s)
    for i, j := 0, len(tem)-1; i < j; i, j = i+1, j-1 {
  		tem[i], tem[j] = tem[j], tem[i]
 	}
 	return tem
}
// 这个问题直接for range 遍历字符串也是转为[]rune切片，
```





# 原理部分

> 垃圾回收（CG的三色标记和读写屏障）、并发模型（协程、waitgroup、context）、GMP模型、常用数据结构底层原理（map、slice）、并发安全、锁



## 1、:star2:协程



1. 协程是什么？
2. 协程与线程进程区别是什么？
3. 协程之间的通讯是怎么样的？
4. 协程调度的GMP模型是怎么样的？

### 什么是 Goroutine？你如何停⽌它？

一个goroutine是一个函数或者方法，是实现并行计算的核心，通过函数方法前加`go`关键字启动协程



协程有自己的寄存器上下文和栈，协程调度切换是有runtime控制的，而且创建和切换成本很低

goroutine即协程 拥有强大的并发实现是通过GMP调度模型实现的

需要停止一个协程需要向协程发送一个信号



### 协程与线程的区别？

+ 调度
  + 线程由操作系统参与调度，抢占式。
  + 协程是由go运行时调度，协作式
+ 开销
  + 线程不管在内存、创建还是调度上面开销都是很大的，其中栈的大小通常是1MB，成本是很高的
  + 协程在上面的开销很低，栈的大小初始只有2KB，可轻松处理上千个协程，结合GMP调度模型使得并发效率更高
+ 通信方式
  + 线程的通信方式是通过共享内存
  + 协程通过channel进行通信，简洁高效

由于线程的调度和管理高度依赖与操作系统，为此可移植性差，而协程是由go运行时管理，为此go开发就无需关系操作系统实现，可移植性更好





### GMP模型



![GMP](https://gavvy-cloud.oss-cn-shenzhen.aliyuncs.com/web/GMP_modle.png)

GMP调度模型三个重要结构G、M、P

- G：代表一个goroutine
- M：代表内核级的线程
- P：运行时的一个调度单位，维护一个G的本地队列用于管理和分配G到M上运行

#### 工作原理

- `调度流程`

  - 当创建一个G，会被放入某一个P的本地队列中，本地队列满了就会放入到全局队列

  - 每一个M绑定一个P。M会从P的本地队列获取G来执行

  - M执行完G后，发现P的本地队列为空，优先会从全局队列获取否则从其他P的本地队列窃取一半的G来运行（这种机制叫**工作窃取**，保证负载均衡）

    

- `P的数量与M的数量`

  - P的数量由GOMAXPROCS控制，默认会根据CPU核心数决定P和M的数量，可以收到设置runtime.GOMAXPROCS(n)调节并发数量，数量固定的（最大并发度），多个P是为了更好利用多核CPU的性能
  - M的数量是动态调整的，根据需要动态调整
  - N:M  即使只有少数的M依旧可以处理大量的并发任务



优点

1. 高效的并发模型：协程+工作窃取，最大限度提高CPU利用率，避免线程切换的开销
2. 低开销：使用协程，极低的上下文切换成本使得可以处理大量的并发任务
3. 易于使用：协程+channel提供简易的并发模型

优化考虑：极端并发场景要合理设置GOMAXPROCS、合理控制协程的数量





## 2、:star2:并发



1. 常用的三个并发模型是哪些？--channel、waitgroup、context

### Channel通知 实现并发控制

特点：

+ 可以通过无缓冲的channel 控制并发顺序
+ 可以通过有缓冲的 channel 限制并发任务的数量

无缓冲通道也称为同步通道，发送方的协程和接收方的协程必须是同步，可解决两个协程执行先后顺序



### WaitGroup 实现并发控制  

特点：

- WaitGroup可用于等待一组协程完成任务
- `Add` 增加任务数量，`Done` 表示任务完成，`Wait` 阻塞直到所有任务完成。

可解决控制一组协程同时完成任务，在批量任务的处理应用



```go
// 举例：交替打印奇偶数
func printNum (nums []int) {
    // 定义两个信号量控制循序                       
    evenCh := make(chan struct{}) 
    oddCh  := make(chan struct{})
    
    // 定义一个waitgroup控制两个协程完成后一起退出
    var wg sync.WaitGroup
    wg.Add(2)
    
    // 1、奇数协程
    go func(){
        defer wg.Done()
        for _,num := range nums {
            if num%2 ==1 {
                fmt.Printf("奇数协程：%d",num)
                evenCh <- struct{}{}  // 向evenCh传一个空对象，让偶协程执行
                <- oddCh              // 向oddCh 读取，阻塞到这里知道，偶协程传递信号过来
            }
        }
    }
    // 2、偶数协程
    go func(){
        defer wg.Done()
        for _,num := range nums{
            if num%2 ==0 {
                evenCh <- 
                fmt.Printf("偶数协程：%d",num)
                oddCh <- struct{}{}
            }
        }
    }
    wg.Wait()
}
```

### Context

特点：

- `context.Context` 用于管理 goroutines 的生命周期，特别适用于需要取消操作或传递元数据的场景。
- 提供了超时控制、取消信号和上下文数据传递功能。

上面两个可应用在大部分场景下，但是在web并发下不好处理了（每个请求开启一个协程处理，这个协程可能又会开启其他协程，如数据库或rpc服务等等），我们就需要可跟踪的协程的方案

context上下文可以处理子孙的协程，

<img src="https://gavvy-cloud.oss-cn-shenzhen.aliyuncs.com/web/go_context_Struct.png" alt="image-20250102142501297" style="zoom:50%;" />



```go
// 在父协程中创建一些协程时候创建一些参数
// WithValue 传递参数：原来的上下文附加上键值对，然后创建新的上下文
func WithValue(parent Context, key, val any) Context {}
// WithCancel 设置取消信号
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {}
// WithDeadline 设置cancel时间点
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {}
// WithTimeout 设置超时时间
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc){}

// Context 的一些接口也就是我们一般在子协程会根据上下文调用的方法
type Context interface {
		// Deadline 设置context cancel的时间
		Deadline() (deadline time.Time, ok bool)
		// Done 关闭或者超时，channel会有一个取消信号
		Done() <-chan struct{}
		// Err 执行done方法后返回一个取消原因
		Err() error
		// Value 上下文对象携带并发安全的数据
		Value()
}

// 其他框架中的context（如gin会自己实现一个功能更强大的contex）
比如传递参数会使用锁+map实现存储并传递参数到子协程中去使用
```







## 3、:star:内存

1. 内存逃逸是什么？怎么避免内存逃逸？
2. 垃圾回收机制是怎么样的？（三色标记法）
3. 性能分析
4. 内存对齐

### 内存逃逸是什么？会有什么影响？

内存逃逸是指：变量或者对象超出了原本的范围内，导致它被分配在堆内存上了，后面由GC负责回收

正常的局部变量是分配在栈内存，变量会随着函数执行结束后释放内存



**内存逃逸场景**

1. **变量的地址被返回或者传递到外部函数**

   ```go
   func createSlice() []int {
       s := []int{1, 2, 3}  // s 是局部变量
       return s              // s 的地址被返回，生命周期超出了当前函数
   }
   ```

   

2. **在闭包场景下**

   ```go
   func main() {
       var f func() int
       {
           x := 10  // x 是局部变量
           f = func() int { return x }  // 闭包引用了 x
       }
       fmt.Println(f())  // x 的生命周期超出了它所在的作用域，因此需要逃逸到堆
   }
   ```

   

3. 切片或map作为函数参数



内存逃逸让变量或对象从栈内存变成堆内存，会导致GC的压力增加，降低性能，如是大量的GC会导致CPU毛刺（瞬间飙升很高）



### 怎么分析内存逃逸？以及优化

Go编译器有内制动额逃逸分析器，使用命令进行逃逸分析：`go run -gcflags=-m   file.go`编译器会自动执行并标记哪些变量需要逃逸到堆上，这个命令会给出逃逸分析报告

**怎么才能避免呢？**

本质就是：尽量将变量分配到栈上

1. 尽量避免返回局部变量的地址

2. 函数传参：传值会拷贝整个对象，传指针只会拷贝指针地址，可减少值拷贝，但是会导致内存逃逸，增加GC的压力
   特别是在对象频繁创建和删除的场景下，传递指针会导致GC开销严重影响性能，

   一般情况下，需要修改对象值，或者占用内存较大的结构体，选择传指针。对于只读的占用内存小的结构体直接传值会更好



### GC原理--三色标记+增量式标记清除



#### 三色标记

> 大致的过程：首先将所有的对象放入白色集合。
>
> 1、从根节点遍历对象，遍历到的放入到灰色集合。（最终是进入黑色，暂时放入黑色是为了查它所有引用的对象）
>
> 2、遍历灰色集合的对象所引用到的白色对象放入到灰色，然后将遍历过的灰色对象放入黑色对象
>
> 3、循环步骤2，直到灰色集合为空
>
> 结束：剩下的白色就是垃圾，进行回收

白色：不可达即垃圾

灰色：可能是垃圾

黑色：不是垃圾



#### 并发标记与增量式标记

标记和应用程序的执行是并行执行的，有点减少停顿时间，标记工作分成多个小的增量任务避免长时间阻塞

虽然是通过并发方式但是任然需要stw来暂停程序的执行保证标记的正确性



#### 分代收集

Go的垃圾回收器通过分代收集来优化回收过程

对于年轻代，新分配的对象，这些一般存活时间短，更可能是垃圾

对于老年代，已经存活一段时间的对象，更可能长时间存在



:::tip

GC的控制方式
被动：环境变量GOGC控制，当栈内存增长到触发的阈值，就会触发，GOGC表示触发频率

主动：可代码上手动触发runtime.GC() ，但是这样做法不推荐。 （runtime.ReadMemStats()可获取内存使用和GC相关信息）

:::



### 内存对齐



> go编译会自动内存对齐，为此结构体类型需要注意内存对齐，合理的顺序可减少内存浪费

**CPU访问内存时，并不是逐字节访问，而是以机器字长为单位访问。**（如64位的CPU一次都是读取8字节，还有没有对齐可能会触发总线错误）内存对齐可以提高内存读写性能，也方便实现原子性操作（类型若是被拆开就需要多次读写）

Go编译器会**自动根据规则进行内存对齐但不进行优化**（即不改变顺序），为此我们只要了解规则进行合理安排类型的顺序即可



合适的内存对齐可以提高内存访问效率，减少程序运行时间。go编译时候会自动处理内存对齐



对齐规则（插入填充字节实现空间换时间）：

- 对齐规则：Go会根据每个类型大小确定对齐方式（大小的倍数）

  `bool`：1字节

  `int N、uint N、float N`：通常按照 N/8 字节对齐

  `int、map、chan、func、*T`：1字（根据**机器字长**）

  `string`：2字（数据长度）

  `[]T`:3字（数据、长度、容量）

  `interface`:2字（类型、值）

- 根据实际机器字长判断：32位最大是4字节、64位是8字节



```go
// 不进行合理排序：占用 32 个字节
type person struct {
	hasMoney bool   // 1 个字节
	name     string // 16 个字节
	age      int16  // 2 个字节
}

// 进行合理的排序：占用24字节
type person struct {
	name     string // 16 个字节
	age      int16  // 2 个字节
	hasMoney bool   // 1 个字节
}
```







## 4、锁



1. 互斥锁
2. 读写锁
3. sync.map的安全锁



### 互斥锁

在Go并发程序对共享资源进行控制访问的手段，如并发操作非并发安全的map就要用mutex加锁

用法也简单，只提供两个方法：加锁（Lock）和解锁（Unlock）



```go
func main() {
    // 1、声明一个互斥锁
	var mu sync.Mutex
    
	m := make(map[int]bool)
	var wg sync.WaitGroup

	for j := 0; j < 100; j++ {
		wg.Add(1)
		go func(key int) {
			defer func() {
				wg.Done()
			}()
			
			mu.Lock()     // 写入前加锁
			m[key] = true // 对 Map 进行并发写入
			mu.Unlock()   // 写入完成解锁
		}(j)
	}

	wg.Wait()
	fmt.Printf("Map size = %d\n", len(m))
}
```





### 读写锁

读写锁是针对读写操作的互斥锁。

特性及注意：

1. 持有锁：由**任意数量的读操作或者单个写操作**
2. 唤醒操作：Unlock（写解锁）方法会唤醒**所有要进行读**而被锁定的协程；而RUnlock（读解锁）方法**只会在没有任何读锁的情况下唤醒一个想要写操作**而被阻塞的协程
3. 解锁：多读操作是不互斥的，为此获得多少读锁，就要等量给多少个读解锁，否则其他写操作就无法获得读写锁了



```go
func main() {
    var rwm sync.RWMutex
	for i := 0; i < 5; i++ {
		go func(i int) {
				fmt.Printf("当前是第%d个协程 ", i)
				rwm.RLock()
				fmt.Printf("获得读锁的索引是%d ", i)
				time.Sleep(time.Second * 2)  // --休眠2秒
				fmt.Printf("进行读解锁的索引是%d ", i)
				rwm.RUnlock()
				fmt.Printf("锁：%d 已经释放 ", i)
			}(i)
		}
	time.Sleep(time.Second * 2)
	fmt.Println("试图获取写锁进行，写操作")
	rwm.Lock()
	fmt.Println("解锁")
}
```





### sync.map的安全锁



sync.map内部不直接使用map结构，而是进行**读写分离**优化后的解决方案：分为两部分的存储结构

+ 只读的存储区域
+ 带锁的写入区域

好处：高并发条件下，大多数读操作是无锁的，只有写入操作才会进行加锁（算是读写锁的应用吧）减少锁的争用提高并发





使用：sync.map是开箱即用的，直接对外提供对应的操作

1. `Store(key, value)`：将 k 和 v 存储到 `sync.Map` 中
2. `Load(key)`：读取指定k的值，有则返回值和true，没有则返回零值和false
3. `LoadOrStore(key, value)`：存在就返回值即可，不存在就存储k-v并返回value值
4. `Delete(key)`：删除指定的key这项
5. `Range(f func(key, value interface{}) bool)`：遍历所有的键值对

