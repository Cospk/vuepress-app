---
title: 协程调度时机一：系统调用
source_url: 'https://studygolang.com/articles/11863'
category: Go原理教程
---

<pre><code class="language-text"><span></span>void
·exitsyscall(int32 dummy)
{
    void (*fn)(G*);

    // 这个g到底是什么？ 
    g->m->locks++;  // see comment in entersyscall 

    if(runtime·getcallersp(&dummy) > g->syscallsp)
        runtime·throw("exitsyscall: syscall frame is no longer valid");

    g->waitsince = 0;
    // 判断能否快速找到归属 
    if(exitsyscallfast()) {
        g->m->p->syscalltick++;

        // g的状态从syscall变成running，继续欢快地跑着 
        runtime·casgstatus(g, Gsyscall, Grunning);

        g->syscallsp = (uintptr)nil;
        g->m->locks--;
        if(g->preempt) {
            g->stackguard0 = StackPreempt;
        } else {
            g->stackguard0 = g->stack.lo + StackGuard;
        }
        g->throwsplit = 0;
        return;
    }
    g->m->locks--;

    // Call the scheduler. 
    // 如果M回来发现P已经有别人服务了，那只能将自己挂起 
    // 等着服务别人。 
    fn = exitsyscall0;
    runtime·mcall(&fn);
    ......
}

static bool
exitsyscallfast(void)
{
    void (*fn)(void);
    if(runtime·sched.stopwait) {
        g->m->p = nil;
        return false;
    }

    // 如果之前附属的P尚未被其他M,尝试绑定该P 
    if(g->m->p && g->m->p->status == Psyscall && runtime·cas(&g->m->p->status, Psyscall, Prunning)) {
        g->m->mcache = g->m->p->mcache;
        g->m->p->m = g->m;
        return true;
    }

    // Try to get any other idle P. 
    // 否则从空闲P列表中随便捞一个出来 
    g->m->p = nil;

    if(runtime·sched.pidle) {
        fn = exitsyscallfast_pidle;
        runtime·onM(&fn);
        if(g->m->scalararg[0]) {
            g->m->scalararg[0] = 0;
            return true;
        }
    }
    return false;
}
</code></pre>