---
title: 协程栈扩容
source_url: 'https://studygolang.com/articles/11860'
category: Go原理教程
---
```
go func newstack() { // gp是申请堆栈扩容的协程 gp := thisg.m.curg ...... // Allocate a bigger segment and move the stack. oldsize := int(gp.stackAlloc) // 新的栈大小是原来的两倍 newsize := oldsize \* 2 if uintptr(newsize) > maxstacksize { print("runtime: goroutine stack exceeds ", maxstacksize, "-byte limit\\n") throw("stack overflow") } casgstatus(gp, \_Gwaiting, \_Gcopystack) // The concurrent GC will not scan the stack while we are doing the copy since // the gp is in a Gcopystack status. // 执行堆栈扩容并将原有堆栈数据拷贝至新栈 copystack(gp, uintptr(newsize)) if stackDebug >= 1 { print("stack grow done\\n") } casgstatus(gp, \_Gcopystack, \_Grunning) gogo(&gp.sched) } // 申请新的栈空间并将原有栈数据拷贝至这里 func copystack(gp \*g, newsize uintptr) { if gp.syscallsp != 0 { throw("stack growth not allowed in system call") } old := gp.stack if old.lo == 0 { throw("nil stackbase") } // 原有堆栈使用的空间 used := old.hi - gp.sched.sp // allocate new stack // newstkbar是什么？ // 0xfc是什么？ new, newstkbar := stackalloc(uint32(newsize)) if stackPoisonCopy != 0 { fillstack(new, 0xfd) } ...... // adjust pointers in the to-be-copied frames // 这里主要调整g的一些调度相关参数 // 如果它们存储在老的栈上面，需要将它们拷贝到新栈上 var adjinfo adjustinfo adjinfo.old = old adjinfo.delta = new.hi - old.hi gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, adjustframe, noescape(unsafe.Pointer(&adjinfo)), 0) // adjust other miscellaneous things that have pointers into stacks. adjustctxt(gp, &adjinfo) adjustdefers(gp, &adjinfo) adjustpanics(gp, &adjinfo) adjustsudogs(gp, &adjinfo) adjuststkbar(gp, &adjinfo) // copy the stack to the new location // 0xfb又是什么？ if stackPoisonCopy != 0 { fillstack(new, 0xfb) } // 数据拷贝，老的堆栈数据拷贝到新堆栈 memmove(unsafe.Pointer(new.hi-used), unsafe.Pointer(old.hi-used), used) // copy old stack barriers to new stack barrier array newstkbar = newstkbar\[:len(gp.stkbar)\] copy(newstkbar, gp.stkbar) // Swap out old stack for new one // 切换到新堆栈上工作 gp.stack = new gp.stackguard0 = new.lo + \_StackGuard gp.sched.sp = new.hi - used oldsize := gp.stackAlloc gp.stackAlloc = newsize gp.stkbar = newstkbar // 释放老的堆栈 if stackPoisonCopy != 0 { fillstack(old, 0xfc) } stackfree(old, oldsize) } func fillstack(stk stack, b byte) { for p := stk.lo; p < stk.hi; p++ { \*(\*byte)(unsafe.Pointer(p)) = b } } 
```
