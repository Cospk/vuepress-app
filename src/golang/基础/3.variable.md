---
date: 2022-08-13
---
# 变量

变量是用于保存一个值的存储位置，允许其存储的值在运行时动态的变化。每声明一个变量，都会为其分配一块内存以存储对应类型的值，前往[参考手册-变量](https://go.dev/ref/spec#Variables)以查看更多细节。

<br>

## 声明

在go中的类型声明是后置的，变量的声明会用到`var`关键字，格式为`var 变量名 类型名`，变量名的命名规则必须遵守标识符的命名规则。

```go
var intNum int
var str string
var char byte
```

当要声明多个相同类型的变量时，可以只写一次类型

```go
var numA, numB, numC int
```

当要声明多个不同类型的变量时，可以使用`()`进行包裹，可以存在多个`()`。

```go
var (
	name    string
	age     int
	address string
)

var (
	school string
	class int
) 
```

一个变量如果只是声明而不赋值，那么变量存储的值就是对应类型的零值。

<br>

## 赋值

赋值会用到运算符`=`，例如

```go
var name string
name = "jack"
```

也可以声明的时候直接赋值

```go
var name string = "jack"
```

或者这样也可以

```go
var name string
var age int
name, age = "jack", 1
```

第二种方式每次都要指定类型，可以使用官方提供的语法糖：短变量初始化，可以省略掉`var`关键字和后置类型，具体是什么类型交给编译器自行推断。

```go
name := "jack" // 字符串类型的变量。
```

虽然可以不用指定类型，但是在后续赋值时，类型必须保持一致，下面这种代码无法通过编译。

```
a := 1
a = "1"
```

还需要注意的是，短变量初始化不能使用`nil`，因为`nil`不属于任何类型，编译器无法推断其类型。

```go
name := nil // 无法通过编译
```

短变量声明可以批量初始化

```go
name, age := "jack", 1
```

短变量声明方式无法对一个已存在的变量使用，比如

```go
// 错误示例
var a int
a := 1

// 错误示例
a := 1
a := 2
```

但是有一种情况除外，那就是在赋值旧变量的同时声明一个新的变量，比如

```go
a := 1
a, b := 2, 2
```

这种代码是可以通过编译的，变量`a`被重新赋值，而`b`是新声明的。

<br>

在go语言中，有一个规则，那就是所有在函数中的变量都必须要被使用，比如下面的代码只是声明了变量，但没有使用它

```go
func main() {
	a := 1
}
```

那么在编译时就会报错，提示你这个变量声明了但没有使用

```
a declared and not used
```

这个规则仅适用于函数内的变量，对于函数外的包级变量则没有这个限制，下面这个代码就可以通过编译。

```go
var a = 1

func main() {
	
}
```



## 匿名

用下划线可以表示不需要某一个变量

```go
Open(name string) (*File, error)
```

比如`os.Open`函数有两个返回值，我们只想要第一个，不想要第二个，可以按照下面这样写

```go
file, _ := os.Open("readme.txt")
```

未使用的变量是无法通过编译的，当你不需要某一个变量时，就可以使用下划线`_`代替。



## 交换

在Go中，如果想要交换两个变量的值，不需要使用指针，可以使用赋值运算符直接进行交换，语法上看起来非常直观，例子如下

```go
num1, num2 := 25, 36
num1, num2 = num2, num1
```

三个变量也是同样如此

```go
num1, num2, num3 := 25, 36, 49
num1, num2, num3  = num3, num2, num1
```

思考下面这一段代码，这是计算斐波那契数列的一小段代码，三个变量在计算后的值分别是什么

```go
a, b, c := 0, 1, 1
a, b, c = b, c, a+b
```

答案是

```
1 1 1
```

你可能会疑惑为什么不是

```
1 1 2
```

明明a已经被赋予b的值了，为什么a+b的结果还是1？go在进行多个变量赋值运算时，它的顺序是先计算值再赋值，并非从左到右计算。

```go
a, b, c = b, c, a+b
```

你可能会以为它会被展开成下面这段

```go
a = b
b = c
c = a + b
```

但实际上它会将a, b, c三个数的值分别计算好再赋给它们，就等同于下面这段代码

```go
a, b, c = 1, 1, 0+1
```

当涉及到函数调用时，这个效果就更为明显，我们有一个函数`sum`可以计算两个数字的返回值

```go
func sum(a, b int) int {
	return a + b
}
```

通过函数来进行两数相加

```go
a, b, c := 0, 1, 1
a, b, c = b, c, sum(a, b)
```

结果没有变化，在计算`sum`函数返回值时，它的入参依旧是0和1

```
1 1 1
```

所以代码应该这样分开写。

```go
a, b = b, c
c = a + b
```



## 比较

变量之间的比较有一个大前提，那就是它们之间的类型必须相同，go语言中不存在隐式类型转换，像下面这样的代码是无法通过编译的

```go
func main() {
	var a uint64
	var b int64
	fmt.Println(a == b)
}
```

编译器会告诉你两者之间类型并不相同

```
invalid operation: a == b (mismatched types uint64 and int64)
```

所以必须使用强制类型转换

```go
func main() {
	var a uint64
	var b int64
	fmt.Println(int64(a) == b)
}
```

在没有泛型之前，早期go提供的内置`min`，`max`函数只支持浮点数，到了1.21版本，go才终于将这两个内置函数用泛型重写，现在可以使用`min`函数比较最小值

```go
minVal := min(1, 2, -1, 1.2)
```

使用`max`函数比较最大值

```go
maxVal := max(100, 22, -1, 1.12)
```

它们的参数支持所有的可比较类型，go中的可比较类型有

- 布尔
- 数字
- 字符串
- 指针
- 通道 （仅支持判断是否相等）
- 元素是可比较类型的数组（切片不可比较）（仅支持判断是否相等）（仅支持相同长度的数组间的比较，因为数组长度也是类型的一部分，而不同类型不可比较）
- 字段类型都是可比较类型的结构体（仅支持判断是否相等）

除此之外，还可以通过导入标准库`cmp`来判断，不过仅支持有序类型的参数，在go中内置的有序类型只有数字和字符串。

```go
import "cmp"

func main() {
	cmp.Compare(1, 2)
	cmp.Less(1, 2)
}
```



## 代码块

在函数内部，可以通过花括号建立一个代码块，代码块彼此之间的变量作用域是相互独立的。例如下面的代码

```go
func main() {
	a := 1
	
	{
		a := 2
		fmt.Println(a)
	}
	
	{
		a := 3
		fmt.Println(a)
	}
	fmt.Println(a)
}
```

它的输出是

```
2
3
1
```

块与块之间的变量相互独立，不受干扰，无法访问，但是会受到父块中的影响。

```go
func main() {
	a := 1

	{
		a := 2
		fmt.Println(a)
	}

	{
		fmt.Println(a)
	}
	fmt.Println(a)
}
```

它的输出是

```
2
1
1
```





# 常量

常量的值无法在运行时改变，一旦赋值过后就无法修改，其值只能来源于：

- 字面量
- 其他常量标识符
- 常量表达式
- 结果是常量的类型转换
- iota

常量只能是基本数据类型，不能是

- 除基本类型以外的其它类型，如结构体，接口，切片，数组等
- 函数的返回值

常量的值无法被修改，否则无法通过编译



## 初始化

常量的声明需要用到`const`关键字，常量在声明时就必须初始化一个值，并且常量的类型可以省略，例如

```go
const name string = "Jack" // 字面量

const msg = "hello world" // 字面量

const num = 1 // 字面量

const numExpression = (1+2+3) / 2 % 100 + num // 常量表达式
```

如果仅仅只是声明而不指定值，将会无法通过编译

```go
const name string
```

编译器报错

```
missing init expr for name
```

<br>

批量声明常量可以用`()`括起来以提升可读性，可以存在多个`()`达到分组的效果。

```go
const (
   Count = 1
   Name  = "Jack"
)

const (
   Size = 16
   Len  = 25
)
```

在同一个常量分组中，在已经赋值的常量后面的常量可以不用赋值，其值默认就是前一个的值，比如

```go
const (
	A = 1
	B // 1
	C // 1
	D // 1
	E // 1
)
```



## iota

`iota`是一个内置的常量标识符，通常用于表示一个常量声明中的无类型整数序数，一般都是在括号中使用。

```go
const iota = 0 
```

看几个使用案例

```go
const (
   Num = iota // 0
   Num1 // 1
   Num2 // 2
   Num3 // 3
   Num4 // 4
)
```

也可以这么写

```go
const (
   Num = iota*2 // 0
   Num1 // 2
   Num2 // 4
   Num3 // 6
   Num4 // 8
)
```

还可以

```go
const (
   Num = iota << 2*3 + 1 // 1
   Num1 // 13
   Num2 // 25
   Num3 = iota // 3
   Num4 // 4
)
```

通过上面几个例子可以发现，`iota`是递增的，第一个常量使用`iota`值的表达式，根据序号值的变化会自动的赋值给后续的常量，直到用新的`const`重置，这个序号其实就是**代码的相对行号**，是相对于当前分组的起始行号，看下面的例子

```go
const (
	Num  = iota<<2*3 + 1 // 1 第一行
	Num2 = iota<<2*3 + 1 // 13 第二行
	_ // 25 第三行
	Num3 //37 第四行
	Num4 = iota // 4 第五行
	_ // 5 第六行
	Num5 // 6 第七行
)
```

例子中使用了匿名标识符`_`占了一行的位置，可以看到`iota`的值本质上就是`iota`所在行相对于当前`const`分组的第一行的差值。而不同的`const`分组则相互不会影响。

<br>



## 枚举

Go语言没有为枚举单独设计一个数据类型，不像其它语言通常会有一个`enum`来表示。一般在Go中，都是通过自定义类型 + const + iota来实现枚举，下面是一个简单的例子

```go
type Season uint8

const (
	Spring Season = iota
	Summer
	Autumn
	Winter
)
```

这些枚举实际上就是数字，Go也不支持直接将其转换为字符串，但我们可以通过给自定义类型添加方法来返回其字符串表现形式，实现`Stringer`接口即可。

```go
func (s Season) String() string {
	switch s {
	case Spring:
		return "spring"
	case Summer:
		return "summer"
	case Autumn:
		return "autumn"
	case Winter:
		return "winter"
	}
	return ""
}
```

这样一来就是一个简单的枚举实现了。你也可以通过官方工具[Stringer](https://pkg.go.dev/golang.org/x/tools/cmd/stringer)来自动生成枚举。

不过它有以下缺点：

- 类型不安全，因为`Season`是自定义类型，可以通过强制类型转换将其他数字也转换成该类型

  ```go
  Season(6)
  ```

- 繁琐，字符串表现形式需要自己实现

- 表达能力弱，因为`const`仅支持基本数据类型，所以这些枚举值也只能用字符串和数字来进行表示

为什么不在语言层面支持枚举是笔者非常不能理解的一件事，我认为这绝对是利大于弊的。
