const{entries:$}=Object,{fromEntries:st}=Object,nt="ENTRIES",D="KEYS",W="VALUES",_="";class S{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=b(this._path);if(b(s)===_)return{done:!1,value:this.result()};const n=t.get(b(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=b(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>b(t)).filter(t=>t!==_).join("")}value(){return b(this._path).node.get(_)}result(){switch(this._type){case W:return this.value();case D:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const b=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(typeof t!="string")return n;const o=t.length+1,r=o+s,i=new Uint8Array(r*o).fill(s+1);for(let c=0;c<o;++c)i[c]=c;for(let c=1;c<r;++c)i[c*o]=c;return q(e,t,s,n,i,1,o,""),n},q=(e,t,s,n,o,r,i,c)=>{const l=r*i;t:for(const u of e.keys())if(u===_){const h=o[l-1];h<=s&&n.set(c,[e.get(u),h])}else{let h=r;for(let f=0;f<u.length;++f,++h){const m=u[f],g=i*h,y=g-i;let d=o[g];const a=Math.max(0,h-s-1),x=Math.min(i-1,h+s);for(let p=a;p<x;++p){const O=m!==t[p],C=o[y+p]+ +O,k=o[y+p+1]+1,z=o[g+p]+1,v=o[g+p+1]=Math.min(C,k,z);v<d&&(d=v)}if(d>s)continue t}q(e.get(u),t,s,n,o,h,i,c+u)}};class w{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=I(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,r]=L(n);for(const i of o.keys())if(i!==_&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),o.get(i)),new w(c,t)}}return new w(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,rt(this._tree,t)}entries(){return new S(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=F(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){return F(this._tree,t)?.has(_)??!1}keys(){return new S(this,D)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,E(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new S(this,W)}[Symbol.iterator](){return this.entries()}static from(t){const s=new w;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return w.from(Object.entries(t))}}const I=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),I(e.get(n),t.slice(n.length),s);return s.push([e,t]),I(void 0,"",s)},F=(e,t)=>{if(t.length===0||!e)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return F(e.get(s),t.slice(s.length))},E=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const r of e.keys())if(r!==_&&t[n]===r[0]){const i=Math.min(s-n,r.length);let c=1;for(;c<i&&t[n+c]===r[c];)++c;const l=e.get(r);if(c===r.length)e=l;else{const u=new Map;u.set(r.slice(c),l),e.set(t.slice(n,n+c),u),e.delete(r),e=u}n+=c;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},rt=(e,t)=>{const[s,n]=I(e,t);if(s!==void 0){if(s.delete(_),s.size===0)R(n);else if(s.size===1){const[o,r]=s.entries().next().value;A(n,o,r)}}},R=e=>{if(e.length===0)return;const[t,s]=L(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&A(e.slice(0,-1),n,o)}},A=(e,t,s)=>{if(e.length===0)return;const[n,o]=L(e);n.set(o+t,s),n.delete(o)},L=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},ct=/[\n\r\p{Z}\p{P}]+/u,j="or",N="and",ut="and_not",ht=(e,t)=>{e.includes(t)||e.push(t)},B=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,M=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,H={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:r,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),B(n.terms,r)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:r,terms:i,match:c}=t.get(n);B(o.terms,i),s.set(n,{score:o.score+r,terms:o.terms,match:Object.assign(o.match,c)})}return s},[ut]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,r)=>{const{k:i,b:c,d:l}=r;return Math.log(1+(s-t+.5)/(t+.5))*(l+e*(i+1)/(e+i*(1-c+c*n/o)))},at=e=>(t,s,n)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,s,n):1}),J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,lt),r=o.get(t),i=r?.get(s);!r||typeof i>"u"?J(e,s,t,n):i<=1?r.size<=1?o.delete(t):r.delete(s):r.set(s,i-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},Y={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},U=Symbol("*"),xt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,r]of e._documentIds){const i=n.boostDocument?n.boostDocument(r,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Q=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase();if(!(s in H))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(H[s])},T=(e,t,s,n,o,r,i,c,l,u=new Map)=>{if(r==null)return u;for(const h of Object.keys(i)){const f=i[h],m=e._fieldIds[h],g=r.get(m);if(g==null)continue;let y=g.size;const d=e._avgFieldLength[m];for(const a of g.keys()){if(!e._documentIds.has(a)){ft(e,m,a,s),y-=1;continue}const x=c?c(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!x)continue;const p=g.get(a),O=e._fieldLength.get(a)[m],C=dt(p,y,e._documentCount,O,d,l),k=n*o*f*x*C,z=u.get(a);if(z){z.score+=k,ht(z.terms,t);const v=G(z.match,s);v?v.push(h):z.match[s]=[h]}else u.set(a,{score:k,terms:[t],match:{[s]:[h]}})}}return u},zt=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields??e._options.fields).reduce((d,a)=>({...d,[a]:G(n.boost,a)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:l}=n,{fuzzy:u,prefix:h}={...Y.weights,...i},f=e._index.get(t.term),m=T(e,t.term,t.term,1,t.termBoost,f,o,r,l);let g,y;if(t.prefix&&(g=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,a=d<1?Math.min(c,Math.round(t.term.length*d)):d;a&&(y=e._index.fuzzyGet(t.term,a))}if(g)for(const[d,a]of g){const x=d.length-t.term.length;if(!x)continue;y?.delete(d);const p=h*d.length/(d.length+.3*x);T(e,t.term,d,p,t.termBoost,a,o,r,l,m)}if(y)for(const d of y.keys()){const[a,x]=y.get(d);if(!x)continue;const p=u*d.length/(d.length+x);T(e,t.term,d,p,t.termBoost,a,o,r,l,m)}return m},X=(e,t,s={})=>{if(t===U)return xt(e,s);if(typeof t!="string"){const h={...s,...t,queries:void 0},f=t.queries.map(m=>X(e,m,h));return Q(f,h.combineWith)}const{tokenize:n,processTerm:o,searchOptions:r}=e._options,i={tokenize:n,processTerm:o,...r,...s},{tokenize:c,processTerm:l}=i,u=c(t).flatMap(h=>l(h)).filter(h=>!!h).map(at(i)).map(h=>zt(e,h,i));return Q(u,i.combineWith)},Z=(e,t,s={})=>{const{searchOptions:n}=e._options,o={...n,...s},r=X(e,t,s),i=[];for(const[c,{score:l,terms:u,match:h}]of r){const f=u.length||1,m={id:e._documentIds.get(c),score:l*f,terms:Object.keys(h),queryTerms:u,match:h};Object.assign(m,e._storedFields.get(c)),(o.filter==null||o.filter(m))&&i.push(m)}return t===U&&o.boostDocument==null||i.sort(P),i},wt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:r,terms:i}of Z(e,t,s)){const c=i.join(" "),l=n.get(c);l!=null?(l.score+=r,l.count+=1):n.set(c,{score:r,terms:i,count:1})}const o=[];for(const[r,{score:i,terms:c,count:l}]of n)o.push({suggestion:r,terms:c,score:i/l});return o.sort(P),o};class bt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...Y,...t.searchOptions},autoSuggestOptions:{...pt,...t.autoSuggestOptions}},this._index=new w,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[r,i]of n)o[r]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const vt=e=>new bt(e),kt=({documentCount:e,nextId:t,fieldIds:s,averageFieldLength:n,dirtCount:o,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=vt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=s,c._avgFieldLength=n,c._dirtCount=o??0,c._index=new w,c},It=(e,t)=>{const{index:s,documentIds:n,fieldLength:o,storedFields:r}=e,i=kt(e,t);i._documentIds=M(n),i._fieldLength=M(o),i._storedFields=M(r);for(const[c,l]of i._documentIds)i._idToShortId.set(l,c);for(const[c,l]of s){const u=new Map;for(const h of Object.keys(l))u.set(parseInt(h,10),M(l[h]));i._index.set(c,u)}return i},V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let r=0,i=0;const c=(u,h=!1)=>{let f;i===0?f=u.length>20?`… ${u.slice(-20)}`:u:h?f=u.length+i>100?`${u.slice(0,100-i)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&o.push(f),i+=f.length,h||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let l=s.indexOf(n,r);if(l===-1)return null;for(;l>=0;){const u=l+n.length;if(c(e.slice(r,l)),r=u,i>100)break;l=s.indexOf(n,r)}return i<100&&c(e.slice(r),!0),o},Mt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),Ot=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:r,terms:i,score:c}=o,l=r.includes("@"),u=r.includes("#"),[h,f]=r.split(/[#@]/),m=Number(h),g=i.sort((d,a)=>d.length-a.length).filter((d,a)=>i.slice(a+1).every(x=>!x.includes(d))),{contents:y}=n[m]??={title:"",contents:[]};if(l)y.push([{type:"customField",id:m,index:f,display:g.map(d=>o.c.map(a=>V(a,d))).flat().filter(d=>d!==null)},c]);else{const d=g.map(a=>V(o.h,a)).filter(a=>a!==null);if(d.length&&y.push([{type:u?"heading":"title",id:m,...u&&{anchor:f},display:d},c]),"t"in o&&o.t)for(const a of o.t){const x=g.map(p=>V(a,p)).filter(p=>p!==null);x.length&&y.push([{type:"text",id:m,...u&&{anchor:f},display:x},c])}}}),$(n).sort(([,o],[,r])=>"max"==="total"?Mt(o,r):Ot(o,r)).map(([o,{title:r,contents:i}])=>{if(!r){const c=it(t,o);c&&(r=c.h)}return{title:r,contents:i.map(([c])=>c)}})},et=(e,t,s={})=>{const n=wt(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},Ct=st($(JSON.parse("{\"/\":{\"documentCount\":662,\"nextId\":662,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"1#介绍\",\"3\":\"2\",\"4\":\"2#软件\",\"5\":\"2#视频\",\"6\":\"2#音乐\",\"7\":\"2#解压工具\",\"8\":\"2#截图\",\"9\":\"2#开源项目\",\"10\":\"2#nvm-node版本控制\",\"11\":\"2#chsrc-换源工具\",\"12\":\"2#实用网站\",\"13\":\"2@1\",\"14\":\"3\",\"15\":\"3@1\",\"16\":\"4\",\"17\":\"4@1\",\"18\":\"8\",\"19\":\"8@1\",\"20\":\"9\",\"21\":\"9@1\",\"22\":\"10\",\"23\":\"10#protobuf\",\"24\":\"10@1\",\"25\":\"11\",\"26\":\"11@1\",\"27\":\"12\",\"28\":\"12@1\",\"29\":\"13\",\"30\":\"13@1\",\"31\":\"14\",\"32\":\"14@1\",\"33\":\"16\",\"34\":\"16@1\",\"35\":\"19\",\"36\":\"19@1\",\"37\":\"20\",\"38\":\"20@1\",\"39\":\"24\",\"40\":\"24#常用包\",\"41\":\"24#常用第三方包\",\"42\":\"24#必看项目\",\"43\":\"24#完整标准库列表\",\"44\":\"24#其他优秀的开源工具分类\",\"45\":\"24#音频和音乐\",\"46\":\"24#数据结构\",\"47\":\"24#分布式系统\",\"48\":\"24#电子邮件\",\"49\":\"24#嵌入式脚本语言\",\"50\":\"24#错误处理\",\"51\":\"24#文件\",\"52\":\"24#金融\",\"53\":\"24#游戏开发\",\"54\":\"24#地理位置\",\"55\":\"24#编译器\",\"56\":\"24#goroutines\",\"57\":\"24#图形界面\",\"58\":\"24#图片\",\"59\":\"24#物联网\",\"60\":\"24#json格式\",\"61\":\"24#机器学习\",\"62\":\"24#金融-1\",\"63\":\"24#自然语言处理\",\"64\":\"24#网络\",\"65\":\"24#视频库\",\"66\":\"24@1\",\"67\":\"25\",\"68\":\"25#go-的特点\",\"69\":\"25#_1-1-简洁的语法\",\"70\":\"25#_1-2-高效的并发支持\",\"71\":\"25#_1-3-强类型与垃圾回收\",\"72\":\"25#_1-4-跨平台支持\",\"73\":\"25#_1-5-编译速度快\",\"74\":\"25#_1-6-内置工具\",\"75\":\"25#_1-7-单一可执行文件\",\"76\":\"25#go-语言的应用场景\",\"77\":\"25#_2-1-网络服务与-web-开发\",\"78\":\"25#_2-2-微服务架构\",\"79\":\"25#_2-3-云计算与-devops\",\"80\":\"25#_2-4-系统编程\",\"81\":\"25#_2-5-数据库与大数据处理\",\"82\":\"25#go-语言的优点与缺点\",\"83\":\"25#_3-1-优点\",\"84\":\"25#_3-2-缺点\",\"85\":\"25#go-的生态和社区\",\"86\":\"25#go-与其他语言的比较\",\"87\":\"25#_5-1-与-c-c-比较\",\"88\":\"25#_5-2-与-python-比较\",\"89\":\"25#_5-3-与-java-比较\",\"90\":\"25@1\",\"91\":\"26\",\"92\":\"26#包\",\"93\":\"26#可见性\",\"94\":\"26#导入\",\"95\":\"26#内部包\",\"96\":\"26#注释\",\"97\":\"26#标识符\",\"98\":\"26#运算符\",\"99\":\"26#字面量\",\"100\":\"26#整型字面量\",\"101\":\"26#浮点数字面量\",\"102\":\"26#复数字面量\",\"103\":\"26#字符字面量\",\"104\":\"26#转义字符\",\"105\":\"26#字符串字面量\",\"106\":\"26#函数\",\"107\":\"26#风格\",\"108\":\"26#函数花括号换行\",\"109\":\"26#代码缩进\",\"110\":\"26#代码间隔\",\"111\":\"26#花括号省略\",\"112\":\"26#三元表达式\",\"113\":\"26@1\",\"114\":\"27\",\"115\":\"27#布尔类型\",\"116\":\"27#整型\",\"117\":\"27#浮点型\",\"118\":\"27#复数类型\",\"119\":\"27#字符类型\",\"120\":\"27#派生类型\",\"121\":\"27#零值\",\"122\":\"27#nil\",\"123\":\"28\",\"124\":\"28#声明\",\"125\":\"28#赋值\",\"126\":\"28#匿名\",\"127\":\"28#交换\",\"128\":\"28#比较\",\"129\":\"28#代码块\",\"130\":\"28#初始化\",\"131\":\"28#iota\",\"132\":\"28#枚举\",\"133\":\"29\",\"134\":\"29#文件描述符\",\"135\":\"29#输出\",\"136\":\"29#stdout\",\"137\":\"29#print\",\"138\":\"29#fmt\",\"139\":\"29#bufio\",\"140\":\"29#格式化\",\"141\":\"29#输入\",\"142\":\"29#read\",\"143\":\"29#fmt-1\",\"144\":\"29#bufio-1\",\"145\":\"29#scanner\",\"146\":\"30\",\"147\":\"30#if-else\",\"148\":\"30#else-if\",\"149\":\"30#switch\",\"150\":\"30#label\",\"151\":\"30#goto\",\"152\":\"30#for\",\"153\":\"30#for-range\",\"154\":\"30#break\",\"155\":\"30#continue\",\"156\":\"31\",\"157\":\"31#数组\",\"158\":\"31#初始化\",\"159\":\"31#使用\",\"160\":\"31#切割\",\"161\":\"31#切片-1\",\"162\":\"31#初始化-1\",\"163\":\"31#使用-1\",\"164\":\"31#插入元素\",\"165\":\"31#删除元素\",\"166\":\"31#拷贝\",\"167\":\"31#遍历\",\"168\":\"31#多维切片\",\"169\":\"31#拓展表达式\",\"170\":\"31#clear\",\"171\":\"31#字面量\",\"172\":\"31#访问\",\"173\":\"31#转换\",\"174\":\"31#长度\",\"175\":\"31#拷贝-1\",\"176\":\"31#拼接\",\"177\":\"31#遍历-1\",\"178\":\"31#初始化-2\",\"179\":\"31#访问-1\",\"180\":\"31#存值\",\"181\":\"31#删除\",\"182\":\"31#遍历-2\",\"183\":\"31#清空\",\"184\":\"31#set\",\"185\":\"31#注意\",\"186\":\"31#声明\",\"187\":\"31#实例化\",\"188\":\"31#选项模式\",\"189\":\"31#组合\",\"190\":\"31#指针\",\"191\":\"31#标签\",\"192\":\"31#内存对齐\",\"193\":\"31#空结构体\",\"194\":\"31#创建\",\"195\":\"31#禁止指针运算\",\"196\":\"31#new和make\",\"197\":\"31#声明-1\",\"198\":\"31#参数\",\"199\":\"31#返回值\",\"200\":\"31#匿名函数\",\"201\":\"31#闭包\",\"202\":\"31#延迟调用\",\"203\":\"31#循环\",\"204\":\"31#参数预计算\",\"205\":\"31#值接收者\",\"206\":\"31#指针接收者\",\"207\":\"33\",\"208\":\"33#概念\",\"209\":\"33#基本接口\",\"210\":\"33#声明\",\"211\":\"33#初始化\",\"212\":\"33#实现\",\"213\":\"33#空接口\",\"214\":\"33#通用接口\",\"215\":\"34\",\"216\":\"34#代码调用\",\"217\":\"34#go嵌入c代码\",\"218\":\"34#go引入c文件\",\"219\":\"34#c调用go\",\"220\":\"34#类型转换\",\"221\":\"34#char\",\"222\":\"34#字符串\",\"223\":\"34#整数\",\"224\":\"34#浮点数\",\"225\":\"34#切片\",\"226\":\"34#结构体\",\"227\":\"34#联合体\",\"228\":\"34#枚举\",\"229\":\"34#指针\",\"230\":\"34#链接库\",\"231\":\"34#动态链接库\",\"232\":\"34#静态链接库\",\"233\":\"34#最后\",\"234\":\"35\",\"235\":\"35#逃逸分析\",\"236\":\"35#引用局部指针\",\"237\":\"35#闭包引用\",\"238\":\"35#空间不足\",\"239\":\"35#长度未知\",\"240\":\"35#pprof\",\"241\":\"35#采集\",\"242\":\"35#手动\",\"243\":\"35#自动\",\"244\":\"35#分析\",\"245\":\"35#命令行\",\"246\":\"35#网页\",\"247\":\"35#trace\",\"248\":\"36\",\"249\":\"36#web开发\",\"250\":\"36#im通讯\",\"251\":\"36#网络编程\",\"252\":\"36#游戏服务器\",\"253\":\"36#数据库开发\",\"254\":\"36#命令行工具\",\"255\":\"37\",\"256\":\"37#示例\",\"257\":\"37#泛型结构\",\"258\":\"37#泛型结构注意点\",\"259\":\"37#类型集\",\"260\":\"37#类型集注意点\",\"261\":\"37#使用\",\"262\":\"37#队列\",\"263\":\"37#堆\",\"264\":\"37#小结\",\"265\":\"38\",\"266\":\"38#接口\",\"267\":\"38#桥梁\",\"268\":\"38#核心\",\"269\":\"38#类型\",\"270\":\"38#kind\",\"271\":\"38#elem\",\"272\":\"38#size\",\"273\":\"38#comparable\",\"274\":\"38#implements\",\"275\":\"38#convertibleto\",\"276\":\"38#值\",\"277\":\"38#type\",\"278\":\"38#elem-1\",\"279\":\"38#指针\",\"280\":\"38#设置值\",\"281\":\"38#获取值\",\"282\":\"38#函数\",\"283\":\"38#信息\",\"284\":\"38#调用\",\"285\":\"38#结构体\",\"286\":\"38#访问字段\",\"287\":\"38#修改字段\",\"288\":\"38#访问tag\",\"289\":\"38#访问方法\",\"290\":\"38#调用方法\",\"291\":\"38#创建\",\"292\":\"38#基本类型\",\"293\":\"38#结构体-1\",\"294\":\"38#切片\",\"295\":\"38#map\",\"296\":\"38#管道\",\"297\":\"38#函数-1\",\"298\":\"38#完全相等\",\"299\":\"39\",\"300\":\"39#静态强类型\",\"301\":\"39#类型后置\",\"302\":\"39#类型声明\",\"303\":\"39#类型别名\",\"304\":\"39#类型转换\",\"305\":\"39#类型断言\",\"306\":\"39#类型判断\",\"307\":\"40\",\"308\":\"40#error\",\"309\":\"40#创建\",\"310\":\"40#自定义错误\",\"311\":\"40#传递\",\"312\":\"40#处理\",\"313\":\"40#panic\",\"314\":\"40#创建-1\",\"315\":\"40#善后\",\"316\":\"40#恢复\",\"317\":\"40#fatal\",\"318\":\"41\",\"319\":\"41#打开\",\"320\":\"41#读取\",\"321\":\"41#写入\",\"322\":\"41#复制\",\"323\":\"41#重命名\",\"324\":\"41#删除\",\"325\":\"41#刷新\",\"326\":\"41#文件夹\",\"327\":\"41#读取-1\",\"328\":\"41#创建\",\"329\":\"41#复制-1\",\"330\":\"42\",\"331\":\"42#协程\",\"332\":\"42#管道\",\"333\":\"42#创建\",\"334\":\"42#读写\",\"335\":\"42#无缓冲\",\"336\":\"42#有缓冲\",\"337\":\"42#注意点\",\"338\":\"42#单向管道\",\"339\":\"42#for-range\",\"340\":\"42#select\",\"341\":\"42#waitgroup\",\"342\":\"42#context\",\"343\":\"42#context-1\",\"344\":\"42#emptyctx\",\"345\":\"42#valuectx\",\"346\":\"42#cancelctx\",\"347\":\"42#timerctx\",\"348\":\"42#锁\",\"349\":\"42#互斥锁\",\"350\":\"42#读写锁\",\"351\":\"42#条件变量\",\"352\":\"42#sync\",\"353\":\"42#once\",\"354\":\"42#pool\",\"355\":\"42#map\",\"356\":\"42#原子\",\"357\":\"42#类型\",\"358\":\"42#使用\",\"359\":\"42#cas\",\"360\":\"42#value\",\"361\":\"43\",\"362\":\"43#编写模块\",\"363\":\"43#准备\",\"364\":\"43#创建\",\"365\":\"43#编写\",\"366\":\"43#测试\",\"367\":\"43#文档\",\"368\":\"43#上传\",\"369\":\"43#引用\",\"370\":\"43#设置代理\",\"371\":\"43#下载依赖\",\"372\":\"43#代码引用\",\"373\":\"43#安装命令行\",\"374\":\"43#模块管理\",\"375\":\"43#常用命令\",\"376\":\"43#模块存储\",\"377\":\"43#版本选择\",\"378\":\"43#go-mod\",\"379\":\"43#go-sum\",\"380\":\"43#私有模块\",\"381\":\"43#工作区\",\"382\":\"43#示例\",\"383\":\"43#命令\",\"384\":\"43#指令\",\"385\":\"44\",\"386\":\"44#编写规范\",\"387\":\"44#执行测试\",\"388\":\"44#常用参数\",\"389\":\"44#示例测试\",\"390\":\"44#单元测试\",\"391\":\"44#helper\",\"392\":\"44#子测试\",\"393\":\"44#表格风格\",\"394\":\"44#基准测试\",\"395\":\"44#benchstat\",\"396\":\"44#模糊测试\",\"397\":\"44#类型支持\",\"398\":\"46\",\"399\":\"46@1\",\"400\":\"47\",\"401\":\"47@1\",\"402\":\"49\",\"403\":\"49#依赖\",\"404\":\"49#连接\",\"405\":\"49#索引\",\"406\":\"49#创建\",\"407\":\"49#获取\",\"408\":\"49#分析\",\"409\":\"49#删除\",\"410\":\"49#文档\",\"411\":\"49#创建-1\",\"412\":\"49#获取-1\",\"413\":\"49#更新\",\"414\":\"49#删除-1\",\"415\":\"49#搜索\",\"416\":\"49#小结\",\"417\":\"49@1\",\"418\":\"50\",\"419\":\"50#驱动\",\"420\":\"50#安装\",\"421\":\"50#连接\",\"422\":\"50#bson\",\"423\":\"50#查询文档\",\"424\":\"50#查询单个\",\"425\":\"50#查询多个\",\"426\":\"50#创建文档\",\"427\":\"50#更新文档\",\"428\":\"50#删除文档\",\"429\":\"50#聚合\",\"430\":\"50@1\",\"431\":\"51\",\"432\":\"51#依赖\",\"433\":\"51#连接到数据库\",\"434\":\"51#准备数据\",\"435\":\"51#查询\",\"436\":\"51#新增\",\"437\":\"51#更新\",\"438\":\"51#删除\",\"439\":\"51#事务\",\"440\":\"51@1\",\"441\":\"53\",\"442\":\"53#安装\",\"443\":\"53#快速开始\",\"444\":\"53#连接配置\",\"445\":\"53#建立连接\",\"446\":\"53#关闭连接\",\"447\":\"53#基本操作\",\"448\":\"53#删除键\",\"449\":\"53#过期时间\",\"450\":\"53#取消过期时间\",\"451\":\"53#查询过期时间\",\"452\":\"53#重命名\",\"453\":\"53#查询类型\",\"454\":\"53#扫描\",\"455\":\"53#字符串\",\"456\":\"53#简单存取\",\"457\":\"53#批量存取\",\"458\":\"53#数字增减\",\"459\":\"53#哈希表\",\"460\":\"53#读写操作\",\"461\":\"53#删除键-1\",\"462\":\"53#判断键是否存在\",\"463\":\"53#获取所有的键\",\"464\":\"53#获取哈希表键长度\",\"465\":\"53#遍历哈希表的键值对\",\"466\":\"53#列表\",\"467\":\"53#修改元素\",\"468\":\"53#访问长度\",\"469\":\"53#访问元素\",\"470\":\"53#删除元素\",\"471\":\"53#集合\",\"472\":\"53#新增元素\",\"473\":\"53#访问集合元素\",\"474\":\"53#集合操作\",\"475\":\"53#删除元素-1\",\"476\":\"53#移动元素\",\"477\":\"53#删除元素-2\",\"478\":\"53#遍历\",\"479\":\"53#有序集合\",\"480\":\"53#加入元素\",\"481\":\"53#元素排名\",\"482\":\"53#访问元素-1\",\"483\":\"53#修改权值\",\"484\":\"53#删除元素-3\",\"485\":\"53#脚本\",\"486\":\"53#发布订阅\",\"487\":\"53@1\",\"488\":\"54\",\"489\":\"54@1\",\"490\":\"56\",\"491\":\"56@1\",\"492\":\"57\",\"493\":\"57@1\",\"494\":\"58\",\"495\":\"58@1\",\"496\":\"60\",\"497\":\"60@1\",\"498\":\"61\",\"499\":\"61@1\",\"500\":\"63\",\"501\":\"63@1\",\"502\":\"64\",\"503\":\"64@1\",\"504\":\"66\",\"505\":\"66@1\",\"506\":\"67\",\"507\":\"67@1\",\"508\":\"70\",\"509\":\"72\",\"510\":\"72#xml\",\"511\":\"72#序列化\",\"512\":\"72#反序列化\",\"513\":\"72#yml\",\"514\":\"72#序列化-1\",\"515\":\"72#反序列化-1\",\"516\":\"72#json\",\"517\":\"72#序列化-2\",\"518\":\"72#字段重命名\",\"519\":\"72#缩进\",\"520\":\"72#反序列化-2\",\"521\":\"72#protocol-buffers\",\"522\":\"73\",\"523\":\"73#导入\",\"524\":\"73#类型\",\"525\":\"73#定义\",\"526\":\"73#解析\",\"527\":\"73#其他\",\"528\":\"73#示例\",\"529\":\"74\",\"530\":\"74#get示例\",\"531\":\"74#post示例\",\"532\":\"74#客户端\",\"533\":\"74#简单示例\",\"534\":\"74#增加header\",\"535\":\"74#服务端\",\"536\":\"74#自定义\",\"537\":\"74#路由\",\"538\":\"74#反向代理\",\"539\":\"75\",\"540\":\"75#前缀\",\"541\":\"75#flag\",\"542\":\"76\",\"543\":\"76#整数常量\",\"544\":\"76#浮点常量\",\"545\":\"76#数学常量\",\"546\":\"76#最大值\",\"547\":\"76#最小值\",\"548\":\"76#绝对值\",\"549\":\"76#余数\",\"550\":\"76#nan检测\",\"551\":\"76#inf检测\",\"552\":\"76#取整\",\"553\":\"76#向下取整\",\"554\":\"76#向上取整\",\"555\":\"76#四舍五入\",\"556\":\"76#求对数\",\"557\":\"76#e的指数\",\"558\":\"76#幂\",\"559\":\"76#平方根\",\"560\":\"76#立方根\",\"561\":\"76#开n方\",\"562\":\"76#sin\",\"563\":\"76#cos\",\"564\":\"76#tan\",\"565\":\"77\",\"566\":\"77#地址解析\",\"567\":\"77#mac地址\",\"568\":\"77#cidr\",\"569\":\"77#ip地址\",\"570\":\"77#tcp地址\",\"571\":\"77#udp地址\",\"572\":\"77#unix地址\",\"573\":\"77#dns\",\"574\":\"77#网络编程\",\"575\":\"78\",\"576\":\"78#整型排序\",\"577\":\"78#浮点排序\",\"578\":\"78#字符串排序\",\"579\":\"78#逆向排序\",\"580\":\"78#自定义排序\",\"581\":\"78#是否有序\",\"582\":\"79\",\"583\":\"79#导入\",\"584\":\"79#字符串转整型\",\"585\":\"79#整型转字符串\",\"586\":\"79#字符串转布尔值\",\"587\":\"79#布尔值转字符串\",\"588\":\"79#转换成go字符串\",\"589\":\"79#字符串转浮点数\",\"590\":\"79#浮点数转字符串\",\"591\":\"79#字符串转复数\",\"592\":\"79#复数转字符串\",\"593\":\"79#字符串追加数据\",\"594\":\"80\",\"595\":\"80#导入\",\"596\":\"80#复制字符串\",\"597\":\"80#比较字符串\",\"598\":\"80#包含字符串\",\"599\":\"80#子串出现次数\",\"600\":\"80#删除指定子串\",\"601\":\"80#忽略大小写相等\",\"602\":\"80#分割字符串\",\"603\":\"80#寻找前后缀\",\"604\":\"80#子串的位置\",\"605\":\"80#遍历替换字符串\",\"606\":\"80#重复复制字符串\",\"607\":\"80#替换字符串\",\"608\":\"80#分隔字符串\",\"609\":\"80#大小写转换\",\"610\":\"80#修剪字符串\",\"611\":\"80#字符串builder\",\"612\":\"80#字符串replacer\",\"613\":\"80#字符串reader\",\"614\":\"81\",\"615\":\"81#快速开始\",\"616\":\"81#模板语法\",\"617\":\"81#参数\",\"618\":\"81#注释\",\"619\":\"81#变量\",\"620\":\"81#函数\",\"621\":\"81#管道\",\"622\":\"81#with\",\"623\":\"81#条件\",\"624\":\"81#迭代\",\"625\":\"81#嵌套\",\"626\":\"81#关联\",\"627\":\"81#插槽\",\"628\":\"81#模板文件\",\"629\":\"82\",\"630\":\"82#时间单位\",\"631\":\"82#格式化\",\"632\":\"82#解析时间\",\"633\":\"82#timer\",\"634\":\"82#ticker\",\"635\":\"82#sleep\",\"636\":\"83\",\"637\":\"84\",\"638\":\"84#arbitrarytype\",\"639\":\"84#integertype\",\"640\":\"84#sizeof\",\"641\":\"84#offsetof\",\"642\":\"84#alignof\",\"643\":\"84#pointer\",\"644\":\"84#add\",\"645\":\"84#slicedata\",\"646\":\"84#slice\",\"647\":\"84#stringdata\",\"648\":\"84#string\",\"649\":\"85\",\"650\":\"85@1\",\"651\":\"86\",\"652\":\"86@1\",\"653\":\"87\",\"654\":\"87@1\",\"655\":\"88\",\"656\":\"88@1\",\"657\":\"90\",\"658\":\"91\",\"659\":\"92\",\"660\":\"93\",\"661\":\"94\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,12],\"1\":[1],\"2\":[1,12],\"3\":[1],\"4\":[1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1],\"9\":[1],\"10\":[2,10],\"11\":[2,25],\"12\":[1],\"13\":[null,null,1],\"14\":[3],\"15\":[null,null,1],\"16\":[2],\"17\":[null,null,1],\"18\":[1],\"19\":[null,null,1],\"20\":[1],\"21\":[null,null,1],\"22\":[1],\"23\":[1],\"24\":[null,null,1],\"25\":[1],\"26\":[null,null,1],\"27\":[1],\"28\":[null,null,1],\"29\":[1],\"30\":[null,null,1],\"31\":[1],\"32\":[null,null,1],\"33\":[1],\"34\":[null,null,1],\"35\":[1],\"36\":[null,null,1],\"37\":[1],\"38\":[null,null,1],\"39\":[1,42],\"40\":[1,47],\"41\":[1,200],\"42\":[1,20],\"43\":[1,384],\"44\":[1],\"45\":[1,54],\"46\":[1,173],\"47\":[1,120],\"48\":[1,42],\"49\":[1,53],\"50\":[1,34],\"51\":[1,77],\"52\":[1,34],\"53\":[1,64],\"54\":[1,35],\"55\":[1,17],\"56\":[1,87],\"57\":[1,81],\"58\":[1,98],\"59\":[1,35],\"60\":[1,55],\"61\":[1,106],\"62\":[1,34],\"63\":[1,112],\"64\":[1,193],\"65\":[1,38],\"66\":[null,null,1],\"67\":[1,21],\"68\":[2],\"69\":[2,14],\"70\":[3,21],\"71\":[3,12],\"72\":[3,10],\"73\":[3,5],\"74\":[3,13],\"75\":[3,5],\"76\":[2,3],\"77\":[5,22],\"78\":[2,7],\"79\":[4,12],\"80\":[3,8],\"81\":[3,6],\"82\":[2],\"83\":[3,24],\"84\":[3,32],\"85\":[2,25],\"86\":[2],\"87\":[6,15],\"88\":[5,20],\"89\":[5,26],\"90\":[null,null,1],\"91\":[1,24],\"92\":[1,13],\"93\":[1,32],\"94\":[1,48],\"95\":[1,29],\"96\":[1,16],\"97\":[1,41],\"98\":[1,50],\"99\":[1,10],\"100\":[1,19],\"101\":[1,35],\"102\":[1,25],\"103\":[1,14],\"104\":[1,31],\"105\":[1,17],\"106\":[1,21],\"107\":[1,12],\"108\":[1,16],\"109\":[1,3],\"110\":[1,17],\"111\":[1,19],\"112\":[1,8],\"113\":[null,null,1],\"114\":[1,5],\"115\":[1,13],\"116\":[1,29],\"117\":[1,10],\"118\":[1,6],\"119\":[1,15],\"120\":[1,32],\"121\":[1,22],\"122\":[1,12],\"123\":[1,7],\"124\":[1,30],\"125\":[1,57],\"126\":[1,21],\"127\":[1,49],\"128\":[1,62],\"129\":[1,36],\"130\":[1,48],\"131\":[1,49],\"132\":[1,47],\"133\":[1,11],\"134\":[1,22],\"135\":[1,2],\"136\":[1,12],\"137\":[1,13],\"138\":[1,19],\"139\":[1,23],\"140\":[1,158],\"141\":[1,1],\"142\":[1,19],\"143\":[1,49],\"144\":[1,23],\"145\":[1,31],\"146\":[1,8],\"147\":[2,37],\"148\":[2,41],\"149\":[1,49],\"150\":[1,18],\"151\":[1,24],\"152\":[1,77],\"153\":[2,39],\"154\":[1,30],\"155\":[1,32],\"156\":[1,8],\"157\":[1,12],\"158\":[1,46],\"159\":[1,16],\"160\":[1,38],\"161\":[1,4],\"162\":[1,49],\"163\":[1,65],\"164\":[1,29],\"165\":[1,30],\"166\":[1,25],\"167\":[1,28],\"168\":[1,35],\"169\":[1,56],\"170\":[1,27],\"171\":[1,28],\"172\":[1,33],\"173\":[1,52],\"174\":[1,39],\"175\":[1,26],\"176\":[1,27],\"177\":[1,136],\"178\":[1,55],\"179\":[1,37],\"180\":[1,44],\"181\":[1,33],\"182\":[1,34],\"183\":[1,28],\"184\":[1,34],\"185\":[1,56],\"186\":[1,21],\"187\":[1,45],\"188\":[1,72],\"189\":[1,33],\"190\":[1,17],\"191\":[1,35],\"192\":[1,59],\"193\":[1,26],\"194\":[1,46],\"195\":[1,51],\"196\":[1,40],\"197\":[1,50],\"198\":[1,41],\"199\":[1,50],\"200\":[1,53],\"201\":[1,85],\"202\":[1,34],\"203\":[1,34],\"204\":[1,87],\"205\":[1,35],\"206\":[1,129],\"207\":[1,8],\"208\":[1,72],\"209\":[1,3],\"210\":[1,14],\"211\":[1,13],\"212\":[1,120],\"213\":[1,100],\"214\":[1,4],\"215\":[1,35],\"216\":[1,44],\"217\":[1,77],\"218\":[1,47],\"219\":[1,97],\"220\":[1,48],\"221\":[1,46],\"222\":[1,119],\"223\":[1,61],\"224\":[1,29],\"225\":[1,81],\"226\":[1,52],\"227\":[1,39],\"228\":[1,32],\"229\":[1,73],\"230\":[1,8],\"231\":[1,75],\"232\":[1,50],\"233\":[1,84],\"234\":[1,20],\"235\":[1,11],\"236\":[1,75],\"237\":[1,52],\"238\":[1,34],\"239\":[1,77],\"240\":[1,14],\"241\":[1,31],\"242\":[1,73],\"243\":[1,74],\"244\":[1,22],\"245\":[1,152],\"246\":[1,95],\"247\":[1,80],\"248\":[1,11],\"249\":[1,31],\"250\":[1,9],\"251\":[1,8],\"252\":[1,9],\"253\":[1,21],\"254\":[1,34],\"255\":[1,7],\"256\":[1,87],\"257\":[1,66],\"258\":[1,62],\"259\":[1,100],\"260\":[1,70],\"261\":[1,3],\"262\":[1,46],\"263\":[1,97],\"264\":[1,32],\"265\":[1,13],\"266\":[1,67],\"267\":[1,49],\"268\":[1,16],\"269\":[1,18],\"270\":[1,88],\"271\":[1,50],\"272\":[1,25],\"273\":[1,21],\"274\":[1,32],\"275\":[1,32],\"276\":[1,18],\"277\":[1,16],\"278\":[1,19],\"279\":[1,49],\"280\":[1,27],\"281\":[1,22],\"282\":[1,2],\"283\":[1,34],\"284\":[1,24],\"285\":[1,21],\"286\":[1,67],\"287\":[1,52],\"288\":[1,34],\"289\":[1,61],\"290\":[1,36],\"291\":[1,3],\"292\":[1,22],\"293\":[1,37],\"294\":[1,39],\"295\":[1,27],\"296\":[1,22],\"297\":[1,29],\"298\":[1,54],\"299\":[1,8],\"300\":[1,43],\"301\":[1,19],\"302\":[1,40],\"303\":[1,45],\"304\":[1,69],\"305\":[1,28],\"306\":[1,24],\"307\":[1,123],\"308\":[1,20],\"309\":[1,64],\"310\":[1,22],\"311\":[1,46],\"312\":[1,130],\"313\":[1,32],\"314\":[1,29],\"315\":[1,72],\"316\":[1,42],\"317\":[1,26],\"318\":[1,9],\"319\":[1,183],\"320\":[1,90],\"321\":[1,93],\"322\":[1,74],\"323\":[1,24],\"324\":[1,29],\"325\":[1,23],\"326\":[1,1],\"327\":[1,41],\"328\":[1,26],\"329\":[1,63],\"330\":[1,6],\"331\":[1,123],\"332\":[1,30],\"333\":[1,31],\"334\":[1,42],\"335\":[1,30],\"336\":[1,134],\"337\":[1,60],\"338\":[1,77],\"339\":[2,87],\"340\":[1,127],\"341\":[1,102],\"342\":[1,13],\"343\":[1,42],\"344\":[1,48],\"345\":[1,64],\"346\":[1,106],\"347\":[1,80],\"348\":[1,100],\"349\":[1,68],\"350\":[1,99],\"351\":[1,107],\"352\":[1,8],\"353\":[1,100],\"354\":[1,143],\"355\":[1,103],\"356\":[1,26],\"357\":[1,25],\"358\":[1,41],\"359\":[1,81],\"360\":[1,40],\"361\":[1,32],\"362\":[1,31],\"363\":[1,16],\"364\":[1,45],\"365\":[1,64],\"366\":[1,25],\"367\":[1,42],\"368\":[1,105],\"369\":[1,37],\"370\":[1,36],\"371\":[1,6],\"372\":[1,204],\"373\":[1,146],\"374\":[1,33],\"375\":[1,27],\"376\":[1,49],\"377\":[1,26],\"378\":[2,216],\"379\":[2,124],\"380\":[1,23],\"381\":[1,37],\"382\":[1,104],\"383\":[1,19],\"384\":[1,30],\"385\":[1,20],\"386\":[1,35],\"387\":[1,92],\"388\":[1,111],\"389\":[1,133],\"390\":[1,122],\"391\":[1,65],\"392\":[1,92],\"393\":[1,57],\"394\":[1,148],\"395\":[1,317],\"396\":[1,294],\"397\":[1,18],\"398\":[2,1],\"399\":[null,null,1],\"400\":[2],\"401\":[null,null,1],\"402\":[2,23],\"403\":[1,13],\"404\":[1,102],\"405\":[1,23],\"406\":[1,48],\"407\":[1,68],\"408\":[1,69],\"409\":[1,31],\"410\":[1],\"411\":[1,48],\"412\":[1,39],\"413\":[1,52],\"414\":[1,38],\"415\":[1,68],\"416\":[1,11],\"417\":[null,null,1],\"418\":[2,20],\"419\":[1,18],\"420\":[1,8],\"421\":[1,42],\"422\":[1,40],\"423\":[1,30],\"424\":[1,47],\"425\":[1,59],\"426\":[1,56],\"427\":[1,75],\"428\":[1,38],\"429\":[1,51],\"430\":[null,null,1],\"431\":[2,15],\"432\":[1,40],\"433\":[1,33],\"434\":[1,55],\"435\":[1,62],\"436\":[1,24],\"437\":[1,28],\"438\":[1,25],\"439\":[1,32],\"440\":[null,null,1],\"441\":[2,37],\"442\":[1,11],\"443\":[1,49],\"444\":[1,93],\"445\":[1,18],\"446\":[1,12],\"447\":[1],\"448\":[1,10],\"449\":[1,17],\"450\":[1,14],\"451\":[1,7],\"452\":[1,5],\"453\":[1,4],\"454\":[1,7],\"455\":[1],\"456\":[1,10],\"457\":[1,11],\"458\":[1,14],\"459\":[1],\"460\":[1,28],\"461\":[1,6],\"462\":[1,6],\"463\":[1,5],\"464\":[1,5],\"465\":[1,7],\"466\":[1],\"467\":[1,24],\"468\":[1,5],\"469\":[1,13],\"470\":[1,11],\"471\":[1],\"472\":[1,11],\"473\":[1,13],\"474\":[1,19],\"475\":[1,8],\"476\":[1,7],\"477\":[1,7],\"478\":[1,7],\"479\":[1],\"480\":[1,13],\"481\":[1,9],\"482\":[1,21],\"483\":[1,11],\"484\":[1,12],\"485\":[1,19],\"486\":[1,10],\"487\":[null,null,1],\"488\":[2,1],\"489\":[null,null,1],\"490\":[2,1],\"491\":[null,null,1],\"492\":[2,1],\"493\":[null,null,1],\"494\":[2,1],\"495\":[null,null,1],\"496\":[1,1],\"497\":[null,null,1],\"498\":[1,1],\"499\":[null,null,1],\"500\":[1],\"501\":[null,null,1],\"502\":[1],\"503\":[null,null,1],\"504\":[2],\"505\":[null,null,1],\"506\":[2],\"507\":[null,null,1],\"508\":[1,141],\"509\":[1,57],\"510\":[1,43],\"511\":[1,36],\"512\":[1,50],\"513\":[1,55],\"514\":[1,34],\"515\":[1,28],\"516\":[1,28],\"517\":[1,25],\"518\":[1,22],\"519\":[1,42],\"520\":[1,36],\"521\":[2,74],\"522\":[1,3],\"523\":[1,2],\"524\":[1,10],\"525\":[1,28],\"526\":[1,10],\"527\":[1,9],\"528\":[1,40],\"529\":[1,9],\"530\":[1,28],\"531\":[1,36],\"532\":[1,16],\"533\":[1,19],\"534\":[1,25],\"535\":[1,12],\"536\":[1,26],\"537\":[1,44],\"538\":[1,30],\"539\":[1,14],\"540\":[1,17],\"541\":[1,56],\"542\":[1,3],\"543\":[1,41],\"544\":[1,24],\"545\":[1,39],\"546\":[1,16],\"547\":[1,16],\"548\":[1,15],\"549\":[1,18],\"550\":[1,17],\"551\":[1,18],\"552\":[1,18],\"553\":[1,16],\"554\":[1,17],\"555\":[1,17],\"556\":[1,18],\"557\":[1,17],\"558\":[1,18],\"559\":[1,16],\"560\":[1,18],\"561\":[1,21],\"562\":[1,16],\"563\":[1,17],\"564\":[1,23],\"565\":[1,11],\"566\":[1,3],\"567\":[1,27],\"568\":[1,29],\"569\":[1,38],\"570\":[1,30],\"571\":[1,30],\"572\":[1,28],\"573\":[1,22],\"574\":[1,76],\"575\":[1,27],\"576\":[1,16],\"577\":[1,22],\"578\":[1,12],\"579\":[1,26],\"580\":[1,48],\"581\":[1,31],\"582\":[1,7],\"583\":[1,4],\"584\":[1,24],\"585\":[1,21],\"586\":[1,37],\"587\":[1,20],\"588\":[1,22],\"589\":[1,33],\"590\":[1,73],\"591\":[1,30],\"592\":[1,48],\"593\":[1,38],\"594\":[1,13],\"595\":[1,4],\"596\":[1,26],\"597\":[1,28],\"598\":[1,42],\"599\":[1,29],\"600\":[1,34],\"601\":[1,22],\"602\":[1,33],\"603\":[1,31],\"604\":[1,41],\"605\":[1,39],\"606\":[1,27],\"607\":[1,43],\"608\":[1,33],\"609\":[1,56],\"610\":[1,37],\"611\":[1,62],\"612\":[1,29],\"613\":[1,45],\"614\":[1,24],\"615\":[1,62],\"616\":[1],\"617\":[1,121],\"618\":[1,15],\"619\":[1,50],\"620\":[1,107],\"621\":[1,24],\"622\":[1,46],\"623\":[1,28],\"624\":[1,37],\"625\":[1,54],\"626\":[1,62],\"627\":[1,39],\"628\":[1,80],\"629\":[1,55],\"630\":[1,22],\"631\":[1,37],\"632\":[1,30],\"633\":[1,38],\"634\":[1,52],\"635\":[1,35],\"636\":[1],\"637\":[1,18],\"638\":[1,9],\"639\":[1,11],\"640\":[1,41],\"641\":[1,29],\"642\":[1,36],\"643\":[1,130],\"644\":[1,30],\"645\":[1,39],\"646\":[1,29],\"647\":[1,33],\"648\":[1,29],\"649\":[1],\"650\":[null,null,1],\"651\":[1],\"652\":[null,null,1],\"653\":[1],\"654\":[null,null,1],\"655\":[1],\"656\":[null,null,1],\"657\":[1,3],\"658\":[1],\"659\":[1],\"660\":[1],\"661\":[1]},\"averageFieldLength\":[1.1183451061347127,39.69273977047114,0.46650778935578463],\"storedFields\":{\"0\":{\"h\":\"项目主页\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"1\":{\"h\":\"档案主页\"},\"2\":{\"h\":\"介绍\",\"t\":[\"这是一个档案主页的案例。\",\"要使用此布局，你应该在页面 Frontmatter 中设置 home: true 和 portfolio: true。\",\"相关配置文档请见 档案主页。\"]},\"3\":{\"h\":\"好物分享\"},\"4\":{\"h\":\"💻软件\"},\"5\":{\"h\":\"视频\"},\"6\":{\"h\":\"音乐\"},\"7\":{\"h\":\"解压工具\"},\"8\":{\"h\":\"截图\"},\"9\":{\"h\":\"📝开源项目\"},\"10\":{\"h\":\"nvm - node版本控制\",\"t\":[\"node版本管理工具，可做到任意切换想要的版本\",\"使用前还是要卸载node，然后安装nvm，使用nvm命令下载并使用node\",\"原理：将node版本下载到nvm的目录下面，然后使用软连接到指定的目录下面\",\".github地址：nvm\"]},\"11\":{\"h\":\"chsrc - 换源工具\",\"t\":[\"chsrc 不仅是一个命令行工具，同时也是一个换源框架，它甚至使你能够在不了解C语言的情况下编写出新的换源方法(recipe)\",\"# 使用 chsrc <command> [options] [target] [mirror] # 查看可用源 chsrc list # 自动测速，寻找并切换最快的源 (操作系统/编程语言/软件) chsrc set <target>\",\"chsrc ：Change Source everywhere for every software\"]},\"12\":{\"h\":\"🌐实用网站\"},\"13\":{\"c\":[\"share\"]},\"14\":{\"h\":\"-算法-go\"},\"15\":{\"c\":[\"计算机\"]},\"16\":{\"h\":\"-设计模式\"},\"17\":{\"c\":[\"计算机\"]},\"18\":{\"h\":\"Consul\"},\"19\":{\"c\":[\"mq\"]},\"20\":{\"h\":\"Docker\"},\"21\":{\"c\":[\"微服务\"]},\"22\":{\"h\":\"GRPC\"},\"23\":{\"h\":\"Protobuf\"},\"24\":{\"c\":[\"微服务\"]},\"25\":{\"h\":\"Jaeger\"},\"26\":{\"c\":[\"微服务\"]},\"27\":{\"h\":\"Kong\"},\"28\":{\"c\":[\"微服务\"]},\"29\":{\"h\":\"kubernetes\"},\"30\":{\"c\":[\"微服务\"]},\"31\":{\"h\":\"Nacos\"},\"32\":{\"c\":[\"微服务\"]},\"33\":{\"h\":\"Sentinel\"},\"34\":{\"c\":[\"微服务\"]},\"35\":{\"h\":\"gorm使用\"},\"36\":{\"c\":[\"golang\"]},\"37\":{\"h\":\"gorm实现原理\"},\"38\":{\"c\":[\"golang\"]},\"39\":{\"h\":\"常用包和第三方包介绍\",\"t\":[\"包 \",\"常用官方包说明\",\"常用第三方包说明\",\"常用框架\",\"完整标准库列表\",\"优秀的第三方库\",\"音频和音乐\",\"数据结构:Go中的通用数据结构和算法\",\"分布式系统:Go中的通用数据结构和算法\",\"电子邮件:实现电子邮件创建和发送的库和工具\",\"嵌入式脚本语言:在go代码中嵌入其他语言\",\"错误处理\",\"处理文件和文件系统的库\",\"金融:会计和财务软件包\",\"游戏开发:游戏开发相关库\",\"地理位置:地理相关的位置信息和工具库\",\"编译器相关:转到其他语言\",\"Goroutines:用于管理和使用Goroutines的工具\",\"图形界面:用于构建GUI应用程序的库\",\"图片:用于处理图像的库\",\"物联网:物联网设备编程库\",\"JSON格式:用于处理JSON的库\",\"机器学习:常用机器学习库\",\"微软办公软件\",\"自然语言处理\",\"网络:与网络各层配合使用的库\",\"视频:用于处理视频的库\"]},\"40\":{\"h\":\"常用包\",\"t\":[\"常用包\",\"说明\",\"fmt\",\"实现格式化的输入输出操作，其中的fmt.Printf()和fmt.Println()是开发者使用最为频繁的函数。\",\"io\",\"实现了一系列非平台相关的IO相关接口和实现，比如提供了对os中系统相关的IO功能的封装。我们在进行流式读写（比如读写文件）时，通常会用到该包。\",\"bufio\",\"它在io的基础上提供了缓存功能。在具备了缓存功能后， bufio可以比较方便地提供ReadLine之类的操作。\",\"strconv\",\"提供字符串与基本数据类型互转的能力。\",\"os\",\"本包提供了对操作系统功能的非平台相关访问接口。接口为Unix风格。提供的功能包括文件操作、进程管理、信号和用户账号等。\",\"sync\",\"它提供了基本的同步原语。在多个goroutine访问共享资源的时候，需要使用sync中提供的锁机制。\",\"flag\",\"它提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。\",\"encoding/json\",\"JSON目前广泛用做网络程序中的通信格式。本包提供了对JSON的基本支持，比如从一个对象序列化为JSON字符串，或者从JSON字符串反序列化出一个具体的对象等。\",\"http\",\"通过http包，只需要数行代码，即可实现一个爬虫或者一个Web服务器，这在传统语言中是无法想象的。\"]},\"41\":{\"h\":\"常用第三方包\",\"t\":[\"包\",\"地址\",\"数据库操作\",\"github.com/jinzhu/gormgithub.com/go-xorm/xorm\",\"搜索es\",\"github.com/olivere/elastic\",\"rocketmq操作\",\"github.com/apache/rocketmq-client-go/v2\",\"rabbitmq 操作\",\"github.com/streadway/amqp\",\"redis 操作\",\"github.com/go-redis/redis\",\"etcd 操作\",\"github.com/coreos/etcd/clientv3\",\"kafka\",\"https://github.com/Shopify/saramahttps://github.com/bsm/sarama-cluster\",\"excel 操作\",\"github.com/360EntSecGroup-Skylar/excelize\",\"ppt 操作\",\"golang.org/x/tools/cmd/present\",\"go-svg 操作\",\"https://github.com/ajstarks/svgo\",\"go 布隆过滤器实现\",\"https://github.com/AndreasBriese/bbloom\",\"json相关\",\"https://github.com/bitly/go-simplejson\",\"LRU Cache实现\",\"https://github.com/bluele/gcache https://github.com/hashicorp/golang-lru \",\"go运行时函数替换\",\"https://github.com/bouk/monkey \",\"toml\",\"https://github.com/toml-lang/toml https://github.com/naoina/toml \",\"yaml\",\"https://github.com/go-yaml/yaml \",\"viper\",\"https://github.com/spf13/viper \",\"go key/value存储\",\"https://github.com/etcd-io/bbolt \",\"基于ringbuffer的无锁golang workpool\",\"https://github.com/Dai0522/workpool \",\"轻量级的协程池\",\"https://github.com/ivpusic/grpool \",\"打印go的详细数据结构\",\"https://github.com/davecgh/go-spew \",\"基于ringbuffer实现的队列\",\"https://github.com/eapache/queue \",\"拼音\",\"https://github.com/go-ego/gpy \",\"分词\",\"https://github.com/go-ego/gse \",\"搜索\",\"https://github.com/go-ego/riot \",\"windows COM\",\"https://github.com/go-ego/cedar \",\"session\",\"https://github.com/gorilla/sessions \",\"路由\",\"https://github.com/gorilla/mux \",\"websocket\",\"https://github.com/gorilla/websocket \",\"Action handler\",\"https://github.com/gorilla/handlers \",\"csrf\",\"https://github.com/gorilla/csrf \",\"context\",\"https://github.com/gorilla/context \",\"过滤html标签\",\"https://github.com/grokify/html-strip-tags-go \",\"可配置的HTML标签过滤\",\"https://github.com/microcosm-cc/bluemonday \",\"根据IP获取地理位置信息\",\"https://github.com/ipipdotnet/ipdb-go \",\"html转markdown\",\"https://github.com/jaytaylor/html2text \",\"goroutine 本地存储\",\"https://github.com/jtolds/gls \",\"彩色输出\",\"https://github.com/mgutz/ansi\",\"表格打印\",\"https://github.com/olekukonko/tablewriter\",\"reflect 更高效的反射API\",\"https://github.com/modern-go/reflect2\",\"msgfmt (格式化字符串，将%更换为变量名)\",\"https://github.com/modern-go/msgfmt\",\"可取消的goroutine\",\"https://github.com/modern-go/concurrent\",\"深度拷贝\",\"https://github.com/mohae/deepcopy\",\"安全的类型转换包\",\"https://github.com/spf13/cast\",\"从文本中提取链接\",\"https://github.com/mvdan/xurls\",\"字符串格式处理（驼峰转换）\",\"https://godoc.org/github.com/naoina/go-stringutil\",\"文本diff实现\",\"https://github.com/pmezard/go-difflib\",\"uuid相关\",\"https://github.com/satori/go.uuidhttps://github.com/snluu/uuid\",\"去除UTF编码中的BOM\",\"https://github.com/ssor/bom\",\"图片缩放\",\"https://github.com/nfnt/resize\",\"生成 mock server\",\"https://github.com/otokaze/mock\",\"go 性能上报到influxdb\",\"https://github.com/rcrowley/go-metrics\",\"go zookeeper客户端\",\"https://github.com/samuel/go-zookeeper\",\"go thrift\",\"https://github.com/samuel/go-thrift\",\"MQTT 客户端\",\"https://github.com/shirou/mqttcli\",\"hbase\",\"https://github.com/tsuna/gohbase\",\"go 性能上报到influxdb\",\"https://github.com/rcrowley/go-metrics\",\"go 性能上报到prometheus\",\"https://github.com/deathowl/go-metrics-prometheus\",\"ps utils\",\"https://github.com/shirou/gopsutil\",\"小数处理\",\"https://github.com/shopspring/decimal\",\"结构化日志处理(json)\",\"https://github.com/sirupsen/logrus\",\"命令行程序框架 cli\",\"https://github.com/urfave/cli\",\"命令行程序框架 cobra\",\"https://github.com/spf13/cobra\"]},\"42\":{\"h\":\"必看项目\",\"t\":[\"项目\",\"地址\",\"说明\",\"gin\",\"github.com/gin-gonic/gin\",\"轻量级web框架，很多公司都是基于它进行魔改\",\"beego\",\"github.com/beego/beego\",\"也是web框架，比较全能\",\"kratos\",\"github.com/go-kratos/kratos\",\"bilibili开源的微服务框架，b站出品必属于精品\",\"TiDB\",\"github.com/pingcap/tidb\",\"见识过mysql性能瓶颈之后你会想要选择的一款数据库\"]},\"43\":{\"h\":\"完整标准库列表\",\"t\":[\"包\",\"子包\",\"说明\",\"bufio\",\"bytes\",\"提供了对字节切片操作的函数\",\"crypto\",\"收集了常见的加密常数\",\"errors\",\"实现了操作错误的函数\",\"Expvar\",\"为公共变量提供了一个标准的接口，如服务器中的运算计数器\",\"flag\",\"实现了命令行标记解析\",\"fmt\",\"实现了格式化输入输出\",\"hash\",\"提供了哈希函数接口\",\"html\",\"实现了一个HTML5兼容的分词器和解析器\",\"image\",\"实现了一个基本的二维图像库\",\"io\",\"提供了对I/O原语的基本接口\",\"log\",\"它是一个简单的记录包，提供最基本的日志功能\",\"math\",\"提供了一些基本的常量和数学函数\",\"mine\",\"实现了部分的MIME规范\",\"net\",\"提供了一个对UNIX网络套接字的可移植接口，包括TCP/IP、 UDP域名解析和UNIX域套接字\",\"os\",\"为操作系统功能实现了一个平台无关的接口\",\"path\",\"实现了对斜线分割的文件名路径的操作\",\"reflect\",\"实现了运行时反射，允许一个程序以任意类型操作对象\",\"regexp\",\"实现了一个简单的正则表达式库\",\"runtime\",\"包含与Go运行时系统交互的操作，如控制goroutine的函数\",\"sort\",\"提供对集合排序的基础函数集\",\"strconv\",\"实现了在基本数据类型和字符串之间的转换\",\"strings\",\"实现了操作字符串的简单函数\",\"sync\",\"提供了基本的同步机制，如互斥锁\",\"syscall\",\"包含一个低级的操作系统原语的接口\",\"testing\",\"提供对自动测试Go包的支持\",\"time\",\"提供测量和显示时间的功能\",\"unicode\",\"Unicode编码相关的基础函数\",\"archive\",\"tar\",\"实现对tar压缩文档的访问\",\"zip\",\"提供对ZIP压缩文档的读和写支持\",\"compress\",\"bzip2\",\"实现了bzip2解压缩\",\"flate\",\"实现了RFC 1951中所定义的DEFLATE压缩数据格式\",\"gzip\",\"实现了RFC 1951中所定义的gzip格式压缩文件的读和写\",\"lzw\",\"实现了 Lempel-Ziv-Welch编码格式的压缩的数据格式\",\"zlib\",\"实现了RFC 1950中所定义的zlib格式压缩数据的读和写\",\"container\",\"heap\",\"提供了实现heap.Interface接口的任何类型的堆操作\",\"lsit\",\"实现了一个双链表\",\"ring\",\"实现了对循环链表的操作\",\"crypto\",\"aes\",\"实现了AES加密（以前的Rijndael）\",\"cipher\",\"实现了标准的密码块模式，该模式可包装进低级的块加密实现中\",\"des\",\"实现了数据加密标准（ Data Encryption Standard，DES）和三重数据加密算法（ TripleData Encryption Algorithm， TDEA）\",\"dsa\",\"实现了FIPS 186-3所定义的数据签名算法（ Digital Signature Algorithm）\",\"ecdsa\",\"实现了FIPS 186-3所定义的椭圆曲线数据签名算法（ Elliptic Curve Digital SignatureAlgorithm）\",\"elliptic\",\"实现了素数域上几个标准的椭圆曲线\",\"hmac\",\"实现了键控哈希消息身份验证码（ Keyed-Hash Message Authentication Code，HMAC）\",\"md5\",\"实现了RFC 1321中所定义的MD5哈希算法\",\"rand\",\"实现了一个加密安全的伪随机数生成器\",\"rc4\",\"实现了RC4加密，其定义见Bruce Schneier的应用密码学（ Applied Cryptography）\",\"rsa\",\"实现了PKCS#1中所定义的RSA加密\",\"sha1\",\"实现了RFC 3174中所定义的SHA1哈希算法\",\"sha256\",\"实现了FIPS 180-2中所定义的SHA224和SHA256哈希算法\",\"sha512\",\"实现了FIPS 180-2中所定义的SHA384和SHA512哈希算法\",\"subtle\",\"实现了一些有用的加密函数，但需要仔细考虑以便正确应用它们\",\"tls\",\"部分实现了RFC 4346所定义的TLS 1.1协议\",\"x509\",\"可解析X.509编码的键值和证书\",\"x509/pkix\",\"包含用于对X.509证书、 CRL和OCSP的ASN.1解析和序列化的共享的、低级的结构\",\"database\",\"sql\",\"围绕SQL提供了一个通用的接口\",\"sql/driver\",\"定义了数据库驱动所需实现的接口，同sql包的使用方式\",\"debug\",\"dwarf\",\"提供了对从可执行文件加载的DWARF调试信息的访问，这个包对于实现Go语言的调试器非常有价值\",\"elf\",\"实现了对ELF对象文件的访问。 ELF是一种常见的二进制可执行文件和共享库的文件格式。 Linux采用了ELF格式\",\"gosym\",\"访问Go语言二进制程序中的调试信息。对于可视化调试很有价值\",\"macho\",\"实现了对Mach-O对象文件的访问\",\"pe\",\"实现了对PE（ Microsoft Windows Portable Executable）文件的访问\",\"encoding\",\"ascii85\",\"实现了ascii85数据编码，用于btoa工具和Adobe’s PostScript以及PDF文档格式\",\"asn1\",\"实现了解析DER编码的ASN.1数据结构，其定义见ITU-T Rec X.690\",\"base32\",\"实现了RFC 4648中所定义的base32编码\",\"base64\",\"实现了RFC 4648中所定义的base64编码\",\"binary\",\"实现了在无符号整数值和字节串之间的转化，以及对固定尺寸值的读和写\",\"csv\",\"可读和写由逗号分割的数值（ csv）文件\",\"gob\",\"管理gob流——在编码器（发送者）和解码器（接收者）之间进行二进制值交换\",\"hex\",\"实现了十六进制的编码和解码\",\"json\",\"实现了定义于RFC 4627中的JSON对象的编码和解码\",\"pem\",\"实现了PEM（ Privacy Enhanced Mail）数据编码\",\"xml\",\"实现了一个简单的可理解XML名字空间的XML 1.0解析器\",\"go\",\"ast\",\"声明了用于展示Go包中的语法树类型\",\"build\",\"提供了构建Go包的工具\",\"doc\",\"从一个Go AST（抽象语法树）中提取源代码文档\",\"parser\",\"实现了一个Go源文件解析器\",\"printer\",\"实现了对AST（抽象语法树）的打印\",\"scanner\",\"实现了一个Go源代码文本的扫描器\",\"token\",\"定义了代表Go编程语言中词法标记以及基本操作标记（ printing、 predicates）的常量\",\"hash\",\"adler32\",\"实现了Adler-32校验和\",\"crc32\",\"实现了32位的循环冗余校验或CRC-32校验和\",\"crc64\",\"实现了64位的循环冗余校验或CRC-64校验和\",\"fnv\",\"实现了Glenn Fowler、 Landon Curt Noll和Phong Vo所创建的FNV-1和FNV-1a未加密哈希函数\",\"html\",\"template\",\"它自动构建HTML输出，并可防止代码注入\",\"image\",\"color\",\"实现了一个基本的颜色库\",\"draw\",\"提供一些做图函数\",\"gif\",\"实现了一个GIF图像解码器\",\"jpeg\",\"实现了一个JPEG图像解码器和编码器\",\"png\",\"实现了一个PNG图像解码器和编码器\",\"index\",\"suffixarray\",\"通过构建内存索引实现的高速字符串匹配查找算法\",\"io\",\"ioutil\",\"实现了一些实用的I/O函数\",\"log\",\"syslog\",\"提供了对系统日志服务的简单接口\",\"math\",\"big\",\"实现了多精度的算术运算（大数）\",\"cmplx\",\"为复数提供了基本的常量和数学函数\",\"rand\",\"实现了伪随机数生成器\",\"mime\",\"multipart\",\"实现了在RFC 2046中定义的MIME多个部分的解析\",\"net\",\"http\",\"提供了HTTP客户端和服务器的实现\",\"mail\",\"实现了对邮件消息的解析\",\"rpc\",\"提供了对一个来自网络或其他I/O连接的对象可导出的方法的访问\",\"smtp\",\"实现了定义于RFC 5321中的简单邮件传输协议（ Simple Mail Transfer Protocol)\",\"textproto\",\"实现了在HTTP、 NNTP和SMTP中基于文本的通用的请求/响应协议\",\"url\",\"解析URL并实现查询转义\",\"http/cgi\",\"实现了定义于RFC 3875中的CGI（通用网关接口）\",\"http/fcgi\",\"实现了FastCGI协议\",\"http/httptest\",\"提供了一些HTTP测试应用\",\"http/httputil\",\"提供了一些HTTP应用函数，这些是对net/http包中的东西的补充，只不过相对不太常用\",\"http/pprof\",\"通过其HTTP服务器运行时提供性能测试数据，该数据的格式正是pprof可视化工具需要的\",\"rpc/jsonrpc\",\"为rpc包实现了一个JSON-RPC ClientCodec和ServerCodec\",\"os\",\"exec\",\"可运行外部命令\",\"user\",\"通过名称和id进行用户账户检查\",\"path\",\"filepath\",\"实现了以与目标操作系统定义文件路径相兼容的方式处理文件名路径\",\"regexp\",\"syntax\",\"将正则表达式解析为语法树\",\"runtime\",\"debug\",\"包含当程序在运行时调试其自身的功能\",\"pprof\",\"以pprof可视化工具需要的格式写运行时性能测试数据\",\"sync\",\"atomic\",\"提供了低级的用于实现同步算法的原子级的内存机制\",\"testing\",\"iotest\",\"提供一系列测试目的的类型，实现了Reader和Writer标准接口\",\"quick\",\"实现了用于黑箱测试的实用函数\",\"script\",\"帮助测试使用通道的代码\",\"text\",\"scanner\",\"为UTF-8文本提供了一个扫描器和分词器\",\"tabwriter\",\"实现了一个写筛选器（ tabwriter.Writer），它可将一个输入的tab分割的列翻译为适当对齐的文本\",\"template\",\"数据驱动的模板引擎，用于生成类似HTML的文本输出格式\",\"template/parse\",\"为template构建解析树\",\"unicode/utf16\",\"实现了UTF-16序列的的编码和解码\",\"unicode/utf8\",\"实现了支持以UTF-8编码的文本的函数和常数\"]},\"44\":{\"h\":\"其他优秀的开源工具分类\"},\"45\":{\"h\":\"音频和音乐\",\"t\":[\"包\",\"说明\",\"EasyMIDI\",\"EasyMidi是一个简单可靠的库，用于处理标准Midi文件（SMF）。\",\"flac\",\"支持FLAC流的Native Go FLAC编码器/解码器。\",\"gaad\",\"本机Go AAC比特流解析器。\",\"go-sox\",\"用于go的libsox绑定。\",\"go_mediainfo\",\"用于go的libmediainfo绑定。\",\"gosamplerate\",\"用于go的libsamplerate绑定。\",\"id3v2\",\"用于Go的快速，稳定的ID3解析和编写库。\",\"malgo\",\"迷你音频库。\",\"minimp3\",\"轻量级MP3解码器库。\",\"mix\",\"为音乐应用程序基于序列转到本地音频混合器。\",\"mp3\",\"Native Go MP3解码器。\",\"music-theory\",\"Go中的音乐理论模型。\",\"Oto\",\"在多个平台上播放声音的低级库。\",\"PortAudio\",\"用于PortAudio音频I / O库的绑定。\",\"portmidi\",\"绑定PortMidi。\",\"taglib\",\"为taglib绑定。\",\"vorbis\",\"“本机” Go Vorbis解码器（使用CGO，但没有依赖项）。\",\"waveform\",\"Go程序包，能够从音频流生成波形图像。\"]},\"46\":{\"h\":\"数据结构\",\"t\":[\"包\",\"说明\",\"algorithms\",\"算法和数据结构。CLRS研究。\",\"binpacker\",\"二进制打包程序和解包程序可帮助用户构建自定义二进制流。\",\"bit\",\"具有额外的位旋转功能的Golang设置数据结构。\",\"bitset\",\"实现位集的Go包。\",\"bloom\",\"在Go中实现的Bloom过滤器。\",\"bloom\",\"Golang Bloom过滤器实现。\",\"boomfilters\",\"用于处理连续无界流的概率数据结构。\",\"concurrent-writer\",\"高并发直接替换bufio.Writer。\",\"conjungo\",\"一个小型，强大而灵活的合并库。\",\"count-min-log\",\"执行Count-Min-Log草图：使用近似计数器进行近似计数（类似于Count-Min草图，但使用较少的内存）。\",\"crunch\",\"Go包实现了用于轻松处理各种数据类型的缓冲区。\",\"cuckoofilter\",\"Cuckoo过滤器：是Go中实现的计数布隆过滤器的很好替代。\",\"deque\",\"高度优化的双端队列。\",\"deque\",\"快速的环形缓冲区双端队列（双端队列）。\",\"dict\",\"Go的类似Python的字典（dict）。\",\"encoding\",\"Go的整数压缩库。\",\"go-adaptive-radix-tree\",\"自适应基数树的 Go实现。\",\"go-datastructures\",\"有用，高性能和线程安全的数据结构的集合。\",\"go-ef\",\"Elias-Fano编码的Go实现。\",\"go-geoindex\",\"内存中的地理索引。\",\"go-mcache\",\"快速内存键：值存储/缓存库。指针缓存。\",\"go-rquad\",\"具有有效点定位和邻居发现功能的区域四叉树。\",\"gocache\",\"具有多个存储（内存，memcache，redis等），可链接，可加载，指标缓存等的完整Go缓存库。\",\"goconcurrentqueue\",\"并发FIFO队列。\",\"gods\",\"数据结构。容器，集合，列表，堆栈，地图，BidiMap，树，HashSet等。\",\"gofal\",\"Go的小数api。\",\"golang-set\",\"Go的线程安全和非线程安全高性能集。\",\"goset\",\"Go的有用的Set集合实现。\",\"goskiplist\",\"Go中的跳过列表实现。\",\"gota\",\"Go的数据框，序列和数据整理方法的实现。\",\"hide\",\"ID类型，将其编组进/出哈希以防止将ID发送给客户端。\",\"hilbert\",\"Go程序包，用于在空间填充曲线（例如Hilbert和Peano曲线）之间映射值。\",\"hyperloglog\",\"HyperLogLog实施，具有稀疏，LogLog-Beta偏差校正和TailCut空间减少功能。\",\"iter\",\"C ++ STL迭代器和算法的实现。\",\"levenshtein\",\"Levenshtein距离和相似性度量标准，具有可自定义的编辑费用和通用前缀的类似于Winkler的奖金。\",\"levenshtein\",\"在Go中计算levenshtein距离的实现。\",\"mafsa\",\"具有最小完美散列的MA-FSA实现。\",\"merkletree\",\"merkle树的实现，可对数据结构的内容进行有效且安全的验证。\",\"mspm\",\"用于信息检索的多字符串模式匹配算法。\",\"null\",\"可空转到类型，可以被编组/解组到/从JSON。\",\"parsefields\",\"用于解析类似JSON的日志的工具，以收集唯一的字段和事件。\",\"pipeline\",\"具有扇入和扇出的管线的实现。\",\"ptrie\",\"前缀树的实现。\",\"remember-go\",\"缓存慢速数据库查询的通用接口（由redis，memcached，ristretto或内存支持）。\",\"ring\",\"围棋实现了高性能，线程安全的布隆过滤器。\",\"roaring\",\"实施压缩位集的软件包。\",\"set\",\"使用LinkedHashMap的围棋设置简单的数据结构实现。\",\"skiplist\",\"非常快的Go Skiplist实施。\",\"skiplist\",\"Go中的跳过列表实现。\",\"timedmap\",\"具有过期的键/值对的地图。\",\"treap\",\"使用树堆的持久快速排序的地图。\",\"trie\",\"Go中的Trie实现。\",\"ttlcache\",\"内存中的LRU字符串接口{}映射，其中包含golang的到期时间。\",\"typ\",\"空类型，安全的原始类型转换和从复杂结构中获取值。\",\"willf/bloom\",\"Go包实现Bloom过滤器。\"]},\"47\":{\"h\":\"分布式系统\",\"t\":[\"包\",\"说明\",\"celeriac\",\"用于在Go中添加支持以交互和监视Celery工作者，任务和事件的库。\",\"consistent\",\"具有受限负载的一致哈希\",\"dht\",\"BitTorrent Kademlia DHT实施。\",\"digota\",\"grpc电子商务微服务。\",\"dot\",\"使用操作转换/ OT进行分布式同步。\",\"doublejump\",\"改进后的Google的跳转一致性哈希。\",\"dragonboat\",\"Go中功能齐全的高性能多组Raft库。\",\"drmaa\",\"基于DRMAA标准的集群调度程序的作业提交库。\",\"dynamolock\",\"DynamoDB支持的分布式锁定实现。\",\"dynatomic\",\"将DynamoDB用作原子计数器的库。\",\"emitter-io\",\"使用MQTT，Websockets和love构建的高性能，分布式，安全和低延迟的发布-订阅平台。\",\"flowgraph\",\"基于流的编程包。\",\"gleam\",\"用纯围棋和Luajit快速和可扩展的分布式的map / reduce系统，具有Luajit的高性能结合Go的高并发，单独运行或分发。\",\"glow\",\"易于使用的可扩展的分布式大数据处理，Map-Reduce，DAG执行，全部在纯Go中进行。\",\"go-health\",\"health-用于在服务中启用异步依赖项运行状况检查的库。\",\"go-jump\",\"Google的“ Jump”一致性哈希函数的端口。\",\"go-kit\",\"支持服务发现，负载平衡，可插拔传输，请求跟踪等的微服务工具包\",\"go-sundheit\",\"建立用于支持为golang服务定义异步服务运行状况检查的库。\",\"gorpc\",\"简单，快速和可扩展的RPC库，可实现高负载。\",\"grpc-go\",\"gRPC的Go语言实现。基于HTTP / 2的RPC。\",\"hprose\",\"十分新颖的RPC库，现在支持25种以上的语言。\",\"jsonrpc\",\"jsonrpc软件包可帮助实现JSON-RPC 2.0。\",\"jsonrpc\",\"JSON-RPC 2.0 HTTP客户端实现。\",\"KrakenD\",\"具有中间件的超高性能API网关框架。\",\"liftbridge\",\"NATS的轻量级，容错消息流。\",\"micro\",\"可插拔的microService工具箱和分布式系统平台。\",\"NATS\",\"用于微服务，IoT和云本机系统的轻量级高性能消息传递系统。\",\"outboxer\",\"Outboxer是一个实现库模式的go库。\",\"pglock\",\"PostgreSQL支持的分布式锁定实现。\",\"raft\",\"HashiCorp的Raft共识协议的Golang实现。\",\"raft\",\"ETCD中实现的Raft协议。\",\"rain\",\"BitTorrent客户端和库。\",\"redis-lock\",\"使用Redis的简化分布式锁定实现。\",\"resgate\",\"用于构建REST，实时和RPC API的实时API网关，其中所有客户端都可以无缝同步。\",\"ringpop-go\",\"Go应用程序的可扩展，容错应用程序层分片。\",\"rpcx\",\"分布式可插拔RPC服务框架，例如阿里巴巴Dubbo。\",\"sleuth\",\"用于在HTTP服务之间进行无主p2p自动发现和RPC的库（ZeroMQ）。\",\"tendermint\",\"高性能中间件，用于使用Tendermint共识和区块链协议将以任何编程语言编写的状态机转换为拜占庭容错复制状态机。\",\"torrent\",\"BitTorrent客户端软件包。\"]},\"48\":{\"h\":\"电子邮件\",\"t\":[\"包\",\"说明\",\"chasquid\",\"用Go编写的SMTP服务器。\",\"douceur\",\"CSS内衬为您的HTML电子邮件。\",\"email\",\"用于Go的强大而灵活的电子邮件库。\",\"go-dkim\",\"DKIM库，用于签名和验证电子邮件。\",\"go-imap\",\"用于客户端和服务器的IMAP库。\",\"go-message\",\"Internet消息格式和邮件消息的流库。\",\"go-premailer\",\"Go中HTML邮件的内联样式。\",\"go-simple-mail\",\"使用SMTP保持活动状态和两个超时发送电子邮件的非常简单的程序包：连接和发送。\",\"Hectane\",\"提供HTTP API的轻型SMTP客户端。\",\"hermes\",\"Golang软件包，可生成干净的响应式HTML电子邮件。\",\"mailchain\",\"将加密的电子邮件发送到用Go编写的区块链地址。\",\"mailgun-go\",\"Go库，用于使用Mailgun API发送邮件。\",\"MailHog\",\"通过Web和API界面进行电子邮件和SMTP测试。\",\"SendGrid\",\"SendGrid的Go库，用于发送电子邮件。\",\"smtp\",\"SMTP服务器协议状态机。\"]},\"49\":{\"h\":\"嵌入式脚本语言\",\"t\":[\"包\",\"说明\",\"anko\",\"用Go语言编写的可编写脚本的解释器。\",\"binder\",\"转到基于gopher-lua的 Lua绑定库。\",\"cel-go\",\"具有渐进式输入功能的快速，便携式，非图灵完整表达评估。\",\"expr\",\"可以评估表达式的引擎。\",\"gentee\",\"可嵌入的脚本编程语言。\",\"gisp\",\"Go中的简单LISP。\",\"go-duktape\",\"Go的Duktape JavaScript引擎绑定。\",\"go-lua\",\"Lua 5.2 VM到纯Go的端口。\",\"go-php\",\"Go的PHP绑定。\",\"go-python\",\"与CPython C-API的幼稚go绑定。\",\"golua\",\"Lua C API的绑定。\",\"gopher-lua\",\"用Go编写的Lua 5.1 VM和编译器。\",\"gval\",\"用Go编写的高度可定制的表达语言。\",\"ngaro\",\"可嵌入的Ngaro VM实现，支持在Retro中编写脚本。\",\"otto\",\"用Go编写的JavaScript解释器。\",\"purl\",\"Go中嵌入的Perl 5.18.2。\",\"tengo\",\"用于Go的字节码编译脚本语言。\"]},\"50\":{\"h\":\"错误处理\",\"t\":[\"包\",\"说明\",\"emperror\",\"Go库和应用程序的错误处理工具和最佳实践。\",\"errlog\",\"可破解的软件包，用于确定错误的负责任的源代码（以及其他一些快速调试功能）。可插入任何现成的记录器。\",\"errors\",\"下拉更换为标准库的错误包和github.com/pkg/errors。提供各种错误处理原语。\",\"errors\",\"提供简单错误处理原语的软件包。\",\"errors\",\"简单golang错误处理与分类元。\",\"errorx\",\"具有堆栈跟踪，错误组成等的功能丰富的错误包。\",\"Falcon\",\"一个简单但功能强大的错误处理软件包。\",\"go-multierror\",\"Go（golang）软件包，用于将错误列表表示为单个错误。\",\"tracerr\",\"带有堆栈跟踪和源代码片段的Golang错误。\",\"werr\",\"错误包装程序为Go中的错误类型创建了一个包装程序，该包装程序捕获了调用它的文件，行和堆栈。\"]},\"51\":{\"h\":\"文件\",\"t\":[\"包\",\"说明\",\"afero\",\"Go的文件系统抽象系统。\",\"afs\",\"Go的抽象文件存储（mem，scp，zip，tar，云：s3，gs）。\",\"bigfile\",\"文件传输系统，支持使用http api，rpc调用和ftp客户端管理文件。\",\"checksum\",\"计算大型文件的消息摘要，例如MD5和SHA256。\",\"flop\",\"文件操作库，旨在与GNU cp镜像功能奇偶校验。\",\"go-csv-tag\",\"tag-使用标签加载csv文件。\",\"go-decent-copy\",\"复制human文件。\",\"go-exiftool\",\"ExifTool的Go绑定，这是众所周知的库，用于从文件（图片，PDF，office，...）提取尽可能多的元数据（EXIF，IPTC等）。\",\"go-gtfs\",\"在go中加载gtfs文件。\",\"notify\",\"具有简单API的文件系统事件通知库，类似于os / signal。\",\"opc\",\"为Go加载Open Packaging Conventions（OPC）文件。\",\"parquet\",\"读取和写入 parquet文件。\",\"pdfcpu\",\"PDF 处理器。\",\"skywalker\",\"一种软件包，允许一个人轻松地同时通过文件系统。\",\"stl\",\"读取和写入STL（立体光刻）文件的模块。并发读取算法。\",\"tarfs\",\"tar文件FileSystem interface接口的实现。\",\"vfs\",\"跨多种文件系统类型（例如os，S3和GCS）的Go的一组可插拔，可扩展且自以为是的文件系统功能。\"]},\"52\":{\"h\":\"金融\",\"t\":[\"包\",\"说明\",\"accounting\",\"golang的货币和货币格式。\",\"currency\",\"高性能和准确的货币计算包。\",\"decimal\",\"任意精度定点十进制数字。\",\"go-finance\",\"Go中的综合金融市场数据。\",\"go-finance\",\"金融功能库，用于货币时间价值（年金），现金流量，利率转换，债券和折旧计算。\",\"go-finance\",\"获取汇率，通过VIES检查增值税号和检查IBAN银行帐号的模块。\",\"go-money\",\"Fowler的Money模式的实现。\",\"ofxgo\",\"查询OFX服务器和/或解析响应（使用示例命令行客户端）。\",\"orderbook\",\"匹配引擎的限价订单在Golang。\",\"techan\",\"具有高级市场分析和交易策略的技术分析库。\",\"transaction\",\"以多线程模式运行的嵌入式帐户嵌入式事务数据库。\",\"vat\",\"增值税号验证和欧盟增值税率。\"]},\"53\":{\"h\":\"游戏开发\",\"t\":[\"包\",\"说明\",\"Azul3D\",\"用Go语言编写的3D游戏引擎。\",\"Ebiten\",\"Go中死的简单2D游戏库。\",\"engo\",\"Engo是用Go语言编写的开源2D游戏引擎。它遵循实体组件系统范式。\",\"g3n\",\"Go 3D游戏引擎。\",\"GarageEngine\",\"用Go语言编写的2D游戏引擎，可在OpenGL上使用。\",\"glop\",\"Glop（权力游戏库）是一个相当简单的跨平台游戏库。\",\"go-astar\",\"A 路径查找算法的Go实现。\",\"go-collada\",\"Go包，用于Collada文件格式。\",\"go-sdl2\",\"Simple DirectMedia Layer的 Go绑定。\",\"go3d\",\"用于Go的面向性能的2D/3D数学软件包。\",\"gonet\",\"使用golang实现的游戏服务器框架。\",\"goworld\",\"可扩展的游戏服务器引擎，具有空间实体框架和热插拔功能。\",\"Leaf\",\"轻量级游戏服务器框架。\",\"nano\",\"重量轻，设备，高性能的基于golang游戏服务器架构。\",\"Oak\",\"Pure Go游戏引擎。\",\"Pitaya\",\"可扩展的游戏服务器框架，具有群集支持和通过C SDK的iOS，Android，Unity等客户端库。\",\"Pixel\",\"Go中的手工制作2D游戏库。\",\"raylib-go\",\"去绑定raylib，简单和易于使用的库，以了解电子游戏编程。\",\"termloop\",\"Go的基于终端的游戏引擎，建立在Termbox之上。\"]},\"54\":{\"h\":\"地理位置\",\"t\":[\"包\",\"说明\",\"geocache\",\"适用于基于地理位置的应用程序的内存中缓存。\",\"geoserver\",\"geoserver是Go软件包，用于通过GeoServer REST API操纵GeoServer实例。\",\"gismanager\",\"将 GIS数据（矢量数据）发布到PostGIS和Geoserver。\",\"osm\",\"用于读取，编写和使用OpenStreetMap数据和API的库。\",\"pbf\",\"OpenStreetMap PBF golang编码器/解码器。\",\"S2 geometry\",\"Go中的S2几何库。\",\"Tile38\",\"具有空间索引和实时地理围栏的地理位置数据库。\",\"WGS84\",\"库坐标转换和变换（ETRS89，OSGB36，NAD83，RGF93，网络墨卡托UTM）。\"]},\"55\":{\"h\":\"编译器\",\"t\":[\"包\",\"说明\",\"c4go\",\"将C代码转换为Go代码。\",\"f4go\",\"将FORTRAN 77代码转换为Go代码。\",\"gopherjs\",\"从Go到JavaScript的编译器。\",\"llgo\",\"Go的基于LLVM的编译器。\",\"tardisgo\",\"Golang转换为CPP / CSharp / Java / JavaScript转译器。\"]},\"56\":{\"h\":\"Goroutines\",\"t\":[\"包\",\"说明\",\"ants\",\"用于golang的高性能goroutine池。\",\"artifex\",\"Golang使用基于工作程序的分派的简单内存中作业队列。\",\"async\",\"一种异步执行功能的安全方法，以防万一。\",\"breaker\",\"使执行流程可中断的灵活机制。\",\"cyclicbarrier\",\"用于golang的CyclicBarrier。\",\"go-floc\",\"轻松编排goroutine。\",\"go-flow\",\"控制goroutine的执行顺序。\",\"go-tools/multithreading\",\"使用带有简单API的轻量级库管理goroutine池。\",\"go-trylock\",\"支持Golang的读写锁的TryLock。\",\"go-waitgroup\",\"sync.WaitGroup与错误处理和并发控制类似。\",\"gohive\",\"Go的高性能和易于使用的Goroutine池。\",\"gollback\",\"异步简单函数实用程序，用于管理闭包和回调的执行。\",\"GoSlaves\",\"简单和异步Goroutine池库。\",\"goworker\",\"goworker是基于Go的后台工作者。\",\"gowp\",\"gowp是并发限制goroutine池。\",\"gpool\",\"管理可调整大小的上下文感知goroutine池以绑定并发。\",\"grpool\",\"轻巧的Goroutine池。\",\"Hunch\",\"预感提供功能，如：All，First，Retry，Waterfall等等，这使得异步流控制更加直观。\",\"oversight\",\"监督是Erlang监督树的完整实现。\",\"parallel-fn\",\"并行运行功能。\",\"pool\",\"有限的消费者goroutine池或无限制的goroutine池，以便更轻松地处理和取消goroutine。\",\"queue\",\"为您提供sync.WaitGroup类似的队列组可访问性。帮助您节流和限制goroutine，等待所有goroutine结束等等。\",\"routine\",\"具有上下文和支持的例程控制：Main，Go，Pool和一些有用的Executors。\",\"semaphore\",\"基于通道和上下文的具有锁定/解锁操作超时的信号量模式实现。\",\"semaphore\",\"基于CAS的快速可调整大小的信号量实现（比基于通道的信号量实现更快）。\",\"stl\",\"基于软件交易内存（STM）并发控制机制的软件交易锁。\",\"threadpool\",\"Golang线程池实现。\",\"tunny\",\"线程池golang。\",\"worker-pool\",\"goworker是一个简单的Go异步工作池。\",\"workerpool\",\"Goroutine池，它限制了任务执行的并发性，而不是排队的任务数。\"]},\"57\":{\"h\":\"图形界面\",\"t\":[\"包\",\"说明\",\"app\",\"打包以使用GO，HTML和CSS创建应用的程序。支持：MacOS，Windows正在开发中。\",\"fyne\",\"为Go设计的跨平台本机GUI，使用EFL呈现。支持：Linux，macOS，Windows。\",\"go-astilectron\",\"使用GO和HTML / JS / CSS（由Electron支持）构建跨平台GUI应用。\",\"go-gtk\",\"GTK的绑定。\",\"go-sciter\",\"Go绑定：用于现代桌面UI开发的可嵌入HTML / CSS / script引擎。跨平台。\",\"gotk3\",\"GTK3的绑定。\",\"gowd\",\"使用GO，HTML，CSS和NW.js进行快速简单的桌面UI开发。跨平台。\",\"qt\",\"Go的Qt绑定（支持Windows / macOS / Linux / Android / iOS / Sailfish OS / Raspberry Pi）。\",\"ui\",\"Go的平台本地GUI库。跨平台。\",\"Wails\",\"使用内置OS HTML渲染器的HTML UI的Mac，Windows，Linux桌面应用程序。\",\"walk\",\"Go的Windows应用程序库工具包。\",\"webview\",\"具有简单双向JavaScript绑定的跨平台Webview窗口（Windows / macOS / Linux）。\",\"go-appindicator\",\"libappindicator3 C库的Go绑定。\",\"gosx-notifier\",\"Go的OSX桌面通知库。\",\"mac-activity-tracker\",\"OSX库，用于通知计算机上的任何（可插入）活动。\",\"mac-sleep-notifier\",\"golang中的OSX睡眠/唤醒通知。\",\"robotgo\",\"Go本机跨平台GUI系统自动化。控制鼠标，键盘等。\",\"systray\",\"跨平台的Go库，用于在通知区域中放置图标和菜单。\",\"trayhost\",\"跨平台的Go库，用于在主机操作系统的任务栏中放置一个图标。\"]},\"58\":{\"h\":\"图片\",\"t\":[\"包\",\"说明\",\"bild\",\"纯Go中图像处理算法的集合。\",\"bimg\",\"使用libvips进行快速有效的图像处理的小包装。\",\"cameron\",\"Go的头像生成器。\",\"canvas\",\"将矢量图形转换为PDF，SVG或光栅图像。\",\"darkroom\",\"具有可变存储后端的图像代理和侧重于速度和弹性的图像处理引擎。\",\"geopattern\",\"从字符串创建漂亮的生成图像图案。\",\"gg\",\"纯Go中的2D渲染。\",\"gift\",\"图像处理过滤器的包装。\",\"gltf\",\"高效，强大的glTF 2.0读取器，写入器和验证器。\",\"go-cairo\",\"用于cairo图形库的绑定。\",\"go-gd\",\"GD库的Go绑定。\",\"go-nude\",\"Go的裸露检测。\",\"go-opencv\",\"用于OpenCV的绑定。\",\"go-webcolors\",\"webcolors库的端口，从Python到Go。\",\"gocv\",\"使用OpenCV 3.3+进行计算机视觉的Go软件包。\",\"goimagehash\",\"Go感知图像哈希包。\",\"goimghdr\",\"imghdr模块确定Go文件中包含的图像类型。\",\"govatar\",\"用于生成有趣头像的库和CMD工具。\",\"image2ascii\",\"将图像转换为ASCII。\",\"imagick\",\"绑定到ImageMagick的MagickWand C API。\",\"imaginary\",\"用于图像大小调整的快速，简单的HTTP微服务。\",\"imaging\",\"简单的Go图像处理包。\",\"img\",\"选择图像处理工具。\",\"ln\",\"Go中的3D线条艺术渲染。\",\"mergi\",\"用于图像处理（合并，裁切，调整大小，水印，动画）的Tool＆Go库。\",\"mort\",\"用Go编写的存储和图像处理服务器。\",\"mpo\",\"用于MPO 3D照片的解码器和转换工具。\",\"picfit\",\"用Go编写的图像大小调整服务器。\",\"pt\",\"用Go语言编写的路径跟踪引擎。\",\"resize\",\"使用常见的插值方法为Go 调整图像大小。\",\"rez\",\"在纯Go和SIMD中调整图像大小。\",\"smartcrop\",\"查找适合任何图像和尺寸的优质作物。\",\"steganography\",\"用于LSB隐写术的Pure Go库。\",\"stegify\",\"用于LSB隐写术的Go工具，能够隐藏图像中的任何文件。\",\"svgo\",\"用于SVG生成的Go语言库。\",\"tga\",\"软件包tga是TARGA图像格式的解码器/编码器。\"]},\"59\":{\"h\":\"物联网\",\"t\":[\"包\",\"说明\",\"connectordb\",\"量化自我和物联网的开源平台。\",\"devices\",\"IoT设备库套件，针对x / exp / io进行实验。\",\"eywa\",\"Project Eywa本质上是一个连接管理器，用于跟踪连接的设备。\",\"flogo\",\"Project Flogo是一个用于IoT Edge应用和集成的开源框架。\",\"gatt\",\"盖特是一个围棋包构建低功耗蓝牙外设。\",\"gobot\",\"Gobot是机器人技术，物理计算和物联网的框架。\",\"huego\",\"适用于Go的飞利浦Hue扩展客户端库。\",\"iot\",\"IoT是用于实现Google IoT Core设备的简单框架。\",\"mainflux\",\"工业物联网消息和设备管理服务器。\",\"periph\",\"外设I / O与低级别的主板设备接口。\",\"sensorbee\",\"用于物联网的轻量级流处理引擎。\"]},\"60\":{\"h\":\"JSON格式\",\"t\":[\"包\",\"说明\",\"ajson\",\"具有JSONPath支持的golang的抽象JSON。\",\"gjo\",\"用于创建JSON对象的小型实用程序。\",\"GJSON\",\"使用一行代码获取JSON值。\",\"go-jsonerror\",\"Go-JsonError可让我们轻松创建遵循JsonApi规范的json响应错误。\",\"go-respond\",\"Go包，用于处理常见的HTTP JSON响应。\",\"gojq\",\"Golang中的 JSON查询。\",\"gojson\",\"从示例JSON自动生成Go（golang）结构定义。\",\"JayDiff\",\"用Go编写的JSON diff实用程序。\",\"jettison\",\"用于Go的高性能，无反射JSON编码器。\",\"JSON-to-Go\",\"将JSON转换为Go结构。\",\"json2go\",\"高级JSON到Go结构转换。提供可以解析多个JSON文档并创建适合所有JSON的结构的包。\",\"jsonapi-errors\",\"根据JSON API错误参考进行绑定。\",\"jsonf\",\"突出显示格式和获取JSON的结构查询的控制台工具。\",\"jsongo\",\"Fluent API，可以更轻松地创建Json对象。\",\"jsonhal\",\"简单的Go包，用于将自定义结构编组为HAL兼容的JSON响应。\",\"kazaam\",\"用于JSON文档的任意转换的API。\",\"mp\",\"简单的cli电子邮件解析器。当前，它使用标准输入并输出JSON。\"]},\"61\":{\"h\":\"机器学习\",\"t\":[\"包\",\"说明\",\"bayesian\",\"贝叶斯分类为Golang天真。\",\"CloudForest\",\"快速，灵活，多线程的决策树集合，用于纯Go中的机器学习。\",\"eaopt\",\"进化优化库。\",\"evoli\",\"遗传算法和粒子群优化库。\",\"fonet\",\"用Go编写的深度神经网络库。\",\"go-cluster\",\"k模式和k-原型聚类算法的Go实现。\",\"go-deep\",\"Go中功能丰富的神经网络库\",\"go-fann\",\"快速人工神经网络（FANN）库的Go绑定。\",\"go-galib\",\"用Go / golang编写的遗传算法库。\",\"go-pr\",\"Go lang中的模式识别包。\",\"gobrain\",\"用go语言编写的神经网络\",\"godist\",\"各种概率分布及相关方法。\",\"goga\",\"Go的遗传算法库。\",\"GoLearn\",\"用于Go的通用机器学习库。\",\"golinear\",\"Go的liblinear绑定。\",\"GoMind\",\"Go中的简单神经网络库。\",\"goml\",\"Go中的在线机器学习。\",\"Goptuna\",\"用于Go语言编写的黑盒函数的贝叶斯优化框架。一切都会被优化。\",\"goRecommend\",\"用Go编写的推荐算法库。\",\"gorgonia\",\"基于图形的计算库，例如Theano for Go，它提供了用于构建各种机器学习和神经网络算法的原语。\",\"gorse\",\"基于Go编写的协作过滤的离线推荐系统后端。\",\"goscore\",\"用于PMML的Go Scoring API。\",\"gosseract\",\"使用Tesseract C ++库的OCR（光学字符识别）软件包。\",\"libsvm\",\"基于LIBSVM 3.14 libsvm的golang版本衍生作品。\",\"neat\",\"用于增强拓扑神经演化（NEAT）的即插即用，并行Go框架。\",\"neural-go\",\"go-在Go中实现的多层感知器网络，通过反向传播进行训练。\",\"ocrserver\",\"一个简单的OCR API服务器，非常容易被Docker和Heroku部署。\",\"onnx-go\",\"转到开放神经网络交换（ONNX）的接口。\",\"probab\",\"概率分布函数。贝叶斯推断。用纯Go语言编写。\",\"regommend\",\"建议和协作过滤引擎。\",\"shield\",\"贝叶斯文本分类器，具有灵活的标记器和Go的存储后端。\",\"tfgo\",\"易于使用的Tensorflow绑定：简化了官方Tensorflow Go绑定的使用。在Go中定义计算图，加载并执行经过Python训练的模型。\",\"Varis\",\"Golang神经网络。\"]},\"62\":{\"h\":\"金融\",\"t\":[\"包\",\"说明\",\"unioffice\",\"Pure Go库，用于创建和处理Office Word（.docx），Excel（.xlsx）和Powerpoint（.pptx）文档。\",\"excelize\",\"Golang库用于读取和写入Microsoft Excel™（XLSX）文件。\",\"go-excel\",\"一个简单而轻便的阅读器，可以将类似于related-db的excel读取为表格。\",\"goxlsxwriter\",\"libxlsxwriter的Golang绑定，用于编写XLSX（Microsoft Excel）文件。\",\"xlsx\",\"用于简化在Go程序中读取Microsoft Excel最新版本使用的XML格式的库。\",\"xlsx\",\"在Go程序中快速/安全地读取/更新您现有的Microsoft Excel文件的方法。\"]},\"63\":{\"h\":\"自然语言处理\",\"t\":[\"包\",\"说明\",\"getlang\",\"快速自然语言检测程序包。\",\"go-i18n\",\"用于处理本地化文本的软件包和一个随附工具。\",\"go-mystem\",\"CGo与Yandex.Mystem的绑定-俄罗斯形态分析仪。\",\"go-nlp\",\"用于处理离散概率分布的实用程序和其他可用于执行NLP工作的工具。\",\"go-pinyin\",\"CN Hanzi至Hanyu拼音转换器。\",\"go-stem\",\"搬运程序阻止算法的实现。\",\"go-unidecode\",\"Unicode文本的ASCII音译。\",\"go2vec\",\"用于word2vec嵌入的阅读器和实用程序功能。\",\"gojieba\",\"这是一个围棋实施解霸其中中国分词算法。\",\"golibstemmer\",\"雪球库libstemmer库的绑定，包括porter 2。\",\"gotokenizer\",\"基于字典和Goram语言的Bigram语言模型的标记器。（现在仅支持中文细分）\",\"gounidecode\",\"Go的Unicode音译器（也称为unidecode）。\",\"gse\",\"进行有效的文本分割；支持英语，中文，日语等。\",\"icu\",\"CGO结合为ICU4C C库检测和转换功能。保证与版本50.1兼容。\",\"kagome\",\"用纯Go语言编写的JP形态分析仪。\",\"libtextcat\",\"libtextcat C库的Cgo绑定。保证与2.2版兼容。\",\"MMSEGO\",\"这是MMSEG的GO实现，它是中文分词算法。\",\"nlp\",\"从字符串中提取值，并用nlp填充您的结构。\",\"nlp\",\"支持LSA（潜在语义分析）的自然语言处理库。\",\"paicehusk\",\"Paice / Husk提取算法的Golang实现。\",\"petrovich\",\"彼得罗维奇（Petrovich）是库，在给定的语法情况下使用俄语名称。\",\"porter\",\"这是Martin Porter的Porter干算法的C实现的相当简单的移植。\",\"porter2\",\"非常快的Porter 2 提取器。\",\"prose\",\"用于文本处理的库，支持标记化，词性标记，命名实体提取等。仅限英语。\",\"RAKE.go\",\"快速自动关键字提取算法（RAKE）的Go端口。\",\"segment\",\"用于执行Unicode标准附件＃29中所述的Unicode文本分段的Go库\",\"sentences\",\"句子标记器：将文本转换为句子列表。\",\"shamoji\",\"shamoji是用Go编写的单词过滤程序包。\",\"snowball\",\"Go的雪球茎端口（cgo包装器）。提供单词词干提取功能Snowball本机。\",\"stemmer\",\"用于Go编程语言的Stemmer软件包。包括英语和德语词干。\",\"textcat\",\"Go软件包，用于基于n-gram的文本分类，并支持utf-8和原始文本。\",\"whatlanggo\",\"Go的自然语言检测程序包。支持84种语言和24种脚本（书写系统，例如拉丁语，西里尔字母等）。\",\"when\",\"自然EN和RU语言日期/时间分析器具有可插拔的规则。\"]},\"64\":{\"h\":\"网络\",\"t\":[\"包\",\"说明\",\"arp\",\"包arp实现ARP协议，如RFC 826中所述。\",\"buffstreams\",\"通过TCP流化协议缓冲区数据变得容易。\",\"canopus\",\"CoAP客户端/服务器实施（RFC 7252）。\",\"cidranger\",\"Go的快速IP到CIDR查找。\",\"dhcp6\",\"软件包dhcp6实现了DHCPv6服务器，如RFC 3315中所述。\",\"dns\",\"使用DNS的Go库。\",\"ether\",\"用于发送和接收以太网帧的跨平台Go软件包。\",\"ethernet\",\"程序包ethernet实施IEEE 802.3以太网II帧和IEEE 802.1Q VLAN标签的封送处理。\",\"fasthttp\",\"软件包fasthttp是Go的一种快速HTTP实现，比net / http快10倍。\",\"fortio\",\"负载测试库和命令行工具，高级回显服务器和Web UI。允许指定设置的每秒查询负载，并记录延迟直方图和其他有用的统计数据并对其进行图形化。Tcp，Http，gRPC。\",\"ftp\",\"程序包ftp实现RFC 959中所述的FTP客户端。\",\"gev\",\"gev是基于Reactor模式的轻量级，快速，无阻塞的TCP网络库。\",\"gmqtt\",\"Gmqtt是一个灵活的高性能MQTT代理库，它完全实现了MQTT协议V3.1.1。\",\"gnet\",\"gnet是一个高性能的，用纯围棋轻便，非阻塞，事件循环网络库。\",\"gNxI\",\"使用gNMI和gNOI协议的网络管理工具的集合。\",\"go-getter\",\"Go库，用于使用URL从各种来源下载文件或目录。\",\"go-powerdns\",\"Golang的 PowerDNS API绑定。\",\"go-stun\",\"STUN客户端的Go实现（RFC 3489和RFC 5389）。\",\"gobgp\",\"使用Go编程语言实现的BGP。\",\"golibwireshark\",\"软件包golibwireshark使用libwireshark库来解码pcap文件并分析解剖数据。\",\"gopacket\",\"Go库，用于使用libpcap绑定进行数据包处理。\",\"gopcap\",\"libpcap的包装器。\",\"goshark\",\"软件包goshark使用tshark解码IP数据包并创建数据结构以分析数据包。\",\"gosnmp\",\"用于执行SNMP操作的本机Go库。\",\"gosocsvr\",\"套接字服务器变得简单。\",\"gotcp\",\"用于快速编写tcp应用程序的Go软件包。\",\"grab\",\"用于管理文件下载的软件包。\",\"graval\",\"实验性FTP服务器框架。\",\"HTTPLab\",\"HTTPLabs可让您检查HTTP请求并伪造响应。\",\"iplib\",\"受python ipaddress和ruby ipaddr启发而使用IP地址（net.IP，net.IPNet）的库\",\"jazigo\",\"Jazigo是用Go语言编写的工具，用于检索多个网络设备的配置。\",\"kcp-go\",\"KCP-快速可靠的ARQ协议。\",\"kcptun\",\"基于KCP协议的极其简单和快速的udp隧道。\",\"lhttp\",\"强大的websocket框架，可更轻松地构建IM服务器。\",\"linkio\",\"用于读取器/写入器接口的网络链接速度模拟。\",\"llb\",\"这是代理服务器的非常简单但快速的后端。对于零内存分配和快速响应的快速重定向到预定义域很有用。\",\"mdns\",\"Golang中的简单mDNS（多播DNS）客户端/服务器库。\",\"mqttPaho\",\"Paho Go客户端提供了一个MQTT客户端库，用于通过TCP，TLS或WebSockets连接到MQTT代理。\",\"NFF-Go\",\"用于快速开发云和裸机（以前的YANFF）的高性能网络功能的框架。\",\"packet\",\"通过TCP和UDP发送数据包。如果需要，它可以缓冲消息和热交换连接。\",\"peerdiscovery\",\"Pure Go库，用于使用UDP多播的跨平台本地对等发现。\",\"portproxy\",\"简单的TCP代理，它将不支持它的API添加到CORS支持中。\",\"publicip\",\"软件包publicip返回您的面向公众的IPv4地址（互联网出口）。\",\"quic-go\",\"在纯Go中实现QUIC协议。\",\"raw\",\"包raw允许在设备驱动程序级别为网络接口读取和写入数据。\",\"sftp\",\"程序包sftp实现SSH文件传输协议，如https://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt\",\"ssh\",\"用于构建SSH服务器的高级API（包装crypto / ssh）。\",\"sslb\",\"这是一个超级简单的负载均衡器，只是一个实现某种性能的小项目。\",\"stun\",\"实施RFC 5389 STUN协议。\",\"tcp_server\",\"用于更快地构建tcp服务器的Go库。\",\"tspool\",\"TCP库使用工作池来提高性能并保护您的服务器。\",\"utp\",\"围棋UTP微传输协议的实现。\",\"water\",\"简单的TUN / TAP库。\",\"webrtc\",\"WebRTC API的纯Go实现。\",\"winrm\",\"进入WinRM客户端以在Windows计算机上远程执行命令。\",\"xtcp\",\"具有同步全双工通信，安全关闭，自定义协议的TCP Server Framework。\"]},\"65\":{\"h\":\"视频库\",\"t\":[\"包\",\"说明\",\"go-astisub\",\"在GO中处理字幕（.srt，.stl，.ttml，.webvtt，.ssa / .ass，图文电视，.smi等）。\",\"go-astits\",\"在GO中本地解析和解复用MPEG传输流（.ts）。\",\"go-m3u8\",\"Apple m3u8播放列表的解析器和生成器库。\",\"goav\",\"FFmpeg的综合Go绑定。\",\"gst\",\"GStreamer的绑定。\",\"libgosubs\",\"go的字幕格式支持。支持.srt，.ttml和.ass。\",\"libvlc-go\",\"libvlc 2.X / 3.X / 4.X的绑定（由VLC媒体播放器使用）。\",\"m3u8\",\"Apple HLS的M3U8播放列表的解析器和生成器库。\",\"v4l\",\"用Go编写的Linux视频捕获库。\"]},\"66\":{\"c\":[\"golang\"]},\"67\":{\"h\":\"Go简介\",\"t\":[\"Go（也叫 Golang）是由 Google 开发的开源编程语言，旨在提供一种简单、快速且高效的语言，特别适用于并发编程、云计算、微服务架构以及高性能网络应用。Go 语言的设计强调简洁性和高效性，尤其在处理高并发任务时表现优异。\",\"Go 是一门静态类型、编译型语言，它将现代编程语言中的许多最佳实践（如内存管理、并发性支持）进行了整合，同时去除了许多不必要的复杂性。\"]},\"68\":{\"h\":\"Go 的特点\"},\"69\":{\"h\":\"1.1 简洁的语法\",\"t\":[\"Go 语言的语法设计简洁，易学易用。它摒弃了传统编程语言中的一些冗余和复杂性，例如没有类和继承，也没有头文件（例如 C 语言中的 #include），避免了程序员的复杂操作和管理。Go 强调通过组合来实现代码复用，借助接口和结构体代替传统的类继承机制。\"]},\"70\":{\"h\":\"1.2 高效的并发支持\",\"t\":[\"Go 的并发模型是其最强大的特性之一。Go 提供了原生支持的轻量级线程——goroutine，这些 goroutine 比传统线程更加轻量，启动和销毁的成本低。配合 channels（通道），Go 提供了简洁且高效的方式来进行并发编程，使得并发操作变得更加容易理解和维护。\",\"Goroutine：一种由 Go 运行时管理的轻量级线程，它的创建开销极小。 Channel：一种用于不同 goroutine 之间通信的机制，它可以确保数据交换的安全性。\"]},\"71\":{\"h\":\"1.3 强类型与垃圾回收\",\"t\":[\"Go 是强类型语言，类型是静态检查的，这意味着所有变量的类型在编译时就已经确定。与 C/C++ 不同，Go 有自动垃圾回收机制，不需要程序员手动管理内存，大大减少了内存泄漏和野指针的风险。\"]},\"72\":{\"h\":\"1.4 跨平台支持\",\"t\":[\"Go 是跨平台的，支持包括 Linux、macOS 和 Windows 在内的多种操作系统，并且有丰富的标准库使得编写跨平台的应用变得简单。\"]},\"73\":{\"h\":\"1.5 编译速度快\",\"t\":[\"Go 编译速度非常快，几乎能在几秒钟内完成整个项目的编译，适合大规模开发和快速迭代。\"]},\"74\":{\"h\":\"1.6 内置工具\",\"t\":[\"Go 提供了一套完整的内置工具链，涵盖了代码格式化、文档生成、测试、性能分析等功能。使用 go fmt 可以自动格式化代码，go test 提供了内建的单元测试支持。\"]},\"75\":{\"h\":\"1.7 单一可执行文件\",\"t\":[\"Go 语言的程序编译后通常会生成一个静态链接的单一可执行文件，没有依赖库。这个特性特别适合容器化应用和微服务架构的部署。\"]},\"76\":{\"h\":\"Go 语言的应用场景\",\"t\":[\"Go 语言特别适用于以下场景：\"]},\"77\":{\"h\":\"2.1 网络服务与 Web 开发\",\"t\":[\"Go 天生适合开发高性能的网络服务，尤其是在需要处理大量并发请求的场景中表现出色。Go 具有强大的 net/http 标准库，能够帮助开发者快速构建 Web 服务和 RESTful API。许多知名的 Web 框架（如 Gin、Beego、Echo 等）都建立在 Go 语言的基础上。\"]},\"78\":{\"h\":\"2.2 微服务架构\",\"t\":[\"Go 是构建微服务架构的理想选择，因为它支持高效的并发处理，能够快速处理多个请求，并且由于其编译后的二进制文件小且独立，适合用于容器化和云原生应用。\"]},\"79\":{\"h\":\"2.3 云计算与 DevOps\",\"t\":[\"Go 是云计算的“宠儿”，特别适合构建用于云计算的工具和服务。许多流行的云平台工具（如 Kubernetes、Docker、Prometheus）都是用 Go 语言编写的。\"]},\"80\":{\"h\":\"2.4 系统编程\",\"t\":[\"Go 具备一定的系统编程能力，虽然没有 C 语言那么底层，但其性能仍然非常出色，适用于开发需要高效执行的系统级应用。\"]},\"81\":{\"h\":\"2.5 数据库与大数据处理\",\"t\":[\"Go 也广泛应用于数据库连接、数据查询、数据分析等领域，得益于其良好的并发支持和高性能。\"]},\"82\":{\"h\":\"Go 语言的优点与缺点\"},\"83\":{\"h\":\"3.1 优点\",\"t\":[\"高效的并发模型：通过 goroutine 和 channel 提供了非常简洁且高效的并发支持。 简洁的语法：Go 语言的设计简洁，减少了传统编程语言中许多复杂的特性。 快速编译：Go 的编译速度极快，能够帮助开发者更快速地迭代和开发。 跨平台支持：Go 是跨平台的，能够在不同操作系统上编译和运行。 内存管理：Go 有垃圾回收机制，减少了程序员手动管理内存的负担。 现代化的标准库：Go 拥有丰富的标准库，能简化开发流程，减少外部依赖。\"]},\"84\":{\"h\":\"3.2 缺点\",\"t\":[\"缺少泛型（直到 Go 1.18）：Go 在早期版本中并没有提供泛型功能，虽然在 Go 1.18 引入了泛型，但这个特性相对较新，可能还不被所有开发者广泛接受和使用。 不支持传统的面向对象编程（OOP）：Go 没有类、继承等传统的 OOP 特性，虽然可以通过结构体和接口来模拟 OOP，但这可能对习惯传统 OOP 编程的开发者来说有一定学习曲线。 错误处理机制繁琐：Go 没有异常处理机制，所有的错误都需要通过返回值显式地处理，这种设计虽然避免了程序中断，但可能导致代码冗长。 标准库缺乏 GUI 支持：Go 的标准库主要专注于网络编程、并发、系统工具等，缺乏对图形用户界面（GUI）应用的原生支持。\"]},\"85\":{\"h\":\"Go 的生态和社区\",\"t\":[\"Go 的生态系统非常活跃，许多知名的开源项目和工具都采用了 Go 语言，如：\",\"Docker：容器化平台，用于构建、分发和运行容器化应用。\",\"Kubernetes：开源的容器编排平台，用于自动化部署、扩展和管理容器化应用。\",\"Prometheus：开源的监控和报警工具，专注于时序数据的收集与处理。\",\"Go Modules：Go 官方推出的依赖管理工具，简化了包管理。\",\"Go 社区也非常活跃，全球有大量开发者参与其中，提供文档、教程、工具和库。\"]},\"86\":{\"h\":\"Go 与其他语言的比较\"},\"87\":{\"h\":\"5.1 与 C/C++ 比较\",\"t\":[\"Go 比 C/C++ 更易学易用，语法简洁，不需要手动内存管理。\",\"Go 具有自动垃圾回收机制，而 C/C++ 需要开发者手动管理内存。\",\"Go 的并发支持比 C/C++ 更加简洁和高效。\",\"Go 不支持指针算术操作，这是为了避免内存安全问题。\"]},\"88\":{\"h\":\"5.2 与 Python 比较\",\"t\":[\"Go 是编译型语言，具有更好的性能，适用于高并发、高性能的应用，而 Python 是解释型语言，虽然开发速度较快，但在性能上可能不如 Go。\",\"Go 的静态类型系统提供了更强的类型安全，而 Python 是动态类型，虽然灵活，但可能导致运行时错误。\",\"Python 有丰富的第三方库，而 Go 的生态相对较新，虽然在快速增长，但某些特定领域的库可能不如 Python 丰富。\"]},\"89\":{\"h\":\"5.3 与 Java 比较\",\"t\":[\"Go 是静态类型的，编译型语言，而 Java 也是静态类型但是解释型语言。Go 编译后的程序更为高效，启动速度更快。\",\"Go 具有更简洁的语法，消除了 Java 中许多繁琐的代码（如 getter/setter 方法）。\",\"Go 的并发模型非常简洁而高效，而 Java 虽然也有线程和并发支持，但并发编程相对复杂。\",\"总体来说，Go 语言以其简洁、高效、并发友好的特性，逐渐成为现代云计算、微服务、网络编程等领域的主流语言之一。\"]},\"90\":{\"c\":[\"golang\"]},\"91\":{\"h\":\"基本语法\",\"t\":[\"Go的基本语法十分简单易懂，让我们从一个最简单的例子开始。\",\"package main import \\\"fmt\\\" func main() { fmt.Println(\\\"Hello 世界!\\\") }\",\"代码分析：\",\"package关键字声明了是当前go文件属于哪一个包，入口文件都必须声明为main包，入口函数是main函数，在自定义包和函数时命名应当尽量避免与之重复。\",\"import是导入关键字，后面跟着的是被导入的包名。\",\"func是函数声明关键字，用于声明一个函数。\",\"fmt.Println(\\\"Hello 世界!\\\")是一个语句，调用了fmt包下的Println函数进行输出。\",\"以上就是一个简单的语法介绍，下面就来略微细致地去了解里面的概念。\"]},\"92\":{\"h\":\"包\",\"t\":[\"在Go中，程序是通过将包链接在一起来构建的。Go中进行导入的最基本单位是一个包，而不是.go文件。包其实就是一个文件夹，英文名package，包内共享所有变量，常量，以及所有定义的类型。包的命名风格建议都是小写字母，并且要尽量简短。\"]},\"93\":{\"h\":\"可见性\",\"t\":[\"前面提到过包内共享所有变量，常量，以及所有定义的类型，但对于包外而言并不是这样，有时候你并不想让别人访问某一个类型，所以就需要控制可见性。你可能在其它OOP语言中见过Public，Pravite等关键字，不过在Go语言中没有这些，它控制可见性的方式非常简单，规则如下\",\"名称大写字母开头，即为公有类型/变量/常量\",\"名字小写或下划线开头，即为私有类型/变量/常量\",\"比如下面的一个例子，常量MyName就是公开的，而常量mySalary就是私有的。\",\"package example // 公有 const MyName = \\\"jack\\\" // 私有 const mySalary = 20_000\",\"这个可见性的规则适用于整个Go语言的任何地方。\"]},\"94\":{\"h\":\"导入\",\"t\":[\"导入一个包就是导入这个包的所有公有的类型/变量/常量，导入的语法就是import加上包名\",\"package main import \\\"example\\\"\",\"当导入多个包时，你可以这么写\",\"package main import \\\"example\\\" import \\\"example1\\\"\",\"也可以用括号括起来，第二种方法在实践中更加常用。\",\"package main import ( \\\"example\\\" \\\"example1\\\" )\",\"如果有包名重复了，或者包名比较复杂，你也可以给它们起别名\",\"package main import ( e \\\"example\\\" e1 \\\"example1\\\" )\",\"还有另一种特殊的使用方法就是匿名导入包，匿名导入的包无法被使用，这么做通常是为了加载包下的init函数，但又不需要用到包中的类型，例如一个常见的场景就是注册数据库驱动\",\"package main import ( e \\\"example\\\" _ \\\"mysql-driver\\\" )\",\"当你导入后，想要访问包中的类型时，通过名称.标识符去访问即可，比如下面这个例子\",\"package main import ( \\\"example\\\" \\\"fmt\\\" ) func main() { fmt.Println(example.MyName) }\",\"若你尝试去访问一个私有的类型，编译器就会告诉你无法访问。\",\"注意\",\"Go中无法进行循环导入，不管是直接的还是间接的。例如包A导入了包B，包B也导入了包A，这是直接循环导入，包A导入了包C，包C导入了包B，包B又导入了包A，这就是间接的循环导入，存在循环导入的话将会无法通过编译。\"]},\"95\":{\"h\":\"内部包\",\"t\":[\"go中约定，一个包内名为internal 包为内部包，外部包将无法访问内部包中的任何内容，否则的话编译不通过，下面看一个例子。\",\"/home/user/go/ src/ crash/ bang/ (go code in package bang) b.go foo/ (go code in package foo) f.go bar/ (go code in package bar) x.go internal/ baz/ (go code in package baz) z.go quux/ (go code in package main) y.go\",\"由文件结构中可知，crash包无法访问baz包中的类型。\"]},\"96\":{\"h\":\"注释\",\"t\":[\"Go支持单行注释和多行注释，注释与内容之间建议隔一个空格，例如\",\"// 这是main包 package main // 导入了fmt包 import \\\"fmt\\\" /* * 这是启动函数main函数 */ func main() { // 这是一个语句 fmt.Println(\\\"Hello 世界!\\\") }\"]},\"97\":{\"h\":\"标识符\",\"t\":[\"标识符就是一个名称，用于包命名，函数命名，变量命名等等，命名规则如下：\",\"只能由字母，数字，下划线组成\",\"只能以字母和下划线开头\",\"严格区分大小写\",\"不能与任何已存在的标识符重复，即包内唯一的存在\",\"不能与Go任何内置的关键字冲突\",\"下方列出所有的内置关键字，也可以前往参考手册-标识符查看更多细节\",\"break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var\"]},\"98\":{\"h\":\"运算符\",\"t\":[\"下面是Go语言中支持的运算符号的优先级排列，也可以前往参考手册-运算符查看更多细节。\",\"Precedence Operator 5 * / % << >> & &^ 4 + - | ^ 3 == != < <= > >= 2 && 1 ||\",\"有一点需要稍微注意下，go语言中没有选择将~作为取反运算符，而是复用了^符号，当两个数字使用^时，例如a^b，它就是异或运算符，只对一个数字使用时，例如^a，那么它就是取反运算符。go也支持增强赋值运算符，如下。\",\"a += 1 a /= 2 a &^= 2\",\"提示\",\"Go语言中没有自增与自减运算符，它们被降级为了语句statement，并且规定了只能位于操作数的后方，所以不用再去纠结i++和++i这样的问题。\",\"a++ // 正确 ++a // 错误 a-- // 正确\",\"还有一点就是，它们不再具有返回值，因此a = b++这类语句的写法是错误的。\"]},\"99\":{\"h\":\"字面量\",\"t\":[\"字面量，按照计算机科学的术语来讲是用于表达源代码中一个固定值的符号，也叫字面值。两个叫法都是一个意思，写了什么东西，值就是什么，值就是“字面意义上“的值。\"]},\"100\":{\"h\":\"整型字面量\",\"t\":[\"为了便于阅读，允许使用下划线_来进行数字划分，但是仅允许在前缀符号之后和数字之间使用。\",\"24 // 24 024 // 24 2_4 // 24 0_2_4 // 24 10_000 // 10k 100_000 // 100k 0O24 // 20 0b00 // 0 0x00 // 0 0x0_0 // 0\"]},\"101\":{\"h\":\"浮点数字面量\",\"t\":[\"通过不同的前缀可以表达不同进制的浮点数\",\"0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction)\"]},\"102\":{\"h\":\"复数字面量\",\"t\":[\"0i 0123i // == 123i 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 * 1i == 0.25i\"]},\"103\":{\"h\":\"字符字面量\",\"t\":[\"字符字面量必须使用单引号括起来''，Go中的字符完全兼容utf8。\",\"'a' 'ä' '你' '\\\\t' '\\\\000' '\\\\007' '\\\\377' '\\\\x07' '\\\\xff' '\\\\u12e4' '\\\\U00101234'\"]},\"104\":{\"h\":\"转义字符\",\"t\":[\"Go中可用的转义字符\",\"\\\\a U+0007 响铃符号 \\\\b U+0008 回退符号 \\\\f U+000C 换页符号 \\\\n U+000A 换行符号 \\\\r U+000D 回车符号 \\\\t U+0009 横向制表符号 \\\\v U+000B 纵向制表符号 \\\\\\\\ U+005C 反斜杠转义 \\\\' U+0027 单引号转义 (该转义仅在字符内有效) \\\\\\\" U+0022 双引号转义 (该转义仅在字符串内有效)\"]},\"105\":{\"h\":\"字符串字面量\",\"t\":[\"字符串字面量必须使用双引号\\\"\\\"括起来或者反引号（反引号字符串不允许转义）\",\"`abc` // \\\"abc\\\" `\\\\n \\\\n` // \\\"\\\\\\\\n\\\\n\\\\\\\\n\\\" \\\"\\\\n\\\" \\\"\\\\\\\"\\\" // `\\\"` \\\"Hello, world!\\\\n\\\" \\\"今天天气不错\\\" \\\"日本語\\\" \\\"\\\\u65e5本\\\\U00008a9e\\\" \\\"\\\\xff\\\\u00FF\\\"\"]},\"106\":{\"h\":\"函数\",\"t\":[\"Go中的函数声明方式通过func关键字来进行，跟大多数语言类似\",\"func main() { println(1) }\",\"不过Go中的函数有两个不同的点，第一个是参数类型后置，像下面这样\",\"func Hello(name string) { fmt.Println(name) }\",\"第二个不同的点就是多返回值，而且可以带名字\",\"func Pos() () (x, y float64) { ... }\"]},\"107\":{\"h\":\"风格\",\"t\":[\"关于编码风格这一块Go是强制所有人统一同一种风格，Go官方提供了一个格式化工具gofmt，通过命令行就可以使用，该格式化工具没有任何的格式化参数可以传递，仅有的两个参数也只是输出格式化过程，所以完全不支持自定义，也就是说所有通过此工具的格式化后的代码都是同一种代码风格，这会极大的降低维护人员的心智负担，所以在这一块追求个性显然是一个不太明智的选择。\",\"下面会简单列举一些规则，平时在编写代码的时候也可以稍微注意一下。\"]},\"108\":{\"h\":\"函数花括号换行\",\"t\":[\"关于函数后的花括号到底该不该换行，几乎每个程序员都能说出属于自己的理由，在Go中所有的花括号都不应该换行\",\"// 正确示例 func main() { fmt.Println(\\\"Hello 世界!\\\") }\",\"如果你真的这么做了，像下面这样\",\"// 错误示例 func main() { fmt.Println(\\\"Hello 世界!\\\") }\",\"这样的代码连编译都过不了，所以Go强制所有程序员花函数后的括号不换行。\"]},\"109\":{\"h\":\"代码缩进\",\"t\":[\"Go默认使用Tab也就是制表符进行缩进，仅在一些特殊情况会使用空格。\"]},\"110\":{\"h\":\"代码间隔\",\"t\":[\"Go中大部分间隔都是有意义的，从某种程度上来说，这也代表了编译器是如何看待你的代码的，例如下方的数学运算\",\"2*9 + 1/3*2\",\"众所周知，乘法的优先级比加法要高，在格式化后，*符号之间的间隔会显得更紧凑，意味着优先进行运算，而+符号附近的间隔则较大，代表着较后进行运算。\"]},\"111\":{\"h\":\"花括号省略\",\"t\":[\"在其它语言中的if和for语句通常可以简写，像下面这样\",\"for (int i=0; i < 10; i++) printf(\\\"%d\\\", i)\",\"但在Go中不行，你可以只写一行，但必须加上花括号\",\"for i := 0; i < 10; i++ {fmt.Println(i)}\"]},\"112\":{\"h\":\"三元表达式\",\"t\":[\"Go中没有三元表达式，所以像下面的代码是无法通过编译的\",\"var c = a > b ? a : b\"]},\"113\":{\"c\":[\"golang\"]},\"114\":{\"h\":\"数据类型\",\"t\":[\"下面列出Go语言中全部的内置类型，以供参考，更多细节可以前往参考手册-类型。\"]},\"115\":{\"h\":\"布尔类型\",\"t\":[\"布尔类型只有真值和假值。\",\"类型\",\"描述\",\"bool\",\"true为真值，false为假值\",\"提示\",\"在Go中，整数0并不代表假值，非零整数也不能代表真值，即数字无法代替布尔值进行逻辑判断，两者是完全不同的类型。\"]},\"116\":{\"h\":\"整型\",\"t\":[\"Go中为不同位数的整数分配了不同的类型，主要分为无符号整型与有符号整型。\",\"序号\",\"类型和描述\",\"uint8\",\"无符号 8 位整型\",\"uint16\",\"无符号 16 位整型\",\"uint32\",\"无符号 32 位整型\",\"uint64\",\"无符号 64 位整型\",\"int8\",\"有符号 8 位整型\",\"int16\",\"有符号 16 位整型\",\"int32\",\"有符号 32 位整型\",\"int64\",\"有符号 64 位整型\",\"uint\",\"无符号整型 至少32位\",\"int\",\"整型 至少32位\",\"uintptr\",\"等价于无符号64位整型，但是专用于存放指针运算，用于存放死的指针地址。\"]},\"117\":{\"h\":\"浮点型\",\"t\":[\"IEEE-754浮点数，主要分为单精度浮点数与双精度浮点数。\",\"类型\",\"类型和描述\",\"float32\",\"IEEE-754 32位浮点数\",\"float64\",\"IEEE-754 64位浮点数\"]},\"118\":{\"h\":\"复数类型\",\"t\":[\"类型\",\"描述\",\"complex128\",\"64位实数和虚数\",\"complex64\",\"32位实数和虚数\"]},\"119\":{\"h\":\"字符类型\",\"t\":[\"go语言字符串完全兼容UTF-8\",\"类型\",\"描述\",\"byte\",\"等价 uint8 可以表达ANSCII字符\",\"rune\",\"等价 int32 可以表达Unicode字符\",\"string\",\"字符串即字节序列，可以转换为[]byte类型即字节切片\"]},\"120\":{\"h\":\"派生类型\",\"t\":[\"类型\",\"例子\",\"数组\",\"[5]int，长度为5的整型数组\",\"切片\",\"[]float64，64位浮点数切片\",\"映射表\",\"map[string]int，键为字符串类型，值为整型的映射表\",\"结构体\",\"type Gopher struct{}，Gopher结构体\",\"指针\",\"*int，一个整型指针。\",\"函数\",\"type f func()，一个没有参数，没有返回值的函数类型\",\"接口\",\"type Gopher interface{}，Gopher接口\",\"通道\",\"chan int，整型通道\"]},\"121\":{\"h\":\"零值\",\"t\":[\"官方文档中零值称为zero value，零值并不仅仅只是字面上的数字零，而是一个类型的空值或者说默认值更为准确。\",\"类型\",\"零值\",\"数字类型\",\"0\",\"布尔类型\",\"false\",\"字符串类型\",\"\\\"\\\"\",\"数组\",\"固定长度的对应类型的零值集合\",\"结构体\",\"内部字段都是零值的结构体\",\"切片，映射表，函数，接口，通道，指针\",\"nil\"]},\"122\":{\"h\":\"nil\",\"t\":[\"nil类似于其它语言中的none或者null，但并不等同。nil仅仅只是一些引用类型的零值，并且不属于任何类型，从源代码中的nil可以看出它仅仅只是一个变量。\",\"var nil Type\",\"并且nil == nil这样的语句是无法通过编译的。\"]},\"123\":{\"h\":\"变量\",\"t\":[\"变量是用于保存一个值的存储位置，允许其存储的值在运行时动态的变化。每声明一个变量，都会为其分配一块内存以存储对应类型的值，前往参考手册-变量以查看更多细节。\"]},\"124\":{\"h\":\"声明\",\"t\":[\"在go中的类型声明是后置的，变量的声明会用到var关键字，格式为var 变量名 类型名，变量名的命名规则必须遵守标识符的命名规则。\",\"var intNum int var str string var char byte\",\"当要声明多个相同类型的变量时，可以只写一次类型\",\"var numA, numB, numC int\",\"当要声明多个不同类型的变量时，可以使用()进行包裹，可以存在多个()。\",\"var ( name string age int address string ) var ( school string class int )\",\"一个变量如果只是声明而不赋值，那么变量存储的值就是对应类型的零值。\"]},\"125\":{\"h\":\"赋值\",\"t\":[\"赋值会用到运算符=，例如\",\"var name string name = \\\"jack\\\"\",\"也可以声明的时候直接赋值\",\"var name string = \\\"jack\\\"\",\"或者这样也可以\",\"var name string var age int name, age = \\\"jack\\\", 1\",\"第二种方式每次都要指定类型，可以使用官方提供的语法糖：短变量初始化，可以省略掉var关键字和后置类型，具体是什么类型交给编译器自行推断。\",\"name := \\\"jack\\\" // 字符串类型的变量。\",\"虽然可以不用指定类型，但是在后续赋值时，类型必须保持一致，下面这种代码无法通过编译。\",\"a := 1 a = \\\"1\\\"\",\"还需要注意的是，短变量初始化不能使用nil，因为nil不属于任何类型，编译器无法推断其类型。\",\"name := nil // 无法通过编译\",\"短变量声明可以批量初始化\",\"name, age := \\\"jack\\\", 1\",\"短变量声明方式无法对一个已存在的变量使用，比如\",\"// 错误示例 var a int a := 1 // 错误示例 a := 1 a := 2\",\"但是有一种情况除外，那就是在赋值旧变量的同时声明一个新的变量，比如\",\"a := 1 a, b := 2, 2\",\"这种代码是可以通过编译的，变量a被重新赋值，而b是新声明的。\",\"在go语言中，有一个规则，那就是所有在函数中的变量都必须要被使用，比如下面的代码只是声明了变量，但没有使用它\",\"func main() { a := 1 }\",\"那么在编译时就会报错，提示你这个变量声明了但没有使用\",\"a declared and not used\",\"这个规则仅适用于函数内的变量，对于函数外的包级变量则没有这个限制，下面这个代码就可以通过编译。\",\"var a = 1 func main() { }\"]},\"126\":{\"h\":\"匿名\",\"t\":[\"用下划线可以表示不需要某一个变量\",\"Open(name string) (*File, error)\",\"比如os.Open函数有两个返回值，我们只想要第一个，不想要第二个，可以按照下面这样写\",\"file, _ := os.Open(\\\"readme.txt\\\")\",\"未使用的变量是无法通过编译的，当你不需要某一个变量时，就可以使用下划线_代替。\"]},\"127\":{\"h\":\"交换\",\"t\":[\"在Go中，如果想要交换两个变量的值，不需要使用指针，可以使用赋值运算符直接进行交换，语法上看起来非常直观，例子如下\",\"num1, num2 := 25, 36 num1, num2 = num2, num1\",\"三个变量也是同样如此\",\"num1, num2, num3 := 25, 36, 49 num1, num2, num3 = num3, num2, num1\",\"思考下面这一段代码，这是计算斐波那契数列的一小段代码，三个变量在计算后的值分别是什么\",\"a, b, c := 0, 1, 1 a, b, c = b, c, a+b\",\"答案是\",\"1 1 1\",\"你可能会疑惑为什么不是\",\"1 1 2\",\"明明a已经被赋予b的值了，为什么a+b的结果还是1？go在进行多个变量赋值运算时，它的顺序是先计算值再赋值，并非从左到右计算。\",\"a, b, c = b, c, a+b\",\"你可能会以为它会被展开成下面这段\",\"a = b b = c c = a + b\",\"但实际上它会将a, b, c三个数的值分别计算好再赋给它们，就等同于下面这段代码\",\"a, b, c = 1, 1, 0+1\",\"当涉及到函数调用时，这个效果就更为明显，我们有一个函数sum可以计算两个数字的返回值\",\"func sum(a, b int) int { return a + b }\",\"通过函数来进行两数相加\",\"a, b, c := 0, 1, 1 a, b, c = b, c, sum(a, b)\",\"结果没有变化，在计算sum函数返回值时，它的入参依旧是0和1\",\"1 1 1\",\"所以代码应该这样分开写。\",\"a, b = b, c c = a + b\"]},\"128\":{\"h\":\"比较\",\"t\":[\"变量之间的比较有一个大前提，那就是它们之间的类型必须相同，go语言中不存在隐式类型转换，像下面这样的代码是无法通过编译的\",\"func main() { var a uint64 var b int64 fmt.Println(a == b) }\",\"编译器会告诉你两者之间类型并不相同\",\"invalid operation: a == b (mismatched types uint64 and int64)\",\"所以必须使用强制类型转换\",\"func main() { var a uint64 var b int64 fmt.Println(int64(a) == b) }\",\"在没有泛型之前，早期go提供的内置min，max函数只支持浮点数，到了1.21版本，go才终于将这两个内置函数用泛型重写，现在可以使用min函数比较最小值\",\"minVal := min(1, 2, -1, 1.2)\",\"使用max函数比较最大值\",\"maxVal := max(100, 22, -1, 1.12)\",\"它们的参数支持所有的可比较类型，go中的可比较类型有\",\"布尔\",\"数字\",\"字符串\",\"指针\",\"通道 （仅支持判断是否相等）\",\"元素是可比较类型的数组（切片不可比较）（仅支持判断是否相等）（仅支持相同长度的数组间的比较，因为数组长度也是类型的一部分，而不同类型不可比较）\",\"字段类型都是可比较类型的结构体（仅支持判断是否相等）\",\"除此之外，还可以通过导入标准库cmp来判断，不过仅支持有序类型的参数，在go中内置的有序类型只有数字和字符串。\",\"import \\\"cmp\\\" func main() { cmp.Compare(1, 2) cmp.Less(1, 2) }\"]},\"129\":{\"h\":\"代码块\",\"t\":[\"在函数内部，可以通过花括号建立一个代码块，代码块彼此之间的变量作用域是相互独立的。例如下面的代码\",\"func main() { a := 1 { a := 2 fmt.Println(a) } { a := 3 fmt.Println(a) } fmt.Println(a) }\",\"它的输出是\",\"2 3 1\",\"块与块之间的变量相互独立，不受干扰，无法访问，但是会受到父块中的影响。\",\"func main() { a := 1 { a := 2 fmt.Println(a) } { fmt.Println(a) } fmt.Println(a) }\",\"它的输出是\",\"2 1 1\",\"常量的值无法在运行时改变，一旦赋值过后就无法修改，其值只能来源于：\",\"字面量\",\"其他常量标识符\",\"常量表达式\",\"结果是常量的类型转换\",\"iota\",\"常量只能是基本数据类型，不能是\",\"除基本类型以外的其它类型，如结构体，接口，切片，数组等\",\"函数的返回值\",\"常量的值无法被修改，否则无法通过编译\"]},\"130\":{\"h\":\"初始化\",\"t\":[\"常量的声明需要用到const关键字，常量在声明时就必须初始化一个值，并且常量的类型可以省略，例如\",\"const name string = \\\"Jack\\\" // 字面量 const msg = \\\"hello world\\\" // 字面量 const num = 1 // 字面量 const numExpression = (1+2+3) / 2 % 100 + num // 常量表达式\",\"如果仅仅只是声明而不指定值，将会无法通过编译\",\"const name string\",\"编译器报错\",\"missing init expr for name\",\"批量声明常量可以用()括起来以提升可读性，可以存在多个()达到分组的效果。\",\"const ( Count = 1 Name = \\\"Jack\\\" ) const ( Size = 16 Len = 25 )\",\"在同一个常量分组中，在已经赋值的常量后面的常量可以不用赋值，其值默认就是前一个的值，比如\",\"const ( A = 1 B // 1 C // 1 D // 1 E // 1 )\"]},\"131\":{\"h\":\"iota\",\"t\":[\"iota是一个内置的常量标识符，通常用于表示一个常量声明中的无类型整数序数，一般都是在括号中使用。\",\"const iota = 0\",\"看几个使用案例\",\"const ( Num = iota // 0 Num1 // 1 Num2 // 2 Num3 // 3 Num4 // 4 )\",\"也可以这么写\",\"const ( Num = iota*2 // 0 Num1 // 2 Num2 // 4 Num3 // 6 Num4 // 8 )\",\"还可以\",\"const ( Num = iota << 2*3 + 1 // 1 Num1 // 13 Num2 // 25 Num3 = iota // 3 Num4 // 4 )\",\"通过上面几个例子可以发现，iota是递增的，第一个常量使用iota值的表达式，根据序号值的变化会自动的赋值给后续的常量，直到用新的const重置，这个序号其实就是代码的相对行号，是相对于当前分组的起始行号，看下面的例子\",\"const ( Num = iota<<2*3 + 1 // 1 第一行 Num2 = iota<<2*3 + 1 // 13 第二行 _ // 25 第三行 Num3 //37 第四行 Num4 = iota // 4 第五行 _ // 5 第六行 Num5 // 6 第七行 )\",\"例子中使用了匿名标识符_占了一行的位置，可以看到iota的值本质上就是iota所在行相对于当前const分组的第一行的差值。而不同的const分组则相互不会影响。\"]},\"132\":{\"h\":\"枚举\",\"t\":[\"Go语言没有为枚举单独设计一个数据类型，不像其它语言通常会有一个enum来表示。一般在Go中，都是通过自定义类型 + const + iota来实现枚举，下面是一个简单的例子\",\"type Season uint8 const ( Spring Season = iota Summer Autumn Winter )\",\"这些枚举实际上就是数字，Go也不支持直接将其转换为字符串，但我们可以通过给自定义类型添加方法来返回其字符串表现形式，实现Stringer接口即可。\",\"func (s Season) String() string { switch s { case Spring: return \\\"spring\\\" case Summer: return \\\"summer\\\" case Autumn: return \\\"autumn\\\" case Winter: return \\\"winter\\\" } return \\\"\\\" }\",\"这样一来就是一个简单的枚举实现了。你也可以通过官方工具Stringer来自动生成枚举。\",\"不过它有以下缺点：\",\"类型不安全，因为Season是自定义类型，可以通过强制类型转换将其他数字也转换成该类型\",\"Season(6)\",\"繁琐，字符串表现形式需要自己实现\",\"表达能力弱，因为const仅支持基本数据类型，所以这些枚举值也只能用字符串和数字来进行表示\",\"为什么不在语言层面支持枚举是笔者非常不能理解的一件事，我认为这绝对是利大于弊的。\"]},\"133\":{\"h\":\"输入输出\",\"t\":[\"package main import \\\"fmt\\\" func main() { fmt.Println(\\\"Hello 世界!\\\") }\",\"本站的第一个入门的案例就是输出一个字符串，这一节就来讲一下在Go中如何进行输入输出。\"]},\"134\":{\"h\":\"文件描述符\",\"t\":[\"var ( Stdin = NewFile(uintptr(syscall.Stdin), \\\"/dev/stdin\\\") Stdout = NewFile(uintptr(syscall.Stdout), \\\"/dev/stdout\\\") Stderr = NewFile(uintptr(syscall.Stderr), \\\"/dev/stderr\\\") )\",\"在os包下有三个外暴露的文件描述符，其类型都是*os.File，分别是：\",\"os.Stdin - 标准输入\",\"os.Stdout - 标准输出\",\"os.Stderr - 标准错误\",\"Go中的输入输出都离不开它们。\"]},\"135\":{\"h\":\"输出\",\"t\":[\"在Go中输出有很多中方法，下面几个比较常见的\"]},\"136\":{\"h\":\"stdout\",\"t\":[\"因为标准输出本身就是一个文件，所以你可以直接将字符串写入到标准输出中\",\"package main import \\\"os\\\" func main() { os.Stdout.WriteString(\\\"hello world!\\\") }\"]},\"137\":{\"h\":\"print\",\"t\":[\"Go有两个内置的函数print，println，他们会将参数输出到标准错误中，仅做调试用，一般不推荐使用。\",\"package main func main() { print(\\\"hello world!\\\\n\\\") println(\\\"hello world\\\") }\"]},\"138\":{\"h\":\"fmt\",\"t\":[\"最常见的用法是使用fmt包，它提供了fmt.Println函数，该函数默认会将参数输出到标准输出中。\",\"package main import \\\"fmt\\\" func main() { fmt.Println(\\\"hello world!\\\") }\",\"它的参数支持任意类型，如果类型实现了String接口也会调用String方法来获取其字符串表现形式，所以它输出的内容可读性比较高，适用于大部分情况，不过由于内部用到了反射，在性能敏感的场景不建议大量使用。\"]},\"139\":{\"h\":\"bufio\",\"t\":[\"bufio提供了可缓冲的输出方法，它会先将数据写入到内存中，积累到了一定阈值再输出到指定的Writer中，默认缓冲区大小是4KB。在文件IO，网络IO的时候建议使用这个包。\",\"func main() { writer := bufio.NewWriter(os.Stdout) defer writer.Flush() writer.WriteString(\\\"hello world!\\\") }\",\"你也可以把它和fmt包结合起来用\",\"func main() { writer := bufio.NewWriter(os.Stdout) defer writer.Flush() fmt.Fprintln(writer, \\\"hello world!\\\") }\"]},\"140\":{\"h\":\"格式化\",\"t\":[\"Go中的格式化输出功能基本上由fmt.Printf函数提供，如果你学过C系语言，一定会觉得很熟悉，下面是一个简单的例子。\",\"func main() { fmt.Printf(\\\"hello world, %s!\\\", \\\"jack\\\") }\",\"下面是Go目前所有的格式化动词。\",\"0\",\"格式化\",\"描述\",\"接收类型\",\"1\",\"%%\",\"输出百分号%\",\"任意\",\"2\",\"%s\",\"输出string/[] byte值\",\"string,[] byte\",\"3\",\"%q\",\"格式化字符串，输出的字符串两端有双引号\\\"\\\"\",\"string,[] byte\",\"4\",\"%d\",\"输出十进制整型值\",\"整型\",\"5\",\"%f\",\"输出浮点数\",\"浮点\",\"6\",\"%e\",\"输出科学计数法形式 ,也可以用于复数\",\"浮点\",\"7\",\"%E\",\"与%e相同\",\"浮点\",\"8\",\"%g\",\"根据实际情况判断输出%f或者%e,会去掉多余的0\",\"浮点\",\"9\",\"%b\",\"输出整型的二进制表现形式\",\"数字\",\"10\",\"%#b\",\"输出二进制完整的表现形式\",\"数字\",\"11\",\"%o\",\"输出整型的八进制表示\",\"整型\",\"12\",\"%#o\",\"输出整型的完整八进制表示\",\"整型\",\"13\",\"%x\",\"输出整型的小写十六进制表示\",\"数字\",\"14\",\"%#x\",\"输出整型的完整小写十六进制表示\",\"数字\",\"15\",\"%X\",\"输出整型的大写十六进制表示\",\"数字\",\"16\",\"%#X\",\"输出整型的完整大写十六进制表示\",\"数字\",\"17\",\"%v\",\"输出值原本的形式，多用于数据结构的输出\",\"任意\",\"18\",\"%+v\",\"输出结构体时将加上字段名\",\"任意\",\"19\",\"%#v\",\"输出完整Go语法格式的值\",\"任意\",\"20\",\"%t\",\"输出布尔值\",\"布尔\",\"21\",\"%T\",\"输出值对应的Go语言类型值\",\"任意\",\"22\",\"%c\",\"输出Unicode码对应的字符\",\"int32\",\"23\",\"%U\",\"输出字符对应的Unicode码\",\"rune,byte\",\"24\",\"%p\",\"输出指针所指向的地址\",\"指针\",\"使用fmt.Sprintf或者fmt.Printf来格式化字符串或者输出格式化字符串，看几个例子\",\"fmt.Printf(\\\"%%%s\\\\n\\\", \\\"hello world\\\") fmt.Printf(\\\"%s\\\\n\\\", \\\"hello world\\\") fmt.Printf(\\\"%q\\\\n\\\", \\\"hello world\\\") fmt.Printf(\\\"%d\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%f\\\\n\\\", 1e2) fmt.Printf(\\\"%e\\\\n\\\", 1e2) fmt.Printf(\\\"%E\\\\n\\\", 1e2) fmt.Printf(\\\"%g\\\\n\\\", 1e2) fmt.Printf(\\\"%b\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%#b\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%o\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%#o\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%x\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%#x\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%X\\\\n\\\", 2<<7-1) fmt.Printf(\\\"%#X\\\\n\\\", 2<<7-1) type person struct { name string age int address string } fmt.Printf(\\\"%v\\\\n\\\", person{\\\"lihua\\\", 22, \\\"beijing\\\"}) fmt.Printf(\\\"%+v\\\\n\\\", person{\\\"lihua\\\", 22, \\\"beijing\\\"}) fmt.Printf(\\\"%#v\\\\n\\\", person{\\\"lihua\\\", 22, \\\"beijing\\\"}) fmt.Printf(\\\"%t\\\\n\\\", true) fmt.Printf(\\\"%T\\\\n\\\", person{}) fmt.Printf(\\\"%c%c\\\\n\\\", 20050, 20051) fmt.Printf(\\\"%U\\\\n\\\", '码') fmt.Printf(\\\"%p\\\\n\\\", &person{})\",\"使用其它进制时，在%与格式化动词之间加上一个空格便可以达到分隔符的效果，例如\",\"func main() { str := \\\"abcdefg\\\" fmt.Printf(\\\"%x\\\\n\\\", str) fmt.Printf(\\\"% x\\\\n\\\", str) }\",\"该例输出的结果为\",\"61626364656667 61 62 63 64 65 66 67\",\"在使用数字时，还可以自动补零。比如\",\"fmt.Printf(\\\"%09d\\\", 1) // 000000001\",\"二进制同理\",\"fmt.Printf(\\\"%09b\\\", 1<<3) // 000001000\",\"错误情况\",\"格式化字符数量 < 参数列表数量\",\"fmt.Printf(\\\"\\\", \\\"\\\") //%!(EXTRA string=)\",\"格式化字符数量 > 参数列表数量\",\"fmt.Printf(\\\"%s%s\\\", \\\"\\\") //%!s(MISSING)\",\"类型不匹配\",\"fmt.Printf(\\\"%s\\\", 1) //%!s(int=1)\",\"缺少格式化动词\",\"fmt.Printf(\\\"%\\\", 1) // %!(NOVERB)%!(EXTRA int=1)\"]},\"141\":{\"h\":\"输入\",\"t\":[\"下面介绍常见的输入方法\"]},\"142\":{\"h\":\"read\",\"t\":[\"你可以像直接读文件一样，读取输入内容，如下\",\"func main() { var buf [1024]byte n, _ := os.Stdin.Read(buf[:]) os.Stdout.Write(buf[:n]) }\",\"这样用起来太麻烦了，一般不推荐使用。\"]},\"143\":{\"h\":\"fmt\",\"t\":[\"我们可以使用fmt包提供的几个函数，用起来跟C差不多。\",\"// 扫描从os.Stdin读入的文本，根据空格分隔，换行也被当作空格 func Scan(a ...any) (n int, err error) // 与Scan类似，但是遇到换行停止扫描 func Scanln(a ...any) (n int, err error) // 根据格式化的字符串扫描 func Scanf(format string, a ...any) (n int, err error)\",\"读取两个数字\",\"func main() { var a, b int fmt.Scanln(&a, &b) fmt.Printf(\\\"%d + %d = %d\\\\n\\\", a, b, a+b) }\",\"读取固定长度的数组\",\"func main() { n := 10 s := make([]int, n) for i := range n { fmt.Scan(&s[i]) } fmt.Println(s) }\",\"1 2 3 4 5 6 7 8 9 10 [1 2 3 4 5 6 7 8 9 10]\"]},\"144\":{\"h\":\"bufio\",\"t\":[\"在有大量输入需要读取的时候，就建议使用bufio.Reader来进行内容读取\",\"func main() { reader := bufio.NewReader(os.Stdin) var a, b int fmt.Fscanln(reader, &a, &b) fmt.Printf(\\\"%d + %d = %d\\\\n\\\", a, b, a+b) }\"]},\"145\":{\"h\":\"scanner\",\"t\":[\"bufio.Scanner与bufio.Reader类似，不过它是按行读取的。\",\"func main() { scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { line := scanner.Text() if line == \\\"exit\\\" { break } fmt.Println(\\\"scan\\\", line) } }\",\"结果如下\",\"first line scan first line second line scan second line third line scan third line exit\",\"提示\",\"在输入输出这方面，想要练手的话，去洛谷做几道简单的ACM模式算法题就能上手熟悉了。\"]},\"146\":{\"h\":\"条件控制\",\"t\":[\"在Go中，条件控制语句总共有三种if，switch，select。select相对前两者而言比较特殊，本节不会讲解，将会留到并发那一节再做介绍。\"]},\"147\":{\"h\":\"if else\",\"t\":[\"if else 至多两个判断分支，语句格式如下\",\"if expression { }\",\"或者\",\"if expression { }else { }\",\"expression必须是一个布尔表达式，即结果要么为真要么为假，必须是一个布尔值，例子如下：\",\"func main() { a, b := 1, 2 if a > b { b++ } else { a++ } }\",\"也可以把表达式写的更复杂些，必要时为了提高可读性，应当使用括号来显式的表示谁应该优先计算。\",\"func main() { a, b := 1, 2 if a<<1%100+3 > b*100/20+6 { // (a<<1%100)+3 > (b*100/20)+6 b++ } else { a++ } }\",\"同时if语句也可以包含一些简单的语句，例如：\",\"func main() { if x := 1 + 1; x > 2 { fmt.Println(x) } }\"]},\"148\":{\"h\":\"else if\",\"t\":[\"else if 语句可以在if else的基础上创建更多的判断分支，语句格式如下：\",\"if expression1 { }else if expression2 { }else if expression3 { }else { }\",\"在执行的过程中每一个表达式的判断是从左到右，整个if语句的判断是从上到下 。一个根据成绩打分的例子如下，第一种写法\",\"func main() { score := 90 var ans string if score == 100 { ans = \\\"S\\\" } else if score >= 90 && score < 100 { ans = \\\"A\\\" } else if score >= 80 && score < 90 { ans = \\\"B\\\" } else if score >= 70 && score < 80 { ans = \\\"C\\\" } else if score >= 60 && score < 70 { ans = \\\"E\\\" } else if score >= 0 && score < 60 { ans = \\\"F\\\" } else { ans = \\\"nil\\\" } fmt.Println(ans) }\",\"第二种写法利用了if语句是从上到下的判断的前提，所以代码要更简洁些。\",\"func main() { score := 90 var ans string if score >= 0 && score < 60 { ans = \\\"F\\\" } else if score < 70 { ans = \\\"D\\\" } else if score < 80 { ans = \\\"C\\\" } else if score < 90 { ans = \\\"B\\\" } else if score < 100 { ans = \\\"A\\\" } else if score == 100 { ans = \\\"S\\\" }else { ans = \\\"nil\\\" } fmt.Println(ans) }\"]},\"149\":{\"h\":\"switch\",\"t\":[\"switch语句也是一种多分支的判断语句，语句格式如下：\",\"switch expr { case case1: statement1 case case2: statement2 default: default statement }\",\"一个简单的例子如下\",\"func main() { str := \\\"a\\\" switch str { case \\\"a\\\": str += \\\"a\\\" str += \\\"c\\\" case \\\"b\\\": str += \\\"bb\\\" str += \\\"aaaa\\\" default: // 当所有case都不匹配后，就会执行default分支 str += \\\"CCCC\\\" } fmt.Println(str) }\",\"还可以在表达式之前编写一些简单语句，例如声明新变量\",\"func main() { switch num := f(); { // 等价于 switch num := f(); true { case num >= 0 && num <= 1: num++ case num > 1: num-- fallthrough case num < 0: num += num } } func f() int { return 1 }\",\"switch语句也可以没有入口处的表达式。\",\"func main() { num := 2 switch { // 等价于 switch true { case num >= 0 && num <= 1: num++ case num > 1: num-- case num < 0: num *= num } fmt.Println(num) }\",\"通过fallthrough关键字来继续执行相邻的下一个分支。\",\"func main() { num := 2 switch { case num >= 0 && num <= 1: num++ case num > 1: num-- fallthrough // 执行完该分支后，会继续执行下一个分支 case num < 0: num += num } fmt.Println(num) }\"]},\"150\":{\"h\":\"label\",\"t\":[\"标签语句，给一个代码块打上标签，可以是goto，break，continue的目标。例子如下：\",\"func main() { A: a := 1 B: b := 2 }\",\"单纯的使用标签是没有任何意义的，需要结合其他关键字来进行使用。\"]},\"151\":{\"h\":\"goto\",\"t\":[\"goto将控制权传递给在同一函数中对应标签的语句，示例如下：\",\"func main() { a := 1 if a == 1 { goto A } else { fmt.Println(\\\"b\\\") } A: fmt.Println(\\\"a\\\") }\",\"在实际应用中goto用的很少，跳来跳去的很降低代码可读性，性能消耗也是一个问题。\",\"在Go中，有仅有一种循环语句：for，Go抛弃了while语句，for语句可以被当作while来使用。\"]},\"152\":{\"h\":\"for\",\"t\":[\"语句格式如下\",\"for init statement; expression; post statement { execute statement }\",\"当只保留循环条件时，就变成了while。\",\"for expression { execute statement }\",\"这是一个死循环，永远也不会退出\",\"for { execute statement }\",\"示例\",\"这是一段输出[0,20]区间数字的代码\",\"for i := 0; i <= 20; i++ { fmt.Println(i) }\",\"你可以同时初始化多个变量，然后将其递增\",\"for i, j := 1, 2; i < 100 && j < 1000; i, j = i+1, j+1 { fmt.Println(i, j) }\",\"当成while来使用\",\"num := 1 for num < 100 { num *= 2 }\",\"双循环打印九九乘法表，这是一个很经典的循环案例\",\"func main() { for i := 1; i <= 9; i++ { for j := 1; j <= 9; j++ { if i <= j { fmt.Printf(\\\"%d*%d = %2d \\\", i, j, i*j) } } fmt.Println() } }\",\"输出如下\",\"1*1 = 1 1*2 = 2 1*3 = 3 1*4 = 4 1*5 = 5 1*6 = 6 1*7 = 7 1*8 = 8 1*9 = 9 2*2 = 4 2*3 = 6 2*4 = 8 2*5 = 10 2*6 = 12 2*7 = 14 2*8 = 16 2*9 = 18 3*3 = 9 3*4 = 12 3*5 = 15 3*6 = 18 3*7 = 21 3*8 = 24 3*9 = 27 4*4 = 16 4*5 = 20 4*6 = 24 4*7 = 28 4*8 = 32 4*9 = 36 5*5 = 25 5*6 = 30 5*7 = 35 5*8 = 40 5*9 = 45 6*6 = 36 6*7 = 42 6*8 = 48 6*9 = 54 7*7 = 49 7*8 = 56 7*9 = 63 8*8 = 64 8*9 = 72 9*9 = 81\"]},\"153\":{\"h\":\"for range\",\"t\":[\"for range可以更加方便的遍历一些可迭代的数据结构，如数组，切片，字符串，映射表，通道。语句格式如下：\",\"for index, value := range iterable { // body }\",\"index为可迭代数据结构的索引，value则是对应索引下的值，例如使用for range遍历一个字符串。\",\"func main() { sequence := \\\"hello world\\\" for index, value := range sequence { fmt.Println(index, value) } }\",\"for range也可以迭代一个整型值，字面量，常量，变量都是有效的。\",\"for i := range 10 { fmt.Println(i) } n := 10 for i := range n { fmt.Println(i) } const n = 10 for i := range n { fmt.Println(i) }\",\"对于每一个种数据结构，for range的实现都有所不同，后续也会讲到，你可以前往Go - for statement以了解更多细节。\"]},\"154\":{\"h\":\"break\",\"t\":[\"break关键字会终止最内层的for循环，结合标签一起使用可以达到终止外层循环的效果，例子如下：这是一个双循环\",\"func main() { for i := 0; i < 10; i++ { for j := 0; j < 10; j++ { if i <= j { break } fmt.Println(i, j) } } }\",\"输出\",\"1 0 2 0 2 1 3 0 3 1 3 2 ... 9 6 9 7 9 8\",\"使用标签来中断外层循环\",\"func main() { Outer: for i := 0; i < 10; i++ { for j := 0; j < 10; j++ { if i <= j { break Outer } fmt.Println(i, j) } } }\",\"输出\"]},\"155\":{\"h\":\"continue\",\"t\":[\"continue关键字会跳过最内层循环的本次迭代，直接进入下一次迭代，结合标签使用可以达到跳过外层循环的效果，例子如下\",\"func main() { for i := 0; i < 10; i++ { for j := 0; j < 10; j++ { if i > j { continue } fmt.Println(i, j) } } }\",\"输出\",\"0 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 ... 7 7 7 8 7 9 8 8 8 9 9 9\",\"使用标签\",\"func main() { Out: for i := 0; i < 10; i++ { for j := 0; j < 10; j++ { if i > j { continue Out } fmt.Println(i, j) } } }\",\"输出\",\"0 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9\"]},\"156\":{\"h\":\"切片\",\"t\":[\"在Go中，数组和切片两者看起来长得几乎一模一样，但功能有着不小的区别，数组是定长的数据结构，长度被指定后就不能被改变，而切片是不定长的，切片在容量不够时会自行扩容。\"]},\"157\":{\"h\":\"数组\",\"t\":[\"如果事先就知道了要存放数据的长度，且后续使用中不会有扩容的需求，就可以考虑使用数组，Go中的数组是值类型，而非引用，并不是指向头部元素的指针。\",\"提示\",\"数组作为值类型，将数组作为参数传递给函数时，由于Go函数是传值传递，所以会将整个数组拷贝。\"]},\"158\":{\"h\":\"初始化\",\"t\":[\"数组在声明是长度只能是一个常量，不能是变量\",\"// 正确示例 var a [5]int // 错误示例 l := 1 var b [l]int\",\"先来初始化一个长度为5的整型数组\",\"var nums [5]int\",\"也可以用元素初始化\",\"nums := [5]int{1, 2, 3}\",\"可以让编译器自动推断长度\",\"nums := [...]int{1, 2, 3, 4, 5} //等价于nums := [5]int{1, 2, 3, 4, 5}，省略号必须存在，否则生成的是切片，不是数组\",\"还可以通过new函数获得一个指针\",\"nums := new([5]int)\",\"以上几种方式都会给nums分配一片固定大小的内存，区别只是最后一种得到的值是指针。\",\"在数组初始化时，需要注意的是，长度必须为一个常量表达式，否则将无法通过编译，常量表达式即表达式的最终结果是一个常量，错误例子如下：\",\"length := 5 // 这是一个变量 var nums [length]int\",\"length是一个变量，因此无法用于初始化数组长度，如下是正确示例：\",\"const length = 5 var nums [length]int // 常量 var nums2 [length + 1]int // 常量表达式 var nums3 [(1 + 2 + 3) * 5]int // 常量表达式 var nums4 [5]int // 最常用的\"]},\"159\":{\"h\":\"使用\",\"t\":[\"只要有数组名和下标，就可以访问数组中对应的元素。\",\"fmt.Println(nums[0])\",\"同样的也可以修改数组元素\",\"nums[0] = 1\",\"还可以通过内置函数len来访问数组元素的数量\",\"len(nums)\",\"内置函数cap来访问数组容量，数组的容量等于数组长度，容量对于切片才有意义。\",\"cap(nums)\"]},\"160\":{\"h\":\"切割\",\"t\":[\"切割数组的格式为arr[startIndex:endIndex]，切割的区间为左闭右开，例子如下：\",\"nums := [5]int{1, 2, 3, 4, 5} nums[1:] // 子数组范围[1,5) -> [2 3 4 5] nums[:5] // 子数组范围[0,5) -> [1 2 3 4 5] nums[2:3] // 子数组范围[2,3) -> [3] nums[1:3] // 子数组范围[1,3) -> [2 3]\",\"数组在切割后，就会变为切片类型\",\"func main() { arr := [5]int{1, 2, 3, 4, 5} fmt.Printf(\\\"%T\\\\n\\\", arr) fmt.Printf(\\\"%T\\\\n\\\", arr[1:2]) }\",\"输出\",\"[5]int []int\",\"若要将数组转换为切片类型，不带参数进行切片即可，转换后的切片与原数组指向的是同一片内存，修改切片会导致原数组内容的变化\",\"func main() { arr := [5]int{1, 2, 3, 4, 5} slice := arr[:] slice[0] = 0 fmt.Printf(\\\"array: %v\\\\n\\\", arr) fmt.Printf(\\\"slice: %v\\\\n\\\", slice) }\",\"输出\",\"array: [0 2 3 4 5] slice: [0 2 3 4 5]\",\"如果要对转换后的切片进行修改，建议使用下面这种方式进行转换\",\"func main() { arr := [5]int{1, 2, 3, 4, 5} slice := slices.Clone(arr[:]) slice[0] = 0 fmt.Printf(\\\"array: %v\\\\n\\\", arr) fmt.Printf(\\\"slice: %v\\\\n\\\", slice) }\",\"输出\",\"array: [1 2 3 4 5] slice: [0 2 3 4 5]\"]},\"161\":{\"h\":\"切片\",\"t\":[\"切片在Go中的应用范围要比数组广泛的多，它用于存放不知道长度的数据，且后续使用过程中可能会频繁的插入和删除元素。\"]},\"162\":{\"h\":\"初始化\",\"t\":[\"切片的初始化方式有以下几种\",\"var nums []int // 值 nums := []int{1, 2, 3} // 值 nums := make([]int, 0, 0) // 值 nums := new([]int) // 指针\",\"可以看到切片与数组在外貌上的区别，仅仅只是少了一个初始化长度。通常情况下，推荐使用make来创建一个空切片，只是对于切片而言，make函数接收三个参数：类型，长度，容量。举个例子解释一下长度与容量的区别，假设有一桶水，水并不是满的，桶的高度就是桶的容量，代表着总共能装多少高度的水，而桶中水的高度就是代表着长度，水的高度一定小于等于桶的高度，否则水就溢出来了。所以，切片的长度代表着切片中元素的个数，切片的容量代表着切片总共能装多少个元素，切片与数组最大的区别在于切片的容量会自动扩张，而数组不会，更多细节前往参考手册 - 长度与容量。\",\"提示\",\"切片的底层实现依旧是数组，是引用类型，可以简单理解为是指向底层数组的指针。\",\"通过var nums []int这种方式声明的切片，默认值为nil，所以不会为其分配内存，而在使用make进行初始化时，建议预分配一个足够的容量，可以有效减少后续扩容的内存消耗。\"]},\"163\":{\"h\":\"使用\",\"t\":[\"切片的基本使用与数组完全一致，区别只是切片可以动态变化长度，下面看几个例子。\",\"切片可以通过append函数实现许多操作，函数签名如下，slice是要添加元素的目标切片，elems是待添加的元素，返回值是添加后的切片。\",\"func append(slice []Type, elems ...Type) []Type\",\"首先创建一个长度为0，容量为0的空切片，然后在尾部插入一些元素，最后输出长度和容量。\",\"nums := make([]int, 0, 0) nums = append(nums, 1, 2, 3, 4, 5, 6, 7) fmt.Println(len(nums), cap(nums)) // 7 8 可以看到长度与容量并不一致。\",\"新 slice 预留的 buffer容量 大小是有一定规律的。 在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的： 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。 在1.18版本更新之后，slice的扩容策略变为了： 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4\"]},\"164\":{\"h\":\"插入元素\",\"t\":[\"切片元素的插入也是需要结合append函数来使用，现有切片如下，\",\"nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\",\"从头部插入元素\",\"nums = append([]int{-1, 0}, nums...) fmt.Println(nums) // [-1 0 1 2 3 4 5 6 7 8 9 10]\",\"从中间下标i插入元素\",\"nums = append(nums[:i+1], append([]int{999, 999}, nums[i+1:]...)...) fmt.Println(nums) // i=3，[1 2 3 4 999 999 5 6 7 8 9 10]\",\"从尾部插入元素，就是append最原始的用法\",\"nums = append(nums, 99, 100) fmt.Println(nums) // [1 2 3 4 5 6 7 8 9 10 99 100]\"]},\"165\":{\"h\":\"删除元素\",\"t\":[\"切片元素的删除需要结合append函数来使用，现有如下切片\",\"nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\",\"从头部删除n个元素\",\"nums = nums[n:] fmt.Println(nums) //n=3 [4 5 6 7 8 9 10]\",\"从尾部删除n个元素\",\"nums = nums[:len(nums)-n] fmt.Println(nums) //n=3 [1 2 3 4 5 6 7]\",\"从中间指定下标i位置开始删除n个元素\",\"nums = append(nums[:i], nums[i+n:]...) fmt.Println(nums)// i=2，n=3，[1 2 6 7 8 9 10]\",\"删除所有元素\",\"nums = nums[:0] fmt.Println(nums) // []\"]},\"166\":{\"h\":\"拷贝\",\"t\":[\"切片在拷贝时需要确保目标切片有足够的长度，例如\",\"func main() { dest := make([]int, 0) src := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(src, dest) fmt.Println(copy(dest, src)) fmt.Println(src, dest) }\",\"[1 2 3 4 5 6 7 8 9] [] 0 [1 2 3 4 5 6 7 8 9] []\",\"将长度修改为10，输出如下\",\"[1 2 3 4 5 6 7 8 9] [0 0 0 0 0 0 0 0 0 0] 9 [1 2 3 4 5 6 7 8 9] [1 2 3 4 5 6 7 8 9 0]\"]},\"167\":{\"h\":\"遍历\",\"t\":[\"切片的遍历与数组完全一致，for循环\",\"func main() { slice := []int{1, 2, 3, 4, 5, 7, 8, 9} for i := 0; i < len(slice); i++ { fmt.Println(slice[i]) } }\",\"for range循环\",\"func main() { slice := []int{1, 2, 3, 4, 5, 7, 8, 9} for index, val := range slice { fmt.Println(index, val) } }\"]},\"168\":{\"h\":\"多维切片\",\"t\":[\"先来看下面的一个例子，官方文档也有解释：Effective Go - 二维切片\",\"var nums [5][5]int for _, num := range nums { fmt.Println(num) } fmt.Println() slices := make([][]int, 5) for _, slice := range slices { fmt.Println(slice) }\",\"输出结果为\",\"[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [] [] [] [] []\",\"可以看到，同样是二维的数组和切片，其内部结构是不一样的。数组在初始化时，其一维和二维的长度早已固定，而切片的长度是不固定的，切片中的每一个切片长度都可能是不相同的，所以必须要单独初始化，切片初始化部分修改为如下代码即可。\",\"slices := make([][]int, 5) for i := 0; i < len(slices); i++ { slices[i] = make([]int, 5) }\",\"最终输出结果为\",\"[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]\"]},\"169\":{\"h\":\"拓展表达式\",\"t\":[\"提示\",\"只有切片才能使用拓展表达式\",\"切片与数组都可以使用简单表达式来进行切割，但是拓展表达式只有切片能够使用，该特性于Go1.2版本添加，主要是为了解决切片共享底层数组的读写问题，主要格式为如下，需要满足关系low<= high <= max <= cap，使用拓展表达式切割的切片容量为max-low\",\"slice[low:high:max]\",\"low与high依旧是原来的含义不变，而多出来的max则指的是最大容量，例如下方的例子中省略了max，那么s2的容量就是cap(s1)-low\",\"s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9 s2 := s1[3:4] // cap = 9 - 3 = 6\",\"那么这么做就会有一个明显的问题，s1与s2是共享的同一个底层数组，在对s2进行读写时，有可能会影响的s1的数据，下列代码就属于这种情况\",\"s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9 s2 := s1[3:4] // cap = 9 - 3 = 6 // 添加新元素，由于容量为6.所以没有扩容，直接修改底层数组 s2 = append(s2, 1) fmt.Println(s2) fmt.Println(s1)\",\"最终的输出为\",\"[4 1] [1 2 3 4 1 6 7 8 9]\",\"可以看到明明是向s2添加元素，却连s1也一起修改了，拓展表达式就是为了解决此类问题而生的，只需要稍微修改一下就能解决该问题\",\"func main() { s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9 s2 := s1[3:4:4] // cap = 4 - 3 = 1 // 容量不足，分配新的底层数组 s2 = append(s2, 1) fmt.Println(s2) fmt.Println(s1) }\",\"现在得到的结果就是正常的\",\"[4 1] [1 2 3 4 5 6 7 8 9]\"]},\"170\":{\"h\":\"clear\",\"t\":[\"在go1.21新增了clear内置函数，clear会将切片内所有的值置为零值，\",\"package main import ( \\\"fmt\\\" ) func main() { s := []int{1, 2, 3, 4} clear(s) fmt.Println(s) }\",\"输出\",\"[0 0 0 0]\",\"如果想要清空切片，可以\",\"func main() { s := []int{1, 2, 3, 4} s = s[:0:0] fmt.Println(s) }\",\"限制了切割后的容量，这样可以避免覆盖原切片的后续元素。\",\"在Go中，字符串本质上是一个不可变的只读的字节数组，也是一片连续的内存空间。\"]},\"171\":{\"h\":\"字面量\",\"t\":[\"前面提到过字符串有两种字面量表达方式，分为普通字符串和原生字符串。\",\"普通字符串\",\"普通字符串由\\\"\\\"双引号表示，支持转义，不支持多行书写，下列是一些普通字符串\",\"\\\"这是一个普通字符串\\\\n\\\" \\\"abcdefghijlmn\\\\nopqrst\\\\t\\\\\\\\uvwxyz\\\"\",\"这是一个普通字符串 abcdefghijlmn opqrst \\\\uvwxyz\",\"原生字符串\",\"原生字符串由反引号表示，不支持转义，支持多行书写，原生字符串里面所有的字符都会原封不动的输出，包括换行和缩进。\",\"`这是一个原生字符串，换行 tab缩进，\\\\t制表符但是无效,换行 \\\"这是一个普通字符串\\\" 结束 `\",\"这是一个原生字符串，换行 tab缩进，\\\\t制表符但是无效,换行 \\\"这是一个普通字符串\\\" 结束\"]},\"172\":{\"h\":\"访问\",\"t\":[\"因为字符串本质是字节数组，所以字符串的访问形式跟数组切片完全一致，例如访问字符串第一个元素\",\"func main() { str := \\\"this is a string\\\" fmt.Println(str[0]) }\",\"输出是字节而不是字符\",\"116\",\"切割字符串\",\"func main() { str := \\\"this is a string\\\" fmt.Println(string(str[0:4])) }\",\"this\",\"尝试修改字符串元素\",\"func main() { str := \\\"this is a string\\\" str[0] = 'a' // 无法通过编译 fmt.Println(str) }\",\"main.go:7:2: cannot assign to str[0] (value of type byte)\",\"虽然没法修改字符串，但是可以覆盖\",\"func main() { str := \\\"this is a string\\\" str = \\\"that is a string\\\" fmt.Println(str) }\",\"that is a string\"]},\"173\":{\"h\":\"转换\",\"t\":[\"字符串可以转换为字节切片，而字节切片或字节数组也可以转换为字符串，例子如下：\",\"func main() { str := \\\"this is a string\\\" // 显式类型转换为字节切片 bytes := []byte(str) fmt.Println(bytes) // 显式类型转换为字符串 fmt.Println(string(bytes)) }\",\"字符串的内容是只读的不可变的，无法修改，但是字节切片是可以修改的。\",\"func main() { str := \\\"this is a string\\\" fmt.Println(&str) bytes := []byte(str) // 修改字节切片 bytes = append(bytes, 96, 97, 98, 99) // 赋值给原字符串 str = string(bytes) fmt.Println(str) }\",\"将字符串转换成字节切片以后，两者之间毫无关联，因为Go会新分配一片内存空间给字节切片，再将字符串的内存复制过去，对字节切片进行修改不会对原字符串产生任何影响，这么做是为了内存安全。\",\"在这种情况下，如果要转换的字符串或字节切片很大，那么性能开销就会很高。不过你也可以通过unsafe库来实现无复制转换，不过背后的安全问题需要自己承担，比如下面的例子，b1和s1的地址是一样的。\",\"func main() { s1 := \\\"hello world\\\" b1 := unsafe.Slice(unsafe.StringData(s1), len(s1)) fmt.Printf(\\\"%p %p\\\", unsafe.StringData(s1), unsafe.SliceData(b1)) }\",\"0xe27bb2 0xe27bb2\"]},\"174\":{\"h\":\"长度\",\"t\":[\"字符串的长度，其实并不是字面量的长度，而是字节数组的长度，只是大多数时候都是ANSCII字符，刚好能用一个字节表示，所以恰好与字面量长度相等，求字符串长度使用内置函数len，例子如下：\",\"func main() { str := \\\"this is a string\\\" // 看起来长度是16 str2 := \\\"这是一个字符串\\\" // 看起来长度是7 fmt.Println(len(str), len(str2)) }\",\"16 21\",\"看起来中文字符串比英文字符串短，但是实际求得的长度却比英文字符串长。这是因为在unicode编码中，一个汉字在大多数情况下占3个字节，一个英文字符只占一个字节，通过输出字符串第一个元素可以看出结果：\",\"func main() { str := \\\"this is a string\\\" str2 := \\\"这是一个字符串\\\" fmt.Println(string(str[0])) fmt.Println(string(str2[0])) fmt.Println(string(str2[0:3])) }\",\"t // 字母t è // 意大利语 这 // 中文汉字\"]},\"175\":{\"h\":\"拷贝\",\"t\":[\"类似数组切片的拷贝方式，字符串拷贝其实是字节切片拷贝，使用内置函数copy\",\"func main() { var dst, src string src = \\\"this is a string\\\" desBytes := make([]byte, len(src)) copy(desBytes, src) dst = string(desBytes) fmt.Println(src, dst) }\",\"也可以使用strings.clone函数，但其实内部实现都差不多\",\"func main() { var dst, src string src = \\\"this is a string\\\" dst = strings.Clone(src) fmt.Println(src, dst) }\"]},\"176\":{\"h\":\"拼接\",\"t\":[\"字符串的拼接使用+操作符\",\"func main() { str := \\\"this is a string\\\" str = str + \\\" that is a int\\\" fmt.Println(str) }\",\"也可以转换为字节切片再进行添加元素\",\"func main() { str := \\\"this is a string\\\" bytes := []byte(str) bytes = append(bytes, \\\"that is a int\\\"...) str = string(bytes) fmt.Println(str) }\",\"以上两种拼接方式性能都很差，一般情况下可以使用，但如果对应性能有更高要求，可以使用strings.Builder\",\"func main() { builder := strings.Builder{} builder.WriteString(\\\"this is a string \\\") builder.WriteString(\\\"that is a int\\\") fmt.Println(builder.String()) }\",\"this is a string that is a int\"]},\"177\":{\"h\":\"遍历\",\"t\":[\"在本文开头就已经提到过，Go中的字符串就是一个只读的字节切片，也就是说字符串的组成单位是字节而不是字符。这种情况经常会在遍历字符串时遇到，例如下方的代码\",\"func main() { str := \\\"hello world!\\\" for i := 0; i < len(str); i++ { fmt.Printf(\\\"%d,%x,%s\\\\n\\\", str[i], str[i], string(str[i])) } }\",\"例子中分别输出了字节的十进制形式和十六进制形式。\",\"104,68,h 101,65,e 108,6c,l 108,6c,l 111,6f,o 32,20, 119,77,w 111,6f,o 114,72,r 108,6c,l 100,64,d 33,21,!\",\"由于例子中的字符都是属于ASCII字符，只需要一个字节就能表示，所以结果恰巧每一个字节对应一个字符。但如果包含非ASCII字符结果就不同了，如下\",\"func main() { str := \\\"hello 世界!\\\" for i := 0; i < len(str); i++ { fmt.Printf(\\\"%d,%x,%s\\\\n\\\", str[i], str[i], string(str[i])) } }\",\"通常情况下，一个中文字符会占用3个字节，所以就可能会看到以下结果\",\"104,68,h 101,65,e 108,6c,l 108,6c,l 111,6f,o 32,20, 228,e4,ä 184,b8,¸ 150,96, 231,e7,ç 149,95, 140,8c, 33,21,!\",\"按照字节来遍历会把中文字符拆开，这显然会出现乱码。Go字符串是明确支持utf8的，应对这种情况就需要用到rune类型，在使用for range进行遍历时，其默认的遍历单位类型就是一个rune，例如下方代码\",\"func main() { str := \\\"hello 世界!\\\" for _, r := range str { fmt.Printf(\\\"%d,%x,%s\\\\n\\\", r, r, string(r)) } }\",\"输出如下\",\"104,68,h 101,65,e 108,6c,l 108,6c,l 111,6f,o 32,20, 19990,4e16,世 30028,754c,界 33,21,!\",\"rune本质上是int32的类型别名，unicode字符集的范围位于0x0000 - 0x10FFFF之间，最大也只有三个字节，合法的UTF8编码最大字节数只有4个字节，所以使用int32来存储是理所当然，上述例子中将字符串转换成[]rune再遍历也是一样的道理，如下\",\"func main() { str := \\\"hello 世界!\\\" runes := []rune(str) for i := 0; i < len(runes); i++ { fmt.Println(string(runes[i])) } }\",\"还可以使用uft8包下的工具，例如\",\"func main() { str := \\\"hello 世界!\\\" for i, w := 0, 0; i < len(str); i += w { r, width := utf8.DecodeRuneInString(str[i:]) fmt.Println(string(r)) w = width } }\",\"这两个例子的输出都是相同的。\",\"提示\",\"关于字符串的更多细节，可以前往Strings, bytes, runes and characters in Go了解。\",\"一般来说，映射表数据结构实现通常有两种，哈希表(hash table)和搜索树(search tree)，区别在于前者无序，后者有序。在Go中，map的实现是基于哈希桶(也是一种哈希表)，所以也是无序的，本篇不会对实现原理做过多的讲解，这超出了基础的范围，后续会进行深入分析。\",\"提示\",\"想要了解map的原理可以前往map实现\"]},\"178\":{\"h\":\"初始化\",\"t\":[\"在Go中，map的键类型必须是可比较的，比如string ，int是可比较的，而[]int是不可比较的，也就无法作为map的键。初始化一个map有两种方法，第一种是字面量，格式如下：\",\"map[keyType]valueType{}\",\"举几个例子\",\"mp := map[int]string{ 0: \\\"a\\\", 1: \\\"a\\\", 2: \\\"a\\\", 3: \\\"a\\\", 4: \\\"a\\\", } mp := map[string]int{ \\\"a\\\": 0, \\\"b\\\": 22, \\\"c\\\": 33, }\",\"第二种方法是使用内置函数make，对于map而言，接收两个参数，分别是类型与初始容量，例子如下：\",\"mp := make(map[string]int, 8) mp := make(map[string][]int, 10)\",\"map是引用类型，零值或未初始化的map可以访问，但是无法存放元素，所以必须要为其分配内存。\",\"func main() { var mp map[string]int mp[\\\"a\\\"] = 1 fmt.Println(mp) }\",\"panic: assignment to entry in nil map\",\"提示\",\"在初始化map时应当尽量分配一个合理的容量，以减少扩容次数。\"]},\"179\":{\"h\":\"访问\",\"t\":[\"访问一个map的方式就像通过索引访问一个数组一样。\",\"func main() { mp := map[string]int{ \\\"a\\\": 0, \\\"b\\\": 1, \\\"c\\\": 2, \\\"d\\\": 3, } fmt.Println(mp[\\\"a\\\"]) fmt.Println(mp[\\\"b\\\"]) fmt.Println(mp[\\\"d\\\"]) fmt.Println(mp[\\\"f\\\"]) }\",\"0 1 3 0\",\"通过代码可以观察到，即使map中不存在\\\"f\\\"这一键值对，但依旧有返回值。map对于不存的键其返回值是对应类型的零值，并且在访问map的时候其实有两个返回值，第一个返回值对应类型的值，第二个返回值一个布尔值，代表键是否存在，例如：\",\"func main() { mp := map[string]int{ \\\"a\\\": 0, \\\"b\\\": 1, \\\"c\\\": 2, \\\"d\\\": 3, } if val, exist := mp[\\\"f\\\"]; exist { fmt.Println(val) } else { fmt.Println(\\\"key不存在\\\") } }\",\"对map求长度\",\"func main() { mp := map[string]int{ \\\"a\\\": 0, \\\"b\\\": 1, \\\"c\\\": 2, \\\"d\\\": 3, } fmt.Println(len(mp)) }\"]},\"180\":{\"h\":\"存值\",\"t\":[\"map存值的方式也类似数组存值一样，例如：\",\"func main() { mp := make(map[string]int, 10) mp[\\\"a\\\"] = 1 mp[\\\"b\\\"] = 2 fmt.Println(mp) }\",\"存值时使用已存在的键会覆盖原有的值\",\"func main() { mp := make(map[string]int, 10) mp[\\\"a\\\"] = 1 mp[\\\"b\\\"] = 2 if _, exist := mp[\\\"b\\\"]; exist { mp[\\\"b\\\"] = 3 } fmt.Println(mp) }\",\"但是也存在一个特殊情况，那就是键为math.NaN()时\",\"func main() { mp := make(map[float64]string, 10) mp[math.NaN()] = \\\"a\\\" mp[math.NaN()] = \\\"b\\\" mp[math.NaN()] = \\\"c\\\" _, exist := mp[math.NaN()] fmt.Println(exist) fmt.Println(mp) }\",\"false map[NaN:c NaN:a NaN:b]\",\"通过结果可以观察到相同的键值并没有覆盖，反而还可以存在多个，也无法判断其是否存在，也就无法正常取值。因为NaN是IEE754标准所定义的，其实现是由底层的汇编指令UCOMISD完成，这是一个无序比较双精度浮点数的指令，该指令会考虑到NaN的情况，因此结果就是任何数字都不等于NaN，NaN也不等于自身，这也造成了每次哈希值都不相同。关于这一点社区也曾激烈讨论过，但是官方认为没有必要去修改，所以应当尽量避免使用NaN作为map的键。\"]},\"181\":{\"h\":\"删除\",\"t\":[\"func delete(m map[Type]Type1, key Type)\",\"删除一个键值对需要用到内置函数delete，例如\",\"func main() { mp := map[string]int{ \\\"a\\\": 0, \\\"b\\\": 1, \\\"c\\\": 2, \\\"d\\\": 3, } fmt.Println(mp) delete(mp, \\\"a\\\") fmt.Println(mp) }\",\"map[a:0 b:1 c:2 d:3] map[b:1 c:2 d:3]\",\"需要注意的是，如果值为NaN，甚至没法删除该键值对。\",\"func main() { mp := make(map[float64]string, 10) mp[math.NaN()] = \\\"a\\\" mp[math.NaN()] = \\\"b\\\" mp[math.NaN()] = \\\"c\\\" fmt.Println(mp) delete(mp, math.NaN()) fmt.Println(mp) }\",\"map[NaN:c NaN:a NaN:b] map[NaN:c NaN:a NaN:b]\"]},\"182\":{\"h\":\"遍历\",\"t\":[\"通过for range可以遍历map，例如\",\"func main() { mp := map[string]int{ \\\"a\\\": 0, \\\"b\\\": 1, \\\"c\\\": 2, \\\"d\\\": 3, } for key, val := range mp { fmt.Println(key, val) } }\",\"c 2 d 3 a 0 b 1\",\"可以看到结果并不是有序的，也印证了map是无序存储。值得一提的是，NaN虽然没法正常获取，但是可以通过遍历访问到，例如\",\"func main() { mp := make(map[float64]string, 10) mp[math.NaN()] = \\\"a\\\" mp[math.NaN()] = \\\"b\\\" mp[math.NaN()] = \\\"c\\\" for key, val := range mp { fmt.Println(key, val) } }\",\"NaN a NaN c NaN b\"]},\"183\":{\"h\":\"清空\",\"t\":[\"在go1.21之前，想要清空map，就只能对每一个map的key进行delete\",\"func main() { m := map[string]int{ \\\"a\\\": 1, \\\"b\\\": 2, } for k, _ := range m { delete(m, k) } fmt.Println(m) }\",\"但是go1.21更新了clear函数，就不用再进行之前的操作了，只需要一个clear就可以清空\",\"func main() { m := map[string]int{ \\\"a\\\": 1, \\\"b\\\": 2, } clear(m) fmt.Println(m) }\",\"输出\",\"map[]\"]},\"184\":{\"h\":\"Set\",\"t\":[\"Set是一种无序的，不包含重复元素的集合，Go中并没有提供类似的数据结构实现，但是map的键正是无序且不能重复的，所以也可以使用map来替代set。\",\"func main() { set := make(map[int]struct{}, 10) for i := 0; i < 10; i++ { set[rand.Intn(100)] = struct{}{} } fmt.Println(set) }\",\"map[0:{} 18:{} 25:{} 40:{} 47:{} 56:{} 59:{} 81:{} 87:{}]\",\"提示\",\"一个空的结构体不会占用内存\"]},\"185\":{\"h\":\"注意\",\"t\":[\"map并不是一个并发安全的数据结构，Go团队认为大多数情况下map的使用并不涉及高并发的场景，引入互斥锁会极大的降低性能，map内部有读写检测机制，如果冲突会触发fatal error。例如下列情况有非常大的可能性会触发fatal。\",\"func main() { group.Add(10) // map mp := make(map[string]int, 10) for i := 0; i < 10; i++ { go func() { // 写操作 for i := 0; i < 100; i++ { mp[\\\"helloworld\\\"] = 1 } // 读操作 for i := 0; i < 10; i++ { fmt.Println(mp[\\\"helloworld\\\"]) } group.Done() }() } group.Wait() }\",\"fatal error: concurrent map writes\",\"在这种情况下，需要使用sync.Map来替代。\",\"结构体可以存储一组不同类型的数据，是一种复合类型。Go抛弃了类与继承，同时也抛弃了构造方法，刻意弱化了面向对象的功能，Go并非是一个传统OOP的语言，但是Go依旧有着OOP的影子，通过结构体和方法也可以模拟出一个类。下面是一个简单的结构体的例子：\",\"type Programmer struct { Name string Age int Job string Language []string }\"]},\"186\":{\"h\":\"声明\",\"t\":[\"结构体的声明非常简单，例子如下：\",\"type Person struct { name string age int }\",\"结构体本身以及其内部的字段都遵守大小写命名的暴露方式。对于一些类型相同的相邻字段，可以不需要重复声明类型，如下：\",\"type Rectangle struct { height, width, area int color string }\",\"提示\",\"在声明结构体字段时，字段名不能与方法名重复\"]},\"187\":{\"h\":\"实例化\",\"t\":[\"Go不存在构造方法，大多数情况下采用如下的方式来实例化结构体，初始化的时候就像map一样指定字段名称再初始化字段值\",\"programmer := Programmer{ Name: \\\"jack\\\", Age: 19, Job: \\\"coder\\\", Language: []string{\\\"Go\\\", \\\"C++\\\"}, }\",\"不过也可以省略字段名称，当省略字段名称时，就必须初始化所有字段，通常不建议使用这种方式，因为可读性很糟糕。\",\"programmer := Programmer{ \\\"jack\\\", 19, \\\"coder\\\", []string{\\\"Go\\\", \\\"C++\\\"}}\",\"如果实例化过程比较复杂，你也可以编写一个函数来实例化结构体，就像下面这样，你也可以把它理解为一个构造函数\",\"type Person struct { Name string Age int Address string Salary float64 } func NewPerson(name string, age int, address string, salary float64) *Person { return &Person{Name: name, Age: age, Address: address, Salary: salary} }\",\"不过Go并不支持函数与方法重载，所以你无法为同一个函数或方法定义不同的参数。如果你想以多种方式实例化结构体，要么创建多个构造函数，要么建议使用options模式。\"]},\"188\":{\"h\":\"选项模式\",\"t\":[\"选项模式是Go语言中一种很常见的设计模式，可以更为灵活的实例化结构体，拓展性强，并且不需要改变构造函数的函数签名。假设有下面这样一个结构体\",\"type Person struct { Name string Age int Address string Salary float64 Birthday string }\",\"声明一个PersonOptions类型，它接受一个*Person类型的参数，它必须是指针，因为我们要在闭包中对Person赋值。\",\"type PersonOptions func(p *Person)\",\"接下来创建选项函数，它们一般是With开头，它们的返回值就是一个闭包函数。\",\"func WithName(name string) PersonOptions { return func(p *Person) { p.Name = name } } func WithAge(age int) PersonOptions { return func(p *Person) { p.Age = age } } func WithAddress(address string) PersonOptions { return func(p *Person) { p.Address = address } } func WithSalary(salary float64) PersonOptions { return func(p *Person) { p.Salary = salary } }\",\"实际声明的构造函数签名如下，它接受一个可变长PersonOptions类型的参数。\",\"func NewPerson(options ...PersonOptions) *Person { // 优先应用options p := &Person{} for _, option := range options { option(p) } // 默认值处理 if p.Age < 0 { p.Age = 0 } ...... return p }\",\"这样一来对于不同实例化的需求只需要一个构造函数即可完成，只需要传入不同的Options函数即可\",\"func main() { pl := NewPerson( WithName(\\\"John Doe\\\"), WithAge(25), WithAddress(\\\"123 Main St\\\"), WithSalary(10000.00), ) p2 := NewPerson( WithName(\\\"Mike jane\\\"), WithAge(30), ) }\",\"函数式选项模式在很多开源项目中都能看见，gRPC Server的实例化方式也是采用了该设计模式。函数式选项模式只适合于复杂的实例化，如果参数只有简单几个，建议还是用普通的构造函数来解决。\"]},\"189\":{\"h\":\"组合\",\"t\":[\"在Go中，结构体之间的关系是通过组合来表示的，可以显式组合，也可以匿名组合，后者使用起来更类似于继承，但本质上没有任何变化。例如：\",\"显式组合的方式\",\"type Person struct { name string age int } type Student struct { p Person school string } type Employee struct { p Person job string }\",\"在使用时需要显式的指定字段p\",\"student := Student{ p: Person{name: \\\"jack\\\", age: 18}, school: \\\"lili school\\\", } fmt.Println(student.p.name)\",\"而匿名组合可以不用显式的指定字段\",\"type Person struct { name string age int } type Student struct { Person school string } type Employee struct { Person job string }\",\"匿名字段的名称默认为类型名，调用者可以直接访问该类型的字段和方法，但除了更加方便以外与第一种方式没有任何的区别。\",\"student := Student{ Person: Person{name: \\\"jack\\\",age: 18}, school: \\\"lili school\\\", } fmt.Println(student.name)\"]},\"190\":{\"h\":\"指针\",\"t\":[\"对于结构体指针而言，不需要解引用就可以直接访问结构体的内容，例子如下：\",\"p := &Person{ name: \\\"jack\\\", age: 18, } fmt.Println(p.age,p.name)\",\"在编译的时候会转换为(*p).name ，(*p).age，其实还是需要解引用，不过在编码的时候可以省去，算是一种语法糖。\"]},\"191\":{\"h\":\"标签\",\"t\":[\"结构体标签是一种元编程的形式，结合反射可以做出很多奇妙的功能，格式如下\",\"`key1:\\\"val1\\\" key2:\\\"val2\\\"`\",\"标签是一种键值对的形式，使用空格进行分隔。结构体标签的容错性很低，如果没能按照正确的格式书写结构体，那么将会导致无法正常读取，但是在编译时却不会有任何的报错，下方是一个使用示例。\",\"type Programmer struct { Name string `json:\\\"name\\\"` Age int `yaml:\\\"age\\\"` Job string `toml:\\\"job\\\"` Language []string `properties:\\\"language\\\"` }\",\"结构体标签最广泛的应用就是在各种序列化格式中的别名定义，标签的使用需要结合反射才能完整发挥出其功能。\"]},\"192\":{\"h\":\"内存对齐\",\"t\":[\"Go结构体字段的内存分布遵循内存对齐的规则，这么做可以减少CPU访问内存的次数，相应的占用的内存要多一些，属于空间换时间的一种手段。假设有如下结构体\",\"type Num struct { A int64 B int32 C int16 D int8 E int32 }\",\"已知这些类型的占用字节数\",\"int64占8个字节\",\"int32占4个字节\",\"int16占2字节\",\"int8占一个字节\",\"整个结构体的内存占用似乎是8+4+2+1+4=19个字节吗，当然不是这样，根据内存对齐规则而言，结构体的内存占用长度至少是最大字段的整数倍，不足的则补齐。该结构体中最大的是int64占用8个字节，那么内存分布如下图所示\",\"所以实际上是占用24个字节，其中有5个字节是无用的。\",\"再来看下面这个结构体\",\"type Num struct { A int8 B int64 C int8 }\",\"明白了上面的规则后，可以很快的理解它的内存占用也是24个字节，尽管它只有三个字段，足足浪费了14个字节。\",\"但是我们可以调整字段，改成如下的顺序\",\"type Num struct { A int8 C int8 B int64 }\",\"如此一来就占用的内存就变为了16字节，浪费了6个字节，减少了8个字节的内存浪费。\",\"从理论上来说，让结构体中的字段按照合理的顺序分布，可以减少其内存占用。不过实际编码过程中，并没有必要的理由去这样做，它不一定能在减少内存占用这方面带来实质性的提升，但一定会提高开发人员的血压和心智负担，尤其是在业务中一些结构体的字段数可能多大几十个或者数百个，所以仅做了解即可。\",\"提示\",\"如果你真的想通过此种方法来节省内存，可以看看这两个库\",\"BetterAlign\",\"go-tools\",\"他们会检查你的源代码中的结构体，计算并重新排布结构体字段来最小化结构体占用的内存。\"]},\"193\":{\"h\":\"空结构体\",\"t\":[\"空结构体没有字段，不占用内存空间，我们可以通过unsafe.SizeOf函数来计算占用的字节大小\",\"func main() { type Empty struct {} fmt.Println(unsafe.Sizeof(Empty{})) }\",\"输出\",\"0\",\"空结构体的使用场景有很多，比如之前提到过的，作为map的值类型，可以将map作为set来进行使用，又或者是作为通道的类型，表示仅做通知类型的通道。\",\"Go保留了指针，在一定程度上保证了性能，同时为了更好的GC和安全考虑，又限制了指针的使用。\"]},\"194\":{\"h\":\"创建\",\"t\":[\"关于指针有两个常用的操作符，一个是取地址符&，另一个是解引用符*。对一个变量进行取地址，会返回对应类型的指针，例如：\",\"func main() { num := 2 p := &num fmt.Println(p) }\",\"指针存储的是变量num的地址\",\"0xc00001c088\",\"解引用符则有两个用途，第一个是访问指针所指向的元素，也就是解引用，例如\",\"func main() { num := 2 p := &num rawNum := *p fmt.Println(rawNum) }\",\"p是一个指针，对指针类型解引用就能访问到指针所指向的元素。还有一个用途就是声明一个指针，例如：\",\"func main() { var numPtr *int fmt.Println(numPtr) }\",\"<nil>\",\"*int即代表该变量的类型是一个int类型的指针，不过指针不能光声明，还得初始化，需要为其分配内存，否则就是一个空指针，无法正常使用。要么使用取地址符将其他变量的地址赋值给该指针，要么就使用内置函数new手动分配，例如：\",\"func main() { var numPtr *int numPtr = new(int) fmt.Println(numPtr) }\",\"更多的是使用短变量\",\"func main() { numPtr := new(int) fmt.Println(numPtr) }\",\"new函数只有一个参数那就是类型，并返回一个对应类型的指针，函数会为该指针分配内存，并且指针指向对应类型的零值，例如：\",\"func main() { fmt.Println(*new(string)) fmt.Println(*new(int)) fmt.Println(*new([5]int)) fmt.Println(*new([]float64)) }\",\"0 [0 0 0 0 0] []\"]},\"195\":{\"h\":\"禁止指针运算\",\"t\":[\"在Go中是不支持指针运算的，也就是说指针无法偏移，先来看一段C++代码：\",\"int main() { int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int *p = &arr[0]; cout << &arr << endl << p << endl << p + 1 << endl << &arr[1] << endl; }\",\"0x31d99ff880 0x31d99ff880 0x31d99ff884 0x31d99ff884\",\"可以看出数组的地址与数字第一个元素的地址一致，并且对指针加一运算后，其指向的元素为数组第二个元素。Go中的数组也是如此，不过区别在于指针无法偏移，例如\",\"func main() { arr := [5]int{0, 1, 2, 3, 4} p := &arr println(&arr[0]) println(p) // 试图进行指针运算 p++ fmt.Println(p) }\",\"这样的程序将无法通过编译，报错如下\",\"main.go:10:2: invalid operation: p++ (non-numeric type *[5]int)\",\"提示\",\"标准库unsafe提供了许多用于低级编程的操作，其中就包括指针运算，前往标准库-unsafe了解细节。\"]},\"196\":{\"h\":\"new和make\",\"t\":[\"在前面的几节已经很多次提到过内置函数new和make，两者有点类似，但也有不同，下面复习下。\",\"func new(Type) *Type\",\"返回值是类型指针\",\"接收参数是类型\",\"专用于给指针分配内存空间\",\"func make(t Type, size ...IntegerType) Type\",\"返回值是值，不是指针\",\"接收的第一个参数是类型，不定长参数根据传入类型的不同而不同\",\"专用于给切片，映射表，通道分配内存。\",\"下面是一些例子：\",\"new(int) // int指针 new(string) // string指针 new([]int) // 整型切片指针 make([]int, 10, 100) // 长度为10，容量100的整型切片 make(map[string]int, 10) // 容量为10的映射表 make(chan int, 10) // 缓冲区大小为10的通道\",\"在Go中，函数是一等公民，函数是Go最基础的组成部分，也是Go的核心。\"]},\"197\":{\"h\":\"声明\",\"t\":[\"函数的声明格式如下\",\"func 函数名([参数列表]) [返回值] { 函数体 }\",\"声明函数有两种办法，一种是通过func关键字直接声明，另一种就是通过var关键字来声明，如下所示\",\"func sum(a int, b int) int { return a + b } var sum = func(a int, b int) int { return a + b }\",\"函数签名由函数名称，参数列表，返回值组成，下面是一个完整的例子，函数名称为Sum，有两个int类型的参数a，b，返回值类型为int。\",\"func Sum(a int, b int) int { return a + b }\",\"还有一个非常重要的点，即Go中的函数不支持重载，像下面的代码就无法通过编译\",\"type Person struct { Name string Age int Address string Salary float64 } func NewPerson(name string, age int, address string, salary float64) *Person { return &Person{Name: name, Age: age, Address: address, Salary: salary} } func NewPerson(name string) *Person { return &Person{Name: name} }\",\"Go的理念便是：如果签名不一样那就是两个完全不同的函数，那么就不应该取一样的名字，函数重载会让代码变得混淆和难以理解。这种理念是否正确见仁见智，至少在Go中你可以仅通过函数名就知道它是干什么的，而不需要去找它到底是哪一个重载。\"]},\"198\":{\"h\":\"参数\",\"t\":[\"Go中的参数名可以不带名称，一般这种是在接口或函数类型声明时才会用到，不过为了可读性一般还是建议尽量给参数加上名称\",\"type ExWriter func(io.Writer) error type Writer interface { ExWrite([]byte) (int, error) }\",\"对于类型相同的参数而言，可以只需要声明一次类型，不过条件是它们必须相邻\",\"func Log(format string, a1, a2 any) { ... }\",\"变长参数可以接收0个或多个值，必须声明在参数列表的末尾，最典型的例子就是fmt.Printf函数。\",\"func Printf(format string, a ...any) (n int, err error) { return Fprintf(os.Stdout, format, a...) }\",\"值得一提的是，Go中的函数参数是传值传递，即在传递参数时会拷贝实参的值。如果你觉得在传递切片或map时会复制大量的内存，我可以告诉你大可不必担心，因为这两个数据结构本质上都是指针。\"]},\"199\":{\"h\":\"返回值\",\"t\":[\"下面是一个简单的函数返回值的例子，Sum函数返回一个int类型的值。\",\"func Sum(a, b int) int { return a + b }\",\"当函数没有返回值时，不需要void，不带返回值即可。\",\"func ErrPrintf(format string, a ...any) { _, _ = fmt.Fprintf(os.Stderr, format, a...) }\",\"Go允许函数有多个返回值，此时就需要用括号将返回值围起来。\",\"func Div(a, b float64) (float64, error) { if a == 0 { return math.NaN(), errors.New(\\\"0不能作为被除数\\\") } return a / b, nil }\",\"Go也支持具名返回值，不能与参数名重复，使用具名返回值时，return关键字可以不需要指定返回哪些值。\",\"func Sum(a, b int) (ans int) { ans = a + b return }\",\"和参数一样，当有多个同类型的具名返回值时，可以省略掉重复的类型声明\",\"func SumAndMul(a, b int) (c, d int) { c = a + b d = a * b return }\",\"不管具名返回值如何声明，永远都是以return关键字后的值为最高优先级。\",\"func SumAndMul(a, b int) (c, d int) { c = a + b d = a * b // c，d将不会被返回 return a + b, a * b }\"]},\"200\":{\"h\":\"匿名函数\",\"t\":[\"匿名函数就是没有签名的函数，例如下面的函数func(a, b int) int，它没有名称，所以我们只能在它的函数体后紧跟括号来进行调用。\",\"func main() { func(a, b int) int { return a + b }(1, 2) }\",\"在调用一个函数时，当它的参数是一个函数类型时，这时名称不再重要，就可以直接传递一个匿名函数，如下所示\",\"type Person struct { Name string Age int Salary float64 } func main() { people := []Person{ {Name: \\\"Alice\\\", Age: 25, Salary: 5000.0}, {Name: \\\"Bob\\\", Age: 30, Salary: 6000.0}, {Name: \\\"Charlie\\\", Age: 28, Salary: 5500.0}, } slices.SortFunc(people, func(p1 Person, p2 Person) int { if p1.Name > p2.Name { return 1 } else if p1.Name < p2.Name { return -1 } return 0 }) }\",\"这是一个自定义排序规则的例子，slices.SortFunc接受两个参数，一个是切片，另一个就是比较函数，不考虑复用的话，我们就可以直接传递匿名函数。\"]},\"201\":{\"h\":\"闭包\",\"t\":[\"闭包（Closure）这一概念，在一些语言中又被称为Lamda表达式，与匿名函数一起使用，闭包 = 函数 + 环境引用吗，看下面一个例子：\",\"func main() { grow := Exp(2) for i := range 10 { fmt.Printf(\\\"2^%d=%d\\\\n\\\", i, grow()) } } func Exp(n int) func() int { e := 1 return func() int { temp := e e *= n return temp } }\",\"输出\",\"2^0=1 2^1=2 2^2=4 2^3=8 2^4=16 2^5=32 2^6=64 2^7=128 2^8=256 2^9=512\",\"Exp函数的返回值是一个函数，这里将称成为grow函数，每将它调用一次，变量e就会以指数级增长一次。grow函数引用了Exp函数的两个变量：e和n，它们诞生在Exp函数的作用域内，在正常情况下随着Exp函数的调用结束，这些变量的内存会随着出栈而被回收。但是由于grow函数引用了它们，所以它们无法被回收，而是逃逸到了堆上，即使Exp函数的生命周期已经结束了，但变量e和n的生命周期并没有结束，在grow函数内还能直接修改这两个变量，grow函数就是一个闭包函数。\",\"利用闭包，可以非常简单的实现一个求费波那契数列的函数，代码如下\",\"func main() { // 10个斐波那契数 fib := Fib(10) for n, next := fib(); next; n, next = fib() { fmt.Println(n) } } func Fib(n int) func() (int, bool) { a, b, c := 1, 1, 2 i := 0 return func() (int, bool) { if i >= n { return 0, false } else if i < 2 { f := i i++ return f, true } a, b = b, c c = a + b i++ return a, true } }\",\"输出为\",\"0 1 1 2 3 5 8 13 21 34\"]},\"202\":{\"h\":\"延迟调用\",\"t\":[\"defer关键字可以使得一个函数延迟一段时间调用，在函数返回之前这些defer描述的函数最后都会被逐个执行，看下面一个例子\",\"func main() { Do() } func Do() { defer func() { fmt.Println(\\\"1\\\") }() fmt.Println(\\\"2\\\") }\",\"输出\",\"2 1\",\"因为defer是在函数返回前执行的，你也可以在defer中修改函数的返回值\",\"func main() { fmt.Println(sum(3, 5)) } func sum(a, b int) (s int) { defer func() { s -= 10 }() s = a + b return }\",\"当有多个defer描述的函数时，就会像栈一样先进后出的顺序执行。\",\"func main() { fmt.Println(0) Do() } func Do() { defer fmt.Println(1) fmt.Println(2) defer fmt.Println(3) defer fmt.Println(4) fmt.Println(5) }\",\"0 2 5 4 3 1\",\"延迟调用通常用于释放文件资源，关闭网络连接等操作，还有一个用法是捕获panic，不过这是错误处理一节中才会涉及到的东西。\"]},\"203\":{\"h\":\"循环\",\"t\":[\"虽然没有明令禁止，一般建议不要在for循环中使用defer，如下所示\",\"func main() { n := 5 for i := range n { defer fmt.Println(i) } }\",\"输出如下\",\"4 3 2 1 0\",\"这段代码结果是正确的，但过程也许不对。在Go中，每创建一个defer，就需要在当前协程申请一片内存空间。假设在上面例子中不是简单的for n循环，而是一个较为复杂的数据处理流程，当外部请求数突然激增时，那么在短时间内就会创建大量的defer，在循环次数很大或次数不确定时，就可能会导致内存占用突然暴涨，这种我们一般称之为内存泄漏。\"]},\"204\":{\"h\":\"参数预计算\",\"t\":[\"对于延迟调用有一些反直觉的细节，比如下面这个例子\",\"func main() { defer fmt.Println(Fn1()) fmt.Println(\\\"3\\\") } func Fn1() int { fmt.Println(\\\"2\\\") return 1 }\",\"这个坑还是非常隐晦的，笔者以前就因为这个坑，半天排查不出来是什么原因，可以猜猜输出是什么，答案如下\",\"2 3 1\",\"可能很多人认为是下面这种输出\",\"3 2 1\",\"按照使用者的初衷来说，fmt.Println(Fn1())这部分应该是希望它们在函数体执行结束后再执行，fmt.Println确实是最后执行的，但Fn1()是在意料之外的，下面这个例子的情况就更加明显了。\",\"func main() { var a, b int a = 1 b = 2 defer fmt.Println(sum(a, b)) a = 3 b = 4 } func sum(a, b int) int { return a + b }\",\"它的输出一定是3而不是7，如果使用闭包而不是延迟调用，结果又不一样了\",\"func main() { var a, b int a = 1 b = 2 f := func() { fmt.Println(sum(a, b)) } a = 3 b = 4 f() }\",\"闭包的输出是7，那如果把延迟调用和闭包结合起来呢\",\"func main() { var a, b int a = 1 b = 2 defer func() { fmt.Println(sum(a, b)) }() a = 3 b = 4 }\",\"这次就正常了，输出的是7。下面再改一下，没有闭包了\",\"func main() { var a, b int a = 1 b = 2 defer func(num int) { fmt.Println(num) }(sum(a, b)) a = 3 b = 4 }\",\"输出又变回3了。通过对比上面几个例子可以发现这段代码\",\"defer fmt.Println(sum(a,b))\",\"其实等价于\",\"defer fmt.Println(3)\",\"go不会等到最后才去调用sum函数，sum函数早在延迟调用被执行以前就被调用了，并作为参数传递了fmt.Println。总结就是，对于defer直接作用的函数而言，它的参数是会被预计算的，这也就导致了第一个例子中的奇怪现象，对于这种情况，尤其是在延迟调用中将函数返回值作为参数的情况尤其需要注意。\",\"方法与函数的区别在于，方法拥有接收者，而函数没有，且只有自定义类型能够拥有方法。先来看一个例子。\",\"type IntSlice []int func (i IntSlice) Get(index int) int { return i[index] } func (i IntSlice) Set(index, val int) { i[index] = val } func (i IntSlice) Len() int { return len(i) }\",\"先声明了一个类型IntSlice，其底层类型为[]int，再声明了三个方法Get，Set和Len，方法的长相与函数并无太大的区别，只是多了一小段(i IntSlice) 。i就是接收者，IntSlice就是接收者的类型，接收者就类似于其他语言中的this或self，只不过在Go中需要显示的指明。\",\"func main() { var intSlice IntSlice intSlice = []int{1, 2, 3, 4, 5} fmt.Println(intSlice.Get(0)) intSlice.Set(0, 2) fmt.Println(intSlice) fmt.Println(intSlice.Len()) }\",\"方法的使用就类似于调用一个类的成员方法，先声明，再初始化，再调用。\"]},\"205\":{\"h\":\"值接收者\",\"t\":[\"接收者也分两种类型，值接收者和指针接收者，先看一个例子\",\"type MyInt int func (i MyInt) Set(val int) { i = MyInt(val) // 修改了，但是不会造成任何影响 } func main() { myInt := MyInt(1) myInt.Set(2) fmt.Println(myInt) }\",\"上述代码运行过后，会发现myInt的值依旧是1，并没有被修改成2。方法在被调用时，会将接收者的值传入方法中，上例的接收者就是一个值接收者，可以简单的看成一个形参，而修改一个形参的值，并不会对方法外的值造成任何影响，那么如果通过指针调用会如何呢？\",\"func main() { myInt := MyInt(1) (&myInt).Set(2) fmt.Println(myInt) }\",\"遗憾的是，这样的代码依旧不能修改内部的值，为了能够匹配上接收者的类型，Go会将其解引用，解释为(*(&myInt)).Set(2)。\"]},\"206\":{\"h\":\"指针接收者\",\"t\":[\"稍微修改了一下，就能正常修改myInt的值。\",\"type MyInt int func (i *MyInt) Set(val int) { *i = MyInt(val) } func main() { myInt := MyInt(1) myInt.Set(2) fmt.Println(myInt) }\",\"现在的接收者就是一个指针接收者，虽然myInt是一个值类型，在通过值类型调用指针接收者的方法时，Go会将其解释为(&myint).Set(2)。所以方法的接收者为指针时，不管调用者是不是指针，都可以修改内部的值。\",\"函数的参数传递过程中，是值拷贝的，如果传递的是一个整型，那就拷贝这个整型，如果是一个切片，那就拷贝这个切片，但如果是一个指针，就只需要拷贝这个指针，显然传递一个指针比起传递一个切片所消耗的资源更小，接收者也不例外，值接收者和指针接收者也是同样的道理。在大多数情况下，都推荐使用指针接收者，不过两者并不应该混合使用，要么都用，要么就都不用，看下面一个例子。\",\"提示\",\"需要先了解接口\",\"type Animal interface { Run() } type Dog struct { } func (d *Dog) Run() { fmt.Println(\\\"Run\\\") } func main() { var an Animal an = Dog{} // an = &Dog{} 正确方式 an.Run() }\",\"这一段代码将会无法通过编译，编译器将会输出如下错误\",\"cannot use Dog{} (value of type Dog) as type Animal in assignment: Dog does not implement Animal (Run method has pointer receiver)\",\"翻译过来就是，无法使用Dog{}初始化Animal类型的变量，因为Dog没有实现Animal ，解决办法有两种，一是将指针接收者改为值接收者，二是将Dog{}改为&Dog{}，接下来逐个讲解。\",\"type Dog struct { } func (d Dog) Run() { // 改为了值接收者 fmt.Println(\\\"Run\\\") } func main() { // 可以正常运行 var an Animal an = Dog{} // an = &Dog{} 同样可以 an.Run() }\",\"在原来的代码中，Run 方法的接收者是*Dog ，自然而然实现Animal接口的就是Dog指针，而不是Dog结构体，这是两个不同的类型，所以编译器就会认为Dog{}并不是Animal的实现，因此无法赋值给变量an，所以第二种解决办法就是赋值Dog指针给变量an。不过在使用值接收者时，Dog指针依然可以正常赋值给animal，这是因为Go会在适当情况下对指针进行解引用，因为通过指针可以找到Dog结构体，但是反过来的话，无法通过Dog结构体找到Dog指针。如果单纯的在结构体中混用值接收者和指针接收者的话无伤大雅，但是和接口一起使用后，就会出现错误，倒不如无论何时要么都用值接收者，要么就都用指针接收者，形成一个良好的规范，也可以减少后续维护的负担。\",\"还有一种情况，就是当值接收者是可寻址的时候，Go会自动的插入指针运算符来进行调用，例如切片是可寻址，依旧可以通过值接收者来修改其内部值。比如下面这个代码\",\"type Slice []int func (s Slice) Set(i int, v int) { s[i] = v } func main() { s := make(Slice, 1) s.Set(0, 1) fmt.Println(s) }\",\"输出\",\"[1]\",\"但这样会引发另一个问题，如果对其添加元素的话，情况就不同了。看下面的例子\",\"type Slice []int func (s Slice) Set(i int, v int) { s[i] = v } func (s Slice) Append(a int) { s = append(s, a) } func main() { s := make(Slice, 1, 2) s.Set(0, 1) s.Append(2) fmt.Println(s) }\",\"[1]\",\"它的输出还是和之前一样，append函数是有返回值的，向切片添加完元素后必须覆盖原切片，尤其是在扩容后，在方法中对值接收者修改并不会产生任何影响，这也就导致了例子中的结果，改成指针接收者就正常了。\",\"type Slice []int func (s *Slice) Set(i int, v int) { (*s)[i] = v } func (s *Slice) Append(a int) { *s = append(*s, a) } func main() { s := make(Slice, 1, 2) s.Set(0, 1) s.Append(2) fmt.Println(s) }\",\"输出\",\"[1 2]\"]},\"207\":{\"h\":\"接口\",\"t\":[\"接口是一个非常重要的概念，它描述了一组抽象的规范，而不提供具体的实现。对于项目而言会使得代码更加优雅可读，对于开发者而言也会减少很多心智负担，代码风格逐渐形成了规范，于是就有了现在人们所推崇的面向接口编程。\"]},\"208\":{\"h\":\"概念\",\"t\":[\"Go关于接口的发展历史有一个分水岭，在Go1.17及以前，官方在参考手册中对于接口的定义为：一组方法的集合。\",\"An interface type specifies a method set called its interface.\",\"接口实现的定义为\",\"A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface\",\"翻译过来就是，当一个类型的方法集是一个接口的方法集的超集时，且该类型的值可以由该接口类型的变量存储，那么称该类型实现了该接口。\",\"不过在Go1.18时，关于接口的定义发生了变化，接口定义为：一组类型的集合。\",\"An interface type defines a type set.\",\"接口实现的定义为\",\"A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface\",\"翻译过来就是，当一个类型位于一个接口的类型集内，且该类型的值可以由该接口类型的变量存储，那么称该类型实现了该接口。并且还给出了如下的额外定义。\",\"当如下情况时，可以称类型T实现了接口I\",\"T不是一个接口，并且是接口I类型集中的一个元素\",\"T是一个接口，并且T的类型集是接口I类型集的一个子集\",\"如果T实现了一个接口，那么T的值也实现了该接口。\",\"Go在1.18最大的变化就是加入了泛型，新接口定义就是为了泛型而服务的，不过一点也不影响之前接口的使用，同时接口也分为了两类，\",\"基本接口(Basic Interface)：只包含方法集的接口就是基本接口\",\"通用接口(General Interface)：只要包含类型集的接口就是通用接口\",\"什么是方法集，方法集就是一组方法的集合，同样的，类型集就是一组类型的集合。\",\"提示\",\"这一堆概念很死板，理解的时候要根据代码来思考。\"]},\"209\":{\"h\":\"基本接口\",\"t\":[\"前面讲到了基本接口就是方法集，就是一组方法的集合。\"]},\"210\":{\"h\":\"声明\",\"t\":[\"先来看看接口长什么样子。\",\"type Person interface { Say(string) string Walk(int) }\",\"这是一个Person接口，有两个对外暴露的方法Walk和Say，在接口里，函数的参数名变得不再重要，当然如果想加上参数名和返回值名也是允许的。\"]},\"211\":{\"h\":\"初始化\",\"t\":[\"仅仅只有接口是无法被初始化的，因为它仅仅只是一组规范，并没有具体的实现，不过可以被声明。\",\"func main() { var person Person fmt.Println(person) }\",\"输出\",\" <nil>\"]},\"212\":{\"h\":\"实现\",\"t\":[\"先来看一个例子，一个建筑公司想一种特殊规格的起重机，于是给出了起重机的特殊规范和图纸，并指明了起重机应该有起重和吊货的功能，建筑公司并不负责造起重机，只是给出了一个规范，这就叫接口，于是公司A接下了订单，根据自家公司的独门技术造出了绝世起重机并交给了建筑公司，建筑公司不在乎是用什么技术实现的，也不在乎什么绝世起重机，只要能够起重和吊货就行，仅仅只是当作一台普通起重机来用，根据规范提供具体的功能，这就叫实现，。只根据接口的规范来使用功能，屏蔽其内部实现，这就叫面向接口编程。过了一段时间，绝世起重机出故障了，公司A也跑路了，于是公司B依据规范造了一台更厉害的巨无霸起重机，由于同样具有起重和吊货的功能，可以与绝世起重机无缝衔接，并不影响建筑进度，建筑得以顺利完成，内部实现改变而功能不变，不影响之前的使用，可以随意替换，这就是面向接口编程的好处。\",\"接下来会用Go描述上述情形\",\"// 起重机接口 type Crane interface { JackUp() string Hoist() string } // 起重机A type CraneA struct { work int //内部的字段不同代表内部细节不一样 } func (c CraneA) Work() { fmt.Println(\\\"使用技术A\\\") } func (c CraneA) JackUp() string { c.Work() return \\\"jackup\\\" } func (c CraneA) Hoist() string { c.Work() return \\\"hoist\\\" } // 起重机B type CraneB struct { boot string } func (c CraneB) Boot() { fmt.Println(\\\"使用技术B\\\") } func (c CraneB) JackUp() string { c.Boot() return \\\"jackup\\\" } func (c CraneB) Hoist() string { c.Boot() return \\\"hoist\\\" } type ConstructionCompany struct { Crane Crane // 只根据Crane类型来存放起重机 } func (c *ConstructionCompany) Build() { fmt.Println(c.Crane.JackUp()) fmt.Println(c.Crane.Hoist()) fmt.Println(\\\"建筑完成\\\") } func main() { // 使用起重机A company := ConstructionCompany{CraneA{}} company.Build() fmt.Println() // 更换起重机B company.Crane = CraneB{} company.Build() }\",\"输出\",\"使用技术A jackup 使用技术A hoist 建筑完成 使用技术B jackup 使用技术B hoist 建筑完成\",\"上面例子中，可以观察到接口的实现是隐式的，也对应了官方对于基本接口实现的定义：方法集是接口方法集的超集，所以在Go中，实现一个接口不需要implements关键字显式的去指定要实现哪一个接口，只要是实现了一个接口的全部方法，那就是实现了该接口。有了实现之后，就可以初始化接口了，建筑公司结构体内部声明了一个Crane类型的成员变量，可以保存所有实现了Crane接口的值，由于是Crane 类型的变量，所以能够访问到的方法只有JackUp 和Hoist，内部的其他方法例如Work和Boot都无法访问。\",\"之前提到过任何自定义类型都可以拥有方法，那么根据实现的定义，任何自定义类型都可以实现接口，下面举几个比较特殊的例子。\",\"type Person interface { Say(string) string Walk(int) } type Man interface { Exercise() Person }\",\"Man接口方法集是Person的超集，所以Man也实现了接口Person，不过这更像是一种\\\"继承\\\"。\",\"type Number int func (n Number) Say(s string) string { return \\\"bibibibibi\\\" } func (n Number) Walk(i int) { fmt.Println(\\\"can not walk\\\") }\",\"类型Number的底层类型是int，虽然这放在其他语言中看起来很离谱，但Number的方法集确实是Person 的超集，所以也算实现。\",\"type Func func() func (f Func) Say(s string) string { f() return \\\"bibibibibi\\\" } func (f Func) Walk(i int) { f() fmt.Println(\\\"can not walk\\\") } func main() { var function Func function = func() { fmt.Println(\\\"do somthing\\\") } function() }\",\"同样的，函数类型也可以实现接口。\"]},\"213\":{\"h\":\"空接口\",\"t\":[\"type Any interface{ }\",\"Any接口内部没有方法集合，根据实现的定义，所有类型都是Any接口的的实现，因为所有类型的方法集都是空集的超集，所以Any接口可以保存任何类型的值。\",\"func main() { var anything Any anything = 1 println(anything) fmt.Println(anything) anything = \\\"something\\\" println(anything) fmt.Println(anything) anything = complex(1, 2) println(anything) fmt.Println(anything) anything = 1.2 println(anything) fmt.Println(anything) anything = []int{} println(anything) fmt.Println(anything) anything = map[string]int{} println(anything) fmt.Println(anything) }\",\"输出\",\"(0xe63580,0xeb8b08) 1 (0xe63d80,0xeb8c48) something (0xe62ac0,0xeb8c58) (1+2i) (0xe62e00,0xeb8b00) 1.2 (0xe61a00,0xc0000080d8) [] (0xe69720,0xc00007a7b0) map[]\",\"通过输出会发现，两种输出的结果不一致，其实接口内部可以看成是一个由(val,type)组成的元组，type是具体类型，在调用方法时会去调用具体类型的具体值。\",\"interface{}\",\"这也是一个空接口，不过是一个匿名空接口，在开发时通常会使用匿名空接口来表示接收任何类型的值，例子如下\",\"func main() { DoSomething(map[int]string{}) } func DoSomething(anything interface{}) interface{} { return anything }\",\"在后续的更新中，官方提出了另一种解决办法，为了方便起见，可以使用any来替代interace{}，两者是完全等价的，因为前者仅仅只是一个类型别名，如下\",\"type any = interface{}\",\"在比较空接口时，会对其底层类型进行比较，如果类型不匹配的话则为false，其次才是值的比较，例如\",\"func main() { var a interface{} var b interface{} a = 1 b = \\\"1\\\" fmt.Println(a == b) a = 1 b = 1 fmt.Println(a == b) }\",\"输出为\",\"false true\",\"如果底层的类型是不可比较的，那么会panic，对于Go而言，内置数据类型是否可比较的情况如下\",\"类型\",\"可比较\",\"依据\",\"数字类型\",\"是\",\"值是否相等\",\"字符串类型\",\"是\",\"值是否相等\",\"数组类型\",\"是\",\"数组的全部元素是否相等\",\"切片类型\",\"否\",\"不可比较\",\"结构体\",\"是\",\"字段值是否全部相等\",\"map类型\",\"否\",\"不可比较\",\"通道\",\"是\",\"地址是否相等\",\"指针\",\"是\",\"指针存储的地址是否相等\",\"接口\",\"是\",\"底层所存储的数据是否相等\",\"在Go中有一个专门的接口类型用于代表所有可比较类型，即comparable\",\"type comparable interface{ comparable }\",\"提示\",\"如果尝试对不可比较的类型进行比较，则会panic\"]},\"214\":{\"h\":\"通用接口\",\"t\":[\"通用接口就是为了泛型服务的，只要掌握了泛型，就掌握了通用接口，请移步泛型\"]},\"215\":{\"h\":\"CGO\",\"t\":[\"由于go需要GC，对于一些性能要求更高的场景，go可能不太适合处理，c作为传统的系统编程语言性能是非常优秀的，而cgo可以将两者联系起来，相互调用，让go调用c，将性能敏感的任务交给c去完成，go负责处理上层逻辑，cgo同样支持c调用go，不过这种场景比较少见，也不太建议这么做。\",\"提示\",\"文中代码演示的环境是win10，命令行用的是gitbash，windows用户建议提前安装好mingw。\",\"关于cgo，官方有一个简单的介绍：C? Go? Cgo! - The Go Programming Language，如果想要更详细的介绍，可以在标准库cmd/cgo/doc.go中获取更加详细的信息，或者也可以直接看文档cgo command - cmd/cgo - Go Packages，两者内容是完全一样的。\"]},\"216\":{\"h\":\"代码调用\",\"t\":[\"看下面一个例子\",\"package main //#include <stdio.h> import \\\"C\\\" func main() { C.puts(C.CString(\\\"hello, cgo!\\\")) }\",\"想要使用cgo特性，通过导入语句import \\\"C\\\"即可开启，需要注意的是C必须是大写字母，且导入名称无法被重写，同时需要确保环境变量CGO_ENABLED是否设置为1，在默认情况下该环境变量是默认启用的。\",\"$ go env | grep CGO $ go env -w CGO_ENABLED=1\",\"除此之外，还需要确保本地拥有C/C++的构建工具链，也就是gcc，在windows平台就是mingw，这样才能确保程序正常通过编译。执行如下命令进行编译，开启了cgo以后编译时间是要比纯go要更久的。\",\"$ go build -o ./ main.go $ ./main.exe hello, cgo!\",\"另外要注意的一个点就是，开启cgo以后，将无法支持交叉编译。\"]},\"217\":{\"h\":\"go嵌入c代码\",\"t\":[\"cgo支持直接把c代码写在go源文件中，然后直接调用，看下面的例子，例子中编写了一个名为printSum的函数，然后在go中的main函数进行调用。\",\"package main /* #include <stdio.h> void printSum(int a, int b) { printf(\\\"c:%d+%d=%d\\\",a,b,a+b); } */ import \\\"C\\\" func main() { C.printSum(C.int(1), C.int(2)) }\",\"输出\",\"c:1+2=3\",\"这适用于简单的场景，如果c代码非常多，跟go代码糅杂在一起十分降低可读性，就不太适合这么做。\",\"错误处理\",\"在go语言中错误处理以返回值的形式返回，但c语言不允许有多返回值，为此可以使用c中的errno，表示在函数调用期间发生了错误，cgo对此做了兼容，在调用c函数时可以像go一样用返回值来处理错误。要使用errno，首先引入errno.h，看下面的一个例子\",\"package main /* #include <stdio.h> #include <stdint.h> #include <errno.h> int32_t sum_positive(int32_t a, int32_t b) { if (a <= 0 || b <= 0) { errno = EINVAL; return 0; } return a + b; } */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"reflect\\\" ) func main() { sum, err := C.sum_positive(C.int32_t(0), C.int32_t(1)) if err != nil { fmt.Println(reflect.TypeOf(err)) fmt.Println(err) return } fmt.Println(sum) }\",\"输出\",\"syscall.Errno The device does not recognize the command.\",\"可以看到它的错误类型是syscall.Errno，errno.h中还定义了其它很多错误代码，可以自己去了解。\"]},\"218\":{\"h\":\"go引入c文件\",\"t\":[\"通过引入c文件，就可以很好的解决上述的问题，首先创建一个头文件sum.h，内容如下\",\"int sum(int a, int b);\",\"然后再创建sum.c，编写具体的函数\",\"#include \\\"sum.h\\\" int sum(int a, int b) { return a + b; }\",\"然后在main.go中导入头文件\",\"package main //#include \\\"sum.h\\\" import \\\"C\\\" import \\\"fmt\\\" func main() { res := C.sum(C.int(1), C.int(2)) fmt.Printf(\\\"cgo sum: %d\\\\n\\\", res) }\",\"现在进行编译的话，必须要指定当前文件夹，否则找不到c文件，如下\",\"$ go build -o sum.exe . && ./sum.exe cgo sum: 3\",\"代码中res是go中的一个变量，C.sum是c语言中的函数，它的返回值是c语言中的int而非go中的int，之所以能成功调用，是因为cgo从中做了类型转换。\"]},\"219\":{\"h\":\"c调用go\",\"t\":[\"c调用go，指的是在cgo中c调用go，而非原生的c程序调用go，它们是这样一个调用链go-cgo-c->cgo->go。go调用c是为了利用c的生态和性能，几乎没有原生的c程序调用go这种需求，如果有的话也建议通过网络通信来代替。\",\"cgo支持导出go函数让c调用，如果要导出go函数，需在函数签名上方加上//export func_name注释，并且其参数和返回值都得是cgo支持的类型，例子如下\",\"//export sum func sum(a, b C.int32_t) C.int32_t { return a + b }\",\"改写刚刚的sum.c文件为如下内容\",\"#include <stdint.h> #include <stdio.h> #include \\\"sum.h\\\" #include \\\"_cgo_export.h\\\" extern int32_t sum(int32_t a, int32_t b); void do_sum() { int32_t a = 10; int32_t b = 10; int32_t c = sum(a, b); printf(\\\"%d\\\", c); }\",\"同时修改头文件sum.h\",\"void do_sum();\",\"然后在go中导出函数\",\"package main /* #include <stdio.h> #include <stdint.h> #include \\\"sum.h\\\" */ import \\\"C\\\" func main() { C.do_sum() } //export sum func sum(a, b C.int32_t) C.int32_t { return a + b }\",\"现在c中使用的sum函数实际上是go提供的，输出结果如下\",\"20\",\"关键点在于sum.c文件中导入的_cgo_export.h，它包含了有关所有go导出的类型，如果不导入的话就无法使用go导出的函数。另一个注意点是_cgo_export.h不能在go文件导入，因为该头文件生成的前提是所有go源文件能够通过编译。因此下面这种写法是错误的\",\"package main /* #include <stdint.h> #include <stdio.h> #include \\\"_cgo_export.h\\\" void do_sum() { int32_t a = 10; int32_t b = 10; int32_t c = sum(a, b); printf(\\\"%d\\\", c); } */ import \\\"C\\\" func main() { C.do_sum() } //export sum func sum(a, b C.int32_t) C.int32_t { return a + b }\",\"编译器会提示头文件不存在\",\"fatal error: _cgo_export.h: No such file or directory #include \\\"_cgo_export.h\\\" ^~~~~~~~~~~~~~~ compilation terminated.\",\"倘若go函数具有多个返回值，那么c调用时将返回一个结构体。\",\"顺带一提，我们可以把go指针通过c函数参数传递给c，在c函数调用期间cgo会尽量保证内存安全，但是导出的go函数返回值不能带指针，因为在这种情况下cgo没法判断其是否被引用，也不好固定内存，如果返回的内存被引用了，然后在go中这段内存被GC掉了或者发生偏移，将导致指针越界，如下所示。\",\"//export newCharPtr func newCharPtr() *C.char { return new(C.char) }\",\"上面的写法默认是不允许通过编译的，如果想要关闭这个检查，可以如下设置。\",\"GODEBUG=cgocheck=0\",\"它有两种检查级别，可以设为1，2，级别越高检查造成运行时开销越大，可以 前往cgo command - passing_pointer了解细节。\"]},\"220\":{\"h\":\"类型转换\",\"t\":[\"cgo对c与go之间的类型做了一个映射，方便它们在运行时调用。对于c中的类型，在go中导入import \\\"C\\\"之后，大部分情况下可以通过\",\"C.typename\",\"这种方式来直接访问，比如\",\"C.int(1) C.char('a')\",\"但c语言类型可以由多个关键字组成，比如\",\"unsigned char\",\"这种情况就没法直接访问了，不过可以使用c中的typedef关键字来给类型取个别名，其功能等同于go中的类型别名。如下\",\"typedef unsigned char byte;\",\"这样一来，就可以通过C.byte来访问类型unsigned char了。例子如下\",\"package main /* #include <stdio.h> typedef unsigned char byte; void printByte(byte b) { printf(\\\"%c\\\\n\\\",b); } */ import \\\"C\\\" func main() { C.printByte(C.byte('a')) C.printByte(C.byte('b')) C.printByte(C.byte('c')) }\",\"输出\",\"a b c\",\"大部分情况下，cgo给常用类型（基本类型之类的）已经取好了别名，也可以根据上述的方法自己定义，不会冲突。\"]},\"221\":{\"h\":\"char\",\"t\":[\"c中的char对应go中的int8类型，unsigned char对应go中的uint8也就是byte类型。\",\"package main /* #include <stdio.h> #include<complex.h> char ch; char get() { return ch; } void set(char c) { ch = c; } */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"reflect\\\" ) func main() { C.set(C.char('c')) res := C.get() fmt.Printf(\\\"type: %s, val: %v\\\", reflect.TypeOf(res), res) }\",\"输出\",\"type: main._Ctype_char, val: 99\",\"如果将set的参数换成C.char(math.MaxInt8 + 1)，那么编译就会失败，并提示如下错误\",\"cannot convert math.MaxInt8 + 1 (untyped int constant 128) to type _Ctype_char\"]},\"222\":{\"h\":\"字符串\",\"t\":[\"cgo提供了一些伪函数用于在c和go之间传递字符串和字节切片，这些函数实际上并不存在，你也没法找到它们的定义，就跟import \\\"C\\\"一样，C这个包也是不存在的，只是为了方便开发者使用，在编译后它们会被转换成其它的操作。\",\"// Go string to C string // The C string is allocated in the C heap using malloc. // It is the caller's responsibility to arrange for it to be // freed, such as by calling C.free (be sure to include stdlib.h // if C.free is needed). func C.CString(string) *C.char // Go []byte slice to C array // The C array is allocated in the C heap using malloc. // It is the caller's responsibility to arrange for it to be // freed, such as by calling C.free (be sure to include stdlib.h // if C.free is needed). func C.CBytes([]byte) unsafe.Pointer // C string to Go string func C.GoString(*C.char) string // C data with explicit length to Go string func C.GoStringN(*C.char, C.int) string // C data with explicit length to Go []byte func C.GoBytes(unsafe.Pointer, C.int) []byte\",\"go中的字符串本质上是一个结构体，里面持有着一个底层数组的引用，在传递给c函数时，需要使用C.CString()在c中使用malloc创建一个“字符串”，为其分配内存空间，然后返回一个c指针，因为c中没有字符串这个类型，通常会使用char*来表示字符串，也就是一个字符数组的指针，使用完毕后记得使用free释放内存。\",\"package main /* #include <stdio.h> #include <stdlib.h> void printfGoString(char* s) { puts(s); } */ import \\\"C\\\" import \\\"unsafe\\\" func main() { cstring := C.CString(\\\"this is a go string\\\") C.printfGoString(cstring) C.free(unsafe.Pointer(cstring)) }\",\"也可以是char数组类型，两者其实都一样，都是指向头部元素的指针。\",\"void printfGoString(char s[]) { puts(s); }\",\"也可以传递字节切片，由于C.CBytes()会返回一个unsafe.Pointer，在传递给c函数之前要将其转换为*C.char类型。\",\"package main /* #include <stdio.h> #include <stdlib.h> void printfGoString(char* s) { puts(s); } */ import \\\"C\\\" import \\\"unsafe\\\" func main() { cbytes := C.CBytes([]byte(\\\"this is a go string\\\")) C.printfGoString((*C.char)(cbytes)) C.free(unsafe.Pointer(cbytes)) }\",\"上面的例子输出都是一样的\",\"this is a go string\",\"上述这几种字符串传递方法涉及到了一次内存拷贝，在传递过后实际上是在c内存和go内存中各自保存了一份，这样做会更安全。话虽如此，我们依然可以直接传递指针给c函数，也可以在c中直接修改go中的字符串，看下面的例子\",\"package main /* #include <stdio.h> #include <stdlib.h> void printfGoString(char* s) { puts(s); } */ import \\\"C\\\" import \\\"unsafe\\\" func main() { ptr := unsafe.Pointer(unsafe.SliceData([]byte(\\\"this is a go string\\\"))) C.printfGoString((*C.char)(ptr)) }\",\"输出\",\"this is a go string\",\"例子通过unsafe.SliceData直接获取了字符串底层数组的指针，并将其转换为了c指针后传递给c函数，该字符串的内存是由go进行管理的，自然也就不再需要free，这样做的好处就是传递的过程不再需要拷贝，但有一定的风险。下面的例子演示了在c中修改go中的字符串\",\"package main /* #include <stdio.h> #include <stdlib.h> void printfGoString(char* s, int len) { puts(s); s[8] = 'c'; puts(s); } */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"unsafe\\\" ) func main() { var buf []byte buf = []byte(\\\"this is a go string\\\") ptr := unsafe.Pointer(unsafe.SliceData(buf)) C.printfGoString((*C.char)(ptr), C.int(len(buf))) fmt.Println(string(buf)) }\",\"输出\",\"this is a go string this is c go string this is c go string\"]},\"223\":{\"h\":\"整数\",\"t\":[\"go与c之间的整数映射关系如下表所示，关于整数的类型映射还在可以在标准库cmd/cgo/gcc.go看到一些相关信息。\",\"go\",\"c\",\"cgo\",\"int8\",\"singed char\",\"C.schar\",\"uint8\",\"unsigned char\",\"C.uchar\",\"int16\",\"short\",\"C.short\",\"uint16\",\"unsigned short\",\"C.ushort\",\"int32\",\"int\",\"C.int\",\"uint32\",\"unsigned int\",\"C.uint\",\"int32\",\"long\",\"C.long\",\"uint32\",\"unsigned long\",\"C.ulong\",\"int64\",\"long long int\",\"C.longlong\",\"uint64\",\"unsigned long long int\",\"C.ulonglong\",\"示例代码如下\",\"package main /* #include <stdio.h> void printGoInt8(signed char n) { printf(\\\"%d\\\\n\\\",n); } void printGoUInt8(unsigned char n) { printf(\\\"%d\\\\n\\\",n); } void printGoInt16(signed short n) { printf(\\\"%d\\\\n\\\",n); } void printGoUInt16(unsigned short n) { printf(\\\"%d\\\\n\\\",n); } void printGoInt32(signed int n) { printf(\\\"%d\\\\n\\\",n); } void printGoUInt32(unsigned int n) { printf(\\\"%d\\\\n\\\",n); } void printGoInt64(signed long long int n) { printf(\\\"%ld\\\\n\\\",n); } void printGoUInt64(unsigned long long int n) { printf(\\\"%ld\\\\n\\\",n); } */ import \\\"C\\\" func main() { C.printGoInt8(C.schar(1)) C.printGoInt8(C.schar(1)) C.printGoInt16(C.short(1)) C.printGoUInt16(C.ushort(1)) C.printGoInt32(C.int(1)) C.printGoUInt32(C.uint(1)) C.printGoInt64(C.longlong(1)) C.printGoUInt64(C.ulonglong(1)) }\",\"cgo同时也对<stdint.h>的整数类型提供了支持，这里的类型内存大小更为清晰明确，而且其命名风格也与go非常相似。\",\"go\",\"c\",\"cgo\",\"int8\",\"int8_t\",\"C.int8_t\",\"uint8\",\"uint8_t\",\"C.uint8_t\",\"int16\",\"int16_t\",\"C.int16_t\",\"uint16\",\"uint16_t\",\"C.uint16_t\",\"int32\",\"int32_t\",\"C.int32_t\",\"uint32\",\"uint32_t\",\"C.uint32_t\",\"int64\",\"int64_t\",\"C.int64_t\",\"uint64\",\"uint64_t\",\"C.uint64_t\",\"在使用cgo时，建议使用<stdint.h>中的整数类型。\"]},\"224\":{\"h\":\"浮点数\",\"t\":[\"go与c的浮点数类型映射如下\",\"go\",\"c\",\"cgo\",\"float32\",\"float\",\"C.float\",\"float64\",\"double\",\"C.double\",\"代码示例如下\",\"package main /* #include <stdio.h> void printGoFloat32(float n) { printf(\\\"%f\\\\n\\\",n); } void printGoFloat64(double n) { printf(\\\"%lf\\\\n\\\",n); } */ import \\\"C\\\" func main() { C.printGoFloat32(C.float(1.11)) C.printGoFloat64(C.double(3.14)) }\"]},\"225\":{\"h\":\"切片\",\"t\":[\"切片的情况的实际上跟上面讲到的字符串差不多，不过区别在于cgo没有提供伪函数来对切片进行拷贝，想让c访问到go中的切片就只能把切片的指针传过去。看下面的一个例子\",\"package main /* #include <stdio.h> #include <stdint.h> void printInt32Arr(int32_t* s, int32_t len) { for (int32_t i = 0; i < len; i++) { printf(\\\"%d \\\", s[i]); } } */ import \\\"C\\\" import ( \\\"unsafe\\\" ) func main() { var arr []int32 for i := 0; i < 10; i++ { arr = append(arr, int32(i)) } ptr := unsafe.Pointer(unsafe.SliceData(arr)) C.printInt32Arr((*C.int32_t)(ptr), C.int(len(arr))) }\",\"输出\",\"0 1 2 3 4 5 6 7 8 9\",\"这里将切片的底层数组的指针传递给了c函数，由于该数组的内存是由go管理，不建议c长期持有其指针引用。反过来，将c的数组作为go切片的底层数组的例子如下\",\"package main /* #include <stdio.h> #include <stdint.h> int32_t s[] = {1, 2, 3, 4, 5, 6, 7}; */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"unsafe\\\" ) func main() { l := unsafe.Sizeof(C.s) / unsafe.Sizeof(C.s[0]) fmt.Println(l) goslice := unsafe.Slice(&C.s[0], l) for i, e := range goslice { fmt.Println(i, e) } }\",\"输出\",\"7 0 1 1 2 2 3 3 4 4 5 5 6 6 7\",\"通过unsafe.Slice函数可以将数组指针转换为切片，按照直觉来说，c中的数组就是一个指向头部元素的指针，按照常理来说应该这样使用\",\"goslice := unsafe.Slice(&C.s, l)\",\"通过输出可以看到，如果这样做的话，除了第一个元素，剩下的内存全都越界了。\",\"0 [1 2 3 4 5 6 7] 1 [0 -1 0 0 0 3432824 0] 2 [0 0 -1 -1 0 0 -1] 3 [0 0 0 255 0 0 0] 4 [2 0 0 0 3432544 0 0] 5 [0 3432576 0 3432592 0 3432608 0] 6 [0 0 3432624 0 0 0 1422773729]\",\"即便c中的数组只是一个头指针，经过cgo包裹了一下就成了go数组，有了自己的地址，所以应该对数组头部元素取址。\",\"goslice := unsafe.Slice(&C.s[0], l)\"]},\"226\":{\"h\":\"结构体\",\"t\":[\"通过C.struct_前缀加上结构体名称，就可以访问c结构体，c结构体无法被当作匿名结构体嵌入go结构体。下面是一个简单的c结构体的例子\",\"package main /* #include <stdio.h> #include <stdint.h> struct person { int32_t age; char* name; }; */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"reflect\\\" ) func main() { var p C.struct_person p.age = C.int32_t(18) p.name = C.CString(\\\"john\\\") fmt.Println(reflect.TypeOf(p)) fmt.Printf(\\\"%+v\\\", p) }\",\"输出\",\"main._Ctype_struct_person {age:18 name:0x1dd043b6e30}\",\"如果c结构体的某些成员包含bit-field，cgo就会忽略这类结构体成员，比如将person修改为下面这种\",\"struct person { int32_t age: 1; char* name; };\",\"再次执行就会报错\",\"p.age undefined (type _Ctype_struct_person has no field or method age)\",\"c和go的结构体字段的内存对齐规则并不相同，如果开启了cgo，大部分情况下会以c为主导。\"]},\"227\":{\"h\":\"联合体\",\"t\":[\"使用C.union_加上名称就可以访问c中的联合体，由于go并不支持联合体，它们在go中会以字节数组的形式存在。下面是一个简单的例子\",\"package main /* #include <stdio.h> #include <stdint.h> union data { int32_t age; char ch; }; */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"reflect\\\" ) func main() { var u C.union_data fmt.Println(reflect.TypeOf(u), u) }\",\"输出\",\"[4]uint8 [0 0 0 0]\",\"通过unsafe.Pointer可以进行访问和修改\",\"func main() { var u C.union_data ptr := (*C.int32_t)(unsafe.Pointer(&u)) fmt.Println(*ptr) *ptr = C.int32_t(1024) fmt.Println(*ptr) fmt.Println(u) }\",\"输出\",\"0 1024 [0 4 0 0]\"]},\"228\":{\"h\":\"枚举\",\"t\":[\"通过前缀C.enum_加上枚举类型名就可以访问c中的枚举类型。下面是一个简单的例子\",\"package main /* #include <stdio.h> #include <stdint.h> enum player_state { alive, dead, }; */ import \\\"C\\\" import \\\"fmt\\\" type State C.enum_player_state func (s State) String() string { switch s { case C.alive: return \\\"alive\\\" case C.dead: return \\\"dead\\\" default: return \\\"unknown\\\" } } func main() { fmt.Println(C.alive, State(C.alive)) fmt.Println(C.dead, State(C.dead)) }\",\"输出\",\"0 alive 1 dead\"]},\"229\":{\"h\":\"指针\",\"t\":[\"谈到了指针避不开内存，cgo之间相互调用最大的问题就是两门语言的内存模型并不相同，c语言的内存完全是由开发者手动管理，用malloc()分配内存，free()释放内存，如果不去手动释放，它是绝对不会自己释放掉的，所以c的内存管理是非常稳定的。而go就不一样了，它带有GC，并且Goroutine的栈空间是会动态调整的，当栈空间不足时会进行增长，那么这样一来，内存地址就可能发生了变化，跟上图一样（图画的并不严谨），指针可能就成了c中常见的悬挂指针。即便cgo在大多数情况可以避免内存移动（由runtime.Pinner来固定内存），但go官方也不建议在c中长期引用go的内存。但是反过来，go中的指针引用c中的内存的话，是比较安全的，除非手动调用C.free()，否则这块内存是不会被自动释放掉的。\",\"如果要在c和go之间传递指针，就需要先将其转为unsafe.Pointer，然后再转换成对应的指针类型，就跟c中的void*一样。看两个例子，第一个是c指针引用go变量的例子，而且还对变量做了修改。\",\"package main /* #include <stdio.h> #include <stdint.h> void printNum(int32_t* s) { printf(\\\"%d\\\\n\\\", *s); *s = 3; printf(\\\"%d\\\\n\\\", *s); } */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"unsafe\\\" ) func main() { var num int32 = 1 ptr := unsafe.Pointer(&num) C.printNum((*C.int32_t)(ptr)) fmt.Println(num) }\",\"输出\",\"1 3 3\",\"第二个是go指针引用c变量，并对其修改的例子。\",\"package main /* #include <stdio.h> #include <stdint.h> int32_t num = 10; */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"unsafe\\\" ) func main() { fmt.Println(C.num) ptr := unsafe.Pointer(&C.num) iptr := (*int32)(ptr) *iptr++ fmt.Println(C.num) }\",\"输出\",\"10 11\",\"顺带一提，cgo不支持c中的函数指针。\"]},\"230\":{\"h\":\"链接库\",\"t\":[\"c语言并没有像go这样的依赖管理，想要直接使用别人写好的库除了直接获取源代码之外，还有个办法就是静态链接库和动态链接库，cgo也支持这些，得益于此，我们就可以在go程序中导入别人写好的库，而不需要源代码。\"]},\"231\":{\"h\":\"动态链接库\",\"t\":[\"动态链接库无法单独运行，它在运行时会与可执行文件一起加载到内存中，下面演示制作一个简单的动态链接库，并使用cgo进行调用。首先准备一个lib/sum.c文件，内容如下\",\"#include <stdint.h> int32_t sum(int32_t a, int32_t b) { return a + b; }\",\"编写头文件lib/sum.h\",\"#include <stdint.h> int sum(int32_t a, int32_t b);\",\"接下来使用gcc来制作动态链接库，首先编译生成目标文件\",\"$ cd lib $ gcc -c sum.c -o sum.o\",\"然后制作动态链接库\",\"$ gcc -shared -o libsum.dll sum.o\",\"制作完成后，然后在go代码中引入sum.h头文件，并且还得通过宏告诉cgo去哪里寻找库文件\",\"package main /* #cgo CFLAGS: -I ./lib #cgo LDFLAGS: -L${SRCDIR}/lib -llibsum #include \\\"sum.h\\\" */ import \\\"C\\\" import \\\"fmt\\\" func main() { res := C.sum(C.int32_t(1), C.int32_t(2)) fmt.Println(res) }\",\"CFLAGS: -I指的是搜索头文件的相对路径，\",\"-L指的是库搜索路径，${SRCDIR}代指当前路径的绝对路径，因为它的参数必须是绝对路径\",\"-l指的是库文件的名称，sum就是sum.dll。\",\"CFFLAGS和LDFLAGS这两个都是gcc的编译选项，出安全考虑，cgo禁用了一些参数，前往cgo command了解细节。\",\"把动态库放到exe的同级目录下\",\"$ ls go.mod go.sum lib/ libsum.dll* main.exe* main.go\",\"最后编译go程序并执行\",\"$ go build main.go && ./main.exe 3\",\"到此动态链接库调用成功。\"]},\"232\":{\"h\":\"静态链接库\",\"t\":[\"不同于动态链接库，使用cgo导入静态链接库时，它会与go的目标文件最终链接成一个可执行文件。还是拿sum.c举例，先将源文件编译成目标文件\",\"$ gcc -o sum.o -c sum.c\",\"然后将目标文件打包成静态链接库（必须是lib前缀开头，不然会找不到）\",\"$ ar rcs libsum.a sum.o\",\"go文件内容\",\"package main /* #cgo CFLAGS: -I ./lib #cgo LDFLAGS: -L${SRCDIR}/lib -llibsum #include \\\"sum.h\\\" */ import \\\"C\\\" import \\\"fmt\\\" func main() { res := C.sum(C.int32_t(1), C.int32_t(2)) fmt.Println(res) }\",\"编译\",\"$ go build && ./main.exe 3\",\"到此，静态链接库调用成功。\"]},\"233\":{\"h\":\"最后\",\"t\":[\"虽然使用cgo的出发点是为了性能，但在c与go之间切换也会不小的造成性能损失，对于一些十分简单的任务，cgo的效率并不如纯go。看一个例子\",\"package main /* #include <stdint.h> int32_t cgo_sum(int32_t a, int32_t b) { return a + b; } */ import \\\"C\\\" import ( \\\"fmt\\\" \\\"time\\\" ) func go_sum(a, b int32) int32 { return a + b } func testSum(N int, do func()) int64 { var sum int64 for i := 0; i < N; i++ { start := time.Now() do() sum += time.Now().Sub(start).Nanoseconds() } return sum / int64(N) } func main() { N := 1000_000 nsop1 := testSum(N, func() { C.cgo_sum(C.int32_t(1), C.int32_t(2)) }) fmt.Printf(\\\"cgo_sum: %d ns/op\\\\n\\\", nsop1) nsop2 := testSum(N, func() { go_sum(1, 2) }) fmt.Printf(\\\"pure_go_sum: %d ns/op\\\\n\\\", nsop2) }\",\"这是一个非常简单的测试，分别用c和go编写了一个两数求和的函数，然后各自运行100w次，求其平均耗时，测试结果如下\",\"cgo_sum: 49 ns/op pure_go_sum: 2 ns/op\",\"从结果可以看到，cgo的平均耗时是纯go的二十几倍，倘若执行的不是单纯的两数相加，而是一个比较耗时的任务，cgo的优势会更大一些。除此之外，使用cgo还有以下缺点\",\"许多go配套工具链将无法使用，比如gotest，pprof，上面的测试例子就不能使用gotest，只能自己手写。\",\"编译速度变慢，自带的交叉编译也没法用了\",\"内存安全问题\",\"依赖问题，如果别人用了你的库，等于也要开启cgo。\",\"在没有考虑周全之前，不要在项目中引入cgo，对于一些十分复杂的任务，使用cgo确实可以带来好处，但如果只是一些简单的任务，还是老老实实用go吧。\"]},\"234\":{\"h\":\"性能分析\",\"t\":[\"当一个程序编写完毕后，我们对它的要求不仅仅只是能运行，还希望它是一个稳定高效的应用。通过各种各样的测试，我们可以保证程序大部分的稳定性，而程序是否高效，就需要我们对其进行性能分析，在此前的内容中，性能分析的唯一手段就只能通过Benchmark来测试某一个功能单元的平均执行耗时，内存分配情况等，然而现实中对程序性能分析的需求远远不止于此，有时候我们需要分析程序整体的CPU占用，内存占用，堆分配情况，协程状态，热点代码路径等等，这是Benchmark所不能满足的。好在go工具链集成了许多性能分析工具以供开发者使用，下面就来逐一讲解。\"]},\"235\":{\"h\":\"逃逸分析\",\"t\":[\"在go中，变量的内存分配是由编译器决定的，一般就分配到栈上和堆上这两个地方。如果一个本该分配到栈上的变量被分配到了堆上，那么这种情况就称之为逃逸，逃逸分析便是要分析程序中的内存分配情况，由于它是在编译期进行，所以是静态分析的一种。\",\"提示\",\"前往内存分配文章了解go具体是如分配内存的。\"]},\"236\":{\"h\":\"引用局部指针\",\"t\":[\"package main func main() { GetPerson() } type Person struct { Name string Mom *Person } func GetPerson() Person { mom := Person{Name: \\\"lili\\\"} son := Person{Name: \\\"jack\\\", Mom: &mom} return son }\",\"GetPerson函数中创建了mom变量，由于它是函数内创建的，本来应该是将其分配到栈上，但是它被son的Mom字段所引用了，并且son被作为了函数返回值返回出去，所以编译器就将其分配到了堆上。这是一个很简单的示例，所以理解起来不需要花费太多力气，但如果是一个大点的项目，代码行数有好几万，人工分析就不是那么的轻松了，为此就需要使用工具来进行逃逸分析。前面提到过内存的分配是由编译器主导的，所以逃逸分析也是由编译器来完成，使用起来十分简单，只需要执行如下命令：\",\"$ go build -gcflags=\\\"-m -m -l\\\"\",\"gcflags即编译器gc的参数，\",\"-m，打印出代码优化建议，同时出现两个会更加进行细节的输出\",\"-l，禁用内联优化\",\"输出如下\",\"$ go build -gcflags=\\\"-m -m -l\\\" . # golearn/example ./main.go:13:2: mom escapes to heap: ./main.go:13:2: flow: son = &mom: ./main.go:13:2: from &mom (address-of) at ./main.go:14:35 ./main.go:13:2: from Person{...} (struct literal element) at ./main.go:14:15 ./main.go:13:2: from son := Person{...} (assign) at ./main.go:14:6 ./main.go:13:2: flow: ~r0 = son: ./main.go:13:2: from return son (return) at ./main.go:15:2 ./main.go:13:2: moved to heap: mom\",\"编译器很明确的告诉了我们变量mom发生了逃逸，导致原因是因为返回值包含了函数内的局部指针，除了这种情况外还有其它情况可能会发生逃逸现象\",\"::: tips\",\"如果你对逃逸分析的细节感兴趣，可以在标准库cmd/compile/internal/escape/escape.go里面了解到更多内容。\",\":::\"]},\"237\":{\"h\":\"闭包引用\",\"t\":[\"闭包引用了函数外的变量，那么该变量也会逃逸到堆上，这个很好理解。\",\"package main func main() { a := make([]string, 0) do(func() []string { return a }) } func do(f func() []string) []string { return f() }\",\"输出\",\"$ go build -gcflags=\\\"-m -m -l\\\" . # golearn/example ./main.go:10:9: f does not escape ./main.go:4:2: main capturing by value: a (addr=false assign=false width=24) ./main.go:4:11: make([]string, 0) escapes to heap: ./main.go:4:11: flow: a = &{storage for make([]string, 0)}: ./main.go:4:11: from make([]string, 0) (spill) at ./main.go:4:11 ./main.go:4:11: from a := make([]string, 0) (assign) at ./main.go:4:4 ./main.go:4:11: flow: ~r0 = a: ./main.go:4:11: from return a (return) at ./main.go:6:3 ./main.go:4:11: make([]string, 0) escapes to heap ./main.go:5:5: func literal does not escape\"]},\"238\":{\"h\":\"空间不足\",\"t\":[\"栈空间不足时，也会发生逃逸现象，下面创建的切片申请了1<<15的容量\",\"package main func main() { _ = make([]int, 0, 1<<15) }\",\"输出\",\"$ go build -gcflags=\\\"-m -m -l\\\" . # golearn/example ./main.go:4:10: make([]int, 0, 32768) escapes to heap: ./main.go:4:10: flow: {heap} = &{storage for make([]int, 0, 32768)}: ./main.go:4:10: from make([]int, 0, 32768) (too large for stack) at ./main.go:4:10 ./main.go:4:10: make([]int, 0, 32768) escapes to heap\"]},\"239\":{\"h\":\"长度未知\",\"t\":[\"当切片的长度是一个变量的时候，由于其长度未知，便会发生逃逸现象（map并不会）\",\"package main func main() { n := 100 _ = make([]int, n) }\",\"输出\",\"$ go build -gcflags=\\\"-m -m -l\\\" . # golearn/example ./main.go:5:10: make([]int, n) escapes to heap: ./main.go:5:10: flow: {heap} = &{storage for make([]int, n)}: ./main.go:5:10: from make([]int, n) (non-constant size) at ./main.go:5:10 ./main.go:5:10: make([]int, n) escapes to heap\",\"还有一种特殊情况便是函数参数为...any类型时也可能会发生逃逸\",\"package main import \\\"fmt\\\" func main() { n := 100 fmt.Println(n) }\",\"输出\",\"$ go build -gcflags=\\\"-m -m -l\\\" . # golearn/example ./main.go:7:14: n escapes to heap: ./main.go:7:14: flow: {storage for ... argument} = &{storage for n}: ./main.go:7:14: from n (spill) at ./main.go:7:14 ./main.go:7:14: from ... argument (slice-literal-element) at ./main.go:7:13 ./main.go:7:14: flow: {heap} = {storage for ... argument}: ./main.go:7:14: from ... argument (spill) at ./main.go:7:13 ./main.go:7:14: from fmt.Println(... argument...) (call parameter) at ./main.go:7:13 ./main.go:7:13: ... argument does not escape ./main.go:7:14: n escapes to heap\",\"我们之所以要进行逃逸分析，把内存分配控制的这么细，主要是为了减轻GC压力，不过go并不是c语言，内存分配的最终决定权依旧掌握在编译器手里，除了极端的性能要求情况下，大多数时候我们也无需太过于专注内存分配的细节，毕竟GC诞生的目的就是为了解放开发者。\",\"小细节\",\"对于一些引用类型，当确认以后不会再用到它时，我们可以将其置为nil，来告诉GC可以将其回收。\",\"type Writer struct { buf []byte } func (w Writer) Close() error { w.buff = nil return nil }\"]},\"240\":{\"h\":\"pprof\",\"t\":[\"pprof（program profiling），是一个程序性能分析的利器，它会对程序运行时的数据进行部分采样，涵盖了cpu，内存，协程，锁，堆栈信息等许多方面，然后再使用工具对采样的数据进行分析并展示结果。\",\"所以pprof的使用步骤就只有两步：\",\"采集数据\",\"分析结果\"]},\"241\":{\"h\":\"采集\",\"t\":[\"数据采集的方式有两种，自动和手动，各有优劣。在此之前，编写一个简单的函数来模拟内存和cpu的消耗\",\"func Do() { for i := 0; i < 10; i++ { slice := makeSlice() sortSlice(slice) } } func makeSlice() []int { var s []int for range 1 << 24 { s = append(s, rand.Int()) } return s } func sortSlice(s []int) { slices.Sort(s) }\"]},\"242\":{\"h\":\"手动\",\"t\":[\"手动采集就是通过代码来控制，其优点是可控，灵活，可以自定义，直接在代码中使用pprof需要引入runtime/pprof包\",\"package main import ( \\\"log\\\" \\\"os\\\" \\\"runtime/pprof\\\" ) func main() { Do() w, _ := os.Create(\\\"heap.pb\\\") heapProfile := pprof.Lookup(\\\"heap\\\") err := heapProfile.WriteTo(w, 0) if err != nil { log.Fatal(err) } }\",\"pprof.Lookup支持的参数如下面代码所示\",\"profiles.m = map[string]*Profile{ \\\"goroutine\\\": goroutineProfile, \\\"threadcreate\\\": threadcreateProfile, \\\"heap\\\": heapProfile, \\\"allocs\\\": allocsProfile, \\\"block\\\": blockProfile, \\\"mutex\\\": mutexProfile, }\",\"该函数会将采集到的数据写入到指定文件中，在写入时传入的数字有以下几个含义\",\"0，写入压缩后的Protobuf数据，没有可读性\",\"1，写入文本格式的数据，能够阅读，http接口返回的就是这一种数据\",\"2，仅goroutine可用，表示打印panic风格的堆栈信息\",\"采集cpu数据需要单独使用 pprof.StartCPUProfile函数，它需要一定的时间进行采样，且其原始数据不可读，如下所示\",\"package main import ( \\\"log\\\" \\\"os\\\" \\\"runtime/pprof\\\" \\\"time\\\" ) func main() { Do() w, _ := os.Create(\\\"cpu.out\\\") err := pprof.StartCPUProfile(w) if err != nil { log.Fatal(err) } time.Sleep(time.Second * 10) pprof.StopCPUProfile() }\",\"采集trace的数据也是同样如此\",\"package main import ( \\\"log\\\" \\\"os\\\" \\\"runtime/trace\\\" \\\"time\\\" ) func main() { Do() w, _ := os.Create(\\\"trace.out\\\") err := trace.Start(w) if err != nil { log.Fatal(err) } time.Sleep(time.Second * 10) trace.Stop() }\"]},\"243\":{\"h\":\"自动\",\"t\":[\"net/http/pprof包将上面的分析函数包装成了http接口，并注册到了默认路由中，如下所示\",\"package pprof import ... func init() { http.HandleFunc(\\\"/debug/pprof/\\\", Index) http.HandleFunc(\\\"/debug/pprof/cmdline\\\", Cmdline) http.HandleFunc(\\\"/debug/pprof/profile\\\", Profile) http.HandleFunc(\\\"/debug/pprof/symbol\\\", Symbol) http.HandleFunc(\\\"/debug/pprof/trace\\\", Trace) }\",\"这使得我们可以直接一键运行pprof数据采集\",\"package main import ( \\\"net/http\\\" // 记得要导入这个包 _ \\\"net/http/pprof\\\" ) func main() { go func(){ http.ListenAndServe(\\\":8080\\\", nil) } for { Do() } }\",\"此时打开浏览器访问http://127.0.0.1:8080/debug/pprof，就会出现这样的页面\",\"页面中有几个可供选择的选项，它们分别代表了\",\"allocs：内存分配抽样\",\"block：同步原语的阻塞跟踪\",\"cmdline：当前程序的命令行调用\",\"goroutine：跟踪所有的协程\",\"heap：对于存活对象的内存分配抽样\",\"mutex：互斥锁相关信息的跟踪\",\"profile：cpu分析，会分析一段时间并下载一个文件\",\"threadcreate：分析导致创建新OS线程原因\",\"trace：当前程序执行情况的跟踪，同样会下载一个文件\",\"这里的数据大多数可读性并不高，主要是拿来给工具分析用的，如下所图\",\"具体的分析工作要留到后面再进行，除了profile和trace两个选项之外，如果你想要在网页中下载数据文件，可以将query参数debug=1去掉。也可以将这些接口集成到自己的路由中而不是使用默认路由，如下所示\",\"package main import ( \\\"net/http\\\" \\\"net/http/pprof\\\" ) func main() { mux := http.NewServeMux() mux.HandleFunc(\\\"/trace\\\", pprof.Trace) servre := &http.Server{ Addr: \\\":8080\\\", Handler: mux, } servre.ListenAndServe() }\",\"如此一来，也能其集成到其它的web框架中，比如gin，iris等等。\"]},\"244\":{\"h\":\"分析\",\"t\":[\"在得到了采集的数据文件后，有两种方式进行分析，命令行或网页，两者都需要借助pprof命令行工具，go默认集成该工具，所以不需要额外下载。\",\"pprof开源地址：google/pprof: pprof is a tool for visualization and analysis of profiling data (github.com)\"]},\"245\":{\"h\":\"命令行\",\"t\":[\"将此前收集到的数据文件作为参数\",\"$ go tool pprof heap.pb\",\"如果数据是由web采集的话，用web url替换掉文件名即可。\",\"$ go tool pprof -http :8080 http://127.0.0.1/debug/pprof/heap\",\"然后就会出现一个交互式的命令行\",\"15:27:38.3266862 +0800 CST Type: inuse_space Time: Apr 15, 2024 at 3:27pm (CST) No samples were found with the default sample value type. Try \\\"sample_index\\\" command to analyze different sample values. Entering interactive mode (type \\\"help\\\" for commands, \\\"o\\\" for options) (pprof)\",\"输入help，可以查看其它命令\",\" Commands: callgrind Outputs a graph in callgrind format comments Output all profile comments disasm Output assembly listings annotated with samples dot Outputs a graph in DOT format eog Visualize graph through eog evince Visualize graph through evince ...\",\"在命令行中查看数据一般使用top命令，也可以用traces命令不过它的输出很冗长，top命令只是简单的看个大概。\",\"(pprof) top 5 Showing nodes accounting for 117.49MB, 100% of 117.49MB total flat flat% sum% cum cum% 117.49MB 100% 100% 117.49MB 100% main.makeSlice (inline) 0 0% 100% 117.49MB 100% main.Do 0 0% 100% 117.49MB 100% main.main 0 0% 100% 117.49MB 100% runtime.main\",\"简单介绍一些其中的一些指标（cpu同理）\",\"flat，代表着当前函数所消耗的资源\",\"cum，当前函数及其后续调用链所消耗的资源总和\",\"flat%，flat/total\",\"cum%，cum/total\",\"我们可以很明显的看到整个调用栈的内存占用是117.49MB，由于Do函数本身什么都没做，只是调用了其它函数，所以其flat的指标是0，创建切片的事情是由makeSlice函数在负责，所以其flat指标是100%。\",\"我们可以将转换可视化的格式，pprof支持相当多的格式，比如pdf，svg，png，gif等等（需要安装Graphviz）。\",\"(pprof) png Generating report in profile001.png\",\"通过图片我们可以更加清晰的看到整个调用栈的内存情况。\",\"通过list命令以源代码的形式查看\",\"(pprof) list Do Total: 117.49MB ROUTINE ======================== main.Do in D:\\\\WorkSpace\\\\Code\\\\GoLeran\\\\golearn\\\\example\\\\main.go 0 117.49MB (flat, cum) 100% of Total . . 21:func Do() { . . 22: for i := 0; i < 10; i++ { . 117.49MB 23: slice := makeSlice() . . 24: sortSlice(slice) . . 25: } . . 26:} . . 27: . . 28:func makeSlice() []int {\",\"对于图片和源代码而言，还可以用web和weblist命令在浏览器中查看图片和源代码。\"]},\"246\":{\"h\":\"网页\",\"t\":[\"在此之前为了数据更加多样化，修改一下模拟的函数\",\"func Do1() { for i := 0; i < 10; i++ { slice := makeSlice() sortSlice(slice) } } func Do2() { for i := 0; i < 10; i++ { slice := makeSlice() sortSlice(slice) } } func makeSlice() []int { var s []int for range 1 << 12 { s = append(s, rand.Int()) } return s } func sortSlice(s []int) { slices.Sort(s) }\",\"网页分析可以可视化结果，免去了我们手动操作命令行，在使用网页分析时，只需执行如下命令\",\"$ go tool pprof -http :8080 heap.pb\",\"如果数据是由web采集的话，将web url替换掉文件名即可\",\"$ go tool pprof -http :8080 http://127.0.0.1:9090/debug/pprof/heap $ go tool pprof -http :8080 http://127.0.0.1:9090/debug/pprof/profile $ go tool pprof -http :8080 http://127.0.0.1:9090/debug/pprof/goroutine\",\"提示\",\"关于如何分析数据，前往pprof: How to read the graph了解更多\",\"网页中总共有6个可查看的项\",\"Top，同命令top\",\"Graph，直线图\",\"Flame Graph，火焰图\",\"Peek，\",\"Source，查看源代码\",\"Disassemble，反汇编查看\",\"对于内存而言四个维度可以分析\",\"alloc_objects：目前已分配的所有对象数量，包括已释放\",\"alloc_spcae：目前为止已分配的所有内存空间，包括已释放\",\"inuse_objects：正在使用的对象数量\",\"inuse_space：正在使用的内存空间\",\"内存分析图\",\"上图最下方的白色叶子节点代表着不同大小的对象占用。\",\"cpu分析图\",\"关于折线图，有几个点要注意\",\"块的颜色越深，占用越高，线越粗，占用越高\",\"实线代表着直接调用，虚线代表着略过了一些调用链。\",\"内存火焰图\",\"cpu火焰图\",\"对于火焰图而言，从上往下看是调用链，从左往右看是cum的占用百分比。\"]},\"247\":{\"h\":\"trace\",\"t\":[\"pprof主要负责分析程序的资源占用，而trace更适合跟踪程序的运行细节，它与前者的数据文件互不兼容，由go tool trace命令来完成相关的分析工作。\",\"如果是手动采集的数据，可以将文件名作为参数\",\"$ go tool trace trace.out\",\"如果是自动采集，也是同样的道理\",\"$ curl http://127.0.0.1:8080/debug/pprof/trace > trace.out && go tool trace trace.out\",\"执行后会开启一个web server\",\"2024/04/15 17:15:40 Preparing trace for viewer... 2024/04/15 17:15:40 Splitting trace for viewer... 2024/04/15 17:15:40 Opening browser. Trace viewer is listening on http://127.0.0.1:51805\",\"打开后页面大概如下所示\",\"这里面主要包含了以下几个部分，这些数据要看懂还挺不容易的。\",\"Event timelines for running goroutines\",\"trace by proc：显示每一时刻在该处理器上运行的协程时间线\",\"trace by thread：显示每一时刻在OS线程上运行的协程时间线\",\"Goroutine analysis：展示每组主函数的协程相关统计信息\",\"Profiles\",\"Network blocking profile： 因网络IO而阻塞的协程信息\",\"Synchronization blocking profile：因同步原语而阻塞的协程信息\",\"Syscall profile：因系统调用而阻塞的协程信息\",\"User-defined tasks and regions\",\"User-defined tasks：用户定义任务的相关协程信息\",\"User-defined regions：用户定义代码区域的相关协程信息\",\"Garbage collection metrics\",\"Minimum mutator utilization：展示最近GC的最大耗时\",\"、\"]},\"248\":{\"h\":\"后记\",\"t\":[\"如果你真的将语法篇和进阶篇都仔细阅读完了，并且动手敲了代码，那么你会认识到Go的语法其实并不难，特性也并不多，经验丰富的人可能几天就上手了，它完完全全是一门面向工程的语言，这一点你会在以后的编码中慢慢体会到。倘若你学习完后感到无处施展拳脚，想要更深一步学习，我可以给出下面几个学习路线和示例项目以供参考。\"]},\"249\":{\"h\":\"Web开发\",\"t\":[\"Web开发是Go语言中一个很常见的应用场景，你可以尝试以下的几个开源Web框架：\",\"Gin\",\"Echo\",\"Iris\",\"Hertz\",\"net/http， 或者不用框架，用Go自带的原生HTTP标准库\",\"如果你想要进行微服务开发，我推荐下面几个开源框架：\",\"GoZero\",\"go-kratos\",\"kitex\",\"然后你需要与数据库交互，我推荐下面几个开源库：\",\"sqlx\",\"Gorm\",\"Xorm\",\"Ent\",\"你可以参照下面这些项目来进行学习：\",\"gin vue admin\",\"go-zero-looklook\",\"gin-admin，单体Web项目我比较推荐参考该项目进行学习\",\"go-platform，微服务项目我推荐参考该项目进行学习\"]},\"250\":{\"h\":\"IM通讯\",\"t\":[\"使用Go进行IM开发，推荐下面这些开源项目：\",\"open-im-server\",\"gim\",\"xxim-server\",\"gochat\",\"TangSengDaoDaoServer\"]},\"251\":{\"h\":\"网络编程\",\"t\":[\"Go在网络编程这块也有非常多的应用，下面给出一些参考的开源项目：\",\"zinx\",\"nps\",\"caddy\",\"goproxy\",\"gws\",\"gev\"]},\"252\":{\"h\":\"游戏服务器\",\"t\":[\"在游戏服务器这个领域，有越来越多的企业转到Go这个方向\",\"agones\",\"leaf\",\"nano\",\"goworld\",\"pitaya\",\"origin\",\"gonet\"]},\"253\":{\"h\":\"数据库开发\",\"t\":[\"数据库开发需要一定的技术功底，基于Go语言的数据库或引擎同样也不少，光是阅读它们的源代码就需要花费不少时间\",\"badger，高速kv数据库\",\"dgraph，图数据库\",\"cayley，图数据库\",\"etcd，分布式键值数据库\",\"rosedb，键值数据库，入门的最佳选择\",\"nutsdb，键值数据库\",\"prometheus，时序数据库\",\"tidb，时序数据库\",\"cockroach，分布式SQL数据库\",\"rqlite，基于SQLite的分布式数据库\"]},\"254\":{\"h\":\"命令行工具\",\"t\":[\"Go非常适合用于命令行CLI工具开发，下面推荐几个命令行开发框架或库：\",\"flag，flag标准库\",\"cobra，强烈推荐使用cobra进行CLI开发，有许多著名项目都是基于cobra，比如Docker，K8S等\",\"go-pretty，用于在命令行进行美观的输出\",\"cli，轻量级的命令行框架\",\"kingpin，强大灵活的命令行解析库\",\"由于cobra十分常用，基于它进行命令行开发的项目非常多，随便都可以找到，下面只是一些参考项目：\",\"cobra-example\",\"govm\",\"hugo\",\"delve\",\"上面只是列出了比较常见的领域，你可以看到的是Go在服务端领域应用较为广泛，而客户端则较少，其实Go在其他领域也有不少的应用，比如webrtc，区块链，对象存储，云计算等等，感兴趣可以在Github上自行了解。\"]},\"255\":{\"h\":\"泛型\",\"t\":[\"最初的Go是没有泛型这一说法的，但自从诞生以来，社区关于Go呼声最高的事情就是希望加入泛型。终于Go在1.18版本加入了对泛型的支持，不过有一点怪。\"]},\"256\":{\"h\":\"示例\",\"t\":[\"在开始之前，先来看一个简单的例子。\",\"func Sum(a, b int) int { return a + b }\",\"这是一个功能十分简单的函数，作用就是将两个int类型的整数相加并返回结果，倘若想要传入两个float64类型的浮点数求和的话，显然是不可以的，因为类型不匹配。一种解决办法就是再定义一个新的函数，如下\",\"func SumFloat64(a, b float64) float64 { return a + b }\",\"那么问题来了，如果开发一个数学工具包，计算所有数字类型的两数之和，难道要每一个类型都要编写一个函数吗？显然是不太可能的，或者也可以使用any类型加反射来判断，如下\",\"func SumAny(a, b any) (any, error) { tA, tB := reflect.ValueOf(a), reflect.ValueOf(b) if tA.Kind() != tB.Kind() { return nil, errors.New(\\\"disMatch type\\\") } switch tA.Kind() { case reflect.Int: case reflect.Int32: ... } }\",\"但是这样写会显得十分复杂，而且性能低下。但是Sum函数的逻辑都是一模一样的，都只不过是将两个数相加而已，这时候就需要用到了泛型，所以为什么需要泛型，泛型是为了解决执行逻辑与类型无关的问题，这类问题不关心给出的类型是什么，只需要完成对应的操作就足够。所以泛型的写法如下\",\"func Sum[T int | float64](a, b T) T { return a + b }\",\"类型形参：T就是一个类型形参，形参具体是什么类型取决于传进来什么类型\",\"类型约束：int | float64构成了一个类型约束，这个类型约束内规定了哪些类型是允许的，约束了类型形参的类型范围\",\"类型实参：Sum[int](1,2)，手动指定了int类型，int就是类型实参。\",\"第一种用法，显式的指明使用哪种类型，如下\",\"Sum[int](2012, 2022)\",\"第二种用法，不指定类型，让编译器自行推断，如下\",\"Sum(3.1415926, 1.114514)\",\"看到这里后，应该对为什么要使用泛型，以及泛型解决了哪种问题有了一个大概的了解。将泛型引入项目后，开发上确实会比较方便，随之而来的是项目复杂度的增加，毫无节制的使用泛型会使得代码难以维护，所以应该在正确的地方使用泛型，而不是为了泛型而泛型。\"]},\"257\":{\"h\":\"泛型结构\",\"t\":[\"这是一个泛型切片，类型约束为int | int32 | int64\",\"type GenericSlice[T int | int32 | int64] []T\",\"这里使用时就不能省略掉类型实参\",\"GenericSlice[int]{1, 2, 3}\",\"这是一个泛型哈希表，键的类型必须是可比较的，所以使用comparable接口，值的类型约束为V int | string | byte\",\"type GenericMap[K comparable, V int | string | byte] map[K]V\",\"使用\",\"gmap1 := GenericMap[int, string]{1: \\\"hello world\\\"} gmap2 := make(GenericMap[string, byte], 0)\",\"这是一个泛型结构体，类型约束为T int | string\",\"type GenericStruct[T int | string] struct { Name string Id T }\",\"使用\",\"GenericStruct[int]{ Name: \\\"jack\\\", Id: 1024, } GenericStruct[string]{ Name: \\\"Mike\\\", Id: \\\"1024\\\", }\",\"这是一个泛型切片形参的例子\",\"type Company[T int | string, S []T] struct { Name string Id T Stuff S } //也可以如下 type Company[T int | string, S []int | string] struct { Name string Id T Stuff S }\",\"使用\",\"Company[int, []int]{ Name: \\\"lili\\\", Id: 1, Stuff: []int{1}, }\",\"提示\",\"在泛型结构体中，更推荐这种写法\",\"type Company[T int | string, S int | string] struct { Name string Id T Stuff []S }\",\"SayAble是一个泛型接口，Person实现了该接口。\",\"type SayAble[T int | string] interface { Say() T } type Person[T int | string] struct { msg T } func (p Person[T]) Say() T { return p.msg } func main() { var s SayAble[string] s = Person[string]{\\\"hello world\\\"} fmt.Println(s.Say()) }\"]},\"258\":{\"h\":\"泛型结构注意点\",\"t\":[\"泛型不能作为一个类型的基本类型\",\"以下写法是错误的，泛型形参T是不能作为基础类型的\",\"type GenericType[T int | int32 | int64] T\",\"虽然下列的写法是允许的，不过毫无意义而且可能会造成数值溢出的问题，所以并不推荐\",\"type GenericType[T int | int32 | int64] int\",\"泛型类型无法使用类型断言\",\"对泛型类型使用类型断言将会无法通过编译，泛型要解决的问题是类型无关的，如果一个问题需要根据不同类型做出不同的逻辑，那么就根本不应该使用泛型，应该使用interface{}或者any。\",\"func Sum[T int | float64](a, b T) T { ints,ok := a.(int) // 不被允许 switch a.(type) { // 不被允许 case int: case bool: ... } return a + b }\",\"匿名结构不支持泛型\",\"匿名结构体是不支持泛型的，如下的代码将无法通过编译\",\"testStruct := struct[T int | string] { Name string Id T }[int]{ Name: \\\"jack\\\", Id: 1 }\",\"匿名函数不支持自定义泛型\",\"以下两种写法都将无法通过编译\",\"var sum[T int | string] func (a, b T) T sum := func[T int | string](a,b T) T{ ... }\",\"但是可以使用已有的泛型类型，例如闭包中\",\"func Sum[T int | float64](a, b T) T { sub := func(c, d T) T { return c - d } return sub(a,b) + a + b }\",\"不支持泛型方法\",\"方法是不能拥有泛型形参的，但是receiver可以拥有泛型形参。如下的代码将会无法通过编译\",\"type GenericStruct[T int | string] struct { Name string Id T } func (g GenericStruct[T]) name[S int | float64](a S) S { return a }\"]},\"259\":{\"h\":\"类型集\",\"t\":[\"在1.18以后，接口的定义变为了类型集(type set)，含有类型集的接口又称为General interfaces即通用接口。\",\"An interface type defines a type set\",\"类型集主要用于类型约束，不能用作类型声明，既然是集合，就会有空集，并集，交集，接下来将会讲解这三种情况。\",\"并集\",\"接口类型SignedInt是一个类型集，有符号整数类型的并集就是SignedInt，反过来SignedInt就是它们的超集。\",\"type SignedInt interface { int8 | int16 | int | int32 | int64 }\",\"基本数据类型如此，对待其它通用接口也是如此\",\"type SignedInt interface { int8 | int16 | int | int32 | int64 } type UnSignedInt interface { uint8 | uint16 | uint32 | uint64 } type Integer interface { SignedInt | UnSignedInt }\",\"交集\",\"非空接口的类型集是其所有元素的类型集的交集，翻译成人话就是：如果一个接口包含多个非空类型集，那么该接口就是这些类型集的交集，例子如下\",\"type SignedInt interface { int8 | int16 | int | int32 | int64 } type Integer interface { int8 | int16 | int | int32 | int64 | uint8 | uint16 | uint | uint32 | uint64 } type Number interface { SignedInt Integer }\",\"例子中的交集肯定就是SignedInt，\",\"func Do[T Number](n T) T { return n } Do[int](2) DO[uint](2) //无法通过编译\",\"空集\",\"空集就是没有交集，例子如下，下面例子中的Integer就是一个类型空集。\",\"type SignedInt interface { int8 | int16 | int | int32 | int64 } type UnsignedInt interface { uint8 | uint16 | uint | uint32 | uint64 } type Integer interface { SignedInt UnsignedInt }\",\"因为无符号整数和有符号整数两个肯定没有交集，所以交集就是个空集，下方例子中不管传什么类型都无法通过编译。\",\"Do[Integer](1) Do[Integer](-100)\",\"空接口\",\"空接口与空集并不同，空接口是所有类型集的集合，即包含所有类型。\",\"func Do[T interface{}](n T) T { return n } func main() { Do[struct{}](struct{}{}) Do[any](\\\"abc\\\") }\",\"底层类型\",\"当使用type关键字声明了一个新的类型时，即便其底层类型包含在类型集内，当传入时也依旧会无法通过编译。\",\"type Int interface { int8 | int16 | int | int32 | int64 | uint8 | uint16 | uint | uint32 | uint64 } type TinyInt int8 func Do[T Int](n T) T { return n } func main() { Do[TinyInt](1) // 无法通过编译，即便其底层类型属于Int类型集的范围内 }\",\"有两种解决办法，第一种是往类型集中并入该类型，但是这毫无意义，因为TinyInt与int8底层类型就是一致的，所以就有了第二种解决办法。\",\"type Int interface { int8 | int16 | int | int32 | int64 | uint8 | uint16 | uint | uint32 | uint64 | TinyInt }\",\"使用~符号，来表示底层类型，如果一个类型的底层类型属于该类型集，那么该类型就属于该类型集，如下所示\",\"type Int interface { ~int8 | ~int16 | ~int | ~int32 | ~int64 | ~uint8 | ~uint16 | ~uint | ~uint32 | ~uint64 }\",\"修改过后就可以通过编译了。\",\"func main() { Do[TinyInt](1) // 可以通过编译，因为TinyInt在类型集Int内 }\"]},\"260\":{\"h\":\"类型集注意点\",\"t\":[\"带有方法集的接口无法并入类型集\",\"只要是带有方法集的接口，不论是基本接口，泛型接口，又或者是通用接口，都无法并入类型集中，同样的也无法在类型约束中并入。以下两种写法都是错误的，都无法通过编译。\",\"type Integer interface { Sum(int, int) int Sub(int, int) int } type SignedInt interface { int8 | int16 | int | int32 | int64 | Integer } func Do[T Integer | float64](n T) T { return n }\",\"类型集无法当作类型实参使用\",\"只要是带有类型集的接口，都无法当作类型实参。\",\"type SignedInt interface { int8 | int16 | int | int32 | int64 } func Do[T SignedInt](n T) T { return n } func main() { Do[SignedInt](1) // 无法通过编译 }\",\"类型集中的交集问题\",\"对于非接口类型，类型并集中不能有交集，例如下例中的TinyInt与~int8有交集。\",\"type Int interface { ~int8 | ~int16 | ~int | ~int32 | ~int64 | ~uint8 | ~uint16 | ~uint | ~uint32 | ~uint64 | TinyInt // 无法通过编译 } type TinyInt int8\",\"但是对于接口类型的话，就允许有交集，如下例\",\"type Int interface { ~int8 | ~int16 | ~int | ~int32 | ~int64 | ~uint8 | ~uint16 | ~uint | ~uint32 | ~uint64 | TinyInt // 可以通过编译 } type TinyInt interface { int8 }\",\"类型集不能直接或间接的并入自身\",\"以下示例中，Floats 直接的并入了自身，而Double又并入了Floats，所以又间接的并入了自身。\",\"type Floats interface { // 代码无法通过编译 Floats | Double } type Double interface { Floats }\",\"comparable接口无法并入类型集\",\"同样的，也无法并入类型约束中，所以基本上都是单独使用。\",\"func Do[T comparable | Integer](n T) T { //无法通过编译 return n } type Number interface { // 无法通过编译 Integer | comparable } type Comparable interface { // 可以通过编译但是毫无意义 comparable }\"]},\"261\":{\"h\":\"使用\",\"t\":[\"数据结构是泛型最常见的使用场景，下面借由两个数据结构来展示下泛型如何使用。\"]},\"262\":{\"h\":\"队列\",\"t\":[\"下面用泛型实现一个简单的队列，首先声明队列类型，队列中的元素类型可以是任意的，所以类型约束为any\",\"type Queue[T any] []T\",\"总共只有四个方法Pop ，Peek，Push，Size，代码如下。\",\"type Queue[T any] []T func (q *Queue[T]) Push(e T) { *q = append(*q, e) } func (q *Queue[T]) Pop(e T) (_ T) { if q.Size() > 0 { res := q.Peek() *q = (*q)[1:] return res } return } func (q *Queue[T]) Peek() (_ T) { if q.Size() > 0 { return (*q)[0] } return } func (q *Queue[T]) Size() int { return len(*q) }\",\"在Pop和Peek方法中，可以看到返回值是_ T，这是具名返回值的使用方式，但是又采用了下划线_表示这是匿名的，这并非多此一举，而是为了表示泛型零值。由于采用了泛型，当队列为空时，需要返回零值，但由于类型未知，不可能返回具体的类型，借由上面的那种方式就可以返回泛型零值。也可以声明泛型变量的方式来解决零值问题，对于一个泛型变量，其默认的值就是该类型的零值，如下\",\"func (q *Queue[T]) Pop(e T) T { var res T if q.Size() > 0 { res = q.Peek() *q = (*q)[1:] return res } return res }\"]},\"263\":{\"h\":\"堆\",\"t\":[\"上面队列的例子，由于对元素没有任何的要求，所以类型约束为any。但堆就不一样了，堆是一种特殊的数据结构，它可以在O(1)的时间内判断最大或最小值，所以它对元素有一个要求，那就是必须是可以排序的类型，但内置的可排序类型只有数字和字符串，并且go的泛型约束不允许存在带方法的接口，所以在堆的初始化时，需要传入一个自定义的比较器，比较器由调用者提供，并且比较器也必须使用泛型，如下\",\"type Comparator[T any] func(a, b T) int\",\"下面是一个简单二项堆的实现，先声明泛型结构体，依旧采用any进行约束，这样可以存放任意类型\",\"type Comparator[T any] func(a, b T) int type BinaryHeap[T any] struct { s []T c Comparator[T] }\",\"几个方法实现\",\"func (heap *BinaryHeap[T]) Peek() (_ T) { if heap.Size() > 0 { return heap.s[0] } return } func (heap *BinaryHeap[T]) Pop() (_ T) { size := heap.Size() if size > 0 { res := heap.s[0] heap.s[0], heap.s[size-1] = heap.s[size-1], heap.s[0] heap.s = heap.s[:size-1] heap.down(0) return res } return } func (heap *BinaryHeap[T]) Push(e T) { heap.s = append(heap.s, e) heap.up(heap.Size() - 1) } func (heap *BinaryHeap[T]) up(i int) { if heap.Size() == 0 || i < 0 || i >= heap.Size() { return } for parentIndex := i>>1 - 1; parentIndex >= 0; parentIndex = i>>1 - 1 { // greater than or equal to if heap.compare(heap.s[i], heap.s[parentIndex]) >= 0 { break } heap.s[i], heap.s[parentIndex] = heap.s[parentIndex], heap.s[i] i = parentIndex } } func (heap *BinaryHeap[T]) down(i int) { if heap.Size() == 0 || i < 0 || i >= heap.Size() { return } size := heap.Size() for lsonIndex := i<<1 + 1; lsonIndex < size; lsonIndex = i<<1 + 1 { rsonIndex := lsonIndex + 1 if rsonIndex < size && heap.compare(heap.s[rsonIndex], heap.s[lsonIndex]) < 0 { lsonIndex = rsonIndex } // less than or equal to if heap.compare(heap.s[i], heap.s[lsonIndex]) <= 0 { break } heap.s[i], heap.s[lsonIndex] = heap.s[lsonIndex], heap.s[i] i = lsonIndex } } func (heap *BinaryHeap[T]) Size() int { return len(heap.s) }\",\"使用起来如下\",\"type Person struct { Age int Name string } func main() { heap := NewHeap[Person](10, func(a, b Person) int { return cmp.Compare(a.Age, b.Age) }) heap.Push(Person{Age: 10, Name: \\\"John\\\"}) heap.Push(Person{Age: 18, Name: \\\"mike\\\"}) heap.Push(Person{Age: 9, Name: \\\"lili\\\"}) heap.Push(Person{Age: 32, Name: \\\"miki\\\"}) fmt.Println(heap.Peek()) fmt.Println(heap.Pop()) fmt.Println(heap.Peek()) }\",\"输出\",\"{9 lili} {9 lili} {10 John}\",\"有泛型的加持，原本不可排序的类型传入比较器后也可以使用堆了，这样做肯定比以前使用interface{}来进行类型转换和断言要优雅和方便很多。\"]},\"264\":{\"h\":\"小结\",\"t\":[\"go的一大特点就是编译速度非常快，编译快是因为编译期做的优化少，泛型的加入会导致编译器的工作量增加，工作更加复杂，这必然会导致编译速度变慢，事实上当初go1.18刚推出泛型的时候确实导致编译更慢了，go团队既想加入泛型又不想太拖累编译速度，开发者用的顺手，编译器就难受，反过来编译器轻松了（最轻松的当然是直接不要泛型），开发者就难受了，现如今的泛型就是这两者之间妥协后的产物。\",\"提示\",\"如果想要了解更多关于泛型的实际案例，可以看看这个泛型数据结构库246859/containers: base data structure in go genericity (github.com)。如果想要了解更多关于泛型的一些设计理念和细节，可以前往Type Parameters Proposal (googlesource.com)。\"]},\"265\":{\"h\":\"反射\",\"t\":[\"反射是一种在运行时检查语言自身结构的机制，它可以很灵活的去应对一些问题，但同时带来的弊端也很明显，例如性能问题等等。在Go中，反射与interface{}密切相关，很大程度上，只要有interface{}出现的地方，就会有反射。Go中的反射API是由标准库reflect包提供的。\"]},\"266\":{\"h\":\"接口\",\"t\":[\"在开始之前先简单的了解一下位于runtime包下的两个接口。在Go中，接口本质上是结构体，Go在运行时将接口分为了两大类，一类是没有方法集的接口，另一个类则是有方法集的接口。对于含有方法集的接口来说，在运行时由如下的结构体iface来进行表示\",\"type iface struct { tab *itab // 包含 数据类型，接口类型，方法集等 data unsafe.Pointer // 指向值的指针 }\",\"而对于没有方法集接口来说，在运行时由eface 结构体来进行表示，如下\",\"type eface struct { _type *_type // 类型 data unsafe.Pointer // 指向值的指针 }\",\"而这两个结构体在reflect包下都有与其对应的结构体类型，iface对应的是nonEmptyInterface\",\"type nonEmptyInterface struct { itab *struct { ityp *rtype // 静态接口类型 typ *rtype // 动态具体类型 hash uint32 // 类型哈希 _ [4]byte fun [100000]unsafe.Pointer // 方法集 } word unsafe.Pointer // 指向值的指针 }\",\"而eface对应的是emptyInterface\",\"type emptyInterface struct { typ *rtype // 动态具体类型 word unsafe.Pointer // 指向指针的值 }\",\"对于这两种类型，官方给出了很明确的定义\",\"nonEmptyInterface： nonEmptyInterface is the header for an interface value with methods\",\"emptyInterface：emptyInterface is the header for an interface{} value\",\"上述提到了动态具体类型这一词，原文为dynamic concrete type，首先Go语言是一个百分之百的静态类型语言，静态这一词是体现在对外表现的抽象的接口类型是不变的，而动态表示是接口底层存储的具体实现的类型是可以变化的。至此，对于接口的简单原理只需要了解到这里就足够满足后续反射的学习。\"]},\"267\":{\"h\":\"桥梁\",\"t\":[\"在reflect包下，分别有reflect.Type接口类型来表示Go中的类型，reflect.Value结构体类型来表示Go中的值\",\"type Type interface { ... Name() string PkgPath() string Size() uintptr String() string Kind() Kind ... } type Value struct { typ *rtype ptr unsafe.Pointer flag }\",\"上面的代码省略了很多细节，先只需要了解这两个类型的存在即可。Go中所有反射相关的操作都是基于这两个类型，reflect包提供了两个函数来将Go中的类型转换为上述的两种类型以便进行反射操作，分别是reflect.TypeOf函数\",\"func TypeOf(i any) Type\",\"与reflect.ValueOf函数\",\"func ValueOf(i any) Value\",\"可以看到两个函数的参数类型都是any，也就是interface{}的别名。如果想要进行反射操作，就需要先将其类型转换为interface{}，这也是为什么前面提到了只要有反射就离不开空接口。不严谨的说，空接口就是连接Go类型系统与反射的桥梁，下图很形象的描述了其过程。\",\"提示\",\"下文中为了方便，统一使用别名any来替代interface{}\"]},\"268\":{\"h\":\"核心\",\"t\":[\"在Go中有三个经典的反射定律，结合上面所讲的内容也就非常好懂，分别如下\",\"反射可以将interface{}类型变量转换成反射对象\",\"反射可以将反射对象还原成interface{}类型变量\",\"要修改反射对象，其值必须是可设置的\",\"这三个定律便是Go反射的核心，当需要访问类型相关信息时，便需要用到reflect.TypeOf，当需要修改反射值时，就需要用到reflect.ValueOf\"]},\"269\":{\"h\":\"类型\",\"t\":[\"reflect.Type代表着Go中的类型，使用reflect.TypeOf()函数可以将变量转换成reflect.Type。代码示例如下\",\"func main() { str := \\\"hello world!\\\" reflectType := reflect.TypeOf(str) fmt.Println(reflectType) }\",\"输出结果为\",\"string\"]},\"270\":{\"h\":\"Kind\",\"t\":[\"对于Type而言，Go内部使用reflect.Kind来表示Go中的基础类型，其本质上是无符号整型uint。\",\"type Kind uint\",\"reflect包使用Kind枚举出了Go中所有的基础类型，如下所示\",\"const ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 Uint Uint8 Uint16 Uint32 Uint64 Uintptr Float32 Float64 Complex64 Complex128 Array Chan Func Interface Map Pointer Slice String Struct UnsafePointer )\",\"Kind类型仅仅实现了Stringer接口的String()方法，该类型也仅有这一个方法，String()方法的返回值来自于一个其内部的map，如下所示\",\"var kindNames = []string{ Invalid: \\\"invalid\\\", Bool: \\\"bool\\\", Int: \\\"int\\\", Int8: \\\"int8\\\", Int16: \\\"int16\\\", Int32: \\\"int32\\\", Int64: \\\"int64\\\", Uint: \\\"uint\\\", Uint8: \\\"uint8\\\", Uint16: \\\"uint16\\\", Uint32: \\\"uint32\\\", Uint64: \\\"uint64\\\", Uintptr: \\\"uintptr\\\", Float32: \\\"float32\\\", Float64: \\\"float64\\\", Complex64: \\\"complex64\\\", Complex128: \\\"complex128\\\", Array: \\\"array\\\", Chan: \\\"chan\\\", Func: \\\"func\\\", Interface: \\\"interface\\\", Map: \\\"map\\\", Pointer: \\\"ptr\\\", Slice: \\\"slice\\\", String: \\\"string\\\", Struct: \\\"struct\\\", UnsafePointer: \\\"unsafe.Pointer\\\", }\",\"type Type interface{ Kind() Kind }\",\"通过Kind，可以知晓空接口存储的值究竟是什么基础类型，例如\",\"func main() { // 声明一个any类型的变量 var eface any // 赋值 eface = 100 // 通过Kind方法，来获取其类型 fmt.Println(reflect.TypeOf(eface).Kind()) }\",\"输出结果\",\"int\"]},\"271\":{\"h\":\"Elem\",\"t\":[\"type Type interface{ Elem() Type }\",\"使用Type.Elem()方法，可以判断类型为any的数据结构所存储的元素类型，可接收的底层参数类型必须是指针，切片，数组，通道，映射表其中之一，否则会panic。下面是代码示例\",\"func main() { var eface any eface = map[string]int{} rType := reflect.TypeOf(eface) // key()会返回map的键反射类型 fmt.Println(rType.Key().Kind()) fmt.Println(rType.Elem().Kind()) }\",\"输出为\",\"string int\",\"指针也可以理解为是一个容器，对于指针使用Elem()会获得其指向元素的反射类型，代码示例如下\",\"func main() { var eface any // 赋值指针 eface = new(strings.Builder) rType := reflect.TypeOf(eface) // 拿到指针所指向元素的反射类型 vType := rType.Elem() // 输出包路径 fmt.Println(vType.PkgPath()) // 输出其名称 fmt.Println(vType.Name()) }\",\"strings Builder\",\"对于数组，切片，通道用使用起来都是类似的。\"]},\"272\":{\"h\":\"Size\",\"t\":[\"type Type interface{ Size() uintptr }\",\"通过Size方法可以获取对应类型所占的字节大小，示例如下\",\"func main() { fmt.Println(reflect.TypeOf(0).Size()) fmt.Println(reflect.TypeOf(\\\"\\\").Size()) fmt.Println(reflect.TypeOf(complex(0, 0)).Size()) fmt.Println(reflect.TypeOf(0.1).Size()) fmt.Println(reflect.TypeOf([]string{}).Size()) }\",\"输出结果为\",\"8 16 16 8 24\",\"提示\",\"使用unsafe.Sizeof()可以达到同样的效果\"]},\"273\":{\"h\":\"Comparable\",\"t\":[\"type Type interface{ Comparable() bool }\",\"通过Comparable方法可以判断一个类型是否可以被比较，例子如下\",\"func main() { fmt.Println(reflect.TypeOf(\\\"hello world!\\\").Comparable()) fmt.Println(reflect.TypeOf(1024).Comparable()) fmt.Println(reflect.TypeOf([]int{}).Comparable()) fmt.Println(reflect.TypeOf(struct{}{}).Comparable()) }\",\"输出如下\",\"true true false true\"]},\"274\":{\"h\":\"Implements\",\"t\":[\"type Type interface{ Implements(u Type) bool }\",\"通过Implements方法可以判断一个类型是否实现了某一接口\",\"type MyInterface interface { My() string } type MyStruct struct { } func (m MyStruct) My() string { return \\\"my\\\" } type HisStruct struct { } func (h HisStruct) String() string { return \\\"his\\\" } func main() { rIface := reflect.TypeOf(new(MyInterface)).Elem() fmt.Println(reflect.TypeOf(new(MyStruct)).Elem().Implements(rIface)) fmt.Println(reflect.TypeOf(new(HisStruct)).Elem().Implements(rIface)) }\",\"输出结果\",\"true false\"]},\"275\":{\"h\":\"ConvertibleTo\",\"t\":[\"type Type interface{ ConvertibleTo(u Type) bool }\",\"使用ConvertibleTo方法可以判断一个类型是否可以被转换为另一个指定的类型\",\"type MyInterface interface { My() string } type MyStruct struct { } func (m MyStruct) My() string { return \\\"my\\\" } type HisStruct struct { } func (h HisStruct) String() string { return \\\"his\\\" } func main() { rIface := reflect.TypeOf(new(MyInterface)).Elem() fmt.Println(reflect.TypeOf(new(MyStruct)).Elem().ConvertibleTo(rIface)) fmt.Println(reflect.TypeOf(new(HisStruct)).Elem().ConvertibleTo(rIface)) }\",\"输出\",\"true false\"]},\"276\":{\"h\":\"值\",\"t\":[\"reflect.Value代表着反射接口的值，使用reflect.ValueOf()函数可以将变量转换成reflect.Value。代码示例如下\",\"func main() { str := \\\"hello world!\\\" reflectValue := reflect.ValueOf(str) fmt.Println(reflectValue) }\",\"输出结果为\",\"hello world!\"]},\"277\":{\"h\":\"Type\",\"t\":[\"func (v Value) Type() Type\",\"Type方法可以获取一个反射值的类型\",\"func main() { num := 114514 rValue := reflect.ValueOf(num) fmt.Println(rValue.Type()) }\",\"输出\",\"int\"]},\"278\":{\"h\":\"Elem\",\"t\":[\"func (v Value) Elem() Value\",\"获取一个反射值的元素反射值\",\"func main() { num := new(int) *num = 114514 // 以指针为例子 rValue := reflect.ValueOf(num).Elem() fmt.Println(rValue.Interface()) }\",\"输出\",\"114514\"]},\"279\":{\"h\":\"指针\",\"t\":[\"获取一个反射值的指针方式有两种\",\"// 返回一个表示v地址的指针反射值 func (v Value) Addr() Value // 返回一个指向v的原始值的uinptr 等价于 uintptr(Value.Addr().UnsafePointer()) func (v Value) UnsafeAddr() uintptr // 返回一个指向v的原始值的uintptr // 仅当v的Kind为 Chan, Func, Map, Pointer, Slice, UnsafePointer时，否则会panic func (v Value) Pointer() uintptr // 返回一个指向v的原始值的unsafe.Pointer // 仅当v的Kind为 Chan, Func, Map, Pointer, Slice, UnsafePointer时，否则会panic func (v Value) UnsafePointer() unsafe.Pointer\",\"示例如下\",\"func main() { num := 1024 ele := reflect.ValueOf(&num).Elem() fmt.Println(\\\"&num\\\", &num) fmt.Println(\\\"Addr\\\", ele.Addr()) fmt.Println(\\\"UnsafeAddr\\\", unsafe.Pointer(ele.UnsafeAddr())) fmt.Println(\\\"Pointer\\\", unsafe.Pointer(ele.Addr().Pointer())) fmt.Println(\\\"UnsafePointer\\\", ele.Addr().UnsafePointer()) }\",\"输出\",\"&num 0xc0000a6058 Addr 0xc0000a6058 UnsafeAddr 0xc0000a6058 Pointer 0xc0000a6058 UnsafePointer 0xc0000a6058\",\"提示\",\"fmt.Println会反射获取参数的类型，如果是reflect.Value类型的话，会自动调用Value.Interface()来获取其原始值。\",\"换成一个map再来一遍\",\"func main() { dic := map[string]int{} ele := reflect.ValueOf(&dic).Elem() println(dic) fmt.Println(\\\"Addr\\\", ele.Addr()) fmt.Println(\\\"UnsafeAddr\\\", *(*unsafe.Pointer)(unsafe.Pointer(ele.UnsafeAddr()))) fmt.Println(\\\"Pointer\\\", unsafe.Pointer(ele.Pointer())) fmt.Println(\\\"UnsafePointer\\\", ele.UnsafePointer()) }\",\"输出\",\"0xc00010e4b0 Addr &map[] UnsafeAddr 0xc00010e4b0 Pointer 0xc00010e4b0 UnsafePointer 0xc00010e4b0\"]},\"280\":{\"h\":\"设置值\",\"t\":[\"func (v Value) Set(x Value)\",\"倘若通过反射来修改反射值，那么其值必须是可取址的，这时应该通过指针来修改其元素值，而不是直接尝试修改元素的值。\",\"func main() { // *int num := new(int) *num = 114514 rValue := reflect.ValueOf(num) // 获取指针指向的元素 ele := rValue.Elem() fmt.Println(ele.Interface()) ele.SetInt(11) fmt.Println(ele.Interface()) }\",\"输出如下\",\"114514 11\"]},\"281\":{\"h\":\"获取值\",\"t\":[\"func (v Value) Interface() (i any)\",\"通过Interface()方法可以获取反射值原有的值\",\"func main() { var str string str = \\\"hello\\\" rValue := reflect.ValueOf(str) if v, ok := rValue.Interface().(string); ok { fmt.Println(v) } }\",\"输出\",\"hello\"]},\"282\":{\"h\":\"函数\",\"t\":[\"通过反射可以获取函数的一切信息，也可以反射调用函数\"]},\"283\":{\"h\":\"信息\",\"t\":[\"通过反射类型来获取函数的一切信息\",\"func Max(a, b int) int { if a > b { return a } return b } func main() { rType := reflect.TypeOf(Max) // 输出函数名称,字面量函数的类型没有名称 fmt.Println(rType.Name()) // 输出参数，返回值的数量 fmt.Println(rType.NumIn(), rType.NumOut()) rParamType := rType.In(0) // 输出第一个参数的类型 fmt.Println(rParamType.Kind()) rResType := rType.Out(0) // 输出第一个返回值的类型 fmt.Println(rResType.Kind()) }\",\"输出\",\" 2 1 int int\"]},\"284\":{\"h\":\"调用\",\"t\":[\"通过反射值来调用函数\",\"func (v Value) Call(in []Value) []Value\",\"func main() { // 获取函数的反射值 rType := reflect.ValueOf(Max) // 传入参数数组 rResValue := rType.Call([]reflect.Value{reflect.ValueOf(18), reflect.ValueOf(50)}) for _, value := range rResValue { fmt.Println(value.Interface()) } }\",\"输出\",\"50\"]},\"285\":{\"h\":\"结构体\",\"t\":[\"假设有如下结构体\",\"type Person struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` Address string `json:\\\"address\\\"` money int } func (p Person) Talk(msg string) string { return msg }\"]},\"286\":{\"h\":\"访问字段\",\"t\":[\"reflect.StructField结构的结构如下\",\"type StructField struct { // 字段名称 Name string // 包名 PkgPath string // 类型名 Type Type // Tag Tag StructTag // 字段的字节偏移 Offset uintptr // 索引 Index []int // 是否为嵌套字段 Anonymous bool }\",\"访问结构体字段的方法有两种，一种是通过索引来进行访问，另一种是通过名称。\",\"type Type interface{ Field(i int) StructField }\",\"通过索引访问的例子如下\",\"func main() { rType := reflect.TypeOf(new(Person)).Elem() // 输出结构体字段的数量 fmt.Println(rType.NumField()) for i := 0; i < rType.NumField(); i++ { structField := rType.Field(i) fmt.Println(structField.Index, structField.Name, structField.Type, structField.Offset, structField.IsExported()) } }\",\"输出\",\"4 [0] Name string 0 true [1] Age int 16 true [2] Address string 24 true [3] money int 40 false\",\"type Type interface{ FieldByName(name string) (StructField, bool) }\",\"通过名称访问的例子如下\",\"func main() { rType := reflect.TypeOf(new(Person)).Elem() // 输出结构体字段的数量 fmt.Println(rType.NumField()) if field, ok := rType.FieldByName(\\\"money\\\"); ok { fmt.Println(field.Name, field.Type, field.IsExported()) } }\",\"输出\",\"4 money int false\"]},\"287\":{\"h\":\"修改字段\",\"t\":[\"倘若要修改结构体字段值，则必须传入一个结构体指针，下面是一个修改字段的例子\",\"func main() { // 传入指针 rValue := reflect.ValueOf(&Person{ Name: \\\"\\\", Age: 0, Address: \\\"\\\", money: 0, }).Elem() // 获取字段 name := rValue.FieldByName(\\\"Name\\\") // 修改字段值 if (name != reflect.Value{}) { // 如果返回reflect.Value{}，则说明该字段不存在 name.SetString(\\\"jack\\\") } // 输出结构体 fmt.Println(rValue.Interface()) }\",\"输出\",\"{jack 0 0}\",\"对于修改结构体私有字段而言，需要进行一些额外的操作，如下\",\"func main() { // 传入指针 rValue := reflect.ValueOf(&Person{ Name: \\\"\\\", Age: 0, Address: \\\"\\\", money: 0, }).Elem() // 获取一个私有字段 money := rValue.FieldByName(\\\"money\\\") // 修改字段值 if (money != reflect.Value{}) { // 构造指向该结构体未导出字段的指针反射值 p := reflect.NewAt(money.Type(), money.Addr().UnsafePointer()) // 获取该指针所指向的元素，也就是要修改的字段 field := p.Elem() // 修改值 field.SetInt(164) } // 输出结构体 fmt.Printf(\\\"%+v\\\\n\\\", rValue.Interface()) }\"]},\"288\":{\"h\":\"访问Tag\",\"t\":[\"获取到StructField后，便可以直接访问其Tag\",\"// 如果不存在，ok为false func (tag StructTag) Lookup(key string) (value string, ok bool) // 如果不存在，返回空字符串 func (tag StructTag) Get(key string) string\",\"示例如下\",\"func main() { rType := reflect.TypeOf(new(Person)).Elem() name, ok := rType.FieldByName(\\\"Name\\\") if ok { fmt.Println(name.Tag.Lookup(\\\"json\\\")) fmt.Println(name.Tag.Get(\\\"json\\\")) } }\",\"输出\",\"name true name\"]},\"289\":{\"h\":\"访问方法\",\"t\":[\"访问方法与访问字段的过程很相似，只是函数签名略有区别。reflect.Method结构体如下\",\"type Method struct { // 方法名 Name string // 包名 PkgPath string // 方法类型 Type Type // 方法对应的函数，第一个参数是接收者 Func Value // 索引 Index int }\",\"访问方法信息示例如下\",\"func main() { // 获取结构体反射类型 rType := reflect.TypeOf(new(Person)).Elem() // 输出方法个数 fmt.Println(rType.NumMethod()) // 遍历输出方法信息 for i := 0; i < rType.NumMethod(); i++ { method := rType.Method(i) fmt.Println(method.Index, method.Name, method.Type, method.IsExported()) } }\",\"输出\",\"1 0 Talk func(main.Person, string) string true\",\"如果想要获取方法的参数和返回值细节，可以通过Method.Func来进行获取，过程与访问函数信息一致，将上面的代码稍微修改下\",\"func main() { // 获取结构体反射类型 rType := reflect.TypeOf(new(Person)).Elem() // 输出方法个数 fmt.Println(rType.NumMethod()) // 遍历输出方法信息 for i := 0; i < rType.NumMethod(); i++ { method := rType.Method(i) fmt.Println(method.Index, method.Name, method.Type, method.IsExported()) fmt.Println(\\\"方法参数\\\") for i := 0; i < method.Func.Type().NumIn(); i++ { fmt.Println(method.Func.Type().In(i).String()) } fmt.Println(\\\"方法返回值\\\") for i := 0; i < method.Func.Type().NumOut(); i++ { fmt.Println(method.Func.Type().Out(i).String()) } } }\",\"可以看到第一个参数是main.Person，也就是接收者类型\",\"1 0 Talk func(main.Person, string) string true 方法参数 main.Person string 方法返回值 string\"]},\"290\":{\"h\":\"调用方法\",\"t\":[\"调用方法与调用函数的过程相似，而且并不需要手动传入接收者，例子如下\",\"func main() { // 获取结构体反射类型 rValue := reflect.ValueOf(new(Person)).Elem() // 输出方法个数 fmt.Println(rValue.NumMethod()) // 遍历输出方法信息 talk := rValue.MethodByName(\\\"Talk\\\") if (talk != reflect.Value{}) { // 调用方法，并获取返回值 res := talk.Call([]reflect.Value{reflect.ValueOf(\\\"hello,reflect!\\\")}) // 遍历输出返回值 for _, re := range res { fmt.Println(re.Interface()) } } }\",\"输出\",\"1 hello,reflect!\"]},\"291\":{\"h\":\"创建\",\"t\":[\"通过反射可以构造新的值，reflect包同时根据一些特殊的类型提供了不同的更为方便的函数。\"]},\"292\":{\"h\":\"基本类型\",\"t\":[\"// 返回指向反射值的指针反射值 func New(typ Type) Value\",\"以string为例\",\"func main() { rValue := reflect.New(reflect.TypeOf(*new(string))) rValue.Elem().SetString(\\\"hello world!\\\") fmt.Println(rValue.Elem().Interface()) }\",\"hello world!\"]},\"293\":{\"h\":\"结构体\",\"t\":[\"结构体的创建同样用到reflect.New函数\",\"type Person struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` Address string `json:\\\"address\\\"` money int } func (p Person) Talk(msg string) string { return msg } func main() { // 创建结构体反射值 rType := reflect.TypeOf(new(Person)).Elem() person := reflect.New(rType).Elem() fmt.Println(person.Interface()) }\",\"输出\",\"{ 0 0}\"]},\"294\":{\"h\":\"切片\",\"t\":[\"反射创建切片\",\"func MakeSlice(typ Type, len, cap int) Value\",\"func main() { // 创建切片反射值 rValue := reflect.MakeSlice(reflect.TypeOf(*new([]int)), 10, 10) // 遍历赋值 for i := 0; i < 10; i++ { rValue.Index(i).SetInt(int64(i)) } fmt.Println(rValue.Interface()) }\",\"[0 1 2 3 4 5 6 7 8 9]\"]},\"295\":{\"h\":\"Map\",\"t\":[\"反射创建Map\",\"func MakeMapWithSize(typ Type, n int) Value\",\"func main() { //构建map反射值 rValue := reflect.MakeMapWithSize(reflect.TypeOf(*new(map[string]int)), 10) // 设置值 rValue.SetMapIndex(reflect.ValueOf(\\\"a\\\"), reflect.ValueOf(1)) fmt.Println(rValue.Interface()) }\",\"map[a:1]\"]},\"296\":{\"h\":\"管道\",\"t\":[\"反射创建管道\",\"func MakeChan(typ Type, buffer int) Value\",\"func main() { // 创建管道反射值 makeChan := reflect.MakeChan(reflect.TypeOf(new(chan int)).Elem(), 0) fmt.Println(makeChan.Interface()) }\"]},\"297\":{\"h\":\"函数\",\"t\":[\"反射创建函数\",\"func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value\",\"func main() { // 传入包装类型和函数体 fn := reflect.MakeFunc(reflect.TypeOf(new(func(int))).Elem(), func(args []reflect.Value) (results []reflect.Value) { for _, arg := range args { fmt.Println(arg.Interface()) } return nil }) fmt.Println(fn.Type()) fn.Call([]reflect.Value{reflect.ValueOf(1024)}) }\",\"输出\",\"func(int) 1024\"]},\"298\":{\"h\":\"完全相等\",\"t\":[\"reflect.DeepEqual是反射包下提供的一个用于判断两个变量是否完全相等的函数，签名如下。\",\"func DeepEqual(x, y any) bool\",\"该函数对于每一种基础类型都做了处理，下面是一些类型判断方式。\",\"数组：数组中的每一个元素都完全相等\",\"切片：都为nil时，判为完全相等，或者都不为空时，长度范围内的元素完全相等\",\"结构体：所有字段都完全相等\",\"映射表：都为nil时，为完全相等，都不为nil时，每一个键所映射的值都完全相等\",\"指针：指向同一个元素或指向的元素完全相等\",\"接口：接口的具体类型完全相等时\",\"函数：只有两者都为nil时才是完全相等，否则就不是完全相等\",\"下面是一些例子：\",\"切片\",\"func main() { a := make([]int, 100) b := make([]int, 100) fmt.Println(reflect.DeepEqual(a, b)) }\",\"输出\",\"true\",\"结构体\",\"func main() { mike := Person{ Name: \\\"mike\\\", Age: 39, Father: nil, } jack := Person{ Name: \\\"jack\\\", Age: 18, Father: &mike, } tom := Person{ Name: \\\"tom\\\", Age: 18, Father: &mike, } fmt.Println(reflect.DeepEqual(mike, jack)) fmt.Println(reflect.DeepEqual(tom, jack)) fmt.Println(reflect.DeepEqual(jack, jack)) }\",\"输出\",\"false false true\"]},\"299\":{\"h\":\"类型\",\"t\":[\"在之前的数据类型的小节中已经简单了介绍过了Go中的所有内置的数据类型，这些内置的基础类型，是后续自定义类型的基础。Go是一个典型的静态类型语言，所有变量的类型都会在编译期确定好，并且在整个程序的生命周期都不会再改变，这一小节会简单的介绍下Go的类型系统和基本使用。\"]},\"300\":{\"h\":\"静态强类型\",\"t\":[\"Go是一个静态强类型语言，静态指的是Go所有变量的类型早在编译期间就已经确定了，在程序的生命周期都不会再发生改变，尽管Go中的短变量声明有点类似动态语言的写法，但其变量类型是由编译器自行推断的，最根本的区别在于它的类型一旦推断出来后不会再发生变化，动态语言则完全相反。所以下面的代码完全无法通过编译，因为a是int类型的变量，不能赋值字符串。\",\"func main() { var a int = 64 a = \\\"64\\\" fmt.Println(a) // cannot use \\\"64\\\" (untyped string constant) as int value in assignment }\",\"强类型则指的是在程序中执行严格的类型检查，如果出现类型不匹配的情况时，会立即告诉程序员不应该这么做，而不是像动态语言一样去尝试推断可能的结果。所以下面的代码无法通过编译，因为两者类型不同，无法进行运算。\",\"func main() { fmt.Println(1 + \\\"1\\\") // invalid operation: 1 + \\\"1\\\" (mismatched types untyped int and untyped string) }\"]},\"301\":{\"h\":\"类型后置\",\"t\":[\"Go为什么要把类型声明放在后面而不是前面，很大程度上是从C语言吸取了教训，拿官方的一个例子展示效果，这是一个函数指针\",\"int (*(*fp)(int (*)(int, int), int))(int, int)\",\"说实话不认真看很难知道这是一个什么类型，在Go中类似的写法如下\",\"f func(func(int,int) int, int) func(int, int) int\",\"Go的声明方式始终遵循名字在前面，类型在后面的原则，从左往右读，大概第一眼就可以知道这是一个函数，且返回值为func(int,int) int。当类型变得越来越复杂时，类型后置在可读性上要好得多，Go在许多层面的设计都是为了可读性而服务的。\"]},\"302\":{\"h\":\"类型声明\",\"t\":[\"在Go中通过类型声明，可以声明一个自定义名称的新类型，声明一个新类型通常需要一个类型名称以及一个基础类型，简单的例子如下：\",\"type MyInt int64\",\"在上述类型声明中，通过type关键字声明了一个基础类型为int64名为MyInt的类型。在Go中，每一个新声明的类型都必须有一个与之对应的基础类型，且类型名称不建议与已有的内置标识符重复。\",\"type MyInt int64 type MyFloat64 float64 type MyMap map[string]int // 可以通过编译，但是不建议使用，这会覆盖原有的类型 type int int64\",\"通过类型声明的类型都是新类型，不同的类型无法进行运算，即便基础类型是相同的。\",\"type MyFloat64 float64 var f1 MyFloat64 var f float64 f1 = 0.2 f = 0.1 fmt.Println(f1 + f)\",\"invalid operation: f1 + f (mismatched types MyFloat64 and float64)\"]},\"303\":{\"h\":\"类型别名\",\"t\":[\"类型别名与类型声明则不同，类型别名仅仅只是一个别名，并不是创建了一个新的类型，简单的例子如下：\",\"type Int = int\",\"两者是都是同一个类型，仅仅叫的名字不同，所以也就可以进行运算，所以下例自然也就可以通过编译。\",\"type Int = int var a Int = 1 var b int = 2 fmt.Println(a + b)\",\"3\",\"类型别名对于一些特别复杂的类型有很大的用处，例如现在有一个类型map[string]map[string]int，这是一个二维map，现有一个函数参数是map[string]map[string]int类型，如下\",\"func PrintMyMap(mymap map[string]map[string]int) { fmt.Println(mymap) }\",\"这种情况下，就没有必要使用类型声明了，因为前者是声明了一个新的类型，无法作为该函数的参数，使用类型别名后的例子如下\",\"type TwoDMap = map[string]map[string]int func PrintMyMap(mymap TwoDMap) { fmt.Println(mymap) }\",\"使用类型别名后看起来会简洁一些。\",\"提示\",\"内置类型any就是interface{}的类型别名，两者完全等价，仅仅叫法不一样。\"]},\"304\":{\"h\":\"类型转换\",\"t\":[\"在Go中，只存在显式的类型转换，不存在隐式类型转换，因此不同类型的变量无法进行运算，无法作为参数传递。类型转换适用的前提是知晓被转换变量的类型和要转换成的目标类型，例子如下：\",\"type MyFloat64 float64 var f1 MyFloat64 var f float64 f1 = 0.2 f = 0.1 fmt.Println(float64(f1) + f)\",\"0.30000000000000004\",\"通过显式的将MyFloat64 转换为float64类型，才能进行加法运算。类型转换的另一个前提是：被转换类型必须是可以被目标类型代表的（Representability），例如int可以被int64类型所代表，也可以被float64类型代表，所以它们之间可以进行显式的类型转换，但是int类型无法被string和bool类型代表，因为也就无法进行类型转换。\",\"提示\",\"关于代表（Representabilitsy）的定义可以前往参考手册 - Representability以了解更多细节。\",\"即便两个类型可以相互代表，类型转换的结果也不总是正确的，看下面的一个例子：\",\"var num1 int8 = 1 var num2 int32 = 512 fmt.Println(int32(num1), int8(num2))\",\"1 0\",\"num1被正确的转换为了int32类型，但是num2并没有。这是一个典型的数值溢出问题，int32能够表示31位整数，int8只能表示7位整数，高精度整数在向低精度整数转换时会抛弃高位保留低位，因此num1的转换结果就是0。在数字的类型转换中，通常建议小转大，而不建议大转小。\",\"在使用类型转换时，对于一些类型需要避免歧义，例子如下：\",\"*Point(p) // 等价于 *(Point(p)) (*Point)(p) // 将p转换为类型 *Point <-chan int(c) // 等价于 <-(chan int(c)) (<-chan int)(c) // 将c转换为类型 <-chan int (func())(x) // 将x转换为类型 func() (func() int)(x) // 将x转换为类型 func() int\"]},\"305\":{\"h\":\"类型断言\",\"t\":[\"类型断言通常用于判断某一接口类型的变量是否属于某一个类型，示例如下\",\"var b int = 1 var a interface{} = b if intVal, ok := a.(int); ok { fmt.Println(intVal) } else { fmt.Println(\\\"error type\\\") }\",\"1\",\"由于interface{}是空接口类型，空接口类型可以代表所有的类型，但是int类型无法代表interface{}类型，所以无法使用类型转换。而类型断言就可以判断其底层类型是否为想要的类型，类型断言语句有两个返回值，一个是类型转换过后的值，另一个是转换结果的布尔值。\"]},\"306\":{\"h\":\"类型判断\",\"t\":[\"在Go中，switch语句还支持一种特殊的写法，通过这种写法可以根据不同的case做出不同的逻辑处理，使用的前提是入参必须是接口类型，示例如下：\",\"var a interface{} = 2 switch a.(type) { case int: fmt.Println(\\\"int\\\") case float64: fmt.Println(\\\"float\\\") case string: fmt.Println(\\\"string\\\") }\",\"int\",\"提示\",\"通过unsafe包下提供的操作，可以绕过Go的类型系统，就可以做到原本无法通过编译的类型转换操作。\"]},\"307\":{\"h\":\"错误\",\"t\":[\"在Go中的异常有三种级别：\",\"error：正常的流程出错，需要处理，直接忽略掉不处理程序也不会崩溃\",\"panic：很严重的问题，程序应该在处理完问题后立即退出\",\"fatal：非常致命的问题，程序应该立即退出\",\"准确的来说，Go语言并没有异常，它是通过错误来体现，同样的，Go中也并没有try-catch-finally这种语句，Go创始人希望能够将错误可控，他们不希望干什么事情都需要嵌套一堆try-catch，所以大多数情况会将其作为函数的返回值来返回，例如下方代码例子：\",\"func main() { // 打开一个文件 if file, err := os.Open(\\\"README.txt\\\"); err != nil { fmt.Println(err) return } fmt.Println(file.Name()) }\",\"这段代码的意图很明显，打开一个名为README.txt的文件，如果打开失败函数将会返回一个错误，输出错误信息，如果错误为nil的话那么就是打开成功，输出文件名。\",\"看起来似乎是要比try-catch简洁一些，那如果有特别多的函数调用，将会到处都充斥着if err != nil 这种判断语句，比如下面的例子，这是一个计算文件哈希值的demo，在这一小段代码中总共出现了三次if err != nil。\",\"func main() { sum, err := checksum(\\\"main.go\\\") if err != nil { fmt.Println(err) return } fmt.Println(sum) } func checksum(path string) (string, error) { file, err := os.Open(path) if err != nil { return \\\"\\\", err } defer file.Close() hash := sha256.New() _, err = io.Copy(hash, file) if err != nil { return \\\"\\\", err } var hexSum [64]byte sum := hash.Sum(nil) hex.Encode(hexSum[:], sum) return string(hexSum[:]), nil }\",\"正因如此，外界对于Go最诟病的点就在错误处理上，Go源代码里if err != nil就占了相当一部分。Rust同样也是返回错误值，但没有人会去说它这一点，因为它通过语法糖的方式解决了这类问题，与Rust相比之下，Go的语法糖不能说很多，只能说是几乎没有。\",\"不过我们看待事物要辩证的来看，凡事都是有好有坏的，Go的错误处理的优点有几个\",\"心智负担小：有错误就处理，不处理就返回\",\"可读性：因为处理的方式非常简单，大部分情况下都很容易读懂代码\",\"易于调试：每一个错误都是通过函数调用的返回值产生的，可以一层一层往回找到，很少会出现突然冒出一个错误却不知道是从哪里来的这种情况\",\"不过缺点也不少\",\"错误中没有堆栈信息（需要第三方包解决或者自己封装）\",\"丑陋，重复代码多（看个人喜好）\",\"自定义错误是通过var来声明的，它是一个变量而不是常量（确实不应该）\",\"变量遮蔽问题\",\"社区中有关于Go错误处理的提案和讨论自从Go诞生以来就从未停止过，有这么一句玩笑话：如果你能接受Go的错误处理，那么你才是个合格的Gopher了。\",\"提示\",\"这里有两篇Go团队关于错误处理的文章，感兴趣可以看看\",\"Errors are values - Rob Pike\",\"Error handling and Go - Andrew Gerrand\"]},\"308\":{\"h\":\"error\",\"t\":[\"error属于是一种正常的流程错误，它的出现是可以被接受的，大多数情况下应该对其进行处理，当然也可以忽略不管，error的严重级别不足以停止整个程序的运行。error本身是一个预定义的接口，该接口下只有一个方法Error()，该方法的返回值是字符串，用于输出错误信息。\",\"type error interface { Error() string }\",\"error在历史上也有过大改，在1.13版本时Go团队推出了链式错误，且提供了更加完善的错误检查机制，接下来都会一一介绍。\"]},\"309\":{\"h\":\"创建\",\"t\":[\"创建一个error有以下几种方法，第一种是使用errors包下的New函数。\",\"err := errors.New(\\\"这是一个错误\\\")\",\"第二种是使用fmt包下的Errorf函数，可以得到一个格式化参数的error。\",\"err := fmt.Errorf(\\\"这是%d个格式化参数的的错误\\\", 1)\",\"下面是一个完整的例子\",\"func sumPositive(i, j int) (int, error) { if i <= 0 || j <= 0 { return -1, errors.New(\\\"必须是正整数\\\") } return i + j, nil }\",\"大部分情况，为了更好的维护性，一般都不会临时创建error，而是会将常用的error当作全局变量使用，例如下方节选自os\\\\erros.go文件的代码\",\"var ( ErrInvalid = fs.ErrInvalid // \\\"invalid argument\\\" ErrPermission = fs.ErrPermission // \\\"permission denied\\\" ErrExist = fs.ErrExist // \\\"file already exists\\\" ErrNotExist = fs.ErrNotExist // \\\"file does not exist\\\" ErrClosed = fs.ErrClosed // \\\"file already closed\\\" ErrNoDeadline = errNoDeadline() // \\\"file type does not support deadline\\\" ErrDeadlineExceeded = errDeadlineExceeded() // \\\"i/o timeout\\\" )\",\"可以看到它们都是被var定义的变量\"]},\"310\":{\"h\":\"自定义错误\",\"t\":[\"通过实现Error()方法，可以很轻易的自定义error，例如erros包下的errorString就是一个很简单的实现。\",\"func New(text string) error { return &errorString{text} } // errorString结构体 type errorString struct { s string } func (e *errorString) Error() string { return e.s }\",\"因为errorString实现太过于简单，表达能力不足，所以很多开源库包括官方库都会选择自定义error，以满足不同的错误需求。\"]},\"311\":{\"h\":\"传递\",\"t\":[\"在一些情况中，调用者调用的函数返回了一个错误，但是调用者本身不负责处理错误，于是也将错误作为返回值返回，抛给上一层调用者，这个过程叫传递，错误在传递的过程中可能会层层包装，当上层调用者想要判断错误的类型来做出不同的处理时，可能会无法判别错误的类别或者误判，而链式错误正是为了解决这种情况而出现的。\",\"type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err }\",\"wrappError同样实现了error接口，也多了一个方法Unwrap，用于返回其内部对于原error的引用，层层包装下就形成了一条错误链表，顺着链表上寻找，很容易就能找到原始错误。由于该结构体并不对外暴露，所以只能使用fmt.Errorf函数来进行创建，例如\",\"err := errors.New(\\\"这是一个原始错误\\\") wrapErr := fmt.Errorf(\\\"错误，%w\\\", err)\",\"使用时，必须使用%w格式动词，且参数只能是一个有效的error。\"]},\"312\":{\"h\":\"处理\",\"t\":[\"错误处理中的最后一步就是如何处理和检查错误，errors包提供了几个方便函数用于处理错误。\",\"func Unwrap(err error) error\",\"errors.Unwrap()函数用于解包一个错误链，其内部实现也很简单\",\"func Unwrap(err error) error { u, ok := err.(interface { // 类型断言，是否实现该方法 Unwrap() error }) if !ok { //没有实现说明是一个基础的error return nil } return u.Unwrap() // 否则调用Unwrap }\",\"解包后会返回当前错误链所包裹的错误，被包裹的错误可能依旧是一个错误链，如果想要在错误链中找到对应的值或类型，可以递归进行查找匹配，不过标准库已经提供好了类似的函数。\",\"func Is(err, target error) bool\",\"errors.Is函数的作用是判断错误链中是否包含指定的错误，例子如下\",\"var originalErr = errors.New(\\\"this is an error\\\") func wrap1() error { // 包裹原始错误 return fmt.Errorf(\\\"wrapp error %w\\\", wrap2()) } func wrap2() error { // 原始错误 return originalErr } func main() { err := wrap1() if errors.Is(err, originalErr) { // 如果使用if err == originalErr 将会是false fmt.Println(\\\"original\\\") } }\",\"所以在判断错误时，不应该使用==操作符，而是应该使用errors.Is()。\",\"func As(err error, target any) bool\",\"errors.As()函数的作用是在错误链中寻找第一个类型匹配的错误，并将值赋值给传入的err。有些情况下需要将error类型的错误转换为具体的错误实现类型，以获得更详细的错误细节，而对一个错误链使用类型断言是无效的，因为原始错误是被结构体包裹起来的，这也是为什么需要As函数的原因。例子如下\",\"type TimeError struct { // 自定义error Msg string Time time.Time //记录发生错误的时间 } func (m TimeError) Error() string { return m.Msg } func NewMyError(msg string) error { return &TimeError{ Msg: msg, Time: time.Now(), } } func wrap1() error { // 包裹原始错误 return fmt.Errorf(\\\"wrapp error %w\\\", wrap2()) } func wrap2() error { // 原始错误 return NewMyError(\\\"original error\\\") } func main() { var myerr *TimeError err := wrap1() // 检查错误链中是否有*TimeError类型的错误 if errors.As(err, &myerr) { // 输出TimeError的时间 fmt.Println(\\\"original\\\", myerr.Time) } }\",\"target必须是指向error的指针，由于在创建结构体时返回的是结构体指针，所以error实际上*TimeError类型的，那么target就必须是**TimeError类型的。\",\"不过官方提供的errors包其实并不够用，因为它没有堆栈信息，不能定位，一般会比较推荐使用官方的另一个增强包\",\"github.com/pkg/errors\",\"例子\",\"import ( \\\"fmt\\\" \\\"github.com/pkg/errors\\\" ) func Do() error { return errors.New(\\\"error\\\") } func main() { if err := Do(); err != nil { fmt.Printf(\\\"%+v\\\", err) } }\",\"输出\",\"some unexpected error happened main.Do D:/WorkSpace/Code/GoLeran/golearn/main.go:9 main.main D:/WorkSpace/Code/GoLeran/golearn/main.go:13 runtime.main D:/WorkSpace/Library/go/root/go1.21.3/src/runtime/proc.go:267 runtime.goexit D:/WorkSpace/Library/go/root/go1.21.3/src/runtime/asm_amd64.s:1650\",\"通过格式化输出，就可以看到堆栈信息了，默认情况下是不会输出堆栈的。这个包相当于是标准库errors包的加强版，同样都是官方写的，不知道为什么没有并入标准库。\"]},\"313\":{\"h\":\"panic\",\"t\":[\"panic中文译为恐慌，表示十分严重的程序问题，程序需要立即停止来处理该问题，否则程序立即停止运行并输出堆栈信息，panic是Go是运行时异常的表达形式，通常在一些危险操作中会出现，主要是为了及时止损，从而避免造成更加严重的后果。不过panic在退出之前会做好程序的善后工作，同时panic也可以被恢复来保证程序继续运行。\",\"下方是一个向nil的map写入值的例子，肯定会触发panic\",\"func main() { var dic map[string]int dic[\\\"a\\\"] = 'a' }\",\"panic: assignment to entry in nil map\",\"提示\",\"当程序中存在多个协程时，只要任一协程发生panic，如果不将其捕获的话，整个程序都会崩溃\"]},\"314\":{\"h\":\"创建\",\"t\":[\"显式的创建panic十分简单，使用内置函数panic即可，函数签名如下\",\"func panic(v any)\",\"panic函数接收一个类型为 any的参数v，当输出错误堆栈信息时，v也会被输出。使用例子如下\",\"func main() { initDataBase(\\\"\\\", 0) } func initDataBase(host string, port int) { if len(host) == 0 || port == 0 { panic(\\\"非法的数据链接参数\\\") } // ...其他的逻辑 }\",\"当初始化数据库连接失败时，程序就不应该启动，因为没有数据库程序就运行的毫无意义，所以此处应该抛出panic\",\"panic: 非法的数据链接参数\"]},\"315\":{\"h\":\"善后\",\"t\":[\"程序因为panic退出之前会做一些善后工作，例如执行defer语句。\",\"func main() { defer fmt.Println(\\\"A\\\") defer fmt.Println(\\\"B\\\") fmt.Println(\\\"C\\\") panic(\\\"panic\\\") defer fmt.Println(\\\"D\\\") }\",\"输出为\",\"C B A panic: panic\",\"并且上游函数的defer语句同样会执行，例子如下\",\"func main() { defer fmt.Println(\\\"A\\\") defer fmt.Println(\\\"B\\\") fmt.Println(\\\"C\\\") dangerOp() defer fmt.Println(\\\"D\\\") } func dangerOp() { defer fmt.Println(1) defer fmt.Println(2) panic(\\\"panic\\\") defer fmt.Println(3) }\",\"输出\",\"C 2 1 B A panic: panic\",\"defer中也可以嵌套panic，下面是一个比较复杂的例子\",\"func main() { defer fmt.Println(\\\"A\\\") defer func() { func() { panic(\\\"panicA\\\") defer fmt.Println(\\\"E\\\") }() }() fmt.Println(\\\"C\\\") dangerOp() defer fmt.Println(\\\"D\\\") } func dangerOp() { defer fmt.Println(1) defer fmt.Println(2) panic(\\\"panicB\\\") defer fmt.Println(3) }\",\"defer中嵌套的panic 执行顺序依旧一致，发生panic时后续的逻辑将无法执行。\",\"C 2 1 A panic: panicB panic: panicA\",\"综上所述，当发生panic时，会立即退出所在函数，并且执行当前函数的善后工作，例如defer，然后层层上抛，上游函数同样的也进行善后工作，直到程序停止运行。\",\"当子协程发生panic时，不会触发当前协程的善后工作，如果直到子协程退出都没有恢复panic，那么程序将会直接停止运行。\",\"var waitGroup sync.WaitGroup func main() { demo() } func demo() { waitGroup.Add(1) defer func() { fmt.Println(\\\"A\\\") }() fmt.Println(\\\"C\\\") go dangerOp() waitGroup.Wait() // 父协程阻塞等待子协程执行完毕 defer fmt.Println(\\\"D\\\") } func dangerOp() { defer fmt.Println(1) defer fmt.Println(2) panic(\\\"panicB\\\") defer fmt.Println(3) waitGroup.Done() }\",\"输出为\",\"C 2 1 panic: panicB\",\"可以看到demo()中的defer语句一个都没有执行，程序就直接退出了。需要注意的是，如果没有waitGroup来阻塞父协程的话，demo()的执行速度可能会快于子协程的执行速度，输出的结果就会变得非常有迷惑性，下面稍微修改一下代码\",\"func main() { demo() } func demo() { defer func() { // 父协程善后工作要花费20ms time.Sleep(time.Millisecond * 20) fmt.Println(\\\"A\\\") }() fmt.Println(\\\"C\\\") go dangerOp() defer fmt.Println(\\\"D\\\") } func dangerOp() { // 子协程要执行一些逻辑，要花费1ms time.Sleep(time.Millisecond) defer fmt.Println(1) defer fmt.Println(2) panic(\\\"panicB\\\") defer fmt.Println(3) }\",\"输出为\",\"C D 2 1 panic: panicB\",\"在本例中，当子协程发生panic时，父协程早已完成的函数的执行，进入了善后工作，在执行最后一个defer时，碰巧遇到了子协程发生panic，所以程序就直接退出运行。\"]},\"316\":{\"h\":\"恢复\",\"t\":[\"当发生panic时，使用内置函数recover()可以及时的处理并且保证程序继续运行，必须要在defer语句中运行，使用示例如下。\",\"func main() { dangerOp() fmt.Println(\\\"程序正常退出\\\") } func dangerOp() { defer func() { if err := recover(); err != nil { fmt.Println(err) fmt.Println(\\\"panic恢复\\\") } }() panic(\\\"发生panic\\\") }\",\"调用者完全不知道dangerOp()函数内部发生了panic，程序执行剩下的逻辑后正常退出，所以输出如下\",\"发生panic panic恢复 程序正常退出\",\"但事实上recover()的使用有许多隐含的陷阱。例如在defer中再次闭包使用recover。\",\"func main() { dangerOp() fmt.Println(\\\"程序正常退出\\\") } func dangerOp() { defer func() { func() { if err := recover(); err != nil { fmt.Println(err) fmt.Println(\\\"panic恢复\\\") } }() }() panic(\\\"发生panic\\\") }\",\"闭包函数可以看作调用了一个函数，panic是向上传递而不是向下，自然闭包函数也就无法恢复panic，所以输出如下。\",\"panic: 发生panic\",\"除此之外，还有一种很极端的情况，那就是panic()的参数是nil。\",\"func main() { dangerOp() fmt.Println(\\\"程序正常退出\\\") } func dangerOp() { defer func() { if err := recover(); err != nil { fmt.Println(err) fmt.Println(\\\"panic恢复\\\") } }() panic(nil) }\",\"这种情况panic确实会恢复，但是不会输出任何的错误信息。\",\"输出\",\"程序正常退出\",\"总的来说recover函数有几个注意点\",\"必须在defer中使用\",\"多次使用也只会有一个能恢复panic\",\"闭包recover不会恢复外部函数的任何panic\",\"panic的参数禁止使用nil\"]},\"317\":{\"h\":\"fatal\",\"t\":[\"fatal是一种极其严重的问题，当发生fatal时，程序需要立刻停止运行，不会执行任何善后工作，通常情况下是调用os包下的Exit函数退出程序，如下所示\",\"func main() { dangerOp(\\\"\\\") } func dangerOp(str string) { if len(str) == 0 { fmt.Println(\\\"fatal\\\") os.Exit(1) } fmt.Println(\\\"正常逻辑\\\") }\",\"输出\",\"fatal\",\"fatal级别的问题一般很少会显式的去触发，大多数情况都是被动触发。\"]},\"318\":{\"h\":\"文件\",\"t\":[\"Go语言提供文件处理的标准库大致以下几个：\",\"os库，负责OS文件系统交互的具体实现\",\"io库，读写IO的抽象层\",\"fs库，文件系统的抽象层\",\"本文会讲解如何通过Go语言来进行基本的文件处理。\"]},\"319\":{\"h\":\"打开\",\"t\":[\"常见的两种打开文件的方式是使用os包提供的两个函数，Open函数返回值一个文件指针和一个错误，\",\"func Open(name string) (*File, error)\",\"后者OpenFile能够提供更加细粒度的控制，函数Open就是对OpenFile函数的一个简单封装。\",\"func OpenFile(name string, flag int, perm FileMode) (*File, error)\",\"先来介绍第一种使用方法，直接提供对应的文件名即可，代码如下\",\"func main() { file, err := os.Open(\\\"README.txt\\\") fmt.Println(file, err) }\",\"文件的查找路径默认为项目go.mod文件所在的路径，由于项目下并没有文件README.txt，所以自然会返回一个错误。\",\"<nil> open README.txt: The system cannot find the file specified.\",\"因为IO错误的类型有很多，所以需要手动的去判断文件是否存在，同样的os包也为此提供了方便函数，修改后的代码如下\",\"func main() { file, err := os.Open(\\\"README.txt\\\") if os.IsNotExist(err) { fmt.Println(\\\"文件不存在\\\") } else if err != nil { fmt.Println(\\\"文件访问异常\\\") } else { fmt.Println(\\\"文件读取成功\\\", file) } }\",\"再次运行输出如下\",\"文件不存在\",\"事实上第一种函数读取的文件仅仅只是只读的，无法被修改\",\"func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) }\",\"通过OpenFile函数可以控制更多细节，例如修改文件描述符和文件权限，关于文件描述符，os包下提供了以下常量以供使用。\",\"const ( // 只读，只写，读写 三种必须指定一个 O_RDONLY int = syscall.O_RDONLY // 以只读的模式打开文件 O_WRONLY int = syscall.O_WRONLY // 以只写的模式打开文件 O_RDWR int = syscall.O_RDWR // 以读写的模式打开文件 // 剩余的值用于控制行为 O_APPEND int = syscall.O_APPEND // 当写入文件时，将数据添加到文件末尾 O_CREATE int = syscall.O_CREAT // 如果文件不存在则创建文件 O_EXCL int = syscall.O_EXCL // 与O_CREATE一起使用, 文件必须不存在 O_SYNC int = syscall.O_SYNC // 以同步IO的方式打开文件 O_TRUNC int = syscall.O_TRUNC // 当打开的时候截断可写的文件 )\",\"关于文件权限的则提供了以下常量。\",\"const ( ModeDir = fs.ModeDir // d: 目录 ModeAppend = fs.ModeAppend // a: 只能添加 ModeExclusive = fs.ModeExclusive // l: 专用 ModeTemporary = fs.ModeTemporary // T: 临时文件 ModeSymlink = fs.ModeSymlink // L: 符号链接 ModeDevice = fs.ModeDevice // D: 设备文件 ModeNamedPipe = fs.ModeNamedPipe // p: 具名管道 (FIFO) ModeSocket = fs.ModeSocket // S: Unix 域套接字 ModeSetuid = fs.ModeSetuid // u: setuid ModeSetgid = fs.ModeSetgid // g: setgid ModeCharDevice = fs.ModeCharDevice // c: Unix 字符设备, 前提是设置了 ModeDevice ModeSticky = fs.ModeSticky // t: 黏滞位 ModeIrregular = fs.ModeIrregular // ?: 非常规文件 // 类型位的掩码. 对于常规文件而言，什么都不会设置. ModeType = fs.ModeType ModePerm = fs.ModePerm // Unix 权限位, 0o777 )\",\"下面是一个以读写模式打开一个文件的代码例子，权限为0666，表示为所有人都可以对该文件进行读写，且不存在时会自动创建。\",\"func main() { file, err := os.OpenFile(\\\"README.txt\\\", os.O_RDWR|os.O_CREATE, 0666) if os.IsNotExist(err) { fmt.Println(\\\"文件不存在\\\") } else if err != nil { fmt.Println(\\\"文件访问异常\\\") } else { fmt.Println(\\\"文件打开成功\\\", file.Name()) file.Close() } }\",\"输出如下\",\"文件打开成功 README.txt\",\"倘若只是想获取该文件的一些信息，并不想读取该文件，可以使用os.Stat()函数进行操作，代码示例如下\",\"func main() { fileInfo, err := os.Stat(\\\"README.txt\\\") if err != nil { fmt.Println(err) } else { fmt.Println(fmt.Sprintf(\\\"%+v\\\", fileInfo)) } }\",\"输出如下\",\"&{name:README.txt FileAttributes:32 CreationTime:{LowDateTime:3603459389 HighDateTime:31016791} LastAccessTime:{LowDateTime:3603459389 HighDateTime:31016791} LastWriteTime:{LowDateTime:3603459389 HighDateTime:31016791} FileSizeHigh :0 FileSizeLow:0 Reserved0:0 filetype:0 Mutex:{state:0 sema:0} path:README.txt vol:0 idxhi:0 idxlo:0 appendNameToPath:false}\",\"注意\",\"打开一个文件后永远要记得关闭该文件，通常关闭操作会放在defer语句里\",\"defer file.Close()\"]},\"320\":{\"h\":\"读取\",\"t\":[\"当成功的打开文件后，便可以进行读取操作了，关于读取文件的操作，*os.File类型提供了以下几个公开的方法\",\"// 将文件读进传入的字节切片 func (f *File) Read(b []byte) (n int, err error) // 相较于第一种可以从指定偏移量读取 func (f *File) ReadAt(b []byte, off int64) (n int, err error)\",\"大多数情况第一种使用的较多。针对于第一种方法，需要自行编写逻辑来进行读取时切片的动态扩容，代码如下\",\"func ReadFile(file *os.File) ([]byte, error) { buffer := make([]byte, 0, 512) for { // 当容量不足时 if len(buffer) == cap(buffer) { // 扩容 buffer = append(buffer, 0)[:len(buffer)] } // 继续读取文件 offset, err := file.Read(buffer[len(buffer):cap(buffer)]) // 将已写入的数据归入切片 buffer = buffer[:len(buffer)+offset] // 发生错误时 if err != nil { if errors.Is(err, io.EOF) { err = nil } return buffer, err } } }\",\"剩余逻辑如下\",\"func main() { file, err := os.OpenFile(\\\"README.txt\\\", os.O_RDWR|os.O_CREATE, 0666) if err != nil { fmt.Println(\\\"文件访问异常\\\") } else { fmt.Println(\\\"文件打开成功\\\", file.Name()) bytes, err := ReadFile(file) if err != nil { fmt.Println(\\\"文件读取异常\\\", err) } else { fmt.Println(string(bytes)) } file.Close() } }\",\"输出为\",\"文件打开成功 README.txt hello world!\",\"除此之外，还可以使用两个方便函数来进行文件读取，分别是os包下的ReadFile函数，以及io包下的ReadAll函数。对于os.ReadFile而言，只需要提供文件路径即可，而对于io.ReadAll而言，则需要提供一个io.Reader类型的实现，\",\"os.ReadFile\",\"func ReadFile(name string) ([]byte, error)\",\"使用例子如下\",\"func main() { bytes, err := os.ReadFile(\\\"README.txt\\\") if err != nil { fmt.Println(err) } else { fmt.Println(string(bytes)) } }\",\"输出如下\",\"hello world!\",\"io.ReadAll\",\"func ReadAll(r Reader) ([]byte, error)\",\"使用例子如下\",\"func main() { file, err := os.OpenFile(\\\"README.txt\\\", os.O_RDWR|os.O_CREATE, 0666) if err != nil { fmt.Println(\\\"文件访问异常\\\") } else { fmt.Println(\\\"文件打开成功\\\", file.Name()) bytes, err := io.ReadAll(file) if err != nil { fmt.Println(err) } else { fmt.Println(string(bytes)) } file.Close() } }\",\"文件打开成功 README.txt hello world!\"]},\"321\":{\"h\":\"写入\",\"t\":[\"os.File结构体提供了以下几种方法以供写入数据\",\"// 写入字节切片 func (f *File) Write(b []byte) (n int, err error) // 写入字符串 func (f *File) WriteString(s string) (n int, err error) // 从指定位置开始写，当以os.O_APPEND模式打开时，会返回错误 func (f *File) WriteAt(b []byte, off int64) (n int, err error)\",\"如果想要对一个文件写入数据，则必须以O_WRONLY或O_RDWR的模式打开，否则无法成功写入文件。下面是一个以os.O_RDWR|os.O_CREATE|os.O_APPEND|os.O_TRUNC模式打开文件，且权限为0666向指定写入数据的例子\",\"func main() { file, err := os.OpenFile(\\\"README.txt\\\", os.O_RDWR|os.O_CREATE|os.O_APPEND|os.O_TRUNC, 0666) if err != nil { fmt.Println(\\\"文件访问异常\\\") } else { fmt.Println(\\\"文件打开成功\\\", file.Name()) for i := 0; i < 5; i++ { offset, err := file.WriteString(\\\"hello world!\\\\n\\\") if err != nil { fmt.Println(offset, err) } } fmt.Println(file.Close()) } }\",\"由于是以os.O_APPEND模式打开的文件，所以在写入文件时会将数据添加到文件尾部，执行完毕后文件内容如下\",\"hello world! hello world! hello world! hello world! hello world!\",\"向文件写入字节切片也是类似的操作，就不再赘述。对于写入文件的操作标准库同样提供了方便函数，分别是os.WriteFile与io.WriteString\",\"os.WriteFile\",\"func WriteFile(name string, data []byte, perm FileMode) error\",\"使用例子如下\",\"func main() { err := os.WriteFile(\\\"README.txt\\\", []byte(\\\"hello world!\\\\n\\\"), 0666) if err != nil { fmt.Println(err) } }\",\"此时文件内容如下\",\"hello world!\",\"io.WriteString\",\"func WriteString(w Writer, s string) (n int, err error)\",\"使用例子如下\",\"func main() { file, err := os.OpenFile(\\\"README.txt\\\", os.O_RDWR|os.O_CREATE|os.O_APPEND|os.O_TRUNC, 0666) if err != nil { fmt.Println(\\\"文件访问异常\\\") } else { fmt.Println(\\\"文件打开成功\\\", file.Name()) for i := 0; i < 5; i++ { offset, err := io.WriteString(file, \\\"hello world!\\\\n\\\") if err != nil { fmt.Println(offset, err) } } fmt.Println(file.Close()) } }\",\"hello world! hello world! hello world! hello world! hello world!\",\"函数os.Create函数用于创建文件，本质上也是对OpenFile的封装。\",\"func Create(name string) (*File, error) { return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) }\",\"注意\",\"在创建一个文件时，如果其父目录不存在，将创建失败并会返回错误。\"]},\"322\":{\"h\":\"复制\",\"t\":[\"对于复制文件而言，需要同时打开两个文件，第一种方法是将原文件中的数据读取出来，然后写入目标文件中，代码示例如下\",\"func main() { // 从原文件中读取数据 data, err := os.ReadFile(\\\"README.txt\\\") if err != nil { fmt.Println(err) return } // 写入目标文件 err = os.WriteFile(\\\"README(1).txt\\\", data, 0666) if err != nil { fmt.Println(err) } else { fmt.Println(\\\"复制成功\\\") } }\",\"*os.File.ReadFrom\",\"另一种方法是使用os.File提供的方法ReadFrom，打开文件时，一个只读，一个只写。\",\"func (f *File) ReadFrom(r io.Reader) (n int64, err error)\",\"使用示例如下\",\"func main() { // 以只读的方式打开原文件 origin, err := os.OpenFile(\\\"README.txt\\\", os.O_RDONLY, 0666) if err != nil { fmt.Println(err) return } defer origin.Close() // 以只写的方式打开副本文件 target, err := os.OpenFile(\\\"README(1).txt\\\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) return } defer target.Close() // 从原文件中读取数据，然后写入副本文件 offset, err := target.ReadFrom(origin) if err != nil { fmt.Println(err) return } fmt.Println(\\\"文件复制成功\\\", offset) }\",\"这种复制方式需要先将源文件的全部内容读取到内存中，再写入目标文件，文件特别大的时候不建议这么做。\",\"io.Copy\",\"另一种方法就是使用io.Copy函数，它则是一边读一边写，先将内容读到缓冲区中，再写入到目标文件中，缓冲区默认大小为32KB。\",\"func Copy(dst Writer, src Reader) (written int64, err error)\",\"使用示例如下\",\"func main() { // 以只读的方式打开原文件 origin, err := os.OpenFile(\\\"README.txt\\\", os.O_RDONLY, 0666) if err != nil { fmt.Println(err) return } defer origin.Close() // 以只写的方式打开副本文件 target, err := os.OpenFile(\\\"README(1).txt\\\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) return } defer target.Close() // 复制 written, err := io.Copy(target, origin) if err != nil { fmt.Println(err) } else { fmt.Println(written) } }\",\"你也可以使用io.CopyBuffer来指定缓冲区大小。\"]},\"323\":{\"h\":\"重命名\",\"t\":[\"重命名也可以理解为移动文件，会用到os包下的Rename函数。\",\"func Rename(oldpath, newpath string) error\",\"示例如下\",\"func main() { err := os.Rename(\\\"README.txt\\\", \\\"readme.txt\\\") if err != nil { fmt.Println(err) } else { fmt.Println(\\\"重命名成功\\\") } }\",\"该函数对于文件夹也是同样的效果。\"]},\"324\":{\"h\":\"删除\",\"t\":[\"删除操作相较于其他操作要简单的多，只会用到os包下的两个函数\",\"// 删除单个文件或者空目录，当目录不为空时会返回错误 func Remove(name string) error // 删除指定目录的所有文件和目录包括子目录与子文件 func RemoveAll(path string) error\",\"使用起来十分的简单，下面是删除目录的例子\",\"func main() { // 删除当前目录下所有的文件与子目录 err := os.RemoveAll(\\\".\\\") if err != nil { fmt.Println(err) }else { fmt.Println(\\\"删除成功\\\") } }\",\"下面是删除单个文件的例子\",\"func main() { // 删除当前目录下所有的文件与子目录 err := os.Remove(\\\"README.txt\\\") if err != nil { fmt.Println(err) } else { fmt.Println(\\\"删除成功\\\") } }\"]},\"325\":{\"h\":\"刷新\",\"t\":[\"os.Sync这一个函数封装了底层的系统调用Fsync，用于将操作系统中缓存的IO写入落实到磁盘上\",\"func main() { create, err := os.Create(\\\"test.txt\\\") if err != nil { panic(err) } defer create.Close() _, err = create.Write([]byte(\\\"hello\\\")) if err != nil { panic(err) } // 刷盘 if err := create.Sync();err != nil { return } }\"]},\"326\":{\"h\":\"文件夹\",\"t\":[\"文件夹的许多操作都与文件操作类似\"]},\"327\":{\"h\":\"读取\",\"t\":[\"对于文件夹而言，打开方式有两种，\",\"os.ReadDir\",\"第一种方式是使用os.ReadDir函数\",\"func ReadDir(name string) ([]DirEntry, error)\",\"func main() { // 当前目录 dir, err := os.ReadDir(\\\".\\\") if err != nil { fmt.Println(err) } else { for _, entry := range dir { fmt.Println(entry.Name()) } } }\",\"*os.File.ReadDir\",\"第二种方式是使用*os.File.ReadDir函数，os.ReadDir本质上也只是对*os.File.ReadDir的一层简单封装。\",\"// n < 0时，则读取文件夹下所有的内容 func (f *File) ReadDir(n int) ([]DirEntry, error)\",\"func main() { // 当前目录 dir, err := os.Open(\\\".\\\") if err != nil { fmt.Println(err) } defer dir.Close() dirs, err := dir.ReadDir(-1) if err != nil { fmt.Println(err) } else { for _, entry := range dirs { fmt.Println(entry.Name()) } } }\"]},\"328\":{\"h\":\"创建\",\"t\":[\"创建文件夹操作会用到os包下的两个函数\",\"// 用指定的权限创建指定名称的目录 func Mkdir(name string, perm FileMode) error // 相较于前者该函数会创建一切必要的父目录 func MkdirAll(path string, perm FileMode) error\",\"示例如下\",\"func main() { err := os.Mkdir(\\\"src\\\", 0666) if err != nil { fmt.Println(err) } else { fmt.Println(\\\"创建成功\\\") } }\"]},\"329\":{\"h\":\"复制\",\"t\":[\"我们可以自己写函数递归遍历整个文件夹，不过filepath标准库已经提供了类似功能的函数，所以可以直接使用，一个简单的文件夹复制的代码示例如下。\",\"func CopyDir(src, dst string) error { // 检查源文件夹的状态 _, err := os.Stat(src) if err != nil { return err } return filepath.Walk(src, func(path string, info fs.FileInfo, err error) error { if err != nil { return err } // 计算相对路径 rel, err := filepath.Rel(src, path) if err != nil { return err } // 拼接目标路径 destpath := filepath.Join(dst, rel) // 创建文件夹 var dirpath string var mode os.FileMode = 0755 if info.IsDir() { dirpath = destpath mode = info.Mode() } else if info.Mode().IsRegular() { dirpath = filepath.Dir(destpath) } if err := os.MkdirAll(dirpath, mode); err != nil { return err } // 创建文件 if info.Mode().IsRegular() { srcfile, err := os.Open(path) if err != nil { return err } // 一定要记得关闭文件 defer srcfile.Close() destfile, err := os.OpenFile(destpath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, info.Mode()) if err != nil { return err } defer destfile.Close() // 复制文件内容 if _, err := io.Copy(destfile, srcfile); err != nil { return err } return nil } return nil }) }\",\"filepath.Walk会递归遍历整个文件夹，在过程中，遇到文件夹就创建文件夹，遇到文件就创建新文件并复制，代码相比复制文件有点多但算不上复杂。\"]},\"330\":{\"h\":\"并发\",\"t\":[\"Go语言对于并发的支持是纯天然的，这是这门语言的核心所在，其上手难度相对较小，开发人员不太需要关注底层实现就能做出一个相当不错的并发应用，提高了开发人员的下限。\"]},\"331\":{\"h\":\"协程\",\"t\":[\"协程（coroutine）是一种轻量级的线程，或者说是用户态的线程，不受操作系统直接调度，由Go语言自身的调度器进行运行时调度，因此上下文切换开销非常小，这也是为什么Go的并发性能很不错的原因之一。协程这一概念并非Go首次提出，Go也不是第一个支持协程的语言，但Go是第一个能够将协程和并发支持的相当简洁和优雅的语言。\",\"在Go中，创建一个协程十分的简单，仅需要一个go关键字，就能够快速开启一个协程，go关键字后面必须是一个函数调用。例子如下\",\"提示\",\"具有返回值的内置函数不允许跟随在go关键字后面，例如下面的错误示范\",\"go make([]int,10) // go discards result of make([]int, 10) (value of type []int)\",\"func main() { go fmt.Println(\\\"hello world!\\\") go hello() go func() { fmt.Println(\\\"hello world!\\\") }() } func hello() { fmt.Println(\\\"hello world!\\\") }\",\"以上三种开启协程的方式都是可以的，但是其实这个例子执行过后在大部分情况下什么都不会输出，协程是并发执行的，系统创建协程需要时间，而在此之前，主协程早已运行结束，一旦主线程退出，其他子协程也就自然退出了。并且协程的执行顺序也是不确定的，无法预判的，例如下面的例子\",\"func main() { fmt.Println(\\\"start\\\") for i := 0; i < 10; i++ { go fmt.Println(i) } fmt.Println(\\\"end\\\") }\",\"这是一个在循环体中开启协程的例子，永远也无法精准的预判到它到底会输出什么。可能子协程还没开始运行，主协程就已经结束了，情况如下\",\"start end\",\"又或者只有一部分子协程在主协程退出前成功运行，情况如下\",\"start 0 1 5 3 4 6 7 end\",\"最简单的做法就是让主协程等一会儿，需要使用到time包下的Sleep函数，可以使当前协程暂停一段时间，例子如下\",\"func main() { fmt.Println(\\\"start\\\") for i := 0; i < 10; i++ { go fmt.Println(i) } // 暂停1ms time.Sleep(time.Millisecond) fmt.Println(\\\"end\\\") }\",\"再次执行输出如下，可以看到所有的数字都完整输出了，没有遗漏\",\"start 0 1 5 2 3 4 6 8 9 7 end\",\"但是顺序还是乱的，因此让每次循环都稍微的等一下。例子如下\",\"func main() { fmt.Println(\\\"start\\\") for i := 0; i < 10; i++ { go fmt.Println(i) time.Sleep(time.Millisecond) } time.Sleep(time.Millisecond) fmt.Println(\\\"end\\\") }\",\"现在的输出已经是正常的顺序了\",\"start 0 1 2 3 4 5 6 7 8 9 end\",\"上面的例子中结果输出很完美，那么并发的问题解决了吗，不，一点也没有。对于并发的程序而言，不可控的因素非常多，执行的时机，先后顺序，执行过程的耗时等等，倘若循环中子协程的工作不只是一个简单的输出数字，而是一个非常巨大复杂的任务，耗时的不确定的，那么依旧会重现之前的问题。例如下方代码\",\"func main() { fmt.Println(\\\"start\\\") for i := 0; i < 10; i++ { go hello(i) time.Sleep(time.Millisecond) } time.Sleep(time.Millisecond) fmt.Println(\\\"end\\\") } func hello(i int) { // 模拟随机耗时 time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) fmt.Println(i) }\",\"这段代码的输出依旧是不确定的，下面是可能的情况之一\",\"start 0 3 4 end\",\"因此time.Sleep并不是一种良好的解决办法，幸运的是Go提供了非常多的并发控制手段，常用的并发控制方法有三种：\",\"channel：管道\",\"WaitGroup：信号量\",\"Context：上下文\",\"三种方法有着不同的适用情况，WaitGroup可以动态的控制一组指定数量的协程，Context更适合子孙协程嵌套层级更深的情况，管道更适合协程间通信。对于较为传统的锁控制，Go也对此提供了支持：\",\"Mutex：互斥锁\",\"RWMutex ：读写互斥锁\"]},\"332\":{\"h\":\"管道\",\"t\":[\"channel，译为管道，Go对于管道的作用如下解释：\",\"Do not communicate by sharing memory; instead, share memory by communicating.\",\"即通过消息来进行内存共享，channel就是为此而生，它是一种在协程间通信的解决方案，同时也可以用于并发控制，先来认识下channel的基本语法。Go中通过关键字chan来代表管道类型，同时也必须声明管道的存储类型，来指定其存储的数据是什么类型，下面的例子是一个普通管道的模样。\",\"var ch chan int\",\"这是一个管道的声明语句，此时管道还未初始化，其值为nil，不可以直接使用。\"]},\"333\":{\"h\":\"创建\",\"t\":[\"在创建管道时，有且只有一种方法，那就是使用内置函数make，对于管道而言，make函数接收两个参数，第一个是管道的类型，第二个是可选参数为管道的缓冲大小。例子如下\",\"intCh := make(chan int) // 缓冲区大小为1的管道 strCh := make(chan string, 1)\",\"在使用完一个管道后一定要记得关闭该管道，使用内置函数close来关闭一个管道，该函数签名如下。\",\"func close(c chan<- Type)\",\"一个关闭管道的例子如下\",\"func main() { intCh := make(chan int) // do something close(intCh) }\",\"有些时候使用defer来关闭管道可能会更好。\"]},\"334\":{\"h\":\"读写\",\"t\":[\"对于一个管道而言，Go使用了两种很形象的操作符来表示读写操作：\",\"ch <-：表示对一个管道写入数据\",\"<- ch：表示对一个管道读取数据\",\"<-很生动的表示了数据的流动方向，来看一个对int类型的管道读写的例子\",\"func main() { // 如果没有缓冲区则会导致死锁 intCh := make(chan int, 1) defer close(intCh) // 写入数据 intCh <- 114514 // 读取数据 fmt.Println(<-intCh) }\",\"上面的例子中创建了一个缓冲区大小为1的int型管道，对其写入数据114514，然后再读取数据并输出，最后关闭该管道。对于读取操作而言，还有第二个返回值，一个布尔类型的值，用于表示数据是否读取成功\",\"ints, ok := <-intCh\",\"管道中的数据流动方式与队列一样，即先进先出（FIFO），协程对于管道的操作是同步的，在某一个时刻，只有一个协程能够对其写入数据，同时也只有一个协程能够读取管道中的数据。\"]},\"335\":{\"h\":\"无缓冲\",\"t\":[\"对于无缓冲管道而言，因为缓冲区容量为0，所以不会临时存放任何数据。正因为无缓冲管道无法存放数据，在向管道写入数据时必须立刻有其他协程来读取数据，否则就会阻塞等待，读取数据时也是同理，这也解释了为什么下面看起来很正常的代码会发生死锁。\",\"func main() { // 创建无缓冲管道 ch := make(chan int) defer close(ch) // 写入数据 ch <- 123 // 读取数据 n := <-ch fmt.Println(n) }\",\"无缓冲管道不应该同步的使用，正确来说应该开启一个新的协程来发送数据，如下例\",\"func main() { // 创建无缓冲管道 ch := make(chan int) defer close(ch) go func() { // 写入数据 ch <- 123 }() // 读取数据 n := <-ch fmt.Println(n) }\"]},\"336\":{\"h\":\"有缓冲\",\"t\":[\"当管道有了缓冲区，就像是一个阻塞队列一样，读取空的管道和写入已满的管道都会造成阻塞。无缓冲管道在发送数据时，必须立刻有人接收，否则就会一直阻塞。对于有缓冲管道则不必如此，对于有缓冲管道写入数据时，会先将数据放入缓冲区里，只有当缓冲区容量满了才会阻塞的等待协程来读取管道中的数据。同样的，读取有缓冲管道时，会先从缓冲区中读取数据，直到缓冲区没数据了，才会阻塞的等待协程来向管道中写入数据。因此，无缓冲管道中会造成死锁例子在这里可以顺利运行。\",\"func main() { // 创建有缓冲管道 ch := make(chan int, 1) defer close(ch) // 写入数据 ch <- 123 // 读取数据 n := <-ch fmt.Println(n) }\",\"尽管可以顺利运行，但这种同步读写的方式是非常危险的，一旦管道缓冲区空了或者满了，将会永远阻塞下去，因为没有其他协程来向管道中写入或读取数据。来看看下面的一个例子\",\"func main() { // 创建有缓冲管道 ch := make(chan int, 5) // 创建两个无缓冲管道 chW := make(chan struct{}) chR := make(chan struct{}) defer func() { close(ch) close(chW) close(chR) }() // 负责写 go func() { for i := 0; i < 10; i++ { ch <- i fmt.Println(\\\"写入\\\", i) } chW <- struct{}{} }() // 负责读 go func() { for i := 0; i < 10; i++ { // 每次读取数据都需要花费1毫秒 time.Sleep(time.Millisecond) fmt.Println(\\\"读取\\\", <-ch) } chR <- struct{}{} }() fmt.Println(\\\"写入完毕\\\", <-chW) fmt.Println(\\\"读取完毕\\\", <-chR) }\",\"这里总共创建了3个管道，一个有缓冲管道用于协程间通信，两个无缓冲管道用于同步父子协程的执行顺序。负责读的协程每次读取之前都会等待1毫秒，负责写的协程一口气做多也只能写入5个数据，因为管道缓冲区最大只有5，在没有协程来读取之前，只能阻塞等待。所以该示例输出如下\",\"写入 0 写入 1 写入 2 写入 3 写入 4 // 一下写了5个，缓冲区满了，等其他协程来读 读取 0 写入 5 // 读一个，写一个 读取 1 写入 6 读取 2 写入 7 读取 3 写入 8 写入 9 读取 4 写入完毕 {} // 所有的数据都发送完毕，写协程执行完毕 读取 5 读取 6 读取 7 读取 8 读取 9 读取完毕 {} // 所有的数据都读完了，读协程执行完毕\",\"可以看到负责写的协程刚开始就一口气发送了5个数据，缓冲区满了以后就开始阻塞等待读协程来读取，后面就是每当读协程1毫秒读取一个数据，缓冲区有空位了，写协程就写入一个数据，直到所有数据发送完毕，写协程执行结束，随后当读协程将缓冲区所有数据读取完毕后，读协程也执行结束，最后主协程退出。\",\"提示\",\"通过内置函数len可以访问管道缓冲区中数据的个数，通过cap可以访问管道缓冲区的大小。\",\"func main() { ch := make(chan int, 5) ch <- 1 ch <- 2 ch <- 3 fmt.Println(len(ch), cap(ch)) }\",\"输出\",\"3 5\",\"利用管道的阻塞条件，可以很轻易的写出一个主协程等待子协程执行完毕的例子\",\"func main() { // 创建一个无缓冲管道 ch := make(chan struct{}) defer close(ch) go func() { fmt.Println(2) // 写入 ch <- struct{}{} }() // 阻塞等待读取 <-ch fmt.Println(1) }\",\"输出\",\"2 1\",\"通过有缓冲管道还可以实现一个简单的互斥锁，看下面的例子\",\"var count = 0 // 缓冲区大小为1的管道 var lock = make(chan struct{}, 1) func Add() { // 加锁 lock <- struct{}{} fmt.Println(\\\"当前计数为\\\", count, \\\"执行加法\\\") count += 1 // 解锁 <-lock } func Sub() { // 加锁 lock <- struct{}{} fmt.Println(\\\"当前计数为\\\", count, \\\"执行减法\\\") count -= 1 // 解锁 <-lock }\",\"由于管道的缓冲区大小为1，最多只有一个数据存放在缓冲区中。Add和Sub函数在每次操作前都会尝试向管道中发送数据，由于缓冲区大小为1，倘若有其他协程已经写入了数据，缓冲区已经满了，当前协程就必须阻塞等待，直到缓冲区空出位置来，如此一来，在某一个时刻，最多只能有一个协程对变量count进行修改，这样就实现了一个简单的互斥锁。\"]},\"337\":{\"h\":\"注意点\",\"t\":[\"下面是一些总结，以下几种情况使用不当会导致管道阻塞：\",\"读写无缓冲管道\",\"当对一个无缓冲管道直接进行同步读写操作都会导致该协程阻塞\",\"func main() { // 创建了一个无缓冲管道 intCh := make(chan int) defer close(intCh) // 发送数据 intCh <- 1 // 读取数据 ints, ok := <-intCh fmt.Println(ints, ok) }\",\"读取空缓冲区的管道\",\"当读取一个缓冲区为空的管道时，会导致该协程阻塞\",\"func main() { // 创建的有缓冲管道 intCh := make(chan int, 1) defer close(intCh) // 缓冲区为空，阻塞等待其他协程写入数据 ints, ok := <-intCh fmt.Println(ints, ok) }\",\"写入满缓冲区的管道\",\"当管道的缓冲区已满，对其写入数据会导致该协程阻塞\",\"func main() { // 创建的有缓冲管道 intCh := make(chan int, 1) defer close(intCh) intCh <- 1 // 满了，阻塞等待其他协程来读取数据 intCh <- 1 }\",\"管道为nil\",\"当管道为nil时，无论怎样读写都会导致当前协程阻塞\",\"func main() { var intCh chan int // 写 intCh <- 1 }\",\"func main() { var intCh chan int // 读 fmt.Println(<-intCh) }\",\"关于管道阻塞的条件需要好好掌握和熟悉，大多数情况下这些问题隐藏的十分隐蔽，并不会像例子中那样直观。\",\"以下几种情况还会导致panic：\",\"关闭一个nil管道\",\"当管道为nil时，使用close函数对其进行关闭操作会导致panic`\",\"func main() { var intCh chan int close(intCh) }\",\"写入已关闭的管道\",\"对一个已关闭的管道写入数据会导致panic\",\"func main() { intCh := make(chan int, 1) close(intCh) intCh <- 1 }\",\"关闭已关闭的管道\",\"在一些情况中，管道可能经过层层传递，调用者或许也不知道到底该由谁来关闭管道，如此一来，可能会发生关闭一个已经关闭了的管道，就会发生panic。\",\"func main() { ch := make(chan int, 1) defer close(ch) go write(ch) fmt.Println(<-ch) } func write(ch chan<- int) { // 只能对管道发送数据 ch <- 1 close(ch) }\"]},\"338\":{\"h\":\"单向管道\",\"t\":[\"双向管道指的是既可以写，也可以读，即可以在管道两边进行操作。单向管道指的是只读或只写的管道，即只能在管道的一边进行操作。手动创建的一个只读或只写的管道没有什么太大的意义，因为不能对管道读写就失去了其存在的作用。单向管道通常是用来限制通道的行为，一般会在函数的形参和返回值中出现，例如用于关闭通道的内置函数close的函数签名就用到了单向通道。\",\"func close(c chan<- Type)\",\"又或者说常用到的time包下的After函数\",\"func After(d Duration) <-chan Time\",\"close函数的形参是一个只写通道，After函数的返回值是一个只读通道，所以单向通道的语法如下：\",\"箭头符号<-在前，就是只读通道，如<-chan int\",\"箭头符号<-在后，就是只写通道，如chan<- string\",\"当尝试对只读的管道写入数据时，将会无法通过编译\",\"func main() { timeCh := time.After(time.Second) timeCh <- time.Now() }\",\"报错如下，意思非常明确\",\"invalid operation: cannot send to receive-only channel timeCh (variable of type <-chan time.Time)\",\"对只写的管道读取数据也是同理。\",\"双向管道可以转换为单向管道，反过来则不可以。通常情况下，将双向管道传给某个协程或函数并且不希望它读取/发送数据，就可以用到单向管道来限制另一方的行为。\",\"func main() { ch := make(chan int, 1) go write(ch) fmt.Println(<-ch) } func write(ch chan<- int) { // 只能对管道发送数据 ch <- 1 }\",\"只读管道也是一样的道理\",\"提示\",\"chan是引用类型，即便Go的函数参数是值传递，但其引用依旧是同一个，这一点会在后续的管道原理中说明。\"]},\"339\":{\"h\":\"for range\",\"t\":[\"通过for range语句，可以遍历读取缓冲管道中的数据，如下例\",\"func main() { ch := make(chan int, 10) go func() { for i := 0; i < 10; i++ { ch <- i } }() for n := range ch { fmt.Println(n) } }\",\"通常来说，for range遍历其他可迭代数据结构时，会有两个返回值，第一个是索引，第二个元素值，但是对于管道而言，有且仅有一个返回值，for range会不断读取管道中的元素，当管道缓冲区为空或无缓冲时，就会阻塞等待，直到有其他协程向管道中写入数据才会继续读取数据。所以输出如下：\",\"0 1 2 3 4 5 6 7 8 9 fatal error: all goroutines are asleep - deadlock!\",\"可以看到上面的代码发生了死锁，因为子协程已经执行完毕了，而主协程还在阻塞等待其他协程来向管道中写入数据，所以应该管道在写入完毕后将其关闭。修改为如下代码\",\"func main() { ch := make(chan int, 10) go func() { for i := 0; i < 10; i++ { ch <- i } // 关闭管道 close(ch) }() for n := range ch { fmt.Println(n) } }\",\"写完后关闭管道，上述代码便不再会发生死锁。前面提到过读取管道是有两个返回值的，for range遍历管道时，当无法成功读取数据时，便会退出循环。第二个返回值指的是能否成功读取数据，而不是管道是否已经关闭，即便管道已经关闭，对于有缓冲管道而言，依旧可以读取数据，并且第二个返回值仍然为true。看下面的一个例子\",\"func main() { ch := make(chan int, 10) for i := 0; i < 5; i++ { ch <- i } // 关闭管道 close(ch) // 再读取数据 for i := 0; i < 6; i++ { n, ok := <-ch fmt.Println(n, ok) } }\",\"输出结果\",\"0 true 1 true 2 true 3 true 4 true 0 false\",\"由于管道已经关闭了，即便缓冲区为空，再读取数据也不会导致当前协程阻塞，可以看到在第六次遍历的时候读取的是零值，并且ok为false。\",\"提示\",\"关于管道关闭的时机，应该尽量在向管道发送数据的那一方关闭管道，而不要在接收方关闭管道，因为大多数情况下接收方只知道接收数据，并不知道该在什么时候关闭管道。\"]},\"340\":{\"h\":\"select\",\"t\":[\"select在Linux系统中，是一种IO多路复用的解决方案，类似的，在Go中，select是一种管道多路复用的控制结构。什么是多路复用，简单的用一句话概括：在某一时刻，同时监测多个元素是否可用，被监测的可以是网络请求，文件IO等。在Go中的select监测的元素就是管道，且只能是管道。select的语法与switch语句类似，下面看看一个select语句长什么样\",\"func main() { // 创建三个管道 chA := make(chan int) chB := make(chan int) chC := make(chan int) defer func() { close(chA) close(chB) close(chC) }() select { case n, ok := <-chA: fmt.Println(n, ok) case n, ok := <-chB: fmt.Println(n, ok) case n, ok := <-chC: fmt.Println(n, ok) default: fmt.Println(\\\"所有管道都不可用\\\") } }\",\"与switch类似，select由多个case和一个default组成，default分支可以省略。每一个case只能操作一个管道，且只能进行一种操作，要么读要么写，当有多个case可用时，select会伪随机的选择一个case来执行。如果所有case都不可用，就会执行default分支，倘若没有default分支，将会阻塞等待，直到至少有一个case可用。由于上例中没有对管道写入数据，自然所有的case都不可用，所以最终输出为default分支的执行结果。稍微修改下后如下：\",\"func main() { chA := make(chan int) chB := make(chan int) chC := make(chan int) defer func() { close(chA) close(chB) close(chC) }() // 开启一个新的协程 go func() { // 向A管道写入数据 chA <- 1 }() select { case n, ok := <-chA: fmt.Println(n, ok) case n, ok := <-chB: fmt.Println(n, ok) case n, ok := <-chC: fmt.Println(n, ok) } }\",\"上例开启了一个新的协程来向管道A写入数据，select由于没有默认分支，所以会一直阻塞等待直到有case可用。当管道A可用时，执行完对应分支后主协程就直接退出了。要想一直监测管道，可以配合for循环使用，如下。\",\"func main() { chA := make(chan int) chB := make(chan int) chC := make(chan int) defer func() { close(chA) close(chB) close(chC) }() go Send(chA) go Send(chB) go Send(chC) // for循环 for { select { case n, ok := <-chA: fmt.Println(\\\"A\\\", n, ok) case n, ok := <-chB: fmt.Println(\\\"B\\\", n, ok) case n, ok := <-chC: fmt.Println(\\\"C\\\", n, ok) } } } func Send(ch chan<- int) { for i := 0; i < 3; i++ { time.Sleep(time.Millisecond) ch <- i } }\",\"这样确实三个管道都能用上了，但是死循环+select会导致主协程永久阻塞，所以可以将其单独放到新协程中，并且加上一些其他的逻辑。\",\"func main() { chA := make(chan int) chB := make(chan int) chC := make(chan int) defer func() { close(chA) close(chB) close(chC) }() l := make(chan struct{}) go Send(chA) go Send(chB) go Send(chC) go func() { Loop: for { select { case n, ok := <-chA: fmt.Println(\\\"A\\\", n, ok) case n, ok := <-chB: fmt.Println(\\\"B\\\", n, ok) case n, ok := <-chC: fmt.Println(\\\"C\\\", n, ok) case <-time.After(time.Second): // 设置1秒的超时时间 break Loop // 退出循环 } } l <- struct{}{} // 告诉主协程可以退出了 }() <-l } func Send(ch chan<- int) { for i := 0; i < 3; i++ { time.Sleep(time.Millisecond) ch <- i } }\",\"上例中通过for循环配合select来一直监测三个管道是否可以用，并且第四个case是一个超时管道，超时过后便会退出循环，结束子协程。最终输出如下\",\"C 0 true A 0 true B 0 true A 1 true B 1 true C 1 true B 2 true C 2 true A 2 true\",\"超时\",\"上一个例子用到了time.After函数，其返回值是一个只读的管道，该函数配合select使用可以非常简单的实现超时机制，例子如下\",\"func main() { chA := make(chan int) defer close(chA) go func() { time.Sleep(time.Second * 2) chA <- 1 }() select { case n := <-chA: fmt.Println(n) case <-time.After(time.Second): fmt.Println(\\\"超时\\\") } }\",\"永久阻塞\",\"当select语句中什么都没有时，就会永久阻塞，例如\",\"func main() { fmt.Println(\\\"start\\\") select {} fmt.Println(\\\"end\\\") }\",\"end永远也不会输出，主协程会一直阻塞，这种情况一般是有特殊用途。\",\"提示\",\"在select的case中对值为nil的管道进行操作的话，并不会导致阻塞，该case则会被忽略，永远也不会被执行。例如下方代码无论执行多少次都只会输出timeout。\",\"func main() { var nilCh chan int select { case <-nilCh: fmt.Println(\\\"read\\\") case nilCh <- 1: fmt.Println(\\\"write\\\") case <-time.After(time.Second): fmt.Println(\\\"timeout\\\") } }\"]},\"341\":{\"h\":\"WaitGroup\",\"t\":[\"sync.WaitGroup是sync包下提供的一个结构体，WaitGroup即等待执行，使用它可以很轻易的实现等待一组协程的效果。该结构体只对外暴露三个方法。\",\"Add方法用于指明要等待的协程的数量\",\"func (wg *WaitGroup) Add(delta int)\",\"Done方法表示当前协程已经执行完毕\",\"func (wg *WaitGroup) Done()\",\"Wait方法等待子协程结束，否则就阻塞\",\"func (wg *WaitGroup) Wait()\",\"WaitGroup使用起来十分简单，属于开箱即用。其内部的实现是计数器+信号量，程序开始时调用Add初始化计数，每当一个协程执行完毕时调用Done，计数就-1，直到减为0，而在此期间，主协程调用Wait 会一直阻塞直到全部计数减为0，然后才会被唤醒。看一个简单的使用例子\",\"func main() { var wait sync.WaitGroup // 指定子协程的数量 wait.Add(1) go func() { fmt.Println(1) // 执行完毕 wait.Done() }() // 等待子协程 wait.Wait() fmt.Println(2) }\",\"这段代码永远都是先输出1再输出2，主协程会等待子协程执行完毕后再退出。\",\"1 2\",\"针对协程介绍中最开始的例子，可以做出如下修改\",\"func main() { var mainWait sync.WaitGroup var wait sync.WaitGroup // 计数10 mainWait.Add(10) fmt.Println(\\\"start\\\") for i := 0; i < 10; i++ { // 循环内计数1 wait.Add(1) go func() { fmt.Println(i) // 两个计数-1 wait.Done() mainWait.Done() }() // 等待当前循环的协程执行完毕 wait.Wait() } // 等待所有的协程执行完毕 mainWait.Wait() fmt.Println(\\\"end\\\") }\",\"这里使用了sync.WaitGroup替代了原先的time.Sleep，协程并发执行的的顺序更加可控，不管执行多少次，输出都如下\",\"start 0 1 2 3 4 5 6 7 8 9 end\",\"WaitGroup通常适用于可动态调整协程数量的时候，例如事先知晓协程的数量，又或者在运行过程中需要动态调整。WaitGroup的值不应该被复制，复制后的值也不应该继续使用，尤其是将其作为函数参数传递时，因该传递指针而不是值。倘若使用复制的值，计数完全无法作用到真正的WaitGroup上，这可能会导致主协程一直阻塞等待，程序将无法正常运行。例如下方的代码\",\"func main() { var mainWait sync.WaitGroup mainWait.Add(1) hello(mainWait) mainWait.Wait() fmt.Println(\\\"end\\\") } func hello(wait sync.WaitGroup) { fmt.Println(\\\"hello\\\") wait.Done() }\",\"错误提示所有的协程都已经退出，但主协程依旧在等待，这就形成了死锁，因为hello函数内部对一个形参WaitGroup调用Done并不会作用到原来的mainWait上，所以应该使用指针来进行传递。\",\"hello fatal error: all goroutines are asleep - deadlock!\",\"提示\",\"当计数变为负数，或者计数数量大于子协程数量时，将会引发panic。\"]},\"342\":{\"h\":\"Context\",\"t\":[\"Context译为上下文，是Go提供的一种并发控制的解决方案，相比于管道和WaitGroup，它可以更好的控制子孙协程以及层级更深的协程。Context本身是一个接口，只要实现了该接口都可以称之为上下文例如著名Web框架Gin中的gin.Context。context标准库也提供了几个实现，分别是：\",\"emptyCtx\",\"cancelCtx\",\"timerCtx\",\"valueCtx\"]},\"343\":{\"h\":\"Context\",\"t\":[\"先来看看Context接口的定义，再去了解它的具体实现。\",\"type Context interface { Deadline() (deadline time.Time, ok bool) Done() <-chan struct{} Err() error Value(key any) any }\",\"Deadline\",\"该方法具有两个返回值，deadline是截止时间，即上下文应该取消的时间。第二个值是是否设置deadline，如果没有设置则一直为false。\",\"Deadline() (deadline time.Time, ok bool)\",\"Done\",\"其返回值是一个空结构体类型的只读管道，该管道仅仅起到通知作用，不传递任何数据。当上下文所做的工作应该取消时，该通道就会被关闭，对于一些不支持取消的上下文，可能会返回nil。\",\"Done() <-chan struct{}\",\"Err\",\"该方法返回一个error，用于表示上下关闭的原因。当Done管道没有关闭时，返回nil，如果关闭过后，会返回一个err来解释为什么会关闭。\",\"Err() error\",\"Value\",\"该方法返回对应的键值，如果key不存在，或者不支持该方法，就会返回nil。\",\"Value(key any) any\"]},\"344\":{\"h\":\"emptyCtx\",\"t\":[\"顾名思义，emptyCtx就是空的上下文，context包下所有的实现都是不对外暴露的，但是提供了对应的函数来创建上下文。emptyCtx就可以通过context.Background和context.TODO来进行创建。两个函数如下\",\"var ( background = new(emptyCtx) todo = new(emptyCtx) ) func Background() Context { return background } func TODO() Context { return todo }\",\"可以看到仅仅只是返回了emptyCtx指针。emptyCtx的底层类型实际上是一个int，之所以不使用空结构体，是因为emptyCtx的实例必须要有不同的内存地址，它没法被取消，没有deadline，也不能取值，实现的方法都是返回零值。\",\"type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() <-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key any) any { return nil }\",\"emptyCtx通常是用来当作最顶层的上下文，在创建其他三种上下文时作为父上下文传入。context包中的各个实现关系如下图所示\"]},\"345\":{\"h\":\"valueCtx\",\"t\":[\"valueCtx实现比较简单，其内部只包含一对键值对，和一个内嵌的Context类型的字段。\",\"type valueCtx struct { Context key, val any }\",\"其本身只实现了Value方法，逻辑也很简单，当前上下文找不到就去父上下文找。\",\"func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) }\",\"下面看一个valueCtx的简单使用案例\",\"var waitGroup sync.WaitGroup func main() { waitGroup.Add(1) // 传入上下文 go Do(context.WithValue(context.Background(), 1, 2)) waitGroup.Wait() } func Do(ctx context.Context) { // 新建定时器 ticker := time.NewTimer(time.Second) defer waitGroup.Done() for { select { case <-ctx.Done(): // 永远也不会执行 case <-ticker.C: fmt.Println(\\\"timeout\\\") return default: fmt.Println(ctx.Value(1)) } time.Sleep(time.Millisecond * 100) } }\",\"valueCtx多用于在多级协程中传递一些数据，无法被取消，因此ctx.Done永远会返回nil，select会忽略掉nil管道。最后输出如下\",\"2 2 2 2 2 2 2 2 2 2 timeout\"]},\"346\":{\"h\":\"cancelCtx\",\"t\":[\"cancelCtx以及timerCtx都实现了canceler接口，接口类型如下\",\"type canceler interface { // removeFromParent 表示是否从父上下文中删除自身 // err 表示取消的原因 cancel(removeFromParent bool, err error) // Done 返回一个管道，用于通知取消的原因 Done() <-chan struct{} }\",\"cancel方法不对外暴露，在创建上下文时通过闭包将其包装为返回值以供外界调用，就如context.WithCancel源代码中所示\",\"func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { if parent == nil { panic(\\\"cannot create context from nil parent\\\") } c := newCancelCtx(parent) // 尝试将自身添加进父级的children中 propagateCancel(parent, &c) // 返回context和一个函数 return &c, func() { c.cancel(true, Canceled) } }\",\"cancelCtx译为可取消的上下文，创建时，如果父级实现了canceler，就会将自身添加进父级的children中，否则就一直向上查找。如果所有的父级都没有实现canceler，就会启动一个协程等待父级取消，然后当父级结束时取消当前上下文。当调用cancelFunc时，Done通道将会关闭，该上下文的任何子级也会随之取消，最后会将自身从父级中删除。下面是一个简单的示例：\",\"var waitGroup sync.WaitGroup func main() { bkg := context.Background() // 返回了一个cancelCtx和cancel函数 cancelCtx, cancel := context.WithCancel(bkg) waitGroup.Add(1) go func(ctx context.Context) { defer waitGroup.Done() for { select { case <-ctx.Done(): fmt.Println(ctx.Err()) return default: fmt.Println(\\\"等待取消中...\\\") } time.Sleep(time.Millisecond * 200) } }(cancelCtx) time.Sleep(time.Second) cancel() waitGroup.Wait() }\",\"输出如下\",\"等待取消中... 等待取消中... 等待取消中... 等待取消中... 等待取消中... context canceled\",\"再来一个层级嵌套深一点的示例\",\"var waitGroup sync.WaitGroup func main() { waitGroup.Add(3) ctx, cancelFunc := context.WithCancel(context.Background()) go HttpHandler(ctx) time.Sleep(time.Second) cancelFunc() waitGroup.Wait() } func HttpHandler(ctx context.Context) { cancelCtxAuth, cancelAuth := context.WithCancel(ctx) cancelCtxMail, cancelMail := context.WithCancel(ctx) defer cancelAuth() defer cancelMail() defer waitGroup.Done() go AuthService(cancelCtxAuth) go MailService(cancelCtxMail) for { select { case <-ctx.Done(): fmt.Println(ctx.Err()) return default: fmt.Println(\\\"正在处理http请求...\\\") } time.Sleep(time.Millisecond * 200) } } func AuthService(ctx context.Context) { defer waitGroup.Done() for { select { case <-ctx.Done(): fmt.Println(\\\"auth 父级取消\\\", ctx.Err()) return default: fmt.Println(\\\"auth...\\\") } time.Sleep(time.Millisecond * 200) } } func MailService(ctx context.Context) { defer waitGroup.Done() for { select { case <-ctx.Done(): fmt.Println(\\\"mail 父级取消\\\", ctx.Err()) return default: fmt.Println(\\\"mail...\\\") } time.Sleep(time.Millisecond * 200) } }\",\"例子中创建了3个cancelCtx，尽管父级cancelCtx在取消的同时会取消它的子上下文，但是保险起见，如果创建了一个cancelCtx，在相应的流程结束后就应该调用cancel函数。输出如下\",\"正在处理http请求... auth... mail... mail... auth... 正在处理http请求... auth... mail... 正在处理http请求... 正在处理http请求... auth... mail... auth... 正在处理http请求... mail... context canceled auth 父级取消 context canceled mail 父级取消 context canceled\"]},\"347\":{\"h\":\"timerCtx\",\"t\":[\"timerCtx在cancelCtx 的基础之上增加了超时机制，context包下提供了两种创建的函数，分别是WithDeadline和WithTimeout，两者功能类似，前者是指定一个具体的超时时间，比如指定一个具体时间2023/3/20 16:32:00，后者是指定一个超时的时间间隔，比如5分钟后。两个函数的签名如下\",\"func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\",\"timerCtx会在时间到期后自动取消当前上下文，取消的流程除了要额外的关闭timer之外，基本与cancelCtx一致。下面是一个简单的timerCtx的使用示例\",\"var wait sync.WaitGroup func main() { deadline, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second)) defer cancel() wait.Add(1) go func(ctx context.Context) { defer wait.Done() for { select { case <-ctx.Done(): fmt.Println(\\\"上下文取消\\\", ctx.Err()) return default: fmt.Println(\\\"等待取消中...\\\") } time.Sleep(time.Millisecond * 200) } }(deadline) wait.Wait() }\",\"尽管上下文到期会自动取消，但是为了保险起见，在相关流程结束后，最好手动取消上下文。输出如下\",\"等待取消中... 等待取消中... 等待取消中... 等待取消中... 等待取消中... 上下文取消 context deadline exceeded\",\"WithTimeout其实与WithDealine非常相似，它的实现也只是稍微封装了一下并调用WithDeadline，和上面例子中的WithDeadline用法一样，如下\",\"func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) }\",\"提示\",\"就跟内存分配后不回收会造成内存泄漏一样，上下文也是一种资源，如果创建了但从来不取消，一样会造成上下文泄露，所以最好避免此种情况的发生。\"]},\"348\":{\"h\":\"锁\",\"t\":[\"先来看看的一个例子\",\"var wait sync.WaitGroup var count = 0 func main() { wait.Add(10) for i := 0; i < 10; i++ { go func(data *int) { // 模拟访问耗时 time.Sleep(time.Millisecond * time.Duration(rand.Intn(5000))) // 访问数据 temp := *data // 模拟计算耗时 time.Sleep(time.Millisecond * time.Duration(rand.Intn(5000))) ans := 1 // 修改数据 *data = temp + ans fmt.Println(*data) wait.Done() }(&count) } wait.Wait() fmt.Println(\\\"最终结果\\\", count) }\",\"对于上面的例子，开启了十个协程来对count进行+1操作，并且使用了time.Sleep来模拟不同的耗时，根据直觉来讲，10个协程执行10个+1操作，最终结果一定是10，正确结果也确实是10，但事实并非如此，上面的例子执行结果如下：\",\"1 2 3 3 2 2 3 3 3 4 最终结果 4\",\"可以看到最终结果为4，而这只是众多可能结果中的一种。由于每个协程访问和计算所需的时间不同，A协程访问数据耗费500毫秒，此时访问到的count值为1，随后又花费了400毫秒计算，但在这400毫秒内，B协程已经完成了访问和计算并成功更新了count的值，A协程在计算完毕后，A协程最初访问到的值已经过时了，但A协程并不知道这件事，依旧在原先访问到的值基础上加一，并赋值给count，这样一来，B协程的执行结果被覆盖了。多个协程读取和访问一个共享数据时，尤其会发生这样的问题，为此就需要用到锁。\",\"Go中sync包下的Mutex与RWMutex提供了互斥锁与读写锁两种实现，且提供了非常简单易用的API，加锁只需要Lock()，解锁也只需要Unlock()。需要注意的是，Go所提供的锁都是非递归锁，也就是不可重入锁，所以重复加锁或重复解锁都会导致fatal。锁的意义在于保护不变量，加锁是希望数据不会被其他协程修改，如下\",\"func DoSomething() { Lock() // 在这个过程中，数据不会被其他协程修改 Unlock() }\",\"倘若是递归锁的话，就可能会发生如下情况\",\"func DoSomething() { Lock() DoOther() Unlock() } func DoOther() { Lock() // do other Unlock() }\",\"DoSomthing函数显然不知道DoOther函数可能会对数据做点什么，从而修改了数据，比如再开几个子协程破坏了不变量。这在Go中是行不通的，一旦加锁以后就必须保证不变量的不变性，此时重复加锁解锁都会导致死锁。所以在编写代码时应该避免上述情况，必要时在加锁的同时立即使用defer语句解锁。\"]},\"349\":{\"h\":\"互斥锁\",\"t\":[\"sync.Mutex是Go提供的互斥锁实现，其实现了sync.Locker接口\",\"type Locker interface { // 加锁 Lock() // 解锁 Unlock() }\",\"使用互斥锁可以非常完美的解决上述问题，例子如下\",\"var wait sync.WaitGroup var count = 0 var lock sync.Mutex func main() { wait.Add(10) for i := 0; i < 10; i++ { go func(data *int) { // 加锁 lock.Lock() // 模拟访问耗时 time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) // 访问数据 temp := *data // 模拟计算耗时 time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) ans := 1 // 修改数据 *data = temp + ans // 解锁 lock.Unlock() fmt.Println(*data) wait.Done() }(&count) } wait.Wait() fmt.Println(\\\"最终结果\\\", count) }\",\"每一个协程在访问数据前，都先上锁，更新完成后再解锁，其他协程想要访问就必须要先获得锁，否则就阻塞等待。如此一来，就不存在上述问题了，所以输出如下\",\"1 2 3 4 5 6 7 8 9 10 最终结果 10\"]},\"350\":{\"h\":\"读写锁\",\"t\":[\"互斥锁适合读操作与写操作频率都差不多的情况，对于一些读多写少的数据，如果使用互斥锁，会造成大量的不必要的协程竞争锁，这会消耗很多的系统资源，这时候就需要用到读写锁，即读写互斥锁，对于一个协程而言：\",\"如果获得了读锁，其他协程进行写操作时会阻塞，其他协程进行读操作时不会阻塞\",\"如果获得了写锁，其他协程进行写操作时会阻塞，其他协程进行读操作时会阻塞\",\"Go中读写互斥锁的实现是sync.RWMutex，它也同样实现了Locker接口，但它提供了更多可用的方法，如下：\",\"// 加读锁 func (rw *RWMutex) RLock() // 尝试加读锁 func (rw *RWMutex) TryRLock() bool // 解读锁 func (rw *RWMutex) RUnlock() // 加写锁 func (rw *RWMutex) Lock() // 尝试加写锁 func (rw *RWMutex) TryLock() bool // 解写锁 func (rw *RWMutex) Unlock()\",\"其中TryRlock与TryLock两个尝试加锁的操作是非阻塞式的，成功加锁会返回true，无法获得锁时并不会阻塞而是返回false。读写互斥锁内部实现依旧是互斥锁，并不是说分读锁和写锁就有两个锁，从始至终都只有一个锁。下面来看一个读写互斥锁的使用案例\",\"var wait sync.WaitGroup var count = 0 var rw sync.RWMutex func main() { wait.Add(12) // 读多写少 go func() { for i := 0; i < 3; i++ { go Write(&count) } wait.Done() }() go func() { for i := 0; i < 7; i++ { go Read(&count) } wait.Done() }() // 等待子协程结束 wait.Wait() fmt.Println(\\\"最终结果\\\", count) } func Read(i *int) { time.Sleep(time.Millisecond * time.Duration(rand.Intn(500))) rw.RLock() fmt.Println(\\\"拿到读锁\\\") time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) fmt.Println(\\\"释放读锁\\\", *i) rw.RUnlock() wait.Done() } func Write(i *int) { time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) rw.Lock() fmt.Println(\\\"拿到写锁\\\") temp := *i time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) *i = temp + 1 fmt.Println(\\\"释放写锁\\\", *i) rw.Unlock() wait.Done() }\",\"该例开启了3个写协程，7个读协程，在读数据的时候都会先获得读锁，读协程可以正常获得读锁，但是会阻塞写协程，获得写锁的时候，则会同时阻塞读协程和写协程，直到释放写锁，如此一来实现了读协程与写协程互斥，保证了数据的正确性。例子输出如下：\",\"拿到读锁 拿到读锁 拿到读锁 拿到读锁 释放读锁 0 释放读锁 0 释放读锁 0 释放读锁 0 拿到写锁 释放写锁 1 拿到读锁 拿到读锁 拿到读锁 释放读锁 1 释放读锁 1 释放读锁 1 拿到写锁 释放写锁 2 拿到写锁 释放写锁 3 最终结果 3\",\"提示\",\"对于锁而言，不应该将其作为值传递和存储，应该使用指针。\"]},\"351\":{\"h\":\"条件变量\",\"t\":[\"条件变量，与互斥锁一同出现和使用，所以有些人可能会误称为条件锁，但它并不是锁，是一种通讯机制。Go中的sync.Cond对此提供了实现，而创建条件变量的函数签名如下：\",\"func NewCond(l Locker) *Cond\",\"可以看到创建一个条件变量前提就是需要创建一个锁，sync.Cond提供了如下的方法以供使用\",\"// 阻塞等待条件生效，直到被唤醒 func (c *Cond) Wait() // 唤醒一个因条件阻塞的协程 func (c *Cond) Signal() // 唤醒所有因条件阻塞的协程 func (c *Cond) Broadcast()\",\"条件变量使用起来非常简单，将上面的读写互斥锁的例子稍微修改下即可\",\"var wait sync.WaitGroup var count = 0 var rw sync.RWMutex // 条件变量 var cond = sync.NewCond(rw.RLocker()) func main() { wait.Add(12) // 读多写少 go func() { for i := 0; i < 3; i++ { go Write(&count) } wait.Done() }() go func() { for i := 0; i < 7; i++ { go Read(&count) } wait.Done() }() // 等待子协程结束 wait.Wait() fmt.Println(\\\"最终结果\\\", count) } func Read(i *int) { time.Sleep(time.Millisecond * time.Duration(rand.Intn(500))) rw.RLock() fmt.Println(\\\"拿到读锁\\\") // 条件不满足就一直阻塞 for *i < 3 { cond.Wait() } time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) fmt.Println(\\\"释放读锁\\\", *i) rw.RUnlock() wait.Done() } func Write(i *int) { time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) rw.Lock() fmt.Println(\\\"拿到写锁\\\") temp := *i time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) *i = temp + 1 fmt.Println(\\\"释放写锁\\\", *i) rw.Unlock() // 唤醒所有因条件变量阻塞的协程 cond.Broadcast() wait.Done() }\",\"在创建条件变量时，因为在这里条件变量作用的是读协程，所以将读锁作为互斥锁传入，如果直接传入读写互斥锁会导致写协程重复解锁的问题。这里传入的是sync.rlocker，通过RWMutex.RLocker方法获得。\",\"func (rw *RWMutex) RLocker() Locker { return (*rlocker)(rw) } type rlocker RWMutex func (r *rlocker) Lock() { (*RWMutex)(r).RLock() } func (r *rlocker) Unlock() { (*RWMutex)(r).RUnlock() }\",\"可以看到rlocker也只是把读写互斥锁的读锁操作封装了一下，实际上是同一个引用，依旧是同一个锁。读协程读取数据时，如果小于3就会一直阻塞等待，直到数据大于3，而写协程在更新数据后都会尝试唤醒所有因条件变量而阻塞的协程，所以最后的输出如下\",\"拿到读锁 拿到读锁 拿到读锁 拿到读锁 拿到写锁 释放写锁 1 拿到读锁 拿到写锁 释放写锁 2 拿到读锁 拿到读锁 拿到写锁 释放写锁 3 // 第三个写协程执行完毕 释放读锁 3 释放读锁 3 释放读锁 3 释放读锁 3 释放读锁 3 释放读锁 3 释放读锁 3 最终结果 3\",\"从结果中可以看到，当第三个写协程更新完数据后，七个因条件变量而阻塞的读协程都恢复了运行。\",\"提示\",\"对于条件变量，应该使用for而不是if，应该使用循环来判断条件是否满足，因为协程被唤醒时并不能保证当前条件就已经满足了。\",\"for !condition { cond.Wait() }\"]},\"352\":{\"h\":\"sync\",\"t\":[\"Go中很大一部分的并发相关的工具都是sync标准库提供的，上述已经介绍过了sync.WaitGroup，sync.Locker等，除此之外，sync包下还有一些其他的工具可以使用。\"]},\"353\":{\"h\":\"Once\",\"t\":[\"当在使用一些数据结构时，如果这些数据结构太过庞大，可以考虑采用懒加载的方式，即真正要用到它的时候才会初始化该数据结构。如下面的例子\",\"type MySlice []int func (m *MySlice) Get(i int) (int, bool) { if *m == nil { return 0, false } else { return (*m)[i], true } } func (m *MySlice) Add(i int) { // 当真正用到切片的时候，才会考虑去初始化 if *m == nil { *m = make([]int, 0, 10) } *m = append(*m, i) }\",\"那么问题就来了，如果只有一个协程使用肯定是没有任何问题的，但是如果有多个协程访问的话就可能会出现问题了。比如协程A和B同时调用了Add方法，A执行的稍微快一些，已经初始化完毕了，并且将数据成功添加，随后协程B又初始化了一遍，这样一来将协程A添加的数据直接覆盖掉了，这就是问题所在。\",\"而这就是sync.Once要解决的问题，顾名思义，Once译为一次，sync.Once保证了在并发条件下指定操作只会执行一次。它的使用非常简单，只对外暴露了一个Do方法，签名如下：\",\"func (o *Once) Do(f func())\",\"在使用时，只需要将初始化操作传入Do方法即可，如下\",\"var wait sync.WaitGroup func main() { var slice MySlice wait.Add(4) for i := 0; i < 4; i++ { go func() { slice.Add(1) wait.Done() }() } wait.Wait() fmt.Println(slice.Len()) } type MySlice struct { s []int o sync.Once } func (m *MySlice) Get(i int) (int, bool) { if m.s == nil { return 0, false } else { return m.s[i], true } } func (m *MySlice) Add(i int) { // 当真正用到切片的时候，才会考虑去初始化 m.o.Do(func() { fmt.Println(\\\"初始化\\\") if m.s == nil { m.s = make([]int, 0, 10) } }) m.s = append(m.s, i) } func (m *MySlice) Len() int { return len(m.s) }\",\"输出如下\",\"初始化 4\",\"从输出结果中可以看到，所有的数据等正常添加进切片，初始化操作只执行了一次。其实sync.Once的实现相当简单，去除注释真正的代码逻辑只有16行，其原理就是锁+原子操作。源代码如下：\",\"type Once struct { // 用于判断操作是否已经执行 done uint32 m Mutex } func (o *Once) Do(f func()) { // 原子加载数据 if atomic.LoadUint32(&o.done) == 0 { o.doSlow(f) } } func (o *Once) doSlow(f func()) { // 加锁 o.m.Lock() // 解锁 defer o.m.Unlock() // 判断是否执行 if o.done == 0 { // 执行完毕后修改done defer atomic.StoreUint32(&o.done, 1) f() } }\"]},\"354\":{\"h\":\"Pool\",\"t\":[\"sync.Pool的设计目的是用于存储临时对象以便后续的复用，是一个临时的并发安全对象池，将暂时用不到的对象放入池中，在后续使用中就不需要再额外的创建对象可以直接复用，减少内存的分配与释放频率，最重要的一点就是降低GC压力。sync.Pool总共只有两个方法，如下：\",\"// 申请一个对象 func (p *Pool) Get() any // 放入一个对象 func (p *Pool) Put(x any)\",\"并且sync.Pool有一个对外暴露的New字段，用于对象池在申请不到对象时初始化一个对象\",\"New func() any\",\"下面以一个例子演示\",\"var wait sync.WaitGroup // 临时对象池 var pool sync.Pool // 用于计数过程中总共创建了多少个对象 var numOfObject atomic.Int64 // BigMemData 假设这是一个占用内存很大的结构体 type BigMemData struct { M string } func main() { pool.New = func() any { numOfObject.Add(1) return BigMemData{\\\"大内存\\\"} } wait.Add(1000) // 这里开启1000个协程 for i := 0; i < 1000; i++ { go func() { // 申请对象 val := pool.Get() // 使用对象 _ = val.(BigMemData) // 用完之后再释放对象 pool.Put(val) wait.Done() }() } wait.Wait() fmt.Println(numOfObject.Load()) }\",\"例子中开启了1000个协程不断的在池中申请和释放对象，如果不采用对象池，那么1000个协程都需要各自实例化对象，并且这1000个实例化后的对象在使用完毕后都需要由GC来释放内存，如果有几十万个协程或者说创建该对象的成本十分的高昂，这种情况下就会占用很大的内存并且给GC带来非常大的压力，采用对象池后，可以复用对象减少实例化的频率，比如上述的例子输出可能如下：\",\"5\",\"即便开启了1000个协程，整个过程中也只创建了5个对象，如果不采用对象池的话1000个协程将会创建1000个对象，这种优化带来的提升是显而易见的，尤其是在并发量特别大和实例化对象成本特别高的时候更能体现出优势。\",\"在使用sync.Pool时需要注意几个点：\",\"临时对象：sync.Pool只适合存放临时对象，池中的对象可能会在没有任何通知的情况下被GC移除，所以并不建议将网络链接，数据库连接这类存入sync.Pool中。\",\"不可预知：sync.Pool在申请对象时，无法预知这个对象是新创建的还是复用的，也无法知晓池中有几个对象\",\"并发安全：官方保证sync.Pool一定是并发安全，但并不保证用于创建对象的New函数就一定是并发安全的，New函数是由使用者传入的，所以New函数的并发安全性要由使用者自己来维护，这也是为什么上例中对象计数要用到原子值的原因。\",\"提示\",\"最后需要注意的是，当使用完对象后，一定要释放回池中，如果用了不释放那么对象池的使用将毫无意义。\",\"标准库fmt包下就有一个对象池的使用案例，在fmt.Fprintf函数中\",\"func Fprintf(w io.Writer, format string, a ...any) (n int, err error) { // 申请一个打印缓冲区 p := newPrinter() p.doPrintf(format, a) n, err = w.Write(p.buf) // 使用完毕后释放 p.free() return }\",\"其中newPointer函数和free方法的实现如下\",\"func newPrinter() *pp { // 向对象池申请的一个对象 p := ppFree.Get().(*pp) p.panicking = false p.erroring = false p.wrapErrs = false p.fmt.init(&p.buf) return p } func (p *pp) free() { // 为了让对象池中的缓冲区大小大致相同以便更好的弹性控制缓冲区大小 // 过大的缓冲区就不用放回对象池 if cap(p.buf) > 64<<10 { return } // 字段重置后释放对象到池中 p.buf = p.buf[:0] p.arg = nil p.value = reflect.Value{} p.wrappedErr = nil ppFree.Put(p) }\"]},\"355\":{\"h\":\"Map\",\"t\":[\"sync.Map是官方提供的一种并发安全Map的实现，开箱即用，使用起来十分的简单，下面是该结构体对外暴露的方法：\",\"// 根据一个key读取值，返回值会返回对应的值和该值是否存在 func (m *Map) Load(key any) (value any, ok bool) // 存储一个键值对 func (m *Map) Store(key, value any) // 删除一个键值对 func (m *Map) Delete(key any) // 如果该key已存在，就返回原有的值，否则将新的值存入并返回，当成功读取到值时，loaded为true，否则为false func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool) // 删除一个键值对，并返回其原有的值，loaded的值取决于key是否存在 func (m *Map) LoadAndDelete(key any) (value any, loaded bool) // 遍历Map，当f()返回false时，就会停止遍历 func (m *Map) Range(f func(key, value any) bool)\",\"下面用一个简单的示例来演示下sync.Map的基本使用\",\"func main() { var syncMap sync.Map // 存入数据 syncMap.Store(\\\"a\\\", 1) syncMap.Store(\\\"a\\\", \\\"a\\\") // 读取数据 fmt.Println(syncMap.Load(\\\"a\\\")) // 读取并删除 fmt.Println(syncMap.LoadAndDelete(\\\"a\\\")) // 读取或存入 fmt.Println(syncMap.LoadOrStore(\\\"a\\\", \\\"hello world\\\")) syncMap.Store(\\\"b\\\", \\\"goodbye world\\\") // 遍历map syncMap.Range(func(key, value any) bool { fmt.Println(key, value) return true }) }\",\"输出\",\"a true a true hello world false a hello world b goodbye world\",\"接下来看一个并发使用map的例子：\",\"func main() { myMap := make(map[int]int, 10) var wait sync.WaitGroup wait.Add(10) for i := 0; i < 10; i++ { go func(n int) { for i := 0; i < 100; i++ { myMap[n] = n } wait.Done() }(i) } wait.Wait() }\",\"上例中使用的普通map，开了10个协程不断的存入数据，显然这很可能会触发fatal，结果大概率会如下\",\"fatal error: concurrent map writes\",\"使用sync.Map就可以避免这个问题\",\"func main() { var syncMap sync.Map var wait sync.WaitGroup wait.Add(10) for i := 0; i < 10; i++ { go func(n int) { for i := 0; i < 100; i++ { syncMap.Store(n, n) } wait.Done() }(i) } wait.Wait() syncMap.Range(func(key, value any) bool { fmt.Println(key, value) return true }) }\",\"输出如下\",\"8 8 3 3 1 1 9 9 6 6 5 5 7 7 0 0 2 2 4 4\",\"为了并发安全肯定需要做出一定的牺牲，sync.Map的性能要比map低10-100倍左右。\"]},\"356\":{\"h\":\"原子\",\"t\":[\"在计算机学科中，原子或原语操作，通常用于表述一些不可再细化分割的操作，由于这些操作无法再细化为更小的步骤，在执行完毕前，不会被其他的任何协程打断，所以执行结果要么成功要么失败，没有第三种情况可言，如果出现了其他情况，那么它就是不是原子操作。例如下方的代码：\",\"func main() { a := 0 if a == 0 { a = 1 } fmt.Println(a) }\",\"上方的代码是一个简单的判断分支，尽管代码很少，但也不是原子操作，真正的原子操作是由硬件指令层面支持的。\"]},\"357\":{\"h\":\"类型\",\"t\":[\"好在大多情况下并不需要自行编写汇编，Go标准库sync/atomic包下已经提供了原子操作相关的API，其提供了以下几种类型以供进行原子操作。\",\"atomic.Bool{} atomic.Pointer[]{} atomic.Int32{} atomic.Int64{} atomic.Uint32{} atomic.Uint64{} atomic.Uintptr{} atomic.Value{}\",\"其中Pointer原子类型支持泛型，Value类型支持存储任何类型，除此之外，还提供了许多函数来方便操作。因为原子操作的粒度过细，在大多数情况下，更适合处理这些基础的数据类型。\",\"提示\",\"atmoic包下原子操作只有函数签名，没有具体实现，具体的实现是由plan9汇编编写。\"]},\"358\":{\"h\":\"使用\",\"t\":[\"每一个原子类型都会提供以下三个方法：\",\"Load()：原子的获取值\",\"Swap(newVal type) (old type)：原子的交换值，并且返回旧值\",\"Store(val type)：原子的存储值\",\"不同的类型可能还会有其他的额外方法，比如整型类型都会提供Add方法来实现原子加减操作。下面以一个int64类型演示为例：\",\"func main() { var aint64 atomic.Uint64 // 存储值 aint64.Store(64) // 交换值 aint64.Swap(128) // 增加 aint64.Add(112) // 加载值 fmt.Println(aint64.Load()) }\",\"或者也可以直接使用函数\",\"func main() { var aint64 int64 // 存储值 atomic.StoreInt64(&aint64, 64) // 交换值 atomic.SwapInt64(&aint64, 128) // 增加 atomic.AddInt64(&aint64, 112) // 加载 fmt.Println(atomic.LoadInt64(&aint64)) }\",\"其他的类型的使用也是十分类似的，最终输出为：\",\"240\"]},\"359\":{\"h\":\"CAS\",\"t\":[\"atmoic包还提供了CompareAndSwap操作，也就是CAS，它是乐观锁的一种典型实现。乐观锁本身并不是锁，是一种并发条件下无锁化并发控制方式。之所以被称作乐观锁，是因为它总是乐观的假设共享数据不会被修改，仅当发现数据未被修改时才会去执行对应操作，而前面了解到的互斥量就是悲观锁，互斥量总是悲观的认为共享数据肯定会被修改，所以在操作时会加锁，操作完毕后就会解锁。由于无锁化实现的并发安全效率相对于锁要高一些，许多并发安全的数据结构都采用了cAS来进行实现，不过真正的效率要结合具体使用场景来看。看下面的一个例子：\",\"var lock sync.Mutex var count int func Add(num int) { lock.Lock() count += num lock.Unlock() }\",\"这是一个使用互斥锁的例子，每次增加数字前都会先上锁，执行完毕后就会解锁，过程中会导致其他协程阻塞，接下来使用CAS改造一下：\",\"var count int64 func Add(num int64) { for { expect := atomic.LoadInt64(&count) if atomic.CompareAndSwapInt64(&count, expect, expect+num) { break } } }\",\"对于CAS而言，有三个参数，内存值，期望值，新值。执行时，CAS会将期望值与当前内存值进行比较，如果内存值与期望值相同，就会执行后续的操作，否则的话什么也不做。对于Go中atomic包下的原子操作，CAS相关的函数则需要传入地址，期望值，新值，且会返回是否成功替换的布尔值。例如int64类型的CAS 操作函数签名如下：\",\"func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)\",\"在CAS的例子中，首先会通过LoadInt64来获取期望值，随后使用CompareAndSwapInt64来进行比较交换，如果不成功的话就不断循环，直到成功。这样无锁化的操作虽然不会导致协程阻塞，但是不断的循环对于CPU而言依旧是一个不小的开销，所以在一些实现中失败达到了一定次数可能会放弃操作。但是对于上面的操作而言，仅仅只是简单的数字相加，涉及到的操作并不复杂，所以完全可以考虑无锁化实现。\",\"提示\",\"大多数情况下，仅仅只是比较值是无法做到并发安全的，比如因CAS引起ABA问题，就需要使用额外加入version来解决问题。\"]},\"360\":{\"h\":\"Value\",\"t\":[\"atomic.Value结构体，可以存储任意类型的值，结构体如下\",\"type Value struct { // any类型 v any }\",\"尽管可以存储任意类型，但是它不能存储nil，并且前后存储的值类型应当一致，下面两个例子都无法通过编译\",\"func main() { var val atomic.Value val.Store(nil) fmt.Println(val.Load()) } // panic: sync/atomic: store of nil value into Value\",\"func main() { var val atomic.Value val.Store(\\\"hello world\\\") val.Store(114154) fmt.Println(val.Load()) } // panic: sync/atomic: store of inconsistently typed value into Value\",\"除此之外，它的使用与其他的原子类型并无太大的差别，并且需要注意的是，所有的原子类型都不应该复制值，而是应该使用它们的指针。\"]},\"361\":{\"h\":\"模块\",\"t\":[\"每一个现代语言都会有属于自己的一个成熟的依赖管理工具，例如Java的Gradle，Python的Pip，NodeJs的Npm等，一个好的依赖管理工具可以为开发者省去不少时间并且可以提升开发效率。然而Go在早期并没有一个成熟的依赖管理解决方案，那时所有的代码都存放在GOPATH目录下，对于工程项目而言十分的不友好，版本混乱，依赖难以管理，为了解决这个问题，各大社区开发者百家争鸣，局面一时间混乱了起来，期间也不乏出现了一些佼佼者例如Vendor，直到Go1.11官方终于推出了Go Mod这款官方的依赖管理工具，结束了先前的混乱局面，并在后续的更新中不断完善，淘汰掉了曾经老旧的工具。时至今日，在撰写本文时，Go发行版本已经到了1.20，在今天几乎所有的Go项目都在采用Go Mod，所以在本文也只会介绍Go Mod，官方对于Go模块也编写了非常细致的文档：Go Modules Reference。\"]},\"362\":{\"h\":\"编写模块\",\"t\":[\"Go Module本质上是基于VCS（版本控制系统），当你在下载依赖时，实际上执行的是VCS命令，比如git，所以如果你想要分享你编写的库，只需要做到以下三点：\",\"源代码仓库可公开访问，且VCS属于以下的其中之一 \",\"git\",\"hg (Mercurial)\",\"bzr (Bazaar)\",\"svn\",\"fossil\",\"是一个符合规范的go mod项目\",\"符合语义化版本规范\",\"所以你只需要正常使用VCS开发，并为你的特定版本打上符合标准的Tag，其它人就可以通过模块名来下载你所编写的库，下面将通过示例来演示进行模块开发的几个步骤。\",\"示例仓库：246859/hello: say hello (github.com)\"]},\"363\":{\"h\":\"准备\",\"t\":[\"在开始之前确保你的版本足以完全支持go mod（go >= 1.17），并且启用了Go Module，通过如下命令来查看是否开启\",\"$ go env GO111MODULE\",\"如果未开启，通过如下命令开启用Go Module\",\"$ go env -w GO111MODULE=on\"]},\"364\":{\"h\":\"创建\",\"t\":[\"首先你需要一个可公网访问的源代码仓库，这个有很多选择，我比较推荐Github。在上面创建一个新项目，将其取名为hello，仓库名虽然没有什么特别限制，但建议还是不要使用特殊字符，因为这会影响到模块名。\",\"创建完成后，可以看到仓库的URL是https://github.com/246859/hello，对应的go模块名就是github.com/246859/hello。\",\"然后将其克隆到本地，通过go mod init命令初始化模块。\",\"$ git clone git@github.com:246859/hello.git Cloning into 'hello'... remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (4/4), done. remote: Total 5 (delta 0), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (5/5), done. $ cd hello && go mod init github.com/246859/hello go: creating new go.mod: module github.com/246859/hello\"]},\"365\":{\"h\":\"编写\",\"t\":[\"然后就可以进行开发工作了，它的功能非常简单，只有一个函数\",\"// hello.go package hello import \\\"fmt\\\" // Hello returns hello message func Hello(name string) string { if name == \\\"\\\" { name = \\\"world\\\" } return fmt.Sprintf(\\\"hello %s!\\\", name) }\",\"顺便写一个测试文件进行单元测试\",\"// hello_test.go package hello_test import ( \\\"testing\\\" \\\"fmt\\\" \\\"github.com/246859/hello\\\" ) func TestHello(t *testing.T) { data := \\\"jack\\\" expected := fmt.Sprintf(\\\"hello %s!\\\", data) result := hello.Hello(data) if result != expected { t.Fatalf(\\\"expected result %s, but got %s\\\", expected, result) } }\",\"接下来继续编写一个命令行程序用于输出hello，它的功能同样非常简单。对于命令行程序而言，按照规范是在项目cmd/app_name/中进行创建，所以hello命令行程序的文件存放在cmd/hello/目录下，然后在其中编写相关代码。\",\"// cmd/hello/main.go package main import ( \\\"flag\\\" \\\"github.com/246859/hello\\\" \\\"os\\\" ) var name string func init() { flag.StringVar(&name, \\\"name\\\", \\\"world\\\", \\\"name to say hello\\\") } func main() { flag.Parse() msg := hello.Hello(name) _, err := os.Stdout.WriteString(msg) if err != nil { os.Stderr.WriteString(err.Error()) } }\"]},\"366\":{\"h\":\"测试\",\"t\":[\"编写完后对源代码格式化并测试\",\"$ go fmt && go vet ./... $ go test -v . === RUN TestHello --- PASS: TestHello (0.00s) PASS ok github.com/246859/hello 0.023s\",\"运行命令行程序\",\"$ go run ./cmd/hello -name jack hello jack!\"]},\"367\":{\"h\":\"文档\",\"t\":[\"最后的最后，需要为这个库编写简洁明了的README，让其它开发者看一眼就知道怎么使用\",\"# hello just say hello ## Install import code ```bash go get github.com/246859/hello@latest ``` install cmd ````bash go install github.com/246859/hello/cmd/hello@latest ```` ## Example Here's a simple example as follows: ```go package main import ( \\\"fmt\\\" \\\"github.com/246859/hello\\\" ) func main() { result := hello.Hello(\\\"jack\\\") fmt.Println(result) } ```\",\"这是一个很简单的README文档，你也可以自己进行丰富。\"]},\"368\":{\"h\":\"上传\",\"t\":[\"当一切代码都编写并测试完毕过后，就可以将修改提交并推送到远程仓库。\",\"$ git add go.mod hello.go hello_test.go cmd/ example/ README.md $ git commit -m \\\"chore(mod): mod init\\\" go.mod [main 5087fa2] chore(mod): mod init 1 file changed, 3 insertions(+) create mode 100644 go.mod $ git commit -m \\\"feat(hello): complete Hello func\\\" hello.go [main 099a8bf] feat(hello): complete Hello func 1 file changed, 11 insertions(+) create mode 100644 hello.go $ git commit -m \\\"test(hello): complete hello testcase\\\" hello_test.go [main 76e8c1e] test(hello): complete hello testcase 1 file changed, 17 insertions(+) create mode 100644 hello_test.go $ git commit -m \\\"feat(hello): complete hello cmd\\\" cmd/hello/ [main a62a605] feat(hello): complete hello cmd 1 file changed, 22 insertions(+) create mode 100644 cmd/hello/main.go $ git commit -m \\\"docs(example): add hello example\\\" example/ [main 5c51ce4] docs(example): add hello example 1 file changed, 11 insertions(+) create mode 100644 example/main.go $ git commit -m \\\"docs(README): update README\\\" README.md [main e6fbc62] docs(README): update README 1 file changed, 27 insertions(+), 1 deletion(-)\",\"总共六个提交并不多，提交完毕后为最新提交创建一个tag\",\"$ git tag v1.0.0 $ git tag -l v1.0.0 $ git log --oneline e6fbc62 (HEAD -> main, tag: v1.0.0, origin/main, origin/HEAD) docs(README): update README 5c51ce4 docs(example): add hello example a62a605 feat(hello): complete hello cmd 76e8c1e test(hello): complete hello testcase 099a8bf feat(hello): complete Hello func 5087fa2 chore(mod): mod init 1f422d1 Initial commit\",\"最后再推送到远程仓库\",\"$ git push --tags Enumerating objects: 23, done. Counting objects: 100% (23/23), done. Delta compression using up to 16 threads Compressing objects: 100% (17/17), done. Writing objects: 100% (21/21), 2.43 KiB | 1.22 MiB/s, done. Total 21 (delta 5), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (5/5), done. To github.com:246859/hello.git 1f422d1..e6fbc62 main -> main * [new tag] v1.0.0 -> v1.0.0\",\"推送完毕后，再为其创建一个release（有一个tag就足矣，release只是符合github规范）\",\"如此一来，模块的编写就完成了，以上就是模块开发的一个基本流程，其它开发者便可以通过模块名来引入代码或安装命令行工具。\"]},\"369\":{\"h\":\"引用\",\"t\":[\"通过go get引用库\",\"$ go get github.com/246859/hello@latest go: downloading github.com/246859/hello v1.0.0 go: added github.com/246859/hello v1.0.0\",\"通过go intall安装命令行程序\",\"$ go install github.com/246859/hello/cmd/hello@latest && hello -name jack hello jack!\",\"或者使用go run直接运行\",\"$ go run -mod=mod github.com/246859/hello/cmd/hello -name jack hello jack!\",\"当一个库被引用过后，Go Package便会为其创建一个页面，这个过程是自动完成的，不需要开发者做什么工作，比如hello库就有一个专属的文档页面，如下图所示。\",\"关于上传模块的更多详细信息，前往Add a package。\",\"关于如何删除模块的信息，前往Removing a package。\"]},\"370\":{\"h\":\"设置代理\",\"t\":[\"Go虽然没有像Maven Repo，PyPi，NPM这样类似的中央仓库，但是有一个官方的代理仓库：Go modules services (golang.org)，它会根据版本及模块名缓存开发者下载过的模块。不过由于其服务器部署在国外，访问速度对于国内的用户不甚友好，所以我们需要修改默认的模块代理地址，目前国内做的比较好的有以下几家：\",\"GOPROXY.IO - 一个全球代理 为 Go 模块而生\",\"七牛云 - Goproxy.cn\",\"这里选择七牛云的代理，执行如下命令来修改Go代理，其中的direct表示代理下载失败后绕过代理缓存直接访问源代码仓库。\",\"$ go env -w GOPROXY=https://goproxy.cn,direct\",\"代理修改成功后，日后下载依赖就会非常的迅速。\"]},\"371\":{\"h\":\"下载依赖\",\"t\":[\"修改完代理后，接下来安装一个第三方依赖试试，Go官方有专门的依赖查询网站：Go Packages。\"]},\"372\":{\"h\":\"代码引用\",\"t\":[\"在里面搜索著名的Web框架Gin。\",\"这里会出现很多搜索结果，在使用第三方依赖时，需要结合引用次数和更新时间来决定是否采用该依赖，这里直接选择第一个\",\"进入对应的页面后，可以看出这是该依赖的一个文档页面，有着非常多关于它的详细信息，后续查阅文档时也可以来这里。\",\"这里只需要将它的地址复制下来，然后在之前创建的项目下使用go get命令，命令如下\",\"$ go get github.com/gin-gonic/gin\",\"过程中会下载很多的依赖，只要没有报错就说明下载成功。\",\"$ go get github.com/gin-gonic/gin go: added github.com/bytedance/sonic v1.8.0 go: added github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 go: added github.com/gin-contrib/sse v0.1.0 go: added github.com/gin-gonic/gin v1.9.0 go: added github.com/go-playground/locales v0.14.1 go: added github.com/go-playground/universal-translator v0.18.1 go: added github.com/go-playground/validator/v10 v10.11.2 go: added github.com/goccy/go-json v0.10.0 go: added github.com/json-iterator/go v1.1.12 go: added github.com/klauspost/cpuid/v2 v2.0.9 go: added github.com/leodido/go-urn v1.2.1 go: added github.com/mattn/go-isatty v0.0.17 go: added github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 go: added github.com/modern-go/reflect2 v1.0.2 go: added github.com/pelletier/go-toml/v2 v2.0.6 go: added github.com/twitchyliquid64/golang-asm v0.15.1 go: added github.com/ugorji/go/codec v1.2.9 go: added golang.org/x/arch v0.0.0-20210923205945-b76863e36670 go: added golang.org/x/crypto v0.5.0 go: added golang.org/x/net v0.7.0 go: added golang.org/x/sys v0.5.0 go: added golang.org/x/text v0.7.0 go: added google.golang.org/protobuf v1.28.1 go: added gopkg.in/yaml.v3 v3.0.1\",\"完成后查看go.mod文件\",\"$ cat go.mod module golearn go 1.20 require github.com/gin-gonic/gin v1.9.0 require ( github.com/bytedance/sonic v1.8.0 // indirect github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect github.com/gin-contrib/sse v0.1.0 // indirect github.com/go-playground/locales v0.14.1 // indirect github.com/go-playground/universal-translator v0.18.1 // indirect github.com/go-playground/validator/v10 v10.11.2 // indirect github.com/goccy/go-json v0.10.0 // indirect github.com/json-iterator/go v1.1.12 // indirect github.com/klauspost/cpuid/v2 v2.0.9 // indirect github.com/leodido/go-urn v1.2.1 // indirect github.com/mattn/go-isatty v0.0.17 // indirect github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect github.com/modern-go/reflect2 v1.0.2 // indirect github.com/pelletier/go-toml/v2 v2.0.6 // indirect github.com/twitchyliquid64/golang-asm v0.15.1 // indirect github.com/ugorji/go/codec v1.2.9 // indirect golang.org/x/arch v0.0.0-20210923205945-b76863e36670 // indirect golang.org/x/crypto v0.5.0 // indirect golang.org/x/net v0.7.0 // indirect golang.org/x/sys v0.5.0 // indirect golang.org/x/text v0.7.0 // indirect google.golang.org/protobuf v1.28.1 // indirect gopkg.in/yaml.v3 v3.0.1 // indirect )\",\"可以发现相较于之前多了很多东西，同时也会发现目录下多了一个名为go.sum的文件\",\"$ ls go.mod go.sum main.go\",\"这里先按下不表，修改main.go文件如下代码：\",\"package main import ( \\\"github.com/gin-gonic/gin\\\" ) func main() { gin.Default().Run() }\",\"再次运行项目\",\"$ go run golearn [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \\\"debug\\\" mode. Switch to \\\"release\\\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Environment variable PORT is undefined. Using port :8080 by default [GIN-debug] Listening and serving HTTP on :8080\",\"于是，通过一行代码就运行起了一个最简单的Web服务器。当不再需要某一个依赖时，也可以使用go get命令来删除该依赖，这里以删除Gin为例子\",\"$ go get github.com/gin-gonic/gin@none go: removed github.com/gin-gonic/gin v1.9.0\",\"在依赖地址后面加上@none即可删除该依赖，结果也提示了删除成功，此时再次查看go.mod文件会发现没有了Gin依赖。\",\"$ cat go.mod | grep github.com/gin-gonic/gin\",\"当需要升级最新版本时，可以加上@latest后缀，或者可以自行查询可用的Release版本号\",\"$ go get -u github.com/gin-gonic/gin@latest\"]},\"373\":{\"h\":\"安装命令行\",\"t\":[\"go install命令会将第三方依赖下载到本地并编译成二进制文件，得益于go的编译速度，这一过程通常不会花费太多时间，然后go会将其存放在$GOPATH/bin或者$GOBIN目录下，以便在全局可以执行该二进制文件（前提是你将这些路径添加到了环境变量中）。\",\"提示\",\"在使用install命令时，必须指定版本号。\",\"例如下载由go语言编写的调试器delve\",\"$ go install github.com/go-delve/delve/cmd/dlv@latest go: downloading github.com/go-delve/delve v1.22.1 go: downloading github.com/cosiner/argv v0.1.0 go: downloading github.com/derekparker/trie v0.0.0-20230829180723-39f4de51ef7d go: downloading github.com/go-delve/liner v1.2.3-0.20231231155935-4726ab1d7f62 go: downloading github.com/google/go-dap v0.11.0 go: downloading github.com/hashicorp/golang-lru v1.0.2 go: downloading golang.org/x/arch v0.6.0 go: downloading github.com/cpuguy83/go-md2man/v2 v2.0.2 go: downloading go.starlark.net v0.0.0-20231101134539-556fd59b42f6 go: downloading github.com/cilium/ebpf v0.11.0 go: downloading github.com/mattn/go-runewidth v0.0.13 go: downloading github.com/russross/blackfriday/v2 v2.1.0 go: downloading github.com/rivo/uniseg v0.2.0 go: downloading golang.org/x/exp v0.0.0-20230224173230-c95f2b4c22f2 $ dlv -v Error: unknown shorthand flag: 'v' in -v Usage: dlv [command] Available Commands: attach Attach to running process and begin debugging. completion Generate the autocompletion script for the specified shell connect Connect to a headless debug server with a terminal client. core Examine a core dump. dap Starts a headless TCP server communicating via Debug Adaptor Protocol (DAP). debug Compile and begin debugging main package in current directory, or the package specified. exec Execute a precompiled binary, and begin a debug session. help Help about any command test Compile test binary and begin debugging program. trace Compile and begin tracing program. version Prints version. Additional help topics: dlv backend Help about the --backend flag. dlv log Help about logging flags. dlv redirect Help about file redirection. Use \\\"dlv [command] --help\\\" for more information about a command.\"]},\"374\":{\"h\":\"模块管理\",\"t\":[\"上述所有的内容都只是在讲述Go Mod的基本使用，但事实上要学会Go Mod仅仅只有这些是完全不够的。官方对于模块的定义为：一组被版本标记的包集合。上述定义中，包应该是再熟悉不过的概念了，而版本则是要遵循语义化版本号，定义为：v(major).(minor).(patch)的格式，例如Go的版本号v1.20.1，主版本号是1，小版本号是20，补丁版本是1，合起来就是v1.20.1，下面是详细些的解释：\",\"major：当major版本变化时，说明项目发生了不兼容的改动，老版本的项目升级到新版本大概率没法正常运行。\",\"minor：当minor版本变化时，说明项目增加了新的特性，只是先前版本的基础只是增加了新的功能。\",\"patch：当patch版本发生变化时，说明只是有bug被修复了，没有增加任何新功能。\"]},\"375\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"说明\",\"go mod download\",\"下载当前项目的依赖包\",\"go mod edit\",\"编辑go.mod文件\",\"go mod graph\",\"输出模块依赖图\",\"go mod init\",\"在当前目录初始化go mod\",\"go mod tidy\",\"清理项目模块\",\"go mod verify\",\"验证项目的依赖合法性\",\"go mod why\",\"解释项目哪些地方用到了依赖\",\"go clean -modcache\",\"用于删除项目模块依赖缓存\",\"go list -m\",\"列出模块\",\"前往go mod cmd了解命令的更多有关信息\"]},\"376\":{\"h\":\"模块存储\",\"t\":[\"当使用Go Mod进行项目管理时，模块缓存默认存放在$GOPATH/pkg/mod目录下，也可以修改$GOMODCACHE来指定存放在另外一个位置。\",\"$ go env -w GOMODCACHE=你的模块缓存路径\",\"同一个机器上的所有Go Module项目共享该目录下的缓存，缓存没有大小限制且不会自动删除，在缓存中解压的依赖源文件都是只读的，想要清空缓存可以执行如下命令。\",\"$ go clean -modcache\",\"在$GOMODCACHE/cache/download目录下存放着依赖的原始文件，包括哈希文件，原始压缩包等，如下例：\",\"$ ls $(go env GOMODCACHE)/cache/download/github.com/246859/hello/@v -1 list v1.0.0.info v1.0.0.lock v1.0.0.mod v1.0.0.zip v1.0.0.ziphash\",\"解压过后的依赖组织形式如下所示，就是指定模块的源代码。\",\"$ ls $(go env GOMODCACHE)/github.com/246859/hello@v1.0.0 -1 LICENSE README.md cmd/ example/ go.mod hello.go hello_test.go\"]},\"377\":{\"h\":\"版本选择\",\"t\":[\"Go在依赖版本选择时，遵循最小版本选择原则。下面是一个官网给的例子，主模块引用了模块A的1.2版本和模块B的1.2版本，同时模块A的1.2版本引用了模块C的1.3版本，模块B的1.2版本引用了模块C的1.4版本，并且模块C的1.3和1.4版本都同时引用了模块D的1.2版本，根据最小可用版本原则，Go最终会选择的版本是A1.2，B1.2，C1.4和D1.2。其中淡蓝色的表示go.mod文件加载的，框选的表示最终选择的版本。\",\"官网中还给出了其他几个例子，大体意思都差不多。\"]},\"378\":{\"h\":\"go.mod\",\"t\":[\"每创建一个Go Mod项目都会生成一个go.mod文件，因此熟悉go.mod文件是非常有必要的，不过大部分情况并不需要手动的修改go.mod文件。\",\"module golearn go 1.20 require github.com/gin-gonic/gin v1.9.0 require ( github.com/bytedance/sonic v1.8.0 // indirect github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect github.com/gin-contrib/sse v0.1.0 // indirect github.com/go-playground/locales v0.14.1 // indirect github.com/go-playground/universal-translator v0.18.1 // indirect github.com/go-playground/validator/v10 v10.11.2 // indirect github.com/goccy/go-json v0.10.0 // indirect github.com/json-iterator/go v1.1.12 // indirect github.com/klauspost/cpuid/v2 v2.0.9 // indirect github.com/leodido/go-urn v1.2.1 // indirect github.com/mattn/go-isatty v0.0.17 // indirect github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect github.com/modern-go/reflect2 v1.0.2 // indirect github.com/pelletier/go-toml/v2 v2.0.6 // indirect github.com/twitchyliquid64/golang-asm v0.15.1 // indirect github.com/ugorji/go/codec v1.2.9 // indirect golang.org/x/arch v0.0.0-20210923205945-b76863e36670 // indirect golang.org/x/crypto v0.5.0 // indirect golang.org/x/net v0.7.0 // indirect golang.org/x/sys v0.5.0 // indirect golang.org/x/text v0.7.0 // indirect google.golang.org/protobuf v1.28.1 // indirect gopkg.in/yaml.v3 v3.0.1 // indirect )\",\"在文件中可以发现绝大多数的依赖地址都带有github等字眼，这是因为Go并没有一个公共的依赖仓库，大部分开源项目都是在托管在Gitub上的，也有部分的是自行搭建仓库，例如google.golang.org/protobuf，golang.org/x/crypto。通常情况下，这一串网址同时也是Go项目的模块名称，这就会出现一个问题，URL是不分大小写的，但是存储依赖的文件夹是分大小写的，所以go get github.com/gin-gonic/gin和go get github.com/gin-gonic/Gin两个引用的是同一个依赖但是本地存放的路径不同。发生这种情况时，Go并不会直接把大写字母当作存放路径，而是会将其转义为!小写字母，比如github.com\\\\BurntSushi最终会转义为github.com\\\\!burnt!sushi。\",\"module\",\"module关键字声明了当前项目的模块名，一个go.mod文件中只能出现一个module关键字。例子中的\",\"module golearn\",\"代表着当前模块名为golearn，例如打开Gin依赖的go.mod文件可以发现它的module名\",\"module github.com/gin-gonic/gin\",\"Gin的模块名就是下载依赖时使用的地址，这也是通常而言推荐模块名格式，域名/用户/仓库名。\",\"提示\",\"有一个需要注意的点是，当主版本大于1时，主版本号要体现在模块名中，例如\",\"github.com/my/example\",\"如果版本升级到了v2.0.0，那么模块名就需要修改成如下\",\"github.com/my/example/v2\",\"如果原有项目引用了老版本，且新版本不加以区分的话，在引用依赖时由于路径都一致，所以使用者并不能区分主版本变化所带来的不兼容变动，这样就可能会造成程序错误。\",\"Deprecation\",\"在module的上一行开头注释Deprecated来表示该模块已弃用，例如\",\"// Deprecated: use example.com/mod/v2 instead. module example.com/mod\",\"go\",\"go关键字表示了当前编写当前项目所用到的Go版本，版本号必须遵循语义化规则，根据go版本的不同，Go Mod会表现出不同的行为，下方是一个简单示例，关于Go可用的版本号自行前往官方查阅。\",\"go 1.20\",\"require\",\"require关键字表示引用了一个外部依赖，例如\",\"require github.com/gin-gonic/gin v1.9.0\",\"格式是require 模块名 版本号，有多个引用时可以使用括号括起来\",\"require ( github.com/bytedance/sonic v1.8.0 // indirect )\",\"带有// indirect注释的表示该依赖没有被当前项目直接引用，可能是项目直接引用的依赖引用了该依赖，所以对于当前项目而言就是间接引用。前面提到过主板变化时要体现在模块名上，如果不遵循此规则的模块被称为不规范模块，在require时，就会加上incompatible注释。\",\"require example.com/m v4.1.2+incompatible\",\"伪版本\",\"在上面的go.mod文件中，可以发现有一些依赖包的版本并不是语义化的版本号，而是一串不知所云的字符串，这其实是对应版本的CommitID，语义化版本通常指的是某一个Release。伪版本号则可以细化到指定某一个Commit，通常格式为vx.y.z-yyyyMMddHHmmss-CommitId，由于其vx.y.z并不一定真实存在，所以称为伪版本，例如下面例子中的v0.0.0并不存在，真正有效的是其后的12位CommitID。\",\"// CommitID一般取前12位 github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect\",\"同理，在下载依赖时也可以指定CommitID替换语义化版本号\",\"go get github.com/chenzhuoyu/base64x@fe3a3abad311\",\"exclude\",\"exclude关键字表示了不加载指定版本的依赖，如果同时有require引用了相同版本的依赖，也会被忽略掉。该关键字仅在主模块中才生效。例如\",\"exclude golang.org/x/net v1.2.3 exclude ( golang.org/x/crypto v1.4.5 golang.org/x/text v1.6.7 )\",\"replace\",\"replace将会替换掉指定版本的依赖，可以使用模块路径和版本替换又或者是其他平台指定的文件路径，例子\",\"replace golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5 golang.org/x/net => example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 => ./fork/net golang.org/x/net => ./fork/net )\",\"仅=>左边的版本被替换，其他版本的同一个依赖照样可以正常访问，无论是使用本地路径还是模块路径指定替换，如果替换模块具有 go.mod 文件，则其module指令必须与所替换的模块路径匹配。\",\"retract\",\"retract指令表示，不应该依赖retract所指定依赖的版本或版本范围。例如在一个新的版本发布后发现了一个重大问题，这个时候就可以使用retract指令。\",\"撤回一些版本\",\"retract ( v1.0.0 // Published accidentally. v1.0.1 // Contains retractions only. )\",\"撤回版本范围\",\"retract v1.0.0 retract [v1.0.0, v1.9.9] retract ( v1.0.0 [v1.0.0, v1.9.9] )\"]},\"379\":{\"h\":\"go.sum\",\"t\":[\"go.sum文件在创建项目之初并不会存在，只有在真正引用了外部依赖后，才会生成该文件，go.sum文件并不适合人类阅读，也不建议手动修改该文件。它的作用主要是解决一致性构建问题，即不同的人在不同的环境中使用同一个的项目构建时所引用的依赖包必须是完全相同的，这单单靠一个go.mod文件是无法保证的。\",\"接下来看看下载一个依赖时，Go从头到尾都做了些什么事，首先使用如下命令下载一个依赖\",\"go get github.com/bytedance/sonic v1.8.0\",\"go get命令首先会将依赖包下载到本地的缓存目录中，通常该目录为$GOMODCACHE/cache/download/，该目录根据域名来划分不同网站的依赖包，所以你可能会看到如下的目录结构\",\"$ ls cloud.google.com/ go.opencensus.io/ gopkg.in/ nhooyr.io/ dmitri.shuralyov.com/ go.opentelemetry.io/ gorm.io/ rsc.io/ github.com/ go.uber.org/ honnef.co/ sumdb/ go.etcd.io/ golang.org/ lukechampine.com/ go.mongodb.org/ google.golang.org/ modernc.org/\",\"那么上例中下载的依赖包存放的路径就位于\",\"$GOMODCACHE/cache/download/github.com/bytedance/sonic/@v/\",\"可能的目录结构如下，会有好几个版本命名的文件\",\"$ ls list v1.8.0.lock v1.8.0.ziphash v1.8.3.mod v1.5.0.mod v1.8.0.mod v1.8.3.info v1.8.3.zip v1.8.0.info v1.8.0.zip v1.8.3.lock v1.8.3.ziphash\",\"通常情况下，该目录下一定有一个list文件，用于记录该依赖已知的版本号，而对于每一个版本而言，都会有如下的文件：\",\"zip：依赖的源码压缩包\",\"ziphash：根据依赖压缩包所计算出的哈希值\",\"info：json格式的版本元数据\",\"mod：该版本的go.mod文件\",\"lock：临时文件，官方也没说干什么用的\",\"一般情况下，Go会计算压缩包和go.mod两个文件的哈希值，然后再根据GOSUMDB所指定的服务器（默认是sum.golang.org）查询该依赖包的哈希值，如果本地计算出的哈希值与查询得到的结果不一致，那么就不会再向下执行。如果一致的话，就会更新go.mod文件，并向go.sum文件插入两条记录，大致如下：\",\"github.com/bytedance/sonic v1.8.0 h1:ea0Xadu+sHlu7x5O3gKhRpQ1IKiMrSiHttPF0ybECuA= github.com/bytedance/sonic v1.8.0/go.mod h1:i736AoUSYt75HyZLoJW9ERYxcy6eaN6h4BZXU064P/U=\",\"提示\",\"假如禁用了GOSUMDB，Go会直接将本地计算得到的哈希值写入go.sum文件中，一般不建议这么做。\",\"正常情况下每一个依赖都会有两条记录，第一个是压缩包的哈希值，第二个是依赖包的go.mod文件的哈希值，记录格式为模块名 版本号 算法名称:哈希值，有些比较古老的依赖包可能没有go.mod文件，所以就不会有第二条哈希记录。当这个项目在另一个人的环境中构建时，Go会根据go.mod中指定的本地依赖计算哈希值，再与go.sum中记录的哈希值进行比对，如果哈希值不一致，则说明依赖版本不同，就会拒绝构建。发生这种情况时，本地依赖和go.sum文件都有可能被修改过，但是由于go.sum是经过GOSUMDB查询记录的，所以会倾向于更相信go.sum文件。\"]},\"380\":{\"h\":\"私有模块\",\"t\":[\"Go Mod大多数工具都是针对开源项目而言的，不过Go也对私有模块进行了支持。对于私有项目而言，通常情况下需要配置以下几个环境配置来进行模块私有处理\",\"GOPROXY ：依赖的代理服务器集合\",\"GOPRIVATE ：私有模块的模块路径前缀的通用模式列表，如果模块名符合规则表示该模块为私有模块，具体行为与GONOPROXY和GONOSUMDB一致。\",\"GONOPROXY ：不从代理中下载的模块路径前缀的通用模式列表，如果符合规则在下载模块时不会走GOPROXY，尝试直接从版本控制系统中下载。\",\"GONOSUMDB ：不进行GOSUMDB公共校验的模块路径前缀的通用模式列表，如果符合在下载模块校验时不会走checksum的公共数据库。\",\"GOINSECURE ：可以通过 HTTP 和其他不安全协议检索的模块路径前缀的通用模式列表。\"]},\"381\":{\"h\":\"工作区\",\"t\":[\"前面提到了go.mod文件支持replace指令，这使得我们可以暂时使用一些本地来不及发版的修改，如下所示\",\"replace ( github.com/246859/hello v1.0.1 => ./hello )\",\"在编译时，go就会使用本地的hello模块，在日后发布新版本后再将其去掉。\",\"但如果使用了 replace指令的话会修改go.mod文件的内容，并且该修改可能会被误提交到远程仓库中，这一点是我们不希望看到的，因为replace指令所指定的target是一个文件路径而非网络URL，这台机器上能用的路径可能到另一台机器上就不能用了，文件路径在跨平台方面也会是一个大问题。为了解决这类问题，工作区便应运而生。\",\"工作区(workspace)，是Go在1.18引入的关于多模块管理的一个新的解决方案，旨在更好的进行本地的多模块开发工作，下面将通过一个示例进行讲解。\",\"示例仓库：246859/work: go work example (github.com)\"]},\"382\":{\"h\":\"示例\",\"t\":[\"首先项目下有两个独立的go模块，分别是auth，user\",\"$ ls -1 LICENSE README.md auth go.work user\",\"auth模块依赖于user模块的结构体User，内容如下\",\"package auth import ( \\\"errors\\\" \\\"github.com/246859/work/user\\\" ) // Verify user credentials if is ok func Verify(user user.User) (bool, error) { password, err := query(user.Name) if err != nil { return false, err } if password != user.Password { return false, errors.New(\\\"authentication failed\\\") } return true, nil } func query(username string) (string, error) { if username == \\\"jack\\\" { return \\\"jack123456\\\", nil } return \\\"\\\", errors.New(\\\"user not found\\\") }\",\"user模块内容如下\",\"package user type User struct { Name string Password string Age int }\",\"在这个项目中，我们可以这样编写go.work文件\",\"go 1.22 use ( ./auth ./user )\",\"其内容非常容易理解，使用use指令，指定哪些模块参与编译，接下来运行auth模块中的代码\",\"// auth/example/main.go package main import ( \\\"fmt\\\" \\\"github.com/246859/work/auth\\\" \\\"github.com/246859/work/user\\\" ) func main() { ok, err := auth.Verify(user.User{Name: \\\"jack\\\", Password: \\\"jack123456\\\"}) if err != nil { panic(err) } fmt.Printf(\\\"%v\\\", ok) }\",\"运行如下命令，通过结果得知成功导入了模块。\",\"$ go run ./auth/example true\",\"在以前的版本，对于这两个独立的模块，如果auth模块想要使用user模块中的代码只有两种办法\",\"提交user模块的修改并推送到远程仓库，发布新版本，然后修改go.mod文件为指定版本\",\"修改go.mod文件将依赖重定向到本地文件\",\"两种方法都需要修改go.mod文件，而工作区的存在就是为了能够在不修改go.mod文件的情况下导入其它模块。不过需要明白的一点是，go.work文件仅用在开发过程中，它的存在只是为了更加方便的进行本地开发，而不是进行依赖管理，它只是暂时让你略过了提交到发版的这一过程，可以让你马上使用user模块的新修改而无需进行等待，当user模块测试完毕后，最后依旧需要发布新版本，并且auth模块最后仍然要修改go.mod文件引用最新版本（这一过程可以用go work sync命令来完成），因此在正常的go开发过程中，go.work也不应该提交到VCS中（示例仓库中的go.work仅用于演示），因为其内容都是依赖于本地的文件，且其功能也仅限于本地开发。\"]},\"383\":{\"h\":\"命令\",\"t\":[\"下面是一些工作区的命令\",\"命令\",\"介绍\",\"edit\",\"编辑go.work\",\"init\",\"初始化一个新的工作区\",\"sync\",\"同步工作区的模块依赖\",\"use\",\"往go.work中添加一个新模块\",\"vendor\",\"将依赖按照vendor格式进行复制\",\"前往 go work cmd 了解命令的更多有关信息\"]},\"384\":{\"h\":\"指令\",\"t\":[\"go.work文件的内容很简单，只有三个指令\",\"go，指定go版本\",\"use，指定使用的模块\",\"replace，指定替换的模块\",\"除了use指令外，其它两个基本上等同于go.mod中的指令，只不过go.work中的的replace指令会作用于所有的模块，一个完整的go.work如下所示。\",\"go 1.22 use( ./auth ./user ) repalce github.com/246859/hello v1.0.0 => /home/jack/code/hello\"]},\"385\":{\"h\":\"测试\",\"t\":[\"对于开发者而言，良好的测试可以提前发现程序的中错误，避免后续因维护不及时产生Bug而造成的心智负担，所以写好测试非常有必要。Go在测试这一方面提供了非常简便实用的命令行工具go test，在标准库和许多开源框架都能看到测试的身影，该工具使用起来十分方便，目前支持以下几种测试：\",\"示例测试\",\"单元测试\",\"基准测试\",\"模糊测试\",\"在Go中大部分的API都是由标准库testing提供。\",\"提示\",\"在命令行中执行go help testfunc命令，可看Go官方对于上面四种测试类型的解释。\"]},\"386\":{\"h\":\"编写规范\",\"t\":[\"在开始编写测试之前，首先需要注意几点规范，这样在后续的学习中会更加方便。\",\"测试包：测试文件最好单独放在一个包中，这个包通常命名为test。\",\"测试文件：测试文件通常以_test.go结尾，例如要测试某一个功能，就将其命名为function_test.go，如果想根据测试类型再划分的更细一些也可以将测试类型为作为文件前缀，例如benchmark_marshaling_test.go，或者example_marshaling_test.go。\",\"测试函数：每一个测试文件中都会有若干个测试函数用于不同的测试。对于不同的测试类型，测试函数的命名的风格也不同。例如示例测试是ExampleXXXX，单元测试是TestXXXX，基准测试是BenchmarkXXXX，模糊测试是FuzzXXXX，这样一来即便不需要注释也可以知晓这是什么类型的测试。\",\"提示\",\"当包名为testdata时，该包通常是为了存储用于测试的辅助数据，在执行测试时，Go会忽略名为testdata的包。\",\"遵循上述的规范，养成良好的测试风格，可以为日后的维护省去不少的麻烦。\"]},\"387\":{\"h\":\"执行测试\",\"t\":[\"执行测试主要会用到go test命令，下面拿实际的代码举例，现在有待测试文件/say/hello.go代码如下\",\"package say import \\\"fmt\\\" func Hello() { fmt.Println(\\\"hello\\\") } func GoodBye() { fmt.Println(\\\"bye\\\") }\",\"和测试文件/test/example_test.go代码如下\",\"package test import ( \\\"golearn/say\\\" ) func ExampleHello() { say.Hello() // Output: // hello } func ExampleGoodBye() { say.GoodBye() // Output: // bye } func ExampleSay() { say.Hello() say.GoodBye() // Output: // hello // bye }\",\"执行这些测试有多种方法，比如想要执行test包下所有的测试用例，就可以直接在test目录下执行如下命令\",\"$ go test ./ PASS ok golearn/test 0.422s\",\"./表示当前目录，Go会将test目录下的所有测试文件重新编译后，然后再将所有测试用例全都执行，从结果可以看出所有的测试用例都通过了。其后的参数也可以跟多个目录，例如下方的命令，显然项目的主目录并没有测试文件可供执行。\",\"$ go test ./ ../ ok golearn/test ? golearn [no test files]\",\"提示\",\"当执行的参数有多个包时，Go并不会再次执行已经成功通过的测试用例，在执行时会行尾添加(cached)以表示输出结果是上一次的缓存。当测试的标志参数位于以下集合中时，Go就会缓存测试结果，否则就不会。\",\"-benchtime, -cpu,-list, -parallel, -run, -short, -timeout, -failfast, -v\",\"如果想要禁用缓存，可以加上参数 -count=1。\",\"当然也可以单独指定某一个测试文件来执行。\",\"$ go test example_test.go ok command-line-arguments 0.457s\",\"或者可以单独指定某一个测试文件的某一个测试用例，例如\",\"$ go test -run ExampleSay PASS ok golearn/test 0.038s\",\"上面三种情况虽然都完成了测试，但是输出结果太简介了，这时可以加上参数-v，来使输出结果更加详细一点，例如\",\"$ go test ./ -v === RUN ExampleHello --- PASS: ExampleHello (0.00s) === RUN ExampleGoodBye --- PASS: ExampleGoodBye (0.00s) === RUN ExampleSay --- PASS: ExampleSay (0.00s) PASS ok golearn/test 0.040s\",\"这下可以很清楚的看到每一个测试用例的执行顺序，耗时，执行情况，以及总体的耗时。\",\"提示\",\"go test命令默认运行所有的单元测试，示例测试，模糊测试，如果加上了-bench参数则会运行所有类型的测试，例如下方的命令\",\"$ go test -bench .\",\"所以需要使用-run参数来指定，例如只运行所有的基准测试的命令如下\",\"$ go test -bench . -run ^$\"]},\"388\":{\"h\":\"常用参数\",\"t\":[\"Go 测试有着非常多的标志参数，下面只会介绍常用的参数，想要了解更多细节建议使用go help testflag命令自行查阅。\",\"参数\",\"释义\",\"-o file\",\"指定编译后的二进制文件名称\",\"-c\",\"只编译测试文件，但不运行\",\"-json\",\"以json格式输出测试日志\",\"-exec xprog\",\"使用xprog运行测试，等价于go run\",\"-bench regexp\",\"选中regexp匹配的基准测试\",\"-fuzz regexp\",\"选中regexp匹配的模糊测试\",\"-fuzztime t\",\"模糊测试自动结束的时间，t为时间间隔，当单位为x时，表示次数，例如200x\",\"-fuzzminimizetime t\",\"模式测试运行的最小时间，规则同上\",\"-count n\",\"运行测试n次，默认1次\",\"-cover\",\"开启测试覆盖率分析\",\"-covermode set,count,atomic\",\"设置覆盖率分析的模式\",\"-cpu\",\"为测试执行GOMAXPROCS\",\"-failfast\",\"第一次测试失败后，不会开始新的测试\",\"-list regexp\",\"列出regexp匹配的测试用例\",\"-parallel n\",\"允许调用了t.Parallel的测试用例并行运行，n值为并行的最大数量\",\"-run regexp\",\"只运行regexp匹配的测试用例\",\"-skip regexp\",\"跳过regexp匹配的测试用例\",\"-timeout d\",\"如果单次测试执行时间超过了时间间隔d，就会panic。d为时间间隔，例1s,1ms,1ns等\",\"-shuffle off,on,N\",\"打乱测试的执行顺序，N为随机种子，默认种子为系统时间\",\"-v\",\"输出更详细的测试日志\",\"-benchmem\",\"统计基准测试的内存分配\",\"-blockprofile block.out\",\"统计测试中协程阻塞情况并写入文件\",\"-blockprofilerate n\",\"控制协程阻塞统计频率，通过命令go doc runtime.SetBlockProfileRate查看更多细节\",\"-coverprofile cover.out\",\"统计覆盖率测试的情况并写入文件\",\"-cpuprofile cpu.out\",\"统计cpu情况并写入文件\",\"-memprofile mem.out\",\"统计内存分配情况并写入文件\",\"-memprofilerate n\",\"控制内存分配统计的频率，通过命令go doc runtime.MemProfileRate查看更多细节\",\"-mutexprofile mutex.out\",\"统计锁竞争情况并写入文件\",\" -mutexprofilefraction n\",\"设置统计n个协程竞争一个互斥锁的情况\",\"-trace trace.out\",\"将执行追踪情况写入文件\",\"-outputdir directory\",\"指定上述的统计文件的输出目录，默认为go test的运行目录\"]},\"389\":{\"h\":\"示例测试\",\"t\":[\"示例测试并不像其他三种测试一样是为了发现程序的问题所在，它更多的是为了展示某一个功能的使用方法，起到文档作用。示例测试并不是一个官方定义的概念，也不是一个硬性的规范，更像是一种工程上的约定俗成，是否遵守只取决于开发者。示例测试在标准库中出现的非常多，通常是官方所编写的标准库代码示例，例如标准库context/example_test.go中的ExampleWithDeadline测试函数，该函数中展现了DeadlineContext的基本使用方法：\",\"// This example passes a context with an arbitrary deadline to tell a blocking // function that it should abandon its work as soon as it gets to it. func ExampleWithDeadline() { d := time.Now().Add(shortDuration) ctx, cancel := context.WithDeadline(context.Background(), d) // Even though ctx will be expired, it is good practice to call its // cancellation function in any case. Failure to do so may keep the // context and its parent alive longer than necessary. defer cancel() select { case <-time.After(1 * time.Second): fmt.Println(\\\"overslept\\\") case <-ctx.Done(): fmt.Println(ctx.Err()) } // Output: // context deadline exceeded }\",\"表面上看该测试函数就是一个普通的函数，不过示例测试主要是由Output注释来体现的，待测试函数只有一行输出时，使用Output注释来检测输出。首先创建一个hello.go的文化，写入如下代码\",\"package say import \\\"fmt\\\" func Hello() { fmt.Println(\\\"hello\\\") } func GoodBye() { fmt.Println(\\\"bye\\\") }\",\"SayHello函数就是待测函数，然后创建测试文件example_test.go，写入如下代码\",\"package test import ( \\\"golearn/say\\\" ) func ExampleHello() { say.Hello() // Output: // hello } func ExampleGoodBye() { say.GoodBye() // Output: // bye } func ExampleSay() { say.Hello() say.GoodBye() // Output: // hello // bye }\",\"函数中Output注释表明了检测函数输出是否为hello，接下来执行测试命令看看结果。\",\"$ go test -v === RUN ExampleHello --- PASS: ExampleHello (0.00s) === RUN ExampleGoodBye --- PASS: ExampleGoodBye (0.00s) === RUN ExampleSay --- PASS: ExampleSay (0.00s) PASS ok golearn/test 0.448s\",\"从结果可以看出全部测试都已经通过，关于Output有以下几种写法，第一种是只有一行输出，意为检测该函数的输出是不是hello\",\"// Output: // hello\",\"第二种是多行输出，即按顺序检测输出是否匹配\",\"// Output: // hello // bye\",\"第三种是无序输出，即不按照顺序多行输出匹配\",\"// Unordered output: // bye // hello\",\"需要注意的是，对于测试函数而言，仅当最后几行为Output注释才会被视为示例测试，否则就只是一个普通的函数，不会被Go执行。\"]},\"390\":{\"h\":\"单元测试\",\"t\":[\"单元测试就是对软件中的最小可测试单元进行测试，单元的大小定义取决于开发者，可能是一个结构体，或者是一个包，也可能是一个函数，或者是一个类型。下面依旧通过例子来演示，首先创建/tool/math.go文件，写入如下代码\",\"package tool type Number interface { ~int8 | ~int16 | ~int32 | ~int64 | ~int } func SumInt[T Number](a, b T) T { return a + b } func Equal[T Number](a, b T) bool { return a == b }\",\"然后创建测试文件/tool_test/unit_test.go，对于单元测试而言，命名可以为unit_test或者是想要测试的包或者功能作为文件前缀。\",\"package test_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) func TestSum(t *testing.T) { a, b := 10, 101 expected := 111 actual := tool.SumInt(a, b) if actual != expected { t.Errorf(\\\"Sum(%d,%d) expected %d,actual is %d\\\", a, b, expected, actual) } } func TestEqual(t *testing.T) { a, b := 10, 101 expected := false actual := tool.Equal(a, b) if actual != expected { t.Errorf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } }\",\"对于单元测试而言，每一个测试用例的命名风格为TestXXXX，且函数的入参必须是t *testing.T，testing.T是testing包提供的用于方便测试的结构体，提供了许多可用的方法，例子中的t.Errorf等同于t.Logf，用于格式化输出测试失败的日志信息，其他常用的还有t.Fail用于将当前用例标记为测试失败，功能类似的还有t.FailNow同样会标记为测试失败，但是前者失败后还会继续执行，后者则会直接停止执行，如下方的例子，将预期结果修改为错误的结果：\",\"package tool_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) func TestSum(t *testing.T) { a, b := 10, 101 expected := 110 actual := tool.SumInt(a, b) if actual != expected { // Errorf内部使用的是t.Fail() t.Errorf(\\\"Sum(%d,%d) expected %d,actual is %d\\\", a, b, expected, actual) } t.Log(\\\"test finished\\\") } func TestEqual(t *testing.T) { a, b := 10, 101 expected := true actual := tool.Equal(a, b) if actual != expected { // Fatalf内部使用的是t.FailNow() t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } t.Log(\\\"test finished\\\") }\",\"执行上述测试输出如下\",\"$ go test tool_test.go -v === RUN TestSum tool_test.go:14: Sum(10,101) expected 110,actual is 111 tool_test.go:16: test finished --- FAIL: TestSum (0.00s) === RUN TestEqual tool_test.go:25: Sum(10,101) expected true,actual is false --- FAIL: TestEqual (0.00s) FAIL command-line-arguments 0.037s\",\"从测试日志中可以看出TestSum用例尽管失败了还是输出了test finished，而TestEqual则没有，同样的还有t.SkipNow，会将当前用例标记为SKIP，然后停止执行，在下一轮测试中会继续执行。\",\"package tool_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) func TestSum(t *testing.T) { a, b := 10, 101 expected := 110 actual := tool.SumInt(a, b) if actual != expected { t.Skipf(\\\"Sum(%d,%d) expected %d,actual is %d\\\", a, b, expected, actual) } t.Log(\\\"test finished\\\") } func TestEqual(t *testing.T) { a, b := 10, 101 expected := true actual := tool.Equal(a, b) if actual != expected { t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } t.Log(\\\"test finished\\\") }\",\"在执行测试时，修改测试次数为2\",\"$ go test tool_test.go -v -count=2 === RUN TestSum tool_test.go:14: Sum(10,101) expected 110,actual is 111 --- SKIP: TestSum (0.00s) === RUN TestEqual tool_test.go:25: Sum(10,101) expected true,actual is false --- FAIL: TestEqual (0.00s) === RUN TestSum tool_test.go:14: Sum(10,101) expected 110,actual is 111 --- SKIP: TestSum (0.00s) === RUN TestEqual tool_test.go:25: Sum(10,101) expected true,actual is false --- FAIL: TestEqual (0.00s) FAIL command-line-arguments 0.468s\",\"上数的例子中在最后一行输出了test finished，用于表示测试完毕，其实可以使用t.Cleanup来注册一个收尾函数专门做此事，该函数会在测试用例结束时执行，如下。\",\"package tool_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) func finished(t *testing.T) { t.Log(\\\"test finished\\\") } func TestSum(t *testing.T) { t.Cleanup(func() { finished(t) }) a, b := 10, 101 expected := 111 actual := tool.SumInt(a, b) if actual != expected { t.Skipf(\\\"Sum(%d,%d) expected %d,actual is %d\\\", a, b, expected, actual) } } func TestEqual(t *testing.T) { t.Cleanup(func() { finished(t) }) a, b := 10, 101 expected := false actual := tool.Equal(a, b) if actual != expected { t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } }\",\"执行测试后输出如下\",\"$ go test tool_test.go -v === RUN TestSum tool_test.go:9: test finished --- PASS: TestSum (0.00s) === RUN TestEqual tool_test.go:9: test finished --- PASS: TestEqual (0.00s) PASS ok command-line-arguments 0.462s\"]},\"391\":{\"h\":\"Helper\",\"t\":[\"通过t.Helper()可以将当前函数标记为帮助函数，帮助函数不会单独作为一个测试用例用于执行，在记录日志时输出的行号也是帮助函数的调用者的行号，这样可以使得分析日志时定位更准确，避免的冗杂的其他信息。比如将上述t.Cleanup的例子就可以修改为帮助函数，如下。\",\"package tool_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) func CleanupHelper(t *testing.T) { t.Helper() t.Log(\\\"test finished\\\") } func TestSum(t *testing.T) { t.Cleanup(func() { CleanupHelper(t) }) a, b := 10, 101 expected := 111 actual := tool.SumInt(a, b) if actual != expected { t.Skipf(\\\"Sum(%d,%d) expected %d,actual is %d\\\", a, b, expected, actual) } } func TestEqual(t *testing.T) { t.Cleanup(func() { CleanupHelper(t) }) a, b := 10, 101 expected := false t.Helper() actual := tool.Equal(a, b) if actual != expected { t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } }\",\"执行测试后输出信息如下，与之前的区别在于test finished的行号变成了调用者的行号。\",\"$ go test tool_test.go -v === RUN TestSum tool_test.go:15: test finished --- PASS: TestSum (0.00s) === RUN TestEqual tool_test.go:30: test finished --- PASS: TestEqual (0.00s) PASS ok command-line-arguments 0.464s\",\"提示\",\"上述操作都只能在主测试中进行，即直接执行的测试用例，如果是子测试中使用将会panic。\"]},\"392\":{\"h\":\"子测试\",\"t\":[\"在一些情况下，会需要用到在一个测试用例中测试另外测试用例，这种嵌套的测试用例一般称为子测试，通过t.Run()方法，该方法签名如下\",\"// Run方法会开启一个新的协程用于运行子测试，阻塞等待函数f执行完毕后才会返回 // 返回值为是否通过测试 func (t *T) Run(name string, f func(t *T)) bool\",\"下面是一个例子\",\"func TestTool(t *testing.T) { t.Run(\\\"tool.Sum(10,101)\\\", TestSum) t.Run(\\\"tool.Equal(10,101)\\\", TestEqual) }\",\"执行后结果如下\",\"$ go test -run TestTool -v === RUN TestTool === RUN TestTool/tool.Sum(10,101) tool_test.go:15: test finished === RUN TestTool/tool.Equal(10,101) tool_test.go:30: test finished --- PASS: TestTool (0.00s) --- PASS: TestTool/tool.Sum(10,101) (0.00s) --- PASS: TestTool/tool.Equal(10,101) (0.00s) PASS ok golearn/tool_test 0.449s\",\"通过输出可以很清晰的看到父子的层级结构，在上述的例子中第一个子测试未执行完毕第二个子测试是不会执行的，可以使用t.Parallel()将测试用例标记为可并行运行，如此一来输出的顺序将会无法确定。\",\"package tool_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) func CleanupHelper(t *testing.T) { t.Helper() t.Log(\\\"test finished\\\") } func TestSum(t *testing.T) { t.Parallel() t.Cleanup(func() { CleanupHelper(t) }) a, b := 10, 101 expected := 111 actual := tool.SumInt(a, b) if actual != expected { t.Skipf(\\\"Sum(%d,%d) expected %d,actual is %d\\\", a, b, expected, actual) } } func TestEqual(t *testing.T) { t.Parallel() t.Cleanup(func() { CleanupHelper(t) }) a, b := 10, 101 expected := false actual := tool.Equal(a, b) if actual != expected { t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } } func TestToolParallel(t *testing.T) { t.Log(\\\"setup\\\") t.Run(\\\"tool.Sum(10,101)\\\", TestSum) t.Run(\\\"tool.Equal(10,101)\\\", TestEqual) t.Log(\\\"teardown\\\") }\",\"执行测试后输出如下\",\"$ go test -run TestTool -v === RUN TestToolParallel tool_test.go:46: setup === RUN TestToolParallel/tool.Sum(10,101) === PAUSE TestToolParallel/tool.Sum(10,101) === RUN TestToolParallel/tool.Equal(10,101) === PAUSE TestToolParallel/tool.Equal(10,101) === NAME TestToolParallel tool_test.go:49: teardown === CONT TestToolParallel/tool.Sum(10,101) === CONT TestToolParallel/tool.Equal(10,101) === NAME TestToolParallel/tool.Sum(10,101) tool_test.go:16: test finished === NAME TestToolParallel/tool.Equal(10,101) tool_test.go:32: test finished --- PASS: TestToolParallel (0.00s) --- PASS: TestToolParallel/tool.Sum(10,101) (0.00s) --- PASS: TestToolParallel/tool.Equal(10,101) (0.00s) PASS ok golearn/tool_test 0.444s\",\"从测试结果中就可以很明显的看出有一个阻塞等待的过程，在并发执行测试用例时，像上述的例子肯定是无法正常进行的，因为后续的代码无法保证同步运行，这时可以选择再嵌套一层t.Run()，如下\",\"func TestToolParallel(t *testing.T) { t.Log(\\\"setup\\\") t.Run(\\\"process\\\", func(t *testing.T) { t.Run(\\\"tool.Sum(10,101)\\\", TestSum) t.Run(\\\"tool.Equal(10,101)\\\", TestEqual) }) t.Log(\\\"teardown\\\") }\",\"再次执行，就可以看到正常的执行结果了。\",\"$ go test -run TestTool -v === RUN TestToolParallel tool_test.go:46: setup === RUN TestToolParallel/process === RUN TestToolParallel/process/tool.Sum(10,101) === PAUSE TestToolParallel/process/tool.Sum(10,101) === RUN TestToolParallel/process/tool.Equal(10,101) === PAUSE TestToolParallel/process/tool.Equal(10,101) === CONT TestToolParallel/process/tool.Sum(10,101) === CONT TestToolParallel/process/tool.Equal(10,101) === NAME TestToolParallel/process/tool.Sum(10,101) tool_test.go:16: test finished === NAME TestToolParallel/process/tool.Equal(10,101) tool_test.go:32: test finished === NAME TestToolParallel tool_test.go:51: teardown --- PASS: TestToolParallel (0.00s) --- PASS: TestToolParallel/process (0.00s) --- PASS: TestToolParallel/process/tool.Sum(10,101) (0.00s) --- PASS: TestToolParallel/process/tool.Equal(10,101) (0.00s) PASS ok golearn/tool_test 0.450s\"]},\"393\":{\"h\":\"表格风格\",\"t\":[\"在上述的单元测试中，测试的输入数据都是手动声明的一个个变量，当数据量小的时候无伤大雅，但如果想要测试多组数据时，就不太可能再去声明变量来创建测试数据，所以一般情况下都是尽量采用结构体切片的形式，结构体是临时声明的匿名结构体，因为这样的编码风格看起来就跟表格一样，所以称为table-driven，下面举个例子，这是一个手动声明多个变量来创建测试数据的例子，如果有多组数据狠起来就不是很直观，所以将其修改为表格风格\",\"func TestEqual(t *testing.T) { t.Cleanup(func() { CleanupHelper(t) }) a, b := 10, 101 expected := false actual := tool.Equal(a, b) if actual != expected { t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", a, b, expected, actual) } }\",\"修改后的代码如下\",\"func TestEqual(t *testing.T) { t.Cleanup(func() { CleanupHelper(t) }) // table driven style testData := []struct { a, b int exp bool }{ {10, 101, false}, {5, 5, true}, {30, 32, false}, {100, 101, false}, {2, 3, false}, {4, 4, true}, } for _, data := range testData { if actual := tool.Equal(data.a, data.b); actual != data.exp { t.Fatalf(\\\"Sum(%d,%d) expected %t,actual is %t\\\", data.a, data.b, data.exp, actual) } } }\",\"这样的测试数据看起来就要直观很多。\"]},\"394\":{\"h\":\"基准测试\",\"t\":[\"基准测试又称为性能测试，通常用于测试程序的内存占用，CPU使用情况，执行耗时等等性能指标。对于基准测试而言，测试文件通常以bench_test.go结尾，而测试用例的函数必须为BenchmarkXXXX格式。\",\"下面以一个字符串拼接的例子的性能比较来当作基准测试的例子。首先创建文件/tool/strConcat.go文件，众所周知直接使用字符串进行+拼接性能是很低的，而使用strings.Builder则要好很多，在/tool/strings.go文件分别创建两个函数进行两种方式的字符串拼接。\",\"package tool import \\\"strings\\\" func ConcatStringDirect(longString string) { res := \\\"\\\" for i := 0; i < 100_000.; i++ { res += longString } } func ConcatStringWithBuilder(longString string) { var res strings.Builder for i := 0; i < 100_000.; i++ { res.WriteString(longString) } }\",\"然后创建测试文件/tool_test/bench_tool_test.go ，代码如下\",\"package tool_test import ( \\\"golearn/tool\\\" \\\"testing\\\" ) var longString = \\\"longStringlongStringlongStringlongStringlongStringlongStringlongStringlongString\\\" func BenchmarkConcatDirect(b *testing.B) { for i := 0; i < b.N; i++ { tool.ConcatStringDirect(longString) } } func BenchmarkConcatBuilder(b *testing.B) { for i := 0; i < b.N; i++ { tool.ConcatStringWithBuilder(longString) } }\",\"执行测试命令，命令中开启了详细日志和内存分析，指定了使用的CPU核数列表，且每个测试用例执行两轮，输出如下\",\"$ go test -v -benchmem -bench . -run bench_tool_test.go -cpu=2,4,8 -count=2 goos: windows goarch: amd64 pkg: golearn/tool_test cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkConcatDirect BenchmarkConcatDirect-2 4 277771375 ns/op 4040056736 B/op 10000 allocs/op BenchmarkConcatDirect-2 4 278500125 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-4 1 1153796000 ns/op 4040068784 B/op 10126 allocs/op BenchmarkConcatDirect-4 1 1211017600 ns/op 4040073104 B/op 10171 allocs/op BenchmarkConcatDirect-8 2 665460800 ns/op 4040077760 B/op 10219 allocs/op BenchmarkConcatDirect-8 2 679774450 ns/op 4040080064 B/op 10243 allocs/op BenchmarkConcatBuilder BenchmarkConcatBuilder-2 3428 344530 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 3579 351858 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-4 2448 736177 ns/op 4128185 B/op 29 allocs/op BenchmarkConcatBuilder-4 1688 662993 ns/op 4128185 B/op 29 allocs/op BenchmarkConcatBuilder-8 1958 550333 ns/op 4128199 B/op 29 allocs/op BenchmarkConcatBuilder-8 2174 552113 ns/op 4128196 B/op 29 allocs/op PASS ok golearn/tool_test 21.381s\",\"下面解释一下基准测试的输出结果，goos代表是运行的操作系统，goarh代表的是CPU架构，pkg为测试所在的包，cpu是一些关于CPU的信息。下面的每一个测试用例的结果由每一个基准测试的名称分隔，第一列BenchmarkConcatDirect-2中的2代表了使用的CPU核数，第二列的4代表了代码中b.N的大小，也就是基准测试中的循环次数，第三列277771375 ns/op代表了每一次循环所消耗的时间，ns为纳秒，第四列4040056736 B/op表示每一次循环所分配内存的字节大小，第五列10000 allocs/op表示每一次循环内存分配的次数。\",\"很显然，根据测试的结果看来，使用strings.Builder的性能要远远高于使用+拼接字符串，通过直观的数据对比性能正是基准测试的目的所在。\"]},\"395\":{\"h\":\"benchstat\",\"t\":[\"benchstat是一个开源的性能测试分析工具，上述性能测试的样本数只有两组，一旦样本多了起来人工分析就会十分的费时费力，该工具便是为了解决性能分析问题而生。\",\"首先需要下载该工具\",\"$ go install golang.org/x/perf/benchstat\",\"分两次执行基准测试，这次将样本数修改为5个，并且分别输出到old.txt和new.txt文件以做对比，第一次执行结果\",\"$ go test -v -benchmem -bench . -run bench_tool_test.go -cpu=2,4,8 -count=5 | tee -a old.txt goos: windows goarch: amd64 pkg: golearn/tool_test cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkConcatDirect BenchmarkConcatDirect-2 4 290535650 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 298974625 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 299637800 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 276487000 ns/op 4040056784 B/op 10001 allocs/op BenchmarkConcatDirect-2 4 356465275 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-4 2 894723200 ns/op 4040077424 B/op 10216 allocs/op BenchmarkConcatDirect-4 2 785830400 ns/op 4040078288 B/op 10225 allocs/op BenchmarkConcatDirect-4 2 743634000 ns/op 4040077568 B/op 10217 allocs/op BenchmarkConcatDirect-4 2 953802700 ns/op 4040075408 B/op 10195 allocs/op BenchmarkConcatDirect-4 2 953028750 ns/op 4040077520 B/op 10217 allocs/op BenchmarkConcatDirect-8 2 684023150 ns/op 4040086784 B/op 10313 allocs/op BenchmarkConcatDirect-8 2 634380250 ns/op 4040090528 B/op 10352 allocs/op BenchmarkConcatDirect-8 2 685030600 ns/op 4040090768 B/op 10355 allocs/op BenchmarkConcatDirect-8 2 817909650 ns/op 4040089808 B/op 10345 allocs/op BenchmarkConcatDirect-8 2 600078100 ns/op 4040095664 B/op 10406 allocs/op BenchmarkConcatBuilder BenchmarkConcatBuilder-2 2925 419651 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 2961 423899 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 2714 422275 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 2848 452255 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 2612 454452 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-4 974 1158000 ns/op 4128189 B/op 29 allocs/op BenchmarkConcatBuilder-4 1098 1068682 ns/op 4128192 B/op 29 allocs/op BenchmarkConcatBuilder-4 1042 1056570 ns/op 4128194 B/op 29 allocs/op BenchmarkConcatBuilder-4 1280 978213 ns/op 4128191 B/op 29 allocs/op BenchmarkConcatBuilder-4 1538 1162108 ns/op 4128190 B/op 29 allocs/op BenchmarkConcatBuilder-8 1744 700824 ns/op 4128203 B/op 29 allocs/op BenchmarkConcatBuilder-8 2235 759537 ns/op 4128201 B/op 29 allocs/op BenchmarkConcatBuilder-8 1556 736455 ns/op 4128204 B/op 29 allocs/op BenchmarkConcatBuilder-8 1592 825794 ns/op 4128201 B/op 29 allocs/op BenchmarkConcatBuilder-8 2263 717285 ns/op 4128203 B/op 29 allocs/op PASS ok golearn/tool_test 56.742s\",\"第二次执行结果\",\"$ go test -v -benchmem -bench . -run bench_tool_test.go -cpu=2,4,8 -count=5 | tee -a new.txt goos: windows goarch: amd64 pkg: golearn/tool_test cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkConcatDirect BenchmarkConcatDirect-2 4 285074900 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 291517150 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 281901975 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 292320625 ns/op 4040056592 B/op 9999 allocs/op BenchmarkConcatDirect-2 4 286723000 ns/op 4040056952 B/op 10002 allocs/op BenchmarkConcatDirect-4 1 1188983000 ns/op 4040071856 B/op 10158 allocs/op BenchmarkConcatDirect-4 1 1080713900 ns/op 4040070800 B/op 10147 allocs/op BenchmarkConcatDirect-4 1 1203622300 ns/op 4040067344 B/op 10111 allocs/op BenchmarkConcatDirect-4 1 1045291300 ns/op 4040070224 B/op 10141 allocs/op BenchmarkConcatDirect-4 1 1123163300 ns/op 4040070032 B/op 10139 allocs/op BenchmarkConcatDirect-8 2 790421300 ns/op 4040076656 B/op 10208 allocs/op BenchmarkConcatDirect-8 2 659047300 ns/op 4040079488 B/op 10237 allocs/op BenchmarkConcatDirect-8 2 712991800 ns/op 4040077184 B/op 10213 allocs/op BenchmarkConcatDirect-8 2 706605350 ns/op 4040078000 B/op 10222 allocs/op BenchmarkConcatDirect-8 2 656195700 ns/op 4040085248 B/op 10297 allocs/op BenchmarkConcatBuilder BenchmarkConcatBuilder-2 2726 386412 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 3439 335358 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 3376 338957 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 3870 326301 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-2 4285 339596 ns/op 4128176 B/op 29 allocs/op BenchmarkConcatBuilder-4 1663 671535 ns/op 4128187 B/op 29 allocs/op BenchmarkConcatBuilder-4 1507 744885 ns/op 4128191 B/op 29 allocs/op BenchmarkConcatBuilder-4 1353 1097800 ns/op 4128187 B/op 29 allocs/op BenchmarkConcatBuilder-4 1388 1006019 ns/op 4128189 B/op 29 allocs/op BenchmarkConcatBuilder-4 1635 993764 ns/op 4128189 B/op 29 allocs/op BenchmarkConcatBuilder-8 1332 783599 ns/op 4128198 B/op 29 allocs/op BenchmarkConcatBuilder-8 1818 729821 ns/op 4128202 B/op 29 allocs/op BenchmarkConcatBuilder-8 1398 780614 ns/op 4128202 B/op 29 allocs/op BenchmarkConcatBuilder-8 1526 750513 ns/op 4128204 B/op 29 allocs/op BenchmarkConcatBuilder-8 2164 704798 ns/op 4128204 B/op 29 allocs/op PASS ok golearn/tool_test 50.387s\",\"再使用benchstat进行对比\",\"$ benchstat old.txt new.txt goos: windows goarch: amd64 pkg: golearn/tool_test cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz │ old.txt │ new.txt │ │ sec/op │ sec/op vs base │ ConcatDirect-2 299.0m ± ∞ ¹ 286.7m ± ∞ ¹ ~ (p=0.310 n=5) ConcatDirect-4 894.7m ± ∞ ¹ 1123.2m ± ∞ ¹ +25.53% (p=0.008 n=5) ConcatDirect-8 684.0m ± ∞ ¹ 706.6m ± ∞ ¹ ~ (p=0.548 n=5) ConcatBuilder-2 423.9µ ± ∞ ¹ 339.0µ ± ∞ ¹ -20.04% (p=0.008 n=5) ConcatBuilder-4 1068.7µ ± ∞ ¹ 993.8µ ± ∞ ¹ ~ (p=0.151 n=5) ConcatBuilder-8 736.5µ ± ∞ ¹ 750.5µ ± ∞ ¹ ~ (p=0.841 n=5) geomean 19.84m 19.65m -0.98% ¹ need >= 6 samples for confidence interval at level 0.95 │ old.txt │ new.txt │ │ B/op │ B/op vs base │ ConcatDirect-2 3.763Gi ± ∞ ¹ 3.763Gi ± ∞ ¹ ~ (p=1.000 n=5) ConcatDirect-4 3.763Gi ± ∞ ¹ 3.763Gi ± ∞ ¹ -0.00% (p=0.008 n=5) ConcatDirect-8 3.763Gi ± ∞ ¹ 3.763Gi ± ∞ ¹ -0.00% (p=0.008 n=5) ConcatBuilder-2 3.937Mi ± ∞ ¹ 3.937Mi ± ∞ ¹ ~ (p=1.000 n=5) ² ConcatBuilder-4 3.937Mi ± ∞ ¹ 3.937Mi ± ∞ ¹ ~ (p=0.079 n=5) ConcatBuilder-8 3.937Mi ± ∞ ¹ 3.937Mi ± ∞ ¹ ~ (p=0.952 n=5) geomean 123.2Mi 123.2Mi -0.00% ¹ need >= 6 samples for confidence interval at level 0.95 ² all samples are equal │ old.txt │ new.txt │ │ allocs/op │ allocs/op vs base │ ConcatDirect-2 9.999k ± ∞ ¹ 9.999k ± ∞ ¹ ~ (p=1.000 n=5) ConcatDirect-4 10.22k ± ∞ ¹ 10.14k ± ∞ ¹ -0.74% (p=0.008 n=5) ConcatDirect-8 10.35k ± ∞ ¹ 10.22k ± ∞ ¹ -1.26% (p=0.008 n=5) ConcatBuilder-2 29.00 ± ∞ ¹ 29.00 ± ∞ ¹ ~ (p=1.000 n=5) ² ConcatBuilder-4 29.00 ± ∞ ¹ 29.00 ± ∞ ¹ ~ (p=1.000 n=5) ² ConcatBuilder-8 29.00 ± ∞ ¹ 29.00 ± ∞ ¹ ~ (p=1.000 n=5) ² geomean 543.6 541.7 -0.33% ¹ need >= 6 samples for confidence interval at level 0.95 ² all samples are equal\",\"从结果中可以看出benchstat将其分为了三组，分别是耗时，内存占用和内存分配次数，其中geomoean为平均值，p为 样本的显著性水平，临界区间通常为0.05，高于0.05就不太可信，取其中一条数据如下：\",\" │ sec/op │ sec/op vs base │ ConcatDirect-4 894.7m ± ∞ ¹ 1123.2m ± ∞ ¹ +25.53% (p=0.008 n=5)\",\"可以看到old执行耗时为894.7ms，new执行耗时1123.2ms，相比之下还增加了25.53%的耗时。\"]},\"396\":{\"h\":\"模糊测试\",\"t\":[\"模糊测试是GO1.18推出的一个新功能，属于是单元测试和基准测试的一种增强，区别在于前两者的测试数据都需要开发者手动编写，而模糊测试可以通过语料库来生成随机的测试数据，关于Go中的模糊测试可以前往Go Fuzzing来了解更多概念。模糊测试的好处在于，相比于固定的测试数据，随机数据可以更好的测试程序的边界条件。下面拿官方教程的例子来讲解，这次需要测试的是一个反转字符串的函数，首先创建文件/tool/strings.go，写入如下代码\",\"package tool func Reverse(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1 { b[i], b[j] = b[j], b[i] } return string(b) }\",\"创建模糊测试文件/tool_test/fuzz_tool_test.go，写入如下代码\",\"package tool import ( \\\"golearn/tool\\\" \\\"testing\\\" \\\"unicode/utf8\\\" ) func FuzzReverse(f *testing.F) { testdata := []string{\\\"hello world!\\\", \\\"nice to meet you\\\", \\\"good bye!\\\"} for _, data := range testdata { f.Add(data) } f.Fuzz(func(t *testing.T, str string) { first := tool.Reverse(str) second := tool.Reverse(first) t.Logf(\\\"str:%q,first:%q,second:%q\\\", str, first, second) if str != second { t.Errorf(\\\"before: %q, after: %q\\\", str, second) } if utf8.ValidString(str) && !utf8.ValidString(first) { t.Errorf(\\\"Reverse produced invalid UTF-8 string %q %q\\\", str, first) } }) }\",\"在模糊测试中，首先需要给语料种子库添加数据，示例中使用f.Add()来添加，有助于后续生成随机的测试数据。然后使用f.Fuzz(fn)来进行测试，函数签名如下：\",\"func (f *F) Fuzz(ff any) func (f *F) Add(args ...any)\",\"fn就类似于一个单元测试函数的逻辑，函数的第一个入参必须是t *testing.T，其后跟想要生成的参数。由于传入的字符串是不可预知的，这里采用反转两次的方法来进行验证。执行如下命令\",\"$ go test -run Fuzz -v === RUN FuzzReverse === RUN FuzzReverse/seed#0 fuzz_tool_test.go:18: str:\\\"hello world!\\\",first:\\\"!dlrow olleh\\\",second:\\\"hello world!\\\" === RUN FuzzReverse/seed#1 fuzz_tool_test.go:18: str:\\\"nice to meet you\\\",first:\\\"uoy teem ot ecin\\\",second:\\\"nice to meet you\\\" === RUN FuzzReverse/seed#2 fuzz_tool_test.go:18: str:\\\"good bye!\\\",first:\\\"!eyb doog\\\",second:\\\"good bye!\\\" --- PASS: FuzzReverse (0.00s) --- PASS: FuzzReverse/seed#0 (0.00s) --- PASS: FuzzReverse/seed#1 (0.00s) --- PASS: FuzzReverse/seed#2 (0.00s) PASS ok golearn/tool_test 0.539s\",\"当参数不带-fuzz时，将不会生成随机的测试数据，只会给测试函数传入语料库中的数据，可以从结果中看到测试全部通过了，这样使用就等同于单元测试，但其实是有问题的，下面加上-fuzz参数再次执行。\",\"$ go test -fuzz . -fuzztime 30s -run Fuzz -v === RUN FuzzReverse fuzz: elapsed: 0s, gathering baseline coverage: 0/217 completed fuzz: minimizing 91-byte failing input file fuzz: elapsed: 0s, gathering baseline coverage: 15/217 completed --- FAIL: FuzzReverse (0.13s) --- FAIL: FuzzReverse (0.00s) fuzz_tool_test.go:18: str:\\\"𐑄\\\",first:\\\"\\\\x84\\\\x91\\\\x90\\\\xf0\\\",second:\\\"𐑄\\\" fuzz_tool_test.go:23: Reverse produced invalid UTF-8 string \\\"𐑄\\\" \\\"\\\\x84\\\\x91\\\\x90\\\\xf0\\\" Failing input written to testdata\\\\fuzz\\\\FuzzReverse\\\\d856c981b6266ba2 To re-run: go test -run=FuzzReverse/d856c981b6266ba2 === NAME FAIL exit status 1 FAIL golearn/tool_test 0.697s\",\"提示\",\"模糊测试中失败的用例会输出到当前测试文件夹下的testdata目录下的某个语料文件中，例如上述例子中的\",\"Failing input written to testdata\\\\fuzz\\\\FuzzReverse\\\\d856c981b6266ba2 To re-run: go test -run=FuzzReverse/d856c981b6266ba2\",\"testdata\\\\fuzz\\\\FuzzReverse\\\\d856c981b6266ba2便是输出的语料文件路径，文件的内容如下\",\"go test fuzz v1 string(\\\"𐑄\\\")\",\"可以看到这一次并没有通过，原因是字符串反转后变成了非utf8格式，所以通过模糊测试就发现了这个问题所在。由于一些字符占用并不止一个字节，如果将其以字节为单位反转后肯定是乱码，所以将待测试的源代码修改为如下，将字符串转换为[]rune，这样就可以避免出现上述问题。\",\"func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) }\",\"接下来直接运行根据上次模糊测试失败的用例\",\"$ go test -run=FuzzReverse/d856c981b6266ba2 -v === RUN FuzzReverse === RUN FuzzReverse/d856c981b6266ba2 fuzz_tool_test.go:18: str:\\\"𐑄\\\",first:\\\"𐑄\\\",second:\\\"𐑄\\\" --- PASS: FuzzReverse (0.00s) --- PASS: FuzzReverse/d856c981b6266ba2 (0.00s) PASS ok golearn/tool_test 0.033s\",\"可以看到这一次通过了测试，再次执行模糊测试看看还有没有问题\",\"$ go test -fuzz . -fuzztime 30s -run Fuzz -v === RUN FuzzReverse fuzz: elapsed: 0s, gathering baseline coverage: 0/219 completed fuzz: minimizing 70-byte failing input file failure while testing seed corpus entry: FuzzReverse/d97214ce235bfcf5 fuzz: elapsed: 0s, gathering baseline coverage: 2/219 completed --- FAIL: FuzzReverse (0.15s) --- FAIL: FuzzReverse (0.00s) fuzz_tool_test.go:18: str:\\\"\\\\xe4\\\",first:\\\"�\\\",second:\\\"�\\\" fuzz_tool_test.go:20: before: \\\"\\\\xe4\\\", after: \\\"�\\\" === NAME FAIL exit status 1 FAIL golearn/tool_test 0.184s\",\"可以发现又出错了，这次的问题是对字符串做了两次反转后不相等，原字符为\\\\xe4，期望的结果是4ex\\\\ ，但结果是乱码，如下\",\"func main() { fmt.Println(\\\"\\\\xe4\\\") fmt.Println([]byte(\\\"\\\\xe4\\\")) fmt.Println([]rune(\\\"\\\\xe4\\\")) fmt.Printf(\\\"%q\\\\n\\\", \\\"\\\\xe4\\\") fmt.Printf(\\\"%x\\\\n\\\", \\\"\\\\xe4\\\") }\",\"它的执行结果是\",\"� [65533] \\\"\\\\xe4\\\" e4\",\"究其原因在于Go在字符串单位是字节，而不是字符。所以再次修改待测源代码，如果传入的是非utf8字符串，直接返回错误。\",\"func Reverse(s string) (string, error) { if !utf8.ValidString(s) { return s, errors.New(\\\"input is not valid UTF-8\\\") } r := []rune(s) for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r), nil }\",\"测试代码也需要稍作修改\",\"func FuzzReverse(f *testing.F) { testdata := []string{\\\"hello world!\\\", \\\"nice to meet you\\\", \\\"good bye!\\\"} for _, data := range testdata { f.Add(data) } f.Fuzz(func(t *testing.T, str string) { first, err := tool.Reverse(str) if err != nil { t.Skip() } second, err := tool.Reverse(first) if err != nil { t.Skip() } t.Logf(\\\"str:%q,first:%q,second:%q\\\", str, first, second) if str != second { t.Errorf(\\\"before: %q, after: %q\\\", str, second) } if utf8.ValidString(str) && !utf8.ValidString(first) { t.Errorf(\\\"Reverse produced invalid UTF-8 string %q %q\\\", str, first) } }) }\",\"当反转函数返回error时，就跳过测试，再来进行模糊测试\",\"$ go test -fuzz . -fuzztime 30s -run Fuzz -v === RUN FuzzReverse fuzz: elapsed: 0s, gathering baseline coverage: 0/219 completed fuzz: elapsed: 0s, gathering baseline coverage: 219/219 completed, now fuzzing with 16 workers fuzz: elapsed: 3s, execs: 895571 (297796/sec), new interesting: 32 (total: 251) fuzz: elapsed: 6s, execs: 1985543 (363120/sec), new interesting: 37 (total: 256) fuzz: elapsed: 9s, execs: 3087837 (367225/sec), new interesting: 38 (total: 257) fuzz: elapsed: 12s, execs: 4090817 (335167/sec), new interesting: 40 (total: 259) fuzz: elapsed: 15s, execs: 5132580 (346408/sec), new interesting: 44 (total: 263) fuzz: elapsed: 18s, execs: 6248486 (372185/sec), new interesting: 45 (total: 264) fuzz: elapsed: 21s, execs: 7366827 (373305/sec), new interesting: 46 (total: 265) fuzz: elapsed: 24s, execs: 8439803 (358059/sec), new interesting: 47 (total: 266) fuzz: elapsed: 27s, execs: 9527671 (361408/sec), new interesting: 47 (total: 266) fuzz: elapsed: 30s, execs: 10569473 (348056/sec), new interesting: 48 (total: 267) fuzz: elapsed: 30s, execs: 10569473 (0/sec), new interesting: 48 (total: 267) --- PASS: FuzzReverse (30.16s) === NAME PASS ok golearn/tool_test 30.789s\",\"然后这次就可以得到一个比较完整的模糊测试输出日志，其中一些概念的解释如下：\",\"elapsed: 一个轮次完成后已经流逝的时间\",\"execs: 运行的输入总数，297796/sec表示多少个输入每秒\",\"new interesting: 在测试中，已经添加语料库中的”有趣“输入的总数。（有趣的输入指的是该输入能够将代码覆盖率扩大到现有语料库所能覆盖的范围之外，随着覆盖范围的不断扩大，它的增长趋势总体上而言会持续变缓）\",\"提示\",\"如果没有-fuzztime参数限制时间，模糊测试将会永远的运行下去。\"]},\"397\":{\"h\":\"类型支持\",\"t\":[\"Go Fuzz中的支持的类型如下：\",\"string, []byte\",\"int, int8, int16, int32/rune, int64\",\"uint, uint8/byte, uint16, uint32, uint64\",\"float32, float64\",\"bool\"]},\"398\":{\"h\":\"-基础面试\",\"t\":[\"待定\"]},\"399\":{\"c\":[\"golang\"]},\"400\":{\"h\":\"-进阶面试\"},\"401\":{\"c\":[\"golang\"]},\"402\":{\"h\":\"-ElasticSearch\",\"t\":[\"待定\",\"官方网址：Elasticsearch：官方分布式搜索和分析引擎 | Elastic\",\"Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，Elasticsearch 会集中存储您的数据，让您飞快完成搜索，微调相关性，进行强大的分析，并轻松缩放规模。本文会讲解如何用Go来进行对Elastisearch的一些基本操作，比如增删改查之类的，如果你对Elasticsearch并不了解，请先自行学习。\"]},\"403\":{\"h\":\"依赖\",\"t\":[\"下载官方的依赖库\",\"$ github.com/elastic/go-elasticsearch/v7\",\"如果你是ES8，就换个版本\",\"$ github.com/elastic/go-elasticsearch/v8\",\"提示\",\"本文用ES8来进行演示\"]},\"404\":{\"h\":\"连接\",\"t\":[\"使用函数elasticsearch.NewClient来建立一个新的连接\",\"func NewClient(cfg Config) (*Client, error)\",\"ES8+默认使用HTTPS连接了，在建立HTTPS连接时，要么使用CA证书，要么用CA指纹，两者都是在Elaticsearch服务端生成的，一个例子如下\",\"client, err := elasticsearch.NewClient(elasticsearch.Config{ Addresses: []string{\\\"https://192.168.153.132:9200\\\"}, Username: \\\"elastic\\\", Password: \\\"TETJ8IY+ifbt8SLc+RRQ\\\", CertificateFingerprint: \\\"C0E9867C7D446BFF72FE46E7E9FE3455E970A8ADB0D3DF0E1472D55DB2612CD5\\\", })\",\"elasticsearch提供的Go API基本上都是选项式函数，比如通过ping API测试服务是否可以用\",\"pingResp, err := client.Ping(client.Ping.WithPretty(), client.Ping.WithHuman()) if err != nil { panic(err) } fmt.Println(pingResp)\",\"输出\",\"[200 OK]\",\"再比如，通过Info API查看服务状态\",\"infoResp, err := client.Info(client.Info.WithHuman()) if err != nil { panic(err) } fmt.Println(infoResp)\",\"输出\",\"[200 OK] { \\\"name\\\" : \\\"db-debian12\\\", \\\"cluster_name\\\" : \\\"docker-cluster\\\", \\\"cluster_uuid\\\" : \\\"OMbDIsNwTFiuyjNF9Xnpbw\\\", \\\"version\\\" : { \\\"number\\\" : \\\"8.15.0\\\", \\\"build_flavor\\\" : \\\"default\\\", \\\"build_type\\\" : \\\"docker\\\", \\\"build_hash\\\" : \\\"1a77947f34deddb41af25e6f0ddb8e830159c179\\\", \\\"build_date\\\" : \\\"2024-08-05T10:05:34.233336849Z\\\", \\\"build_snapshot\\\" : false, \\\"lucene_version\\\" : \\\"9.11.1\\\", \\\"minimum_wire_compatibility_version\\\" : \\\"7.17.0\\\", \\\"minimum_index_compatibility_version\\\" : \\\"7.0.0\\\" }, \\\"tagline\\\" : \\\"You Know, for Search\\\" }\",\"提示\",\"有关ES API的任何问题，请查阅官方文档ES Restful API。\"]},\"405\":{\"h\":\"索引\",\"t\":[\"通过go api操作索引，所有关于索引操作的API都位于esapi.Indices结构体中\",\"// Indices contains the Indices APIs type Indices struct { AddBlock IndicesAddBlock Analyze IndicesAnalyze ClearCache IndicesClearCache Clone IndicesClone Close IndicesClose ... ... ValidateQuery IndicesValidateQuery }\"]},\"406\":{\"h\":\"创建\",\"t\":[\"创建一个索引，如下所示\",\"{ \\\"settings\\\": { \\\"number_of_shards\\\": 3, \\\"number_of_replicas\\\": 2 }, \\\"mappings\\\": { \\\"properties\\\": { \\\"name\\\": { \\\"type\\\": \\\"text\\\" }, \\\"age\\\": { \\\"type\\\": \\\"long\\\" }, \\\"salary\\\": { \\\"type\\\": \\\"double\\\" } } } }\",\"实际操作，就跟发HTTP请求一样差不多\",\"func main() { client, err := newClient() if err != nil { panic(err) } dsl := bytes.NewBufferString(`{ \\\"settings\\\": { \\\"number_of_shards\\\": 3, \\\"number_of_replicas\\\": 2 }, \\\"mappings\\\": { \\\"properties\\\": { \\\"name\\\": { \\\"type\\\": \\\"text\\\" }, \\\"age\\\": { \\\"type\\\": \\\"long\\\" }, \\\"salary\\\": { \\\"type\\\": \\\"double\\\" } } } }`) createIndices := client.Indices.Create resp, err := createIndices(\\\"user\\\", createIndices.WithBody(dsl)) if err != nil { panic(err) } fmt.Println(resp) }\",\"输出\",\"[200 OK] {\\\"acknowledged\\\":true,\\\"shards_acknowledged\\\":true,\\\"index\\\":\\\"user\\\"}\"]},\"407\":{\"h\":\"获取\",\"t\":[\"获取若干个索引的信息\",\"func main() { client, err := newClient() if err != nil { panic(err) } get := client.Indices.Get response, err := get([]string{\\\"user\\\"}, get.WithPretty(), get.WithHuman()) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[200 OK] { \\\"user\\\" : { \\\"aliases\\\" : { }, \\\"mappings\\\" : { \\\"properties\\\" : { \\\"age\\\" : { \\\"type\\\" : \\\"long\\\" }, \\\"name\\\" : { \\\"type\\\" : \\\"text\\\" }, \\\"salary\\\" : { \\\"type\\\" : \\\"double\\\" } } }, \\\"settings\\\" : { \\\"index\\\" : { \\\"creation_date_string\\\" : \\\"2024-09-23T04:35:04.528Z\\\", \\\"routing\\\" : { \\\"allocation\\\" : { \\\"include\\\" : { \\\"_tier_preference\\\" : \\\"data_content\\\" } } }, \\\"number_of_shards\\\" : \\\"3\\\", \\\"provided_name\\\" : \\\"user\\\", \\\"creation_date\\\" : \\\"1727066104528\\\", \\\"number_of_replicas\\\" : \\\"2\\\", \\\"uuid\\\" : \\\"AvhhuqV2ShGkRP9z7XbdDA\\\", \\\"version\\\" : { \\\"created_string\\\" : \\\"8.14.4-snapshot[8512000]\\\", \\\"created\\\" : \\\"8512000\\\" } } } } }\"]},\"408\":{\"h\":\"分析\",\"t\":[\"针对指定索引对文本字符串进行分析，并返回结果，文本如下\",\"{ \\\"analyzer\\\" : \\\"standard\\\", \\\"text\\\" : [\\\"this is a test\\\", \\\"the second text\\\"] }\",\"代码\",\"func main() { client, err := newClient() if err != nil { panic(err) } analyze := client.Indices.Analyze dsl := bytes.NewBufferString(`{ \\\"analyzer\\\" : \\\"standard\\\", \\\"text\\\" : [\\\"this is a test\\\", \\\"the second text\\\"] }`) response, err := analyze(analyze.WithIndex(\\\"user\\\"), analyze.WithBody(dsl), analyze.WithPretty(), analyze.WithHuman()) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[200 OK] { \\\"tokens\\\" : [ { \\\"token\\\" : \\\"this\\\", \\\"start_offset\\\" : 0, \\\"end_offset\\\" : 4, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 0 }, { \\\"token\\\" : \\\"is\\\", \\\"start_offset\\\" : 5, \\\"end_offset\\\" : 7, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 1 }, { \\\"token\\\" : \\\"a\\\", \\\"start_offset\\\" : 8, \\\"end_offset\\\" : 9, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 2 }, { \\\"token\\\" : \\\"test\\\", \\\"start_offset\\\" : 10, \\\"end_offset\\\" : 14, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 3 }, { \\\"token\\\" : \\\"the\\\", \\\"start_offset\\\" : 15, \\\"end_offset\\\" : 18, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 104 }, { \\\"token\\\" : \\\"second\\\", \\\"start_offset\\\" : 19, \\\"end_offset\\\" : 25, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 105 }, { \\\"token\\\" : \\\"text\\\", \\\"start_offset\\\" : 26, \\\"end_offset\\\" : 30, \\\"type\\\" : \\\"<ALPHANUM>\\\", \\\"position\\\" : 106 } ] }\"]},\"409\":{\"h\":\"删除\",\"t\":[\"删除若干个指定的索引\",\"func main() { client, err := newClient() if err != nil { panic(err) } indicesDelete := client.Indices.Delete response, err := indicesDelete([]string{\\\"user\\\"}) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[200 OK] {\\\"acknowledged\\\":true}\",\"在上面这些API中，可以看到请求体是需要自己手动序列化的，官方并没有映射成Go结构体，响应体也是需要自己手动处理的。这些是比较常用的API，其他的使用起来都大差不差，没有太大区别。\"]},\"410\":{\"h\":\"文档\"},\"411\":{\"h\":\"创建\",\"t\":[\"创建一个如下的文档\",\"{ \\\"name\\\": \\\"jack\\\", \\\"age\\\": 12, \\\"salary\\\": 5701.1 }\",\"代码\",\"func main() { client, err := newClient() if err != nil { panic(err) } doc := bytes.NewBufferString(`{ \\\"name\\\": \\\"jack\\\", \\\"age\\\": 12, \\\"salary\\\": 5701.1 }`) create := client.Create response, err := create(\\\"user\\\", \\\"1\\\", doc, create.WithPretty()) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[201 Created] { \\\"_index\\\" : \\\"user\\\", \\\"_id\\\" : \\\"1\\\", \\\"_version\\\" : 1, \\\"result\\\" : \\\"created\\\", \\\"_shards\\\" : { \\\"total\\\" : 3, \\\"successful\\\" : 1, \\\"failed\\\" : 0 }, \\\"_seq_no\\\" : 0, \\\"_primary_term\\\" : 1 }\"]},\"412\":{\"h\":\"获取\",\"t\":[\"获取一个指定ID的文档\",\"func main() { client, err := newClient() if err != nil { panic(err) } get := client.Get response, err := get(\\\"user\\\", \\\"1\\\", get.WithPretty()) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[200 OK] { \\\"_index\\\" : \\\"user\\\", \\\"_id\\\" : \\\"1\\\", \\\"_version\\\" : 1, \\\"_seq_no\\\" : 0, \\\"_primary_term\\\" : 1, \\\"found\\\" : true, \\\"_source\\\" : { \\\"name\\\" : \\\"jack\\\", \\\"age\\\" : 12, \\\"salary\\\" : 5701.1 } }\"]},\"413\":{\"h\":\"更新\",\"t\":[\"更新文档内容\",\"{ \\\"doc\\\": { \\\"name\\\": \\\"jack\\\", \\\"age\\\": 35, \\\"salary\\\": 5701.1 } }\",\"代码\",\"func main() { client, err := newClient() if err != nil { panic(err) } doc := bytes.NewBufferString(`{ \\\"doc\\\": { \\\"name\\\": \\\"jack\\\", \\\"age\\\": 35, \\\"salary\\\": 5701.1 }}`) update := client.Update response, err := update(\\\"user\\\", \\\"1\\\", doc, update.WithPretty()) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[200 OK] { \\\"_index\\\" : \\\"user\\\", \\\"_id\\\" : \\\"1\\\", \\\"_version\\\" : 2, \\\"result\\\" : \\\"updated\\\", \\\"_shards\\\" : { \\\"total\\\" : 3, \\\"successful\\\" : 1, \\\"failed\\\" : 0 }, \\\"_seq_no\\\" : 1, \\\"_primary_term\\\" : 1 }\",\"Update API还可以支持script实现upsert等之类的操作，前往Update API了解更多信息。\"]},\"414\":{\"h\":\"删除\",\"t\":[\"通过ID删除一个指定的文档\",\"func main() { client, err := newClient() if err != nil { panic(err) } deleteDoc := client.Delete response, err := deleteDoc(\\\"user\\\", \\\"1\\\", deleteDoc.WithPretty()) if err != nil { panic(err) } fmt.Println(response) }\",\"输出\",\"[200 OK] { \\\"_index\\\" : \\\"user\\\", \\\"_id\\\" : \\\"1\\\", \\\"_version\\\" : 3, \\\"result\\\" : \\\"deleted\\\", \\\"_shards\\\" : { \\\"total\\\" : 3, \\\"successful\\\" : 1, \\\"failed\\\" : 0 }, \\\"_seq_no\\\" : 2, \\\"_primary_term\\\" : 1 }\"]},\"415\":{\"h\":\"搜索\",\"t\":[\"ES API最常用的就是搜索API，下面会简单演示用法，先准备数据。\",\"func main() { client, err := newClient() if err != nil { panic(err) } for i := range 10 { doc := bytes.NewBufferString(fmt.Sprintf(`{ \\\"name\\\": \\\"%s\\\", \\\"age\\\": %d, \\\"salary\\\": %f }`, randomName(), rand.Intn(18)+18, rand.Float64())) create := client.Create response, err := create(\\\"user\\\", string('0'+i), doc, create.WithPretty()) if err != nil { panic(err) } fmt.Println(response) } } func randomName() string { var b []byte for range 10 { b = append(b, byte(rand.Intn(26)+'a')) } return string(b) }\",\"搜索API就跟平时HTTP API用起来完全一样。\",\"查询所有文档\",\"func main() { client, err := newClient() if err != nil { panic(err) } dsl := bytes.NewBufferString(`{\\\"query\\\": {\\\"match_all\\\":{}}, \\\"size\\\": 1}`) search := client.Search response, err := search(search.WithBody(dsl), search.WithPretty()) if err != nil { panic(err) } fmt.Println(response) }\",\"匹配某一字段\",\"func main() { client, err := newClient() if err != nil { panic(err) } dsl := bytes.NewBufferString(`{\\\"query\\\": {\\\"term\\\":{ \\\"age\\\": 22 } }, \\\"size\\\": 1}`) search := client.Search response, err := search(search.WithBody(dsl), search.WithPretty()) if err != nil { panic(err) } fmt.Println(response) }\"]},\"416\":{\"h\":\"小结\",\"t\":[\"基础操作差不多就是这些，用起来跟HTTP API完全一样，把ES学会了，操作Go API完全没问题，像一些比较高级的操作比如cluster，data stream等之类的API，就请自行探索。\"]},\"417\":{\"c\":[\"golang\"]},\"418\":{\"h\":\"-MongoDB\",\"t\":[\"待定\",\"MongoDB是一个文档数据库，它的基本数据单位就是文档，存储格式是BSON（Binary JSON）一种类似JSON的结构，松散的结构可以存储不同类型的数据，相较于关系数据库更为灵活，并且使用js作为脚本语言，可以通过脚本来完成组合操作。本文主要介绍使用在Go中使用官方的mongo驱动操作mongodb数据库，并不是mongodb教程，如果你没有mongo基础，请先自行了解和学习。\",\"mongodb文档：Introduction to MongoDB — MongoDB Manual\"]},\"419\":{\"h\":\"驱动\",\"t\":[\"mongodb在go这方面的库比较少，早期有些社区维护的库，后面都停止维护了，不过官方的mongo驱动库已经完全足够使用了。\",\"开源仓库：mongodb/mongo-go-driver: The Official Golang driver for MongoDB (github.com)\",\"文档地址：mongodb/mongo-go-driver: The Official Golang driver for MongoDB (github.com)\"]},\"420\":{\"h\":\"安装\",\"t\":[\"下载依赖的话使用下面的地址就行了。\",\"$ go get go.mongodb.org/mongo-driver/mongo\"]},\"421\":{\"h\":\"连接\",\"t\":[\"下面是一个简单的mongo客户端与服务端建立连接的例子。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"go.mongodb.org/mongo-driver/mongo\\\" \\\"go.mongodb.org/mongo-driver/mongo/options\\\" \\\"go.mongodb.org/mongo-driver/mongo/readpref\\\" \\\"log\\\" ) func main() { ctx := context.Background() // 使用URI建立连接 client, err := mongo.Connect(ctx, options.Client().ApplyURI(\\\"mongodb://admin:123456@192.168.48.138:27017/\\\")) if err != nil { log.Panicln(err) } // 关闭连接 defer client.Disconnect(ctx) // ping测试连接是否可用 fmt.Println(client.Ping(ctx, readpref.Primary())) }\"]},\"422\":{\"h\":\"bson\",\"t\":[\"mongodb在go里面使用了以下几种类型来映射数据库中的文档，位于bson/bson.go\",\"// BSON文档的有序表示 type D = primitive.D // 一对键值，BSON文档的有序表示的基本单位 type E = primitive.E // BSON文档的无序表示 type M = primitive.M // BSON数据的有序表示 type A = primitive.A\",\"它们的实际类型如下\",\"// BSON文档的有序表示 type D []E // 一对键值，BSON文档的有序表示的基本单位 type E struct { Key string Value interface{} } // BSON文档的无序表示 type M map[string]interface{} // BSON数据的有序表示 type A []interface{}\",\"通过以上几种类型，即可以构造查询SQL，也可以用来映射数据。\",\"提示\",\"驱动examples目录下有着相当多的使用示例，官方非常详细的演示了如何使用上述四种类型。\",\"地址：mongo-go-driver/examples/documentation_examples/examples.go at master · mongodb/mongo-go-driver (github.com)\"]},\"423\":{\"h\":\"查询文档\",\"t\":[\"官方查询示例：mongo-go-driver/examples/documentation_examples/examples.go at master · mongodb/mongo-go-driver (github.com)\",\"首先创建user数据库，向集合users插入如下数据\",\"> use user > db.users.insertMany([ { name: \\\"mike\\\", age: 12, }, { name: \\\"jenny\\\", age: 14, }, { name: \\\"jack\\\", age: 18, address: \\\"usa\\\" } ])\"]},\"424\":{\"h\":\"查询单个\",\"t\":[\"type User struct { Name string `bson:\\\"name\\\"` Age int `bson:\\\"age\\\"` Address string `bson:\\\"address\\\"` } var user User result := client.Database(\\\"user\\\"). // 选中数据库 Collection(\\\"users\\\"). // 选中集合 FindOne(ctx, bson.D{{\\\"address\\\", \\\"usa\\\"}}) // 过滤条件 // 反序列化 if err := result.Decode(&user); err != nil { log.Panicln(err) } fmt.Printf(\\\"%+v\\\\n\\\", user)\",\"上面那段查询代码等价于\",\"db.users.findOne({ address: \\\"usa\\\" })\",\"输出结果\",\"{Name:jack Age:18 Address:usa}\"]},\"425\":{\"h\":\"查询多个\",\"t\":[\"type User struct { Name string `bson:\\\"name\\\"` Age int `bson:\\\"age\\\"` Address string `bson:\\\"address\\\"` } var users []User cursor, err := client.Database(\\\"user\\\"). // 选中数据库 Collection(\\\"users\\\"). // 选中集合 Find(ctx, bson.D{}) // 过滤条件 if err != nil { log.Panicln(err) } if err := cursor.All(ctx, &users); err != nil { log.Panicln(err) } fmt.Printf(\\\"%+v\\\\n\\\", users)\",\"等价于\",\"db.users.find({})\",\"输出\",\"[{Name:jack Age:18 Address:usa} {Name:mike Age:12 Address:} {Name:jenny Age:14 Address:}]\",\"在构造查询条件的时候，也可以使用options\",\"type User struct { Name string `bson:\\\"name\\\"` Age int `bson:\\\"age\\\"` Address string `bson:\\\"address\\\"` } var users []User find := options.Find() find.SetSort(bson.M{\\\"age\\\": 1}) find.SetLimit(1) cursor, err := client.Database(\\\"user\\\"). // 选中数据库 Collection(\\\"users\\\"). // 选中集合 Find(ctx, bson.D{}, find) // 过滤条件 if err != nil { log.Panicln(err) } if err := cursor.All(ctx, &users); err != nil { log.Panicln(err) } fmt.Printf(\\\"%+v\\\\n\\\", users)\",\"等价于\",\"db.users.find({}).sort({age:1}).limit(1)\",\"输出\",\"[{Name:mike Age:12 Address:}]\"]},\"426\":{\"h\":\"创建文档\",\"t\":[\"官方创建实例：mongo-go-driver/examples/documentation_examples/examples.go at master · mongodb/mongo-go-driver (github.com)\",\"下面是创建一个文档的例子\",\"one, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").InsertOne(ctx, User{ Name: \\\"lili\\\", Age: 20, Address: \\\"china\\\", }) if err != nil { log.Panicln(err) } fmt.Println(one.InsertedID)\",\"创建成功后会返回文档的ObjectID\",\"ObjectID(\\\"64c60fa01e2548d9e4de6cf4\\\")\",\"下面是创建多个文档的例子\",\"users := []any{User{ Name: \\\"john\\\", Age: 10, Address: \\\"usa\\\", }, User{ Name: \\\"pop\\\", Age: 30, Address: \\\"uk\\\", }} one, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").InsertMany(ctx, users) if err != nil { log.Panicln(err) } fmt.Println(one.InsertedIDs)\",\"创建成功后返回返回一组ObjectID\",\"[ObjectID(\\\"64c610d5aec2618d6ca0b515\\\") ObjectID(\\\"64c610d5aec2618d6ca0b516\\\")]\",\"上面两段代码就等价于db.users.insertOne和db.users.insertMany。\"]},\"427\":{\"h\":\"更新文档\",\"t\":[\"官方更新示例：mongo-go-driver/examples/documentation_examples/examples.go at master · mongodb/mongo-go-driver (github.com)\",\"下面是更新单个文档的示例，将名为lili人更名为mark\",\"upres, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").UpdateOne(ctx, bson.D{ {\\\"name\\\", \\\"mark\\\"}, }, bson.D{ {\\\"$set\\\", bson.D{ {\\\"name\\\", \\\"lili\\\"}, }}, }) if err != nil { log.Panicln(err) } fmt.Printf(\\\"%+v\\\", upres)\",\"等价于\",\"db.users.updateOne({ name: \\\"lili\\\" }, { $set: { name: \\\"mark\\\" }, })\",\"输出\",\"&{MatchedCount:1 ModifiedCount:1 UpsertedCount:0 UpsertedID:<nil>}\",\"下面是更新多个文档的示例，将年龄为10的人地址更新为cn\",\"upres, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").UpdateMany(ctx, bson.D{ {\\\"age\\\", 10}, }, bson.D{ {\\\"$set\\\", bson.D{ {\\\"address\\\", \\\"cn\\\"}, }}, }) if err != nil { log.Panicln(err) } fmt.Printf(\\\"%+v\\\", upres)\",\"除了使用Update，mongo还提供了Replace，两者的区别在于前者是更新文档字段，后者是直接替换文档。例如下面的代码，就不再需要操作符了。\",\"upres, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").ReplaceOne(ctx, bson.D{ {\\\"age\\\", 10}, }, bson.D{ {\\\"address\\\", \\\"cn\\\"}, }) if err != nil { log.Panicln(err) } fmt.Printf(\\\"%+v\\\", upres)\",\"同时mongo还提供了FindOneAndUpdate和FindOneAndReplace来获取文档和更新文档。如下\",\"res := client.Database(\\\"user\\\").Collection(\\\"users\\\").FindOneAndReplace(ctx, bson.D{ {\\\"address\\\", \\\"cn\\\"}, }, bson.D{ {\\\"address\\\", \\\"uk\\\"}, }) if err := res.Err(); err != nil { log.Panicln(err) } var user User res.Decode(&user) fmt.Printf(\\\"%+v\\\", user)\",\"输出\",\"Name: Age:0 Address:cn}\",\"此操作会先查询文档再进行修改文档。\"]},\"428\":{\"h\":\"删除文档\",\"t\":[\"官方删除示例：mongo-go-driver/examples/documentation_examples/examples.go at master · mongodb/mongo-go-driver (github.com)\",\"下面是删除一个文档的例子\",\"result, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").DeleteOne(ctx, bson.D{ {\\\"name\\\", \\\"jack\\\"}, }) if err != nil { log.Panicln(err) } fmt.Println(result.DeletedCount)\",\"下面是删除多个文档的例子\",\"result, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").DeleteMany(ctx, bson.D{ {\\\"age\\\", \\\"10\\\"}, }) if err != nil { log.Panicln(err) } fmt.Println(result.DeletedCount)\"]},\"429\":{\"h\":\"聚合\",\"t\":[\"官方聚合示例：mongo-go-driver/examples/documentation_examples/examples.go at master · mongodb/mongo-go-driver (github.com)\",\"聚合操作会用到mongo.Pipeline类型，它的本质是[]bson.D\",\"type Pipeline []bson.D\",\"pipline := mongo.Pipeline{ { {\\\"$match\\\", bson.D{ {\\\"address\\\", \\\"uk\\\"}, }}, }, { {\\\"$sort\\\", bson.D{ {\\\"age\\\", 1}, }}, }, } aggregate, err := client.Database(\\\"user\\\").Collection(\\\"users\\\").Aggregate(ctx, pipline) if err != nil { log.Panicln(err) } var users []User if err := aggregate.All(ctx, &users); err != nil { log.Panicln(err) } log.Println(users)\",\"输出\",\"[{lili 20 uk} {kak 30 uk}]\",\"这段聚合操作就是匹配所有address为uk的用户，然后按照年龄排序。\"]},\"430\":{\"c\":[\"db\"]},\"431\":{\"h\":\"-MySQL\",\"t\":[\"待定\",\"Mysql是当下最流行的开源关系型数据库，具体的sql知识这里不会做过多的赘述，如果你不会请先自行学习，本文只是简单讲解如何利用go进行sql操作。在项目中的话一般不会直接使用驱动来进行数据库操作，而是会使用ORM框架，这里使用的是sqlx库，是对标准sql库的增强，没有ORM功能那么丰富但是胜在简洁。如果你想使用ORM，可以去了解Gorm，Xorm，Ent这些库。\"]},\"432\":{\"h\":\"依赖\",\"t\":[\"下载sqlx库\",\"$ go get github.com/jmoiron/sqlx\",\"sqlx或者说标准库database/sql支持的数据库不止MySQL，任何实现了driver.Driver接口的类型都支持，比如：\",\"PostgreSQL\",\"Oracle\",\"MariaDB\",\"SQLite\",\"等其他关系数据库\",\"要使用对应的数据库，就需要实现数据库驱动，驱动可以是你自己写的，也可以是第三方库，在使用之前你就要先使用sql.Register注册驱动，然后才能使用。不过一般下载的驱动库都会自动注册驱动，不需要你来手动注册。\",\"func Register(name string, driver driver.Driver)\",\"由于MySQL比较流行，也最为简单，所以本文采用MySQL来讲解，其他关系数据库操作起来都是大差不大差的，下载MySQL驱动库\",\"$ go get github.com/go-sql-driver/mysql\"]},\"433\":{\"h\":\"连接到数据库\",\"t\":[\"通过sqlx.Open函数，就可以打开一个数据库连接，它接受两个参数，第一个是驱动名称，第二个就是数据源（一般简称DSN）。\",\"func Open(driverName, dataSourceName string) (*DB, error)\",\"驱动名称就是注册驱动时使用的名称，需要保持一致，DSN就是数据库的连接地址，每种数据库都可能会不一样，对于MySQL而言就是下面这样\",\"db,err := sqlx.Open(\\\"mysql\\\",\\\"root:123456@tcp(127.0.0.1:3306)/test\\\")\"]},\"434\":{\"h\":\"准备数据\",\"t\":[\"SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for user -- ---------------------------- DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `age` tinyint(0) NULL DEFAULT NULL, `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of user -- ---------------------------- INSERT INTO `user` VALUES ('12132', '张三', 35, '北京市'); INSERT INTO `user` VALUES ('16162', '王五', 22, '上海市'); SET FOREIGN_KEY_CHECKS = 1;\"]},\"435\":{\"h\":\"查询\",\"t\":[\"查询，并将结果映射到结构体中\",\"var db *sqlx.DB type Person struct { UserId string `db:\\\"id\\\"` Username string `db:\\\"name\\\"` Age int `db:\\\"age\\\"` Address string `db:\\\"address\\\"` } func init() { conn, err := sqlx.Open(\\\"mysql\\\", \\\"root:wyh246859@tcp(127.0.0.1:3306)/test\\\") if err != nil { fmt.Println(\\\"Open mysql failed\\\", err) return } db = conn } func main() { query() defer db.Close() } func query() { var person Person //查询一个是Get，多个是Select err := db.Get(&person, \\\"select * from user where id = ?\\\", \\\"12132\\\") if err != nil { fmt.Println(\\\"query failed:\\\", err) return } fmt.Printf(\\\"query succ:%+v\\\", person) } func list() { var perons []Person err := db.Select(&perons, \\\"select * from user\\\") if err != nil { fmt.Println(\\\"list err\\\", err) return } fmt.Printf(\\\"list succ,%+v\\\", perons) }\"]},\"436\":{\"h\":\"新增\",\"t\":[\"新增数据\",\"func insert() { result, err := db.Exec(\\\"insert into user value (?,?,?,?)\\\", \\\"120230\\\", \\\"李四\\\", 12, \\\"广州市\\\") if err != nil { fmt.Println(\\\"insert err:\\\", err) return } id, err := result.LastInsertId() if err != nil { fmt.Println(\\\"insert err:\\\", err) return } fmt.Println(\\\"insert succ:\\\", id) }\"]},\"437\":{\"h\":\"更新\",\"t\":[\"更新数据\",\"func update() { res, err := db.Exec(\\\"update user set name = ? where id = ?\\\", \\\"赵六\\\", \\\"120230\\\") if err != nil { fmt.Println(\\\"update err:\\\", err) return } eff, err := res.RowsAffected() if err != nil || eff == 0 { fmt.Println(\\\"update err:\\\", err) return } fmt.Println(\\\"Update succ\\\") }\"]},\"438\":{\"h\":\"删除\",\"t\":[\"删除数据\",\"func delete() { res, err := db.Exec(\\\"delete from user where id = ?\\\", \\\"120230\\\") if err != nil { fmt.Println(\\\"delete err:\\\", err) return } eff, err := res.RowsAffected() if err != nil || eff == 0 { fmt.Println(\\\"delete err:\\\", err) return } fmt.Println(\\\"delete succ\\\") }\"]},\"439\":{\"h\":\"事务\",\"t\":[\"func (db *DB) Begin() (*Tx, error) //开始一个事务 func (tx *Tx) Commit() error //提交一个事务 func (tx *Tx) Rollback() error //回滚一个事务\",\"当开启一个事务后，为了保险都会加一句defer tx.Rollback()，如果如果过程出错了，就会回滚，要是事务成功提交了，这个回滚自然是无效的。\",\"func main() { transation, err := db.Begin() if err != nil { fmt.Println(\\\"transation err\\\") } defer transation.Rollback() insert() query() update() query() delete() transation.Commit() }\"]},\"440\":{\"c\":[\"db\"]},\"441\":{\"h\":\"-Redis\",\"t\":[\"待定\",\"Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API，Redis即可以当作一个NoSQL数据库，又可以是当作高速缓存存储，还支持简单的消息队列。\",\"本文仅仅讲解如何使用Go语言驱动来操作Redis数据库，不会对Redis本身做任何讲解。\",\"官方文档：Golang Redis client (uptrace.dev)\",\"官方仓库：go-redis/redis: Type-safe Redis client for Golang (github.com)\"]},\"442\":{\"h\":\"安装\",\"t\":[\"关于Redis的驱动有很多，本文使用的是github.com/go-redis/redis。\",\"如果你使用的Redis版本号为6\",\"go get github.com/go-redis/redis/v8\",\"如果你使用的Redis版本号为7\",\"go get github.com/go-redis/redis/v9\"]},\"443\":{\"h\":\"快速开始\",\"t\":[\"import ( \\\"fmt\\\" \\\"log\\\" \\\"testing\\\" \\\"github.com/go-redis/redis\\\" ) func TestQuickStart(t *testing.T) { // 创建Redis连接客户端 redisClient := redis.NewClient(&redis.Options{ Addr: \\\"192.168.48.134:6379\\\", Password: \\\"123456\\\", DB: 0, // 使用默认DB }) // 设置键值对，0就是永不过期 redisClient.Set(\\\"hello\\\", \\\"world\\\", 0) // 读取值 result, err := redisClient.Get(\\\"hello\\\").Result() if err == redis.Nil { fmt.Println(\\\"ket not exist\\\") } else if err != nil { log.Panic(err) } fmt.Println(result) }\"]},\"444\":{\"h\":\"连接配置\",\"t\":[\"type Options struct { // 网络类型 tcp 或者 unix. // 默认是 tcp. Network string // redis地址，格式 host:port Addr string // Dialer 创建一个新的网络连接且比Network和Addr有着更高的优先级 // Network and Addr options. Dialer func() (net.Conn, error) // 新建一个redis连接的时候，会回调这个函数 OnConnect func(*Conn) error // redis密码，redis server没有设置可以为空。 Password string // redis数据库，序号从0开始，默认是0，可以不用设置 DB int // redis操作失败最大重试次数，默认0。 MaxRetries int // 最小重试时间间隔. // 默认是 8ms ; -1 表示关闭. MinRetryBackoff time.Duration // 最大重试时间间隔 // 默认是 512ms; -1 表示关闭. MaxRetryBackoff time.Duration // redis新连接超时时间. // 默认是 5 秒. DialTimeout time.Duration // socket读取超时时间 // 默认 3 秒. ReadTimeout time.Duration // socket写超时时间 WriteTimeout time.Duration // redis连接池的最大连接数. // 默认连接池大小等于 cpu个数 * 10 PoolSize int // redis连接池最小空闲连接数. MinIdleConns int // redis连接最大的存活时间，默认不会关闭过时的连接. MaxConnAge time.Duration // 当你从redis连接池获取一个连接之后，连接池最多等待这个拿出去的连接多长时间。 // 默认是等待 ReadTimeout + 1 秒. PoolTimeout time.Duration // redis连接池多久会关闭一个空闲连接. // 默认是 5 分钟. -1 则表示关闭这个配置项 IdleTimeout time.Duration // 多长时间检测一下，空闲连接 // 默认是 1 分钟. -1 表示关闭空闲连接检测 IdleCheckFrequency time.Duration // 只读设置，如果设置为true， 在当前节点实例上，redis只能查询缓存不能更新。 readOnly bool // TLS配置 TLSConfig *tls.Config }\"]},\"445\":{\"h\":\"建立连接\",\"t\":[\"// 创建Redis连接客户端 redisClient := redis.NewClient(&redis.Options{ Addr: \\\"192.168.48.134:6379\\\", Password: \\\"123456\\\", DB: 0, // 使用默认DB })\"]},\"446\":{\"h\":\"关闭连接\",\"t\":[\"驱动内部维护着一个连接池，不需要操作一次就关闭一次连接。\",\"defer redisClient.Close()\",\"这个Redis驱动几乎将所有的操作封装好了，Redis命令和方法名一一对应，基本上只要知道Redis命令怎么用，驱动对应的方法都也差不多会了。\",\"Redis命令：redis 命令手册\"]},\"447\":{\"h\":\"基本操作\"},\"448\":{\"h\":\"删除键\",\"t\":[\"redisClient.Set(\\\"name\\\", \\\"jack\\\", 0) fmt.Println(redisClient.Del(\\\"name\\\").Result())\"]},\"449\":{\"h\":\"过期时间\",\"t\":[\"redisClient.Set(\\\"name\\\", \\\"jack\\\", 0) // 设置过期时间 redisClient.Expire(\\\"name\\\", time.Second*2) fmt.Println(redisClient.Get(\\\"name\\\").Val()) time.Sleep(time.Second * 3) fmt.Println(redisClient.Get(\\\"name\\\").Val())\"]},\"450\":{\"h\":\"取消过期时间\",\"t\":[\"redisClient.Set(\\\"name\\\", \\\"jack\\\", 2) // 取消过期时间 redisClient.Persist(\\\"name\\\") time.Sleep(time.Second * 2) fmt.Println(redisClient.Get(\\\"name\\\"))\"]},\"451\":{\"h\":\"查询过期时间\",\"t\":[\"fmt.Println(redisClient.TTL(\\\"name\\\")) fmt.Println(redisClient.PTTL(\\\"name\\\"))\"]},\"452\":{\"h\":\"重命名\",\"t\":[\"redisClient.Rename(\\\"name\\\", \\\"newName\\\")\"]},\"453\":{\"h\":\"查询类型\",\"t\":[\"redisClient.Type(\\\"name\\\")\"]},\"454\":{\"h\":\"扫描\",\"t\":[\"fmt.Println(redisClient.Scan(0, \\\"\\\", 4))\"]},\"455\":{\"h\":\"字符串\"},\"456\":{\"h\":\"简单存取\",\"t\":[\"redisClient.Set(\\\"token\\\", \\\"abcefghijklmn\\\", 0) fmt.Println(redisClient.Get(\\\"token\\\").Val())\"]},\"457\":{\"h\":\"批量存取\",\"t\":[\"redisClient.MSet(\\\"cookie\\\", \\\"12345\\\", \\\"token\\\", \\\"abcefg\\\") fmt.Println(redisClient.MGet(\\\"cookie\\\", \\\"token\\\").Val())\"]},\"458\":{\"h\":\"数字增减\",\"t\":[\"redisClient.Set(\\\"age\\\", \\\"1\\\", 0) // 自增 redisClient.Incr(\\\"age\\\") fmt.Println(redisClient.Get(\\\"age\\\").Val()) // 自减 redisClient.Decr(\\\"age\\\") fmt.Println(redisClient.Get(\\\"age\\\").Val())\"]},\"459\":{\"h\":\"哈希表\"},\"460\":{\"h\":\"读写操作\",\"t\":[\"// 单个设置 redisClient.HSet(\\\"map\\\", \\\"name\\\", \\\"jack\\\") // 批量设置 redisClient.HMSet(\\\"map\\\", map[string]interface{}{\\\"a\\\": \\\"b\\\", \\\"c\\\": \\\"d\\\", \\\"e\\\": \\\"f\\\"}) // 单个访问 fmt.Println(redisClient.HGet(\\\"map\\\", \\\"a\\\").Val()) // 批量访问 fmt.Println(redisClient.HMGet(\\\"map\\\", \\\"a\\\", \\\"b\\\").Val()) // 获取整个map fmt.Println(redisClient.HGetAll(\\\"map\\\").Val())\",\"输出\",\"b [b <nil>] map[a:b c:d e:f name:jack]\"]},\"461\":{\"h\":\"删除键\",\"t\":[\"// 删除map的一个字段 redisClient.HDel(\\\"map\\\", \\\"a\\\")\"]},\"462\":{\"h\":\"判断键是否存在\",\"t\":[\"// 判断字段是否存在 redisClient.HExists(\\\"map\\\", \\\"a\\\")\"]},\"463\":{\"h\":\"获取所有的键\",\"t\":[\"// 获取所有的map的键 redisClient.HKeys(\\\"map\\\")\"]},\"464\":{\"h\":\"获取哈希表键长度\",\"t\":[\"// 获取map长度 redisClient.HLen(\\\"map\\\")\"]},\"465\":{\"h\":\"遍历哈希表的键值对\",\"t\":[\"// 遍历map中的键值对 redisClient.HScan(\\\"map\\\", 0, \\\"\\\", 1)\"]},\"466\":{\"h\":\"列表\"},\"467\":{\"h\":\"修改元素\",\"t\":[\"// 左边添加 redisClient.LPush(\\\"list\\\", \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\") // 右边添加 redisClient.RPush(\\\"list\\\", \\\"g\\\", \\\"i\\\", \\\"a\\\") // 在参考值前面插入值 redisClient.LInsertBefore(\\\"list\\\", \\\"a\\\", \\\"aa\\\") // 在参考值后面插入值 redisClient.LInsertAfter(\\\"list\\\", \\\"a\\\", \\\"gg\\\") // 设置指定下标的元素的值 redisClient.LSet(\\\"list\\\", 0, \\\"head\\\")\"]},\"468\":{\"h\":\"访问长度\",\"t\":[\"// 访问列表长度 redisClient.LLen(\\\"list\\\")\"]},\"469\":{\"h\":\"访问元素\",\"t\":[\"// 左边弹出元素 redisClient.LPop(\\\"list\\\") // 右边弹出元素 redisClient.RPop(\\\"list\\\") // 访问指定下标的元素 redisClient.LIndex(\\\"list\\\", 1) // 访问指定范围内的元素 redisClient.LRange(\\\"list\\\", 0, 1)\"]},\"470\":{\"h\":\"删除元素\",\"t\":[\"// 删除指定元素 redisClient.LRem(\\\"list\\\", 0, \\\"a\\\") // 删除指定范围的元素 redisClient.LTrim(\\\"list\\\", 0, 1) // 保留指定范围的元素 redisClient.LTrim(\\\"list\\\", 0, 1)\"]},\"471\":{\"h\":\"集合\"},\"472\":{\"h\":\"新增元素\",\"t\":[\"// 往一个集合里面添加元素 redisClient.SAdd(\\\"set\\\", \\\"a\\\", \\\"b\\\", \\\"c\\\") redisClient.SAdd(\\\"set2\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\")\"]},\"473\":{\"h\":\"访问集合元素\",\"t\":[\"// 获取集合中的所有成员 redisClient.SMembers(\\\"set\\\") // 判断一个元素是否属于这个集合 redisClient.SIsMember(\\\"set\\\", \\\"a\\\") // 随机返回count个元素 redisClient.SRandMemberN(\\\"set\\\", 1) // 获取一个集合的元素个数 redisClient.SCard(\\\"set\\\")\"]},\"474\":{\"h\":\"集合操作\",\"t\":[\"// 返回给定集合的差集 redisClient.SDiff(\\\"set\\\", \\\"set2\\\") // 将给定集合的差集保存在结果集里，返回结果集的长度 redisClient.SDiffStore(\\\"store\\\", \\\"set\\\", \\\"se2\\\") // 返回给定集合的交集 redisClient.SInter(\\\"set\\\", \\\"set2\\\") // 将给定集合的交集保存在结果集里，返回结果集的长度 redisClient.SInterStore(\\\"store\\\", \\\"set\\\", \\\"set2\\\") // 返回给定集合的并集 redisClient.SUnion(\\\"set\\\", \\\"set2\\\") // 将给定集合的并集保存在结果集里，返回结果集的长度 redisClient.SUnionStore(\\\"store\\\", \\\"set\\\", \\\"store\\\")\"]},\"475\":{\"h\":\"删除元素\",\"t\":[\"// 弹出并删除该元素 redisClient.SPop(\\\"set\\\") // 弹出并删除N给元素 redisClient.SPopN(\\\"set\\\", 2)\"]},\"476\":{\"h\":\"移动元素\",\"t\":[\"// 从源集合移动指定元素刀目标集合 redisClient.SMove(\\\"set\\\", \\\"set2\\\", \\\"a\\\")\"]},\"477\":{\"h\":\"删除元素\",\"t\":[\"// 删除指定元素 redisClient.SRem(\\\"set\\\", \\\"a\\\", \\\"b\\\")\"]},\"478\":{\"h\":\"遍历\",\"t\":[\"// 遍历集合 redisClient.SScan(\\\"set\\\", 0, \\\"\\\", 2)\"]},\"479\":{\"h\":\"有序集合\"},\"480\":{\"h\":\"加入元素\",\"t\":[\"// 往有序集合中加入元素 redisClient.ZAdd(\\\"ss\\\", redis.Z{ Score: 1, Member: \\\"a\\\", }, redis.Z{ Score: 2, Member: \\\"b\\\", })\"]},\"481\":{\"h\":\"元素排名\",\"t\":[\"// 返回有序集合中该元素的排名，从低到高排列 redisClient.ZRank(\\\"ss\\\", \\\"1\\\") // 返回有序集合中该元素的排名，从高到低排列 redisClient.ZRevRank(\\\"ss\\\", \\\"1\\\")\"]},\"482\":{\"h\":\"访问元素\",\"t\":[\"// 返回介于min和max之间的成员数量 redisClient.ZCount(\\\"ss\\\", \\\"1\\\", \\\"2\\\") // 返回对元素的权值 redisClient.ZScore(\\\"ss\\\", \\\"a\\\") // 返回指定区间的元素 redisClient.ZRange(\\\"ss\\\", 1, 2) // 返回介于min和max之间的所有成员列表 redisClient.ZRangeByScore(\\\"ss\\\", redis.ZRangeBy{ Min: \\\"1\\\", Max: \\\"2\\\", Offset: 0, Count: 1, })\"]},\"483\":{\"h\":\"修改权值\",\"t\":[\"// 给一个对应的元素增加相应的权值 redisClient.ZIncr(\\\"ss\\\", redis.Z{ Score: 2, Member: \\\"b\\\", })\"]},\"484\":{\"h\":\"删除元素\",\"t\":[\"// 删除指定元素 redisClient.ZRem(\\\"ss\\\", \\\"a\\\") // 删除指定排名区间的元素 redisClient.ZRemRangeByRank(\\\"ss\\\", 1, 2) // 删除权值在min和max区间的元素 redisClient.ZRemRangeByScore(\\\"ss\\\", \\\"1\\\", \\\"2\\\")\"]},\"485\":{\"h\":\"脚本\",\"t\":[\"// 加载脚本，返回sha值 redisClient.ScriptLoad(\\\"return 0\\\") // 根据sha值执行脚本 redisClient.EvalSha(\\\"sha\\\", []string{}, \\\"\\\") // 直接执行脚本 redisClient.Eval(\\\"return 0\\\", []string{}, \\\"\\\") // 清除脚本缓存 redisClient.ScriptFlush() // 杀死当前正在运行的脚本 redisClient.ScriptKill() // 验证对应哈希值的脚本是否存在 redisClient.ScriptExists(\\\"\\\")\"]},\"486\":{\"h\":\"发布订阅\",\"t\":[\"// 发送消息到指定频道 redisClient.Publish(\\\"channel\\\", \\\"message\\\") // 订阅指定频道 redisClient.Subscribe(\\\"channel\\\") // 查看订阅状态 redisClient.PubSubNumSub(\\\"channel\\\")\"]},\"487\":{\"c\":[\"db\"]},\"488\":{\"h\":\"-EMQX\",\"t\":[\"待定\"]},\"489\":{\"c\":[\"mq\"]},\"490\":{\"h\":\"-RocketMQ\",\"t\":[\"待定\"]},\"491\":{\"c\":[\"mq\"]},\"492\":{\"h\":\"-Kafka\",\"t\":[\"待定\"]},\"493\":{\"c\":[\"mq\"]},\"494\":{\"h\":\"-Nginx\",\"t\":[\"待定\"]},\"495\":{\"c\":[\"web\"]},\"496\":{\"h\":\"Docker\",\"t\":[\"待定\"]},\"497\":{\"c\":[\"docker\"]},\"498\":{\"h\":\"kubernetes\",\"t\":[\"待定\"]},\"499\":{\"c\":[\"k8s\"]},\"500\":{\"h\":\"gin使用\"},\"501\":{\"c\":[\"golang\"]},\"502\":{\"h\":\"gin的原理\"},\"503\":{\"c\":[\"golang\"]},\"504\":{\"h\":\"go-zero使用\"},\"505\":{\"c\":[\"golang\"]},\"506\":{\"h\":\"go-zero实现原理\"},\"507\":{\"c\":[\"golang\"]},\"508\":{\"h\":\"简介\",\"t\":[\"Go语言的标准库非常的丰富（数据结构除外），功能也十分强大，API对开发人员而言十分友好，能够熟练运用标准库对日常开发将会有非常大的帮助。比如你可以不用任何外部依赖，仅使用net/http，html/template，database/sql这三个库就可以开发一个独立完整的Web项目。\",\"下面举一些常用的标准库的作用，每一个标准库的包级注释都会详细说明这个包是干什么用的。\",\"fmt，用于处理格式化输入输出的包\",\"html，html模板操作包\",\"net，提供一系列网络操作的包，相当的强大\",\"flag，命令行参数解析包\",\"reflect，反射操作包\",\"log，自带的日志包\",\"sort，排序操作包\",\"regex，正则表达式包\",\"image，图像操作的包\",\"time，时间操作的包\",\"unicode，unicode字符集操作包\",\"unsafe，提供没有类型限制的指针操作\",\"syscall，操作系统提供的系统调用包\",\"testing，测试包，主要是写测试的时候用。\",\"sync ，并发操作包\",\"context，上下文包\",\"strconv，字符串转换包\",\"strings，字符串操作包\",\"bytes，字节切片操作包\",\"maps，map操作包\",\"slices，切片操作包\",\"io，定义了一系列基础的IO接口，例如常用的Closer，Writer等，还有一些基础的IO操作函数。\",\"io/fs，定义了一系列文件系统的接口，算是对文件系统的抽象。\",\"os，操作系统进行交互的包，提供的是一系列具体的函数，可以简单理解为是上面两个的具体实现。\",\"os/signal，操作系统信号包，用于监听操作系统的信号，主要用于实现程序的优雅关闭。\",\"os/exec，操作系统命令包，用于执行操作系统命令。\",\"os/user，操作系统用户包，用于获取操作系统的用户信息。\",\"bufio，有缓冲IO读写包。\",\"path，处理斜杠分隔路径的包，例如url之类的。\",\"path/filepath，处理文件路径的包。\",\"math，数学操作包\",\"math/bits，位运算操作包\",\"math/cmplx，复数操作包，也提供了一些三角函数的工具函数。\",\"math/rand，伪随机包\",\"math/big，大数高精度计算包\",\"container/heap，最小堆的实现\",\"container/list，双线链表的实现\",\"container/ring，环的实现\",\"archive/zip，zip压缩归档的包\",\"archive/tar，tar归档文件的包\",\"compress，压缩算法实现的包，比如gzip，flate。\",\"database/sql，与数据库进行交互的包\",\"encoding，处理编码的包，其下有很多子包，比如json，xml之类的，还有base64这种。\",\"crypto，处理加密的包，其下有很多子包，比如sha1，rsa等\",\"go/ast，go源代码抽象语法树映射的包\",\"go/parser ，将go源代码解析成抽象语法树的包\",\"go/importer，提供了对导入器的访问\",\"go/format，go语言格式化包\",\"areana，提供可手动分配和释放内存的功能，处于实验阶段\",\"runtime，运行时操作包，go中有许多操作都是这个包实现的。\"]},\"509\":{\"h\":\"encode\",\"t\":[\"在当前互联网时代中，最常用的独立于语言的数据格式有xml， Yaml，json，protobuf，Go同样的也支持这些数据格式的相关的操作，以下为对比表格。\",\"名称\",\"XML\",\"YAML\",\"JSON\",\"Protocol Buffers\",\"数据结构\",\"复杂\",\"较简单\",\"简单\",\"较复杂\",\"保存方式\",\"文本\",\"文本\",\"文本\",\"二进制\",\"保存大小\",\"大\",\"中\",\"中\",\"小\",\"解析效率\",\"慢\",\"中\",\"中\",\"快\",\"语言支持\",\"非常多\",\"多\",\"很多\",\"较多\",\"开发难度\",\"繁琐\",\"较简单\",\"简单\",\"简单\",\"学习成本\",\"低\",\"低\",\"低\",\"低\",\"适用范围\",\"数据交换\",\"配置文件\",\"数据交换\",\"数据交换\",\"提示\",\"在go中，如果想要对结构体进行序列化与反序列化，字段必须是对外暴露的，即首字母大写。\",\"另外，TOML也逐渐开始流行，语法上像是.ini的改进，感兴趣可以前往TOML：Tom 的（语义）明显、（配置）最小化的语言了解一下。\"]},\"510\":{\"h\":\"XML\",\"t\":[\"xml又名eXtensible Markup Language，是用于存储数据的一种格式，起源于20世纪60年代，是以上几种数据格式中最为古老的一种。它的用途十分广泛，可用于网络传输，数据交换，配置文件，数据存储等等。但随着时代的更替，逐渐正在被新的标记语言替代。\",\"首先定义结构体\",\"type Person struct { UserId string `xml:\\\"id\\\"` Username string `xml:\\\"name\\\"` Age int `xml:\\\"age\\\"` Address string `xml:\\\"address\\\"` }\",\"func Marshal(v any) ([]byte, error) //xml序列化 func MarshalIndent(v any, prefix, indent string) ([]byte, error) //格式化 func Unmarshal(data []byte, v any) error //反序列化\"]},\"511\":{\"h\":\"序列化\",\"t\":[\"func main() { person := Person{ UserId: \\\"120\\\", Username: \\\"jack\\\", Age: 18, Address: \\\"usa\\\", } bytes, err := xml.MarshalIndent(person, \\\"\\\", \\\"\\\\t\\\") if err != nil { fmt.Println(err) return } fmt.Println(string(bytes)) }\",\"输出\",\"<Person> <id>120</id> <name>jack</name> <age>18</age> <address>usa</address> </Person>\"]},\"512\":{\"h\":\"反序列化\",\"t\":[\"func main() { var person = Person{ UserId: \\\"\\\", Username: \\\"\\\", Age: 0, Address: \\\"\\\", } xmlStr := \\\"<Person> \\\\n <id>120</id> \\\\n <name>jack</name> \\\\n <age>18</age> \\\\n <address>usa</address>\\\\n</Person> \\\" err := xml.Unmarshal([]byte(xmlStr), &person) if err != nil { fmt.Println(err) return } }\",\"输出\",\"{UserId:120 Username:jack Age:18 Address:usa}\",\"不过传统的xml解析方式经常需要新建结构体，这会十分的繁琐，现在解析的都是简单的xml结构，倘若使用复杂的结构，就会让人十分头疼。所以我们大多数会用一个第三方开源库etree来解析xml，感兴趣的可以自行了解：Go比较好用的解析xml文件的插件etree - 掘金 (juejin.cn)。\"]},\"513\":{\"h\":\"YML\",\"t\":[\"YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件，YML也在许多项目里以配置文件的形式存在，它的内容结构更加简洁，一目了然。go官方并没有提供对于YML的支持，我们需要使用第三方包。\",\"go get github.com/go-yaml/yaml\",\"主要方法\",\"func Marshal(in interface{}) (out []byte, err error) //序列化 func Unmarshal(in []byte, out interface{}) (err error) //反序列化\",\"先准备结构体\",\"type Config struct { Database string `yaml:\\\"database\\\"` Url string `yaml:\\\"url\\\"` Port int `yaml:\\\"port\\\"` Username string `yaml:\\\"username\\\"` Password string `yaml:\\\"password\\\"` }\",\"配置文件\",\"database: mysql url: 127.0.0.1 port: 3306 username: root password: 123456\"]},\"514\":{\"h\":\"序列化\",\"t\":[\"func main() { config := Config{ Database: \\\"oracle\\\", Url: \\\"localhost\\\", Port: 3326, Username: \\\"root\\\", Password: \\\"123456\\\", } out, err := yaml.Marshal(config) if err != nil { fmt.Println(err) return } fmt.Println(string(out)) }\",\"输出\",\"database: oracle url: localhost port: 3326 username: root password: \\\"123456\\\"\",\"不过由于yml本身有着严格的缩进语法，所以也不存在什么序列化格式化的问题了。\"]},\"515\":{\"h\":\"反序列化\",\"t\":[\"func main() { bytes, err := os.ReadFile(\\\"./src/config.yml\\\") if err != nil { fmt.Println(err) return } var config Config err = yaml.Unmarshal(bytes, &config) if err != nil { fmt.Println(err) return } fmt.Println(config) }\",\"输出\",\"{mysql 127.0.0.1 3306 root 123456}\"]},\"516\":{\"h\":\"JSON\",\"t\":[\"json在Restful风格的接口通信中经常会用到，其相较于xml更轻便的大小，低廉的学习成本使其在web领域称为了主流的数据交换格式。\",\"在go中，encoding/json包下提供对应的函数来进行json的序列化与反序列化，主要使用的有如下函数。\",\"func Marshal(v any) ([]byte, error) //将go对象序列化为json字符串 func Unmarshal(data []byte, v any) error //将json字符串反序列化为go对象\",\"首先定义结构体\",\"type Person struct { UserId string Username string Age int Address string }\"]},\"517\":{\"h\":\"序列化\",\"t\":[\"func main() { person := Person{ UserId: \\\"120\\\", Username: \\\"jack\\\", Age: 18, Address: \\\"usa\\\", } bytes, err := json.Marshal(person) if err != nil { fmt.Println(err) return } fmt.Println(string(bytes)) }\",\"结果\",\"{\\\"UserId\\\":\\\"120\\\",\\\"Username\\\":\\\"jack\\\",\\\"Age\\\":18,\\\"Address\\\":\\\"usa\\\"}\"]},\"518\":{\"h\":\"字段重命名\",\"t\":[\"我们可以通过结构体标签来达到重命名的效果。\",\"type Person struct { UserId string `json:\\\"id\\\"` Username string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` Address string `json:\\\"address\\\"` }\",\"此时输出\",\"{\\\"id\\\":\\\"1202\\\",\\\"name\\\":\\\"jack\\\",\\\"age\\\":19,\\\"address\\\":\\\"USA\\\"}\"]},\"519\":{\"h\":\"缩进\",\"t\":[\"序列化时默认是没有任何缩进的，这是为了减少传输过程的空间损耗，但是这并不利于人为观察，在一些情况下我们需要将其序列化成人类能够观察的形式。为此，只需要换一个函数。\",\"func MarshalIndent(v any, prefix, indent string) ([]byte, error)\",\"func main() { person := Person{ UserId: \\\"1202\\\", Username: \\\"jack\\\", Age: 19, Address: \\\"USA\\\", } bytes, err := json.MarshalIndent(person, \\\"\\\", \\\"\\\\t\\\") if err != nil { fmt.Println(err) return } fmt.Println(string(bytes)) }\",\"输出如下\",\"{ \\\"id\\\": \\\"1202\\\", \\\"name\\\": \\\"jack\\\", \\\"age\\\": 19, \\\"address\\\": \\\"USA\\\" }\"]},\"520\":{\"h\":\"反序列化\",\"t\":[\"在反序列化时需要注意，如果结构体有json标签的话，则字段名优先以json标签为准，否则以结构体属性名为准。\",\"func main() { person := Person{} jsonStr := \\\"{\\\\\\\"id\\\\\\\":\\\\\\\"120\\\\\\\",\\\\\\\"name\\\\\\\":\\\\\\\"jack\\\\\\\",\\\\\\\"age\\\\\\\":18,\\\\\\\"address\\\\\\\":\\\\\\\"usa\\\\\\\"}\\\\n\\\" err := json.Unmarshal([]byte(jsonStr), &person) if err != nil { fmt.Println(err) return } fmt.Printf(\\\"%+v\\\", person) }\",\"输出\",\"{UserId:120 Username:jack Age:18 Address:usa}\"]},\"521\":{\"h\":\"Protocol Buffers\",\"t\":[\"protocol是谷歌2008开源的语言中立，协议中立，可扩展的结构化数据序列化机制。相比于以上三种更加的轻便，而且在解包封包的时候更加的快速，多用于RPC领域通信相关，有关Protobuf的讲解可以前往Protobuf。\",\"安装依赖\",\"go get github.com/golang/protobuf/proto\",\"person.proto文件\",\"syntax = \\\"proto3\\\"; option go_package = \\\"./;person\\\"; package proto; enum Gender{ MAIL = 0; FE_MAIL = 1; } message person { string name = 1; int32 age = 2; Gender gender = 3; }\",\"生成文件后\",\"package main import ( p \\\"GoProject/src/proto\\\" \\\"fmt\\\" \\\"github.com/golang/protobuf/proto\\\" ) func main() { person := p.Person{ Name: \\\"wyh\\\", Age: 12, Gender: p.Gender_FE_MAIL, } data, err := proto.Marshal(&person)//序列化 if err != nil { fmt.Println(err) return } temp := &p.Person{} fmt.Println(\\\"proto buffer len: \\\", len(data), \\\"bytes:\\\", data) err = proto.Unmarshal(data, temp)//反序列化 if err != nil { fmt.Println(err) return } fmt.Println(temp) }\",\"输出\",\"proto buffer len: 9 bytes: [10 3 119 121 104 16 12 24 1] name:\\\"wyh\\\" age:12 gender:FE_MAIL\",\"不过通常我们不会去手动序列化，protoc编译器可以根据我们定义好的proto文件生成对应语言的源代码。\"]},\"522\":{\"h\":\"flag\",\"t\":[\"Go语言内置的Flag包实现了命令行参数的解析，Flag包使得开发命令行工具更加简单。\"]},\"523\":{\"h\":\"导入\",\"t\":[\"import flag\"]},\"524\":{\"h\":\"类型\",\"t\":[\"其支持的类型有:\",\"bool\",\"int\",\"int64\",\"uint\",\"uint64\",\"float\",\"float64\",\"string\",\"duration\"]},\"525\":{\"h\":\"定义\",\"t\":[\"使用flag.Type()来定义，返回值是指针\",\"name := flag.String(\\\"name\\\", \\\"张三\\\", \\\"姓名\\\") age := flag.Int(\\\"age\\\", 15, \\\"年龄\\\") sex := flag.Bool(\\\"sex\\\", true, \\\"性别\\\")\",\"也可以使用flag.TypeVar()来定义\",\"var name string var age int var sex bool flag.StringVar(&name, \\\"name\\\", \\\"张三\\\", \\\"姓名\\\") flag.IntVar(&age, \\\"age\\\", 15, \\\"年龄\\\") flag.BoolVar(&sex, \\\"sex\\\", true, \\\"性别\\\")\"]},\"526\":{\"h\":\"解析\",\"t\":[\"通过调用flag.Parse()来解析参数，支持的命令行参数格式有如下几种:\",\"-flag xxx\",\"--flag xxx\",\"-flag=xxx\",\"--flag=xxx\",\"布尔类型的参数必须使用等号，Flag解析会在第一个非命令行参数之前停止。\"]},\"527\":{\"h\":\"其他\",\"t\":[\"func Args() []string //返回所有非命令参数 func NArg() int //返回非命令行参数的个数 func NFlag() int //返回命令行参数的个数\"]},\"528\":{\"h\":\"示例\",\"t\":[\"var name string var age int var sex bool flag.StringVar(&name, \\\"name\\\", \\\"张三\\\", \\\"姓名\\\") flag.IntVar(&age, \\\"age\\\", 15, \\\"年龄\\\") flag.BoolVar(&sex, \\\"sex\\\", true, \\\"性别\\\") flag.Parse() fmt.Println(name, age, sex)\",\"编译后在命令行启动程序\",\"PS D:\\\\WorkSpace\\\\Code\\\\GoProject\\\\bin> .\\\\go_build_GoProject_src_main.exe 张三 15 true PS D:\\\\WorkSpace\\\\Code\\\\GoProject\\\\bin> .\\\\go_build_GoProject_src_main.exe -h Usage of D:\\\\WorkSpace\\\\Code\\\\GoProject\\\\bin\\\\go_build_GoProject_src_main.exe: -age int 年龄 (default 15) -name string 姓名 (default \\\"张三\\\") -sex 性别 (default true) PS D:\\\\WorkSpace\\\\Code\\\\GoProject\\\\bin> .\\\\go_build_GoProject_src_main.exe -age 15 -name \\\"李四\\\" -sex=false 李四 15 false PS D:\\\\WorkSpace\\\\Code\\\\GoProject\\\\bin>\"]},\"529\":{\"h\":\"http\",\"t\":[\"Go语言标准库中的net/http包十分的优秀，提供了非常完善的HTTP客户端与服务端的实现，仅通过几行代码就可以搭建一个非常简单的HTTP服务器。\",\"几乎所有的go语言中的web框架，都是对已有的http包做的封装与修改，因此，十分建议学习其他框架前先行掌握http包。\"]},\"530\":{\"h\":\"Get示例\",\"t\":[\"关于Http相关的知识这里不再赘述，想要了解更多的话可以去百度。\",\"func main() { resp, err := http.Get(\\\"https://baidu.com\\\") if err != nil { fmt.Println(err) return } defer resp.Body.Close() content, err := io.ReadAll(resp.Body) fmt.Println(string(content)) }\",\"通过直接调用Http包下的函数就可以发起简单的请求，会返回一个指针与错误，调用过后必须将其手动关闭。\"]},\"531\":{\"h\":\"Post示例\",\"t\":[\"func main() { person := Person{ UserId: \\\"120\\\", Username: \\\"jack\\\", Age: 18, Address: \\\"usa\\\", } json, _ := json.Marshal(person) reader := bytes.NewReader(json) resp, err := http.Post(\\\"https://golang.org\\\", \\\"application/json;charset=utf-8\\\", reader) if err != nil { fmt.Println(err) } defer resp.Body.Close() }\"]},\"532\":{\"h\":\"客户端\",\"t\":[\"一般情况下，我们都不会直接使用上述的方法，而且会自己配置一个客户端来达到更加细致化的需求。这将会用到http.Client{}结构体，可提供的配置项总共有四个:\",\"Transport:配置Http客户端数据传输相关的配置项，没有就采用默认的策略\",\"Timeout：请求超时时间配置\",\"Jar：Cookie相关配置\",\"CheckRedirect：重定向配置\"]},\"533\":{\"h\":\"\",\"t\":[\"func main() { client := &http.Client{} request, _ := http.NewRequest(\\\"GET\\\", \\\"https://golang.org\\\", nil) resp, _ := client.Do(request) defer resp.Body.Close() }\"]},\"534\":{\"h\":\"\",\"t\":[\"func main() { client := &http.Client{} request, _ := http.NewRequest(\\\"GET\\\", \\\"https://golang.org\\\", nil) request.Header.Add(\\\"Authorization\\\",\\\"123456\\\") resp, _ := client.Do(request) defer resp.Body.Close() }\",\"一些详细的配置这里不会做过多的赘述，还请自行了解。\"]},\"535\":{\"h\":\"服务端\",\"t\":[\"对于go而言，创建一个http服务器只需要一行代码。\",\"第一个参数是监听的地址，第二个参数是处理器，如果为空的话则使用默认的处理器。大多数情况下使用默认的处理器DefaultServeMux即可。\",\"http.ListenAndServe(\\\"localhost:8080\\\", nil)\"]},\"536\":{\"h\":\"\",\"t\":[\"当然也可以自定义配置一个服务端\",\"func main() { server := &http.Server{ Addr: \\\":8080\\\", Handler: nil, TLSConfig: nil, ReadTimeout: 0, ReadHeaderTimeout: 0, WriteTimeout: 0, IdleTimeout: 0, MaxHeaderBytes: 0, TLSNextProto: nil, ConnState: nil, ErrorLog: nil, BaseContext: nil, ConnContext: nil, } server.ListenAndServe() }\",\"一些详细的配置请自行了解。\"]},\"537\":{\"h\":\"\",\"t\":[\"首先需要首先自定义一个结构体实现Handler接口中的ServeHTTP(ResponseWriter, *Request)方法，再调用http.handle()函数即可\",\"func main() { http.Handle(\\\"/index\\\", &MyHandler{}) http.ListenAndServe(\\\":8080\\\", nil) } type MyHandler struct { } func (h *MyHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) { fmt.Println(\\\"my implement\\\") }\",\"但是每一次都要自定义一个结构体将会十分的繁琐，也可以直接http.handlerFunc函数，我们只需要写处理函数即可，从而不用创建结构体。其内部是使用了适配器类型HandlerFunc,HandlerFunc类型是一个适配器，允许将普通函数用作HTTP的处理器。如果f是具有适当签名的函数，HandlerFunc(f)是调用f的Handler。\",\"func main() { http.HandleFunc(\\\"/index\\\", func(responseWriter http.ResponseWriter, request *http.Request) { fmt.Println(responseWriter, \\\"index\\\") }) http.ListenAndServe(\\\":8080\\\", nil) }\",\"ServerMux是核心结构体，实现了基本的方法，DefaultServeMux是的默认实例。\"]},\"538\":{\"h\":\"\",\"t\":[\"http包提供了开箱即用的反向代理功能\",\"func main() { http.HandleFunc(\\\"/forward\\\", func(writer http.ResponseWriter, request *http.Request) { director := func(request *http.Request) { request.URL.Scheme = \\\"https\\\" request.URL.Host = \\\"golang.org\\\" request.URL.Path = \\\"index\\\" } proxy := httputil.ReverseProxy{Director: director} proxy.ServeHTTP(writer, request) }) http.ListenAndServe(\\\":8080\\\", nil) }\",\"上述代码会将所有请求转发到https://golang.org/index。\"]},\"539\":{\"h\":\"log\",\"t\":[\"Go语言标准库log包实现了简单的日志。\",\"func main() { log.Println(\\\"日志\\\") log.Panicln(\\\"panic日志\\\") log.Fatalln(\\\"错误日志\\\") }\",\"Fatal会在写入日志信息后调用os.exit(1)，panic则会抛出panic\"]},\"540\":{\"h\":\"前缀\",\"t\":[\"func (l *Logger) Prefix() string //获取前缀 func (l *Logger) SetPrefix(prefix string) //设置前缀\",\"例子\",\"func main() { log.SetPrefix(\\\"[main]\\\") log.Println(\\\"日志\\\") log.Panicln(\\\"panic日志\\\") }\"]},\"541\":{\"h\":\"Flag\",\"t\":[\"方法\",\"func (l *Logger) Flags() int //访问 func (l *Logger) SetFlags(flag int) //设置\",\"常量\",\"const ( Ldate = 1 << iota // 日期 Ltime // 时间 Lmicroseconds // 微秒 Llongfile // 完成文件名称 Lshortfile // 短文件名称 LUTC // 时区 Lmsgprefix // 前缀 LstdFlags = Ldate | Ltime // 初始值 )\",\"例子\",\"func main() { log.SetFlags(log.Lshortfile | log.Lmicroseconds | log.Lmsgprefix | log.Ldate | log.Ltime) log.Println(\\\"日志\\\") log.Panicln(\\\"panic日志\\\") }\",\"当然也可以使用log.SetOutput(w io.Writer)来设置日志的输出路径，也可以通过New方法创建自己的实例。\",\"func New(out io.Writer, prefix string, flag int) *Logger\",\"总而言之，标准库的log包提供的功能并不够完善，我们通常会使用更加完善的第三方日志包，例如zap等等。\"]},\"542\":{\"h\":\"math\",\"t\":[\"math是Go中的基本数学操作库，也是必须要熟练掌握和使用的库。\"]},\"543\":{\"h\":\"整数常量\",\"t\":[\"const ( intSize = 32 << (^uint(0) >> 63) // 32 or 64 MaxInt = 1<<(intSize-1) - 1 MinInt = -1 << (intSize - 1) MaxInt8 = 1<<7 - 1 MinInt8 = -1 << 7 MaxInt16 = 1<<15 - 1 MinInt16 = -1 << 15 MaxInt32 = 1<<31 - 1 MinInt32 = -1 << 31 MaxInt64 = 1<<63 - 1 MinInt64 = -1 << 63 MaxUint = 1<<intSize - 1 MaxUint8 = 1<<8 - 1 MaxUint16 = 1<<16 - 1 MaxUint32 = 1<<32 - 1 MaxUint64 = 1<<64 - 1 )\"]},\"544\":{\"h\":\"浮点常量\",\"t\":[\"const ( MaxFloat32 = 0x1p127 * (1 + (1 - 0x1p-23)) // 3.40282346638528859811704183484516925440e+38 SmallestNonzeroFloat32 = 0x1p-126 * 0x1p-23 // 1.401298464324817070923729583289916131280e-45 MaxFloat64 = 0x1p1023 * (1 + (1 - 0x1p-52)) // 1.79769313486231570814527423731704356798070e+308 SmallestNonzeroFloat64 = 0x1p-1022 * 0x1p-52 // 4.9406564584124654417656879286822137236505980e-324 )\"]},\"545\":{\"h\":\"数学常量\",\"t\":[\"const ( E = 2.71828182845904523536028747135266249775724709369995957496696763 // https://oeis.org/A001113 Pi = 3.14159265358979323846264338327950288419716939937510582097494459 // https://oeis.org/A000796 Phi = 1.61803398874989484820458683436563811772030917980576286213544862 // https://oeis.org/A001622 Sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974 // https://oeis.org/A002193 SqrtE = 1.64872127070012814684865078781416357165377610071014801157507931 // https://oeis.org/A019774 SqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779 // https://oeis.org/A002161 SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // https://oeis.org/A139339 Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009 // https://oeis.org/A002162 Log2E = 1 / Ln2 Ln10 = 2.30258509299404568401799145468436420760110148862877297603332790 // https://oeis.org/A002392 Log10E = 1 / Ln10 )\"]},\"546\":{\"h\":\"最大值\",\"t\":[\"func TestMax(t *testing.T) { fmt.Println(math.Max(1.0, 2.0)) }\",\"=== RUN TestMax 2 --- PASS: TestMax (0.00s) PASS\"]},\"547\":{\"h\":\"最小值\",\"t\":[\"func TestMin(t *testing.T) { fmt.Println(math.Min(1.0, 2.0)) }\",\"=== RUN TestMin 1 --- PASS: TestMin (0.00s) PASS\"]},\"548\":{\"h\":\"绝对值\",\"t\":[\"func TestAbs(t *testing.T) { fmt.Println(math.Abs(-1)) }\",\"=== RUN TestAbs 1 --- PASS: TestAbs (0.00s) PASS\"]},\"549\":{\"h\":\"余数\",\"t\":[\"func TestMod(t *testing.T) { fmt.Println(math.Mod(1, 10)) fmt.Println(math.Mod(12, 10)) }\",\"=== RUN TestMod 1 2 --- PASS: TestMod (0.00s) PASS\"]},\"550\":{\"h\":\"Nan检测\",\"t\":[\"func TestName(t *testing.T) { fmt.Println(math.IsNaN(math.NaN())) }\",\"=== RUN TestFloor 2 --- PASS: TestFloor (0.00s) PASS\"]},\"551\":{\"h\":\"Inf检测\",\"t\":[\"func TestInf(t *testing.T) { fmt.Println(math.IsInf(1.0, 1)) fmt.Println(math.IsInf(math.Inf(-1), -1)) }\",\"=== RUN TestInf false true --- PASS: TestInf (0.00s) PASS\"]},\"552\":{\"h\":\"取整\",\"t\":[\"func TestTrunc(t *testing.T) { fmt.Println(math.Trunc(1.26)) fmt.Println(math.Trunc(2.3333)) }\",\"=== RUN TestTrunc 1 2 --- PASS: TestTrunc (0.00s) PASS\"]},\"553\":{\"h\":\"向下取整\",\"t\":[\"func TestFloor(t *testing.T) { fmt.Println(math.Floor(2.5)) }\",\"=== RUN TestFloor 2 --- PASS: TestFloor (0.00s) PASS\"]},\"554\":{\"h\":\"向上取整\",\"t\":[\"func TestCeil(t *testing.T) { fmt.Println(math.Ceil(2.5)) }\",\"=== RUN TestCeil 3 --- PASS: TestCeil (0.00s) PASS\"]},\"555\":{\"h\":\"四舍五入\",\"t\":[\"func TestRound(t *testing.T) { fmt.Println(math.Round(1.2389)) fmt.Println(math.Round(-5.2389)) }\",\"=== RUN TestRound 1 -5 --- PASS: TestRound (0.00s) PASS\"]},\"556\":{\"h\":\"求对数\",\"t\":[\"func TestLog(t *testing.T) { fmt.Println(math.Log(100) / math.Log(10)) fmt.Println(math.Log(1) / math.Log(2)) }\",\"=== RUN TestLog 2 0 --- PASS: TestLog (0.00s) PASS\"]},\"557\":{\"h\":\"E的指数\",\"t\":[\"func TestEx(t *testing.T) { fmt.Println(math.Exp(2)) }\",\"=== RUN TestEx 7.38905609893065 --- PASS: TestEx (0.00s) PASS\"]},\"558\":{\"h\":\"幂\",\"t\":[\"func TestPow(t *testing.T) { fmt.Println(math.Pow(2, 3)) fmt.Println(math.Pow(3, 3)) }\",\"=== RUN TestPow 8 27 --- PASS: TestPow (0.00s) PASS\"]},\"559\":{\"h\":\"平方根\",\"t\":[\"func TestSqrt(t *testing.T) { fmt.Println(math.Sqrt(4)) }\",\"=== RUN TestSqrt 2 --- PASS: TestSqrt (0.00s) PASS\"]},\"560\":{\"h\":\"立方根\",\"t\":[\"func TestCube(t *testing.T) { fmt.Println(math.Cbrt(8)) fmt.Println(math.Cbrt(27)) }\",\"=== RUN TestCube 2 3 --- PASS: TestCube (0.00s) PASS\"]},\"561\":{\"h\":\"开N方\",\"t\":[\"func TestN(t *testing.T) { fmt.Println(math.Round(math.Pow(8, 1.0/3))) fmt.Println(math.Round(math.Pow(100, 1.0/2))) }\",\"=== RUN TestN 2 10 --- PASS: TestN (0.00s) PASS\"]},\"562\":{\"h\":\"Sin\",\"t\":[\"func TestSin(t *testing.T) { fmt.Println(math.Sin(0)) fmt.Println(math.Sin(20)) }\",\"=== RUN TestSin 0 0.9129452507276277 --- PASS: TestSin (0.00s) PASS\"]},\"563\":{\"h\":\"Cos\",\"t\":[\"func TestCos(t *testing.T) { fmt.Println(math.Cos(0)) fmt.Println(math.Cos(20)) }\",\"=== RUN TestCos 1 0.40808206181339196 --- PASS: TestCos (0.00s) PASS\"]},\"564\":{\"h\":\"Tan\",\"t\":[\"func TestTan(t *testing.T) { fmt.Println(math.Tan(0)) fmt.Println(math.Tan(20)) }\",\"=== RUN TestTan 0 2.2371609442247427 --- PASS: TestTan (0.00s) PASS\",\"提示\",\"math包下远不止以上函数，不过已经足够满足日常使用，如需深究，可以自行阅读源码。\"]},\"565\":{\"h\":\"net\",\"t\":[\"Go语言的net标准库是一个非常强大的库，它提供了处理网络通信、IP地址、DNS解析、TCP/UDP协议、HTTP协议等常见任务的功能。由于Go语言本身的并发特性，得益于此，Go在处理网络IO的时候非常的简洁高效。\"]},\"566\":{\"h\":\"地址解析\",\"t\":[\"Go提供了四个函数来解析网络地址，下面逐一讲解。\"]},\"567\":{\"h\":\"MAC地址\",\"t\":[\"签名\",\"func ParseMAC(s string) (hw HardwareAddr, err error)\",\"示例\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { hw, err := net.ParseMAC(\\\"00:1A:2B:3C:4D:5E\\\") if err != nil { panic(err) } fmt.Println(hw) }\"]},\"568\":{\"h\":\"CIDR\",\"t\":[\"签名\",\"func ParseCIDR(s string) (IP, *IPNet, error)\",\"示例\",\"package main import ( \\\"fmt\\\" \\\"log\\\" \\\"net\\\" ) func main() { ipv4Addr, ipv4Net, err := net.ParseCIDR(\\\"192.0.2.1/24\\\") if err != nil { log.Fatal(err) } fmt.Println(ipv4Addr) fmt.Println(ipv4Net) }\"]},\"569\":{\"h\":\"IP地址\",\"t\":[\"IP地址支持解析ipv4，ipv6，函数签名如下\",\"func ResolveIPAddr(network, address string) (*IPAddr, error)\",\"使用示例如下\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { ipv4Addr, err := net.ResolveIPAddr(\\\"ip4\\\", \\\"192.168.2.1\\\") if err != nil { panic(err) } fmt.Println(ipv4Addr) ipv6Addr, err := net.ResolveIPAddr(\\\"ip6\\\", \\\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\\") if err != nil { panic(err) } fmt.Println(ipv6Addr) }\"]},\"570\":{\"h\":\"TCP地址\",\"t\":[\"TCP地址支持tcp4，tcp6，签名如下\",\"func ResolveTCPAddr(network, address string) (*TCPAddr, error)\",\"使用示例如下\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { tcp4Addr, err := net.ResolveTCPAddr(\\\"tcp4\\\", \\\"0.0.0.0:2020\\\") if err != nil { panic(err) } fmt.Println(tcp4Addr) tcp6Addr, err := net.ResolveTCPAddr(\\\"tcp6\\\", \\\"[::1]:8080\\\") if err != nil { panic(err) } fmt.Println(tcp6Addr) }\"]},\"571\":{\"h\":\"UDP地址\",\"t\":[\"UDP地址支持udp4，udp6，签名如下\",\"func ResolveUDPAddr(network, address string) (*UDPAddr, error)\",\"使用示例如下\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { udp4Addr, err := net.ResolveUDPAddr(\\\"udp4\\\", \\\"0.0.0.0:2020\\\") if err != nil { panic(err) } fmt.Println(udp4Addr) udp6Addr, err := net.ResolveUDPAddr(\\\"udp6\\\", \\\"[::1]:8080\\\") if err != nil { panic(err) } fmt.Println(udp6Addr) }\"]},\"572\":{\"h\":\"Unix地址\",\"t\":[\"Unix地址支持unix，unixgram，unixpacket，签名如下\",\"func ResolveUnixAddr(network, address string) (*UnixAddr, error)\",\"使用示例如下\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { unixAddr, err := net.ResolveUnixAddr(\\\"unix\\\", \\\"/tmp/mysocket\\\") if err != nil { panic(err) } fmt.Println(unixAddr) }\"]},\"573\":{\"h\":\"DNS\",\"t\":[\"Go还提供了很多函数用于DNS查询，下面一个例子是解析域名的IP地址\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { addrs, err := net.LookupHost(\\\"github.com\\\") if err != nil { panic(err) } fmt.Println(addrs) }\",\"查询记录值\",\"package main import ( \\\"fmt\\\" \\\"net\\\" ) func main() { mxs, err := net.LookupMX(\\\"github.com\\\") if err != nil { panic(err) } fmt.Println(mxs) }\"]},\"574\":{\"h\":\"网络编程\",\"t\":[\"tcp编程的逻辑十分简单，对于客户端而言就是\",\"建立连接\",\"发送数据或读取数据\",\"退出\",\"对于服务端而言就是\",\"监听地址\",\"获取连接\",\"新建一个协程去处理该连接\",\"下面是一个简单的例子，客户端代码\",\"package main import ( \\\"net\\\" ) func main() { // 建立连接 conn, err := net.Dial(\\\"tcp\\\", \\\"0.0.0.0:1234\\\") if err != nil { panic(err) } defer conn.Close() // 发送数据 for i := range 10 { _, err := conn.Write([]byte{'a' + byte(i)}) if err != nil { panic(err) } } }\",\"服务端代码\",\"package main import ( \\\"errors\\\" \\\"fmt\\\" \\\"io\\\" \\\"net\\\" \\\"sync\\\" ) func main() { // 监听地址 listener, err := net.Listen(\\\"tcp\\\", \\\"0.0.0.0:1234\\\") if err != nil { panic(err) } defer listener.Close() var wg sync.WaitGroup for { // 阻塞等待下一个连接建立 conn, err := listener.Accept() if err != nil { panic(err) } // 开启一个新的协程去异步处理该连接 wg.Add(1) go func() { defer wg.Done() buf := make([]byte, 4096) for { // 从连接中读取数据 n, err := conn.Read(buf) if errors.Is(err, io.EOF) { break } else if err != nil { panic(err) } data := string(buf[:n]) fmt.Println(data) } }() } wg.Wait() }\",\"客户端发送数据，服务端接收数据，这个例子非常的简单，服务端建立新连接时，只需开启一个新的协程就可以去处理，不需要阻塞，UDP大体上的写法也都是类似的。\"]},\"575\":{\"h\":\"sort\",\"t\":[\"提示\",\"如果你是1.21版本以上的开发者，我建议使用slices标准库来进行排序，它支持泛型，API设计更加合理。\",\"在go中的sort包下提供了官方实现的排序方法，大部分可以直接开箱即用。倘若想要对结构体进行排序的话必须实现sort.Interface下的三个方法Len()swap()Less()。由于官方已经帮我们实现了Float64SliceStringSliceIntSlice三个类型，所以这三个类型可以不用我们自己实现直接使用即可。\",\"type Interface interface { // 长度方法 Len() int // 比较方法 Less(i, j int) bool // 交换方法 Swap(i, j int) }\"]},\"576\":{\"h\":\"整型排序\",\"t\":[\"func main() { ints := []int{1, 2, 3, 111, 5, 99, 23, 5, 66} sort.Ints(ints) }\"]},\"577\":{\"h\":\"浮点排序\",\"t\":[\"func main() { floats := []float64{1.0, 2.5, 3.8, 1.11, 5.5, 99.99999, 23.9999, 5.66, 66} sort.Float64s(floats) fmt.Println(floats) }\"]},\"578\":{\"h\":\"字符串排序\",\"t\":[\"func main() { strings := []string{\\\"helloworld\\\", \\\"aaa\\\", \\\"bbb\\\", \\\"ccc\\\"} sort.Strings(strings) }\"]},\"579\":{\"h\":\"逆向排序\",\"t\":[\"需要先进行sort.Reverse包装再进行排序\",\"func main() { floats := []float64{1.0, 2.5, 3.8, 1.11, 5.5, 99.99999, 23.9999, 5.66, 66} sort.Sort(sort.Reverse(sort.Float64Slice(floats))) fmt.Println(floats) }\"]},\"580\":{\"h\":\"自定义排序\",\"t\":[\"如果想要自定义结构体排序的话，就必须实现三个方法。\",\"type Person struct { UserId string Username string Age int Address string } type PersonSlice []Person //返回切片的长度 func (p PersonSlice) Len() int { return len(p) } //比较方法 func (p PersonSlice) Less(i, j int) bool { return p[i].Age < p[j].Age } //交换方法 func (p PersonSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\",\"由于是根据年龄比较的，所有结果是根据年龄的大小来排序。\",\"func main() { persons := []Person{{ UserId: \\\"1\\\", Username: \\\"wyh\\\", Age: 18, Address: \\\"us\\\", }, { UserId: \\\"2\\\", Username: \\\"jack\\\", Age: 17, Address: \\\"ch\\\", }, { UserId: \\\"3\\\", Username: \\\"mike\\\", Age: 15, Address: \\\"india\\\", }} sort.Sort(PersonSlice(persons)) fmt.Println(persons) }\"]},\"581\":{\"h\":\"是否有序\",\"t\":[\"判断一个切片是否有序，其内部并不会进行排序操作，而是通过循环调用Less()来判断\",\"func main() { persons := []Person{{ UserId: \\\"1\\\", Username: \\\"wyh\\\", Age: 18, Address: \\\"us\\\", }, { UserId: \\\"2\\\", Username: \\\"jack\\\", Age: 17, Address: \\\"ch\\\", }, { UserId: \\\"3\\\", Username: \\\"mike\\\", Age: 15, Address: \\\"india\\\", }} sort.Sort(PersonSlice(persons)) println(sort.IsSorted(PersonSlice(persons))) }\"]},\"582\":{\"h\":\"strconv\",\"t\":[\"官方文档：strconv package - strconv - Go Packages\",\"包 strconv 实现与基本数据类型的字符串表示形式之间的转换\"]},\"583\":{\"h\":\"导入\",\"t\":[\"import ( \\\"strconv\\\" )\",\"下面将会以例子的形式演示如何使用。\"]},\"584\":{\"h\":\"字符串转整型\",\"t\":[\"func Atoi(s string) (int, error)\",\"s - 要转换的字符串\",\"func TestAoti(t *testing.T) { ints, err := strconv.Atoi(\\\"456789\\\") fmt.Println(ints, err) }\",\"=== RUN TestAoti 456789 <nil> --- PASS: TestAoti (0.00s) PASS\"]},\"585\":{\"h\":\"整型转字符串\",\"t\":[\"func Itoa(i int) string\",\"i - 要转换的整型数字\",\"func TestIota(t *testing.T) { str := strconv.Itoa(114) fmt.Println(str) }\",\"=== RUN TestIota 114 --- PASS: TestIota (0.00s) PASS\"]},\"586\":{\"h\":\"字符串转布尔值\",\"t\":[\"func ParseBool(str string) (bool, error)\",\"s - 要转换的字符串\",\"够转换的字符串如下\",\"\\\"1\\\", \\\"t\\\", \\\"T\\\", \\\"true\\\", \\\"TRUE\\\", \\\"True\\\" // true \\\"0\\\", \\\"f\\\", \\\"F\\\", \\\"false\\\", \\\"FALSE\\\", \\\"False\\\" // false\",\"func TestAtob(t *testing.T) { parseBool, err := strconv.ParseBool(\\\"1\\\") fmt.Println(parseBool, err) b, err := strconv.ParseBool(\\\"true\\\") fmt.Println(b, err) b2, err := strconv.ParseBool(\\\"FALSE\\\") fmt.Println(b2, err) }\",\"=== RUN TestAotb true <nil> true <nil> false <nil> --- PASS: TestAotb (0.00s) PASS\"]},\"587\":{\"h\":\"布尔值转字符串\",\"t\":[\"func FormatBool(b bool) string\",\"b - 布尔值\",\"func TestBota(t *testing.T) { fmt.Println(strconv.FormatBool(true)) fmt.Println(strconv.FormatBool(false)) }\",\"=== RUN TestBota true false --- PASS: TestBota (0.00s) PASS\"]},\"588\":{\"h\":\"转换成Go字符串\",\"t\":[\"两者都会将字符串转换为带引号的Go字符串，区别在于后者会将非ASCII字符转通过\\\\u转义。\",\"func TestQuote(t *testing.T) { fmt.Println(strconv.Quote(\\\"hello 世界\\\")) fmt.Println(strconv.QuoteToASCII(\\\"hello 世界\\\")) }\",\"=== RUN TestQuote \\\"hello 世界\\\" \\\"hello \\\\u4e16\\\\u754c\\\" --- PASS: TestQuote (0.00s) PASS\"]},\"589\":{\"h\":\"字符串转浮点数\",\"t\":[\"func ParseFloat(s string, bitSize int) (float64, error)\",\"s - 要转换的字符串\",\"bitSize - 位数\",\"func TestParseFloat(t *testing.T) { float, err := strconv.ParseFloat(\\\"1.145114\\\", 64) fmt.Println(float, err) float, err = strconv.ParseFloat(\\\"2.3333333333333333333\\\", 64) fmt.Println(float, err) }\",\"=== RUN TestFloat 1.145114 <nil> 2.3333333333333335 <nil> --- PASS: TestFloat (0.00s) PASS\"]},\"590\":{\"h\":\"浮点数转字符串\",\"t\":[\"字符串在转换浮点数时，官方给出了几种格式方法，以便输出不同的样式。\",\"// 'b' (-ddddp±ddd, 二进制指数), // 'e' (-d.dddde±dd, 小写e十进制指数), // 'E' (-d.ddddE±dd, 大写E的十进制指数), // 'f' (-ddd.dddd, 没有指数), // 没有特殊需求一般都用这个 // 'g' (对于大指数采用'e'的格式， 小指数采用'f'的格式), // 'G' (对于大指数采用'e'的格式， 小指数采用'f'的格式)， // 'x' (-0xd.ddddp±ddd, 十六进制分数和二进制指数), // 'X' (-0Xd.ddddP±ddd, 十六进制分数和二进制指数).\",\"转换函数\",\"func FormatFloat(f float64, fmt byte, prec, bitSize int) string\",\"f - 指要转换的浮点数\",\"fmt - 指的是格式化类型\",\"prec - 指的是精度，除了g/G的情况是表示最大有效位数，其他情况都表示的是保留小数到后几位，\",\"bitzise - 指的是位数\",\"当然一般情况都是使用f直接转换小数的格式最多。\",\"func TestFormatFloat(t *testing.T) { f := 1315643.14159261234567891011 fmt.Println(strconv.FormatFloat(f, 'f', 6, 64)) fmt.Println(strconv.FormatFloat(f, 'b', 6, 64)) fmt.Println(strconv.FormatFloat(f, 'e', 6, 64)) fmt.Println(strconv.FormatFloat(f, 'x', 6, 64)) fmt.Println(strconv.FormatFloat(f, 'g', 6, 64)) fmt.Println(strconv.FormatFloat(1.111, 'g', 6, 64)) }\",\"=== RUN TestFormatFloat 1315643.141593 5650644266346967p-32 1.315643e+06 0x1.4133b2p+20 1.31564e+06 1.111 --- PASS: TestFormatFloat (0.00s) PASS\"]},\"591\":{\"h\":\"字符串转复数\",\"t\":[\"func ParseComplex(s string, bitSize int) (complex128, error)\",\"s - 要转换的字符串\",\"bitSize - 位数\",\"func TestParseComplex(t *testing.T) { fmt.Println(strconv.ParseComplex(\\\"1+2i\\\", 128)) fmt.Println(strconv.ParseComplex(\\\"1+2j\\\", 128)) }\",\"=== RUN TestParseComplex (1+2i) <nil> (0+0i) strconv.ParseComplex: parsing \\\"1+2j\\\": invalid syntax --- PASS: TestParseComplex (0.00s) PASS\"]},\"592\":{\"h\":\"复数转字符串\",\"t\":[\"func FormatComplex(c complex128, fmt byte, prec, bitSize int) string\",\"c- 复数\",\"fmt - 格式化类型，参考浮点数格式化类型\",\"prec - 参考浮点数精度\",\"bitsize - 位数\",\"func TestFormatComplex(t *testing.T) { fmt.Println(strconv.FormatComplex(complex(1.1, 12), 'f', 2, 128)) fmt.Println(strconv.FormatComplex(complex(5.6, 2.8), 'b', 2, 128)) fmt.Println(strconv.FormatComplex(complex(18.88999, 89.7), 'g', 2, 128)) }\",\"=== RUN TestFormatComplex (1.10+12.00i) (6305039478318694p-50+6305039478318694p-51i) (19+90i) --- PASS: TestFormatComplex (0.00s) PASS\"]},\"593\":{\"h\":\"字符串追加数据\",\"t\":[\"在其他语言比如java中\\\"1\\\"+1的结果是\\\"11\\\"，java会自动完成类型转换，而在Go语言中这样的操作是不被允许的，因为两者的数据类型不同。所以需要用到strconv下的Append函数 ，具体的参数与上面对于的数据转换函数一致。\",\"func TestAppend(t *testing.T) { bytes := []byte(\\\"这里有一些数据:\\\") bytes = strconv.AppendInt(bytes, 10, 10) bytes = strconv.AppendFloat(bytes, 1.2222, 'f', 2, 64) bytes = strconv.AppendBool(bytes, false) fmt.Println(string(bytes)) }\",\"=== RUN TestAppend 这里有一些数据:101.22false --- PASS: TestAppend (0.00s) PASS\"]},\"594\":{\"h\":\"strings\",\"t\":[\"包 strings实现了简单的函数来操作UTF-8编码的字符串，简单来说就是操作字符串的工具包。\",\"官方文档：strings package - strings - Go Packages\",\"提示\",\"Go天然支持UTF8字符，所有的字符串操作都是建立在UTF8的基础之上。\"]},\"595\":{\"h\":\"导入\",\"t\":[\"import ( \\\"strings\\\" )\",\"下面将以示例的形式讲解常用的函数。\"]},\"596\":{\"h\":\"复制字符串\",\"t\":[\"func Clone(s string) string\",\"将会分配一个新的内存给复制的副本，如果传入一个空字符串，则不会分配内存且返回空字符串。\",\"func TestClone(t *testing.T) { ori := \\\"hello 世界\\\" copys := strings.Clone(ori) fmt.Println(ori, copys) fmt.Println(&ori, &copys) }\",\"=== RUN TestClone hello 世界 hello 世界 0xc00005e5d0 0xc00005e5e0 --- PASS: TestClone (0.00s) PASS\"]},\"597\":{\"h\":\"比较字符串\",\"t\":[\"func Compare(a, b string) int\",\"将a与b按照字典顺序进行字符串比较，如果a>b，返回1，a<b返回-1，a=b返回0。\",\"func TestCompare(t *testing.T) { fmt.Println(strings.Compare(\\\"abc\\\", \\\"abe\\\")) fmt.Println(strings.Compare(\\\"abcd\\\", \\\"abe\\\")) fmt.Println(strings.Compare(\\\"abijk\\\", \\\"abe\\\")) fmt.Println(strings.Compare(\\\"abe\\\", \\\"abe\\\")) }\",\"=== RUN TestCompare -1 -1 1 0 --- PASS: TestCompare (0.00s) PASS\"]},\"598\":{\"h\":\"包含字符串\",\"t\":[\"func Contains(s, substr string) bool\",\"判断一个字符串s是不是包含一个子串substr\",\"func TestContains(t *testing.T) { fmt.Println(strings.Contains(\\\"abcdefg\\\", \\\"a\\\")) fmt.Println(strings.Contains(\\\"abcdefg\\\", \\\"abc\\\")) fmt.Println(strings.Contains(\\\"abcdefg\\\", \\\"ba\\\")) }\",\"=== RUN TestContains true true false --- PASS: TestContains (0.00s) PASS\",\"func ContainsAny(s, chars string) bool\",\"判断字符串chars内任意字符的unicode码是否在字符串s内，翻译一下就是s是否包含chars内的任意字符串\",\"func TestContainsAny(t *testing.T) { fmt.Println(strings.ContainsAny(\\\"abcedfg\\\", \\\"bac\\\")) fmt.Println(strings.ContainsAny(\\\"abcedfg\\\", \\\"gfdecba\\\")) }\",\"=== RUN TestContainsAny true --- PASS: TestContainsAny (0.00s) PASS\",\"func ContainsRune(s string, r rune) bool\",\"判断字符串s内是否包含字符r\",\"func TestContainsRune(t *testing.T) { fmt.Println(strings.ContainsRune(\\\"abcedf\\\", 'a')) fmt.Println(strings.ContainsRune(\\\"abcedf\\\", 'b')) fmt.Println(strings.ContainsRune(\\\"你好世界\\\", '你')) }\",\"=== RUN TestContainsRune true true true --- PASS: TestContainsRune (0.00s) PASS\"]},\"599\":{\"h\":\"子串出现次数\",\"t\":[\"func Count(s, substr string) int\",\"给出子串substr在字符串s内的出现次数\",\"func TestCount(t *testing.T) { fmt.Println(strings.Count(\\\"3.1415926\\\", \\\"1\\\")) fmt.Println(strings.Count(\\\"there is a girl\\\", \\\"e\\\")) fmt.Println(strings.Count(\\\"there is a girl\\\", \\\"\\\")) }\",\"=== RUN TestCount 2 2 16 --- PASS: TestCount (0.00s) PASS\"]},\"600\":{\"h\":\"删除指定子串\",\"t\":[\"func Cut(s, sep string) (before, after string, found bool)\",\"删除在s内第一次出现的子串sep，并返回删除后的结果\",\"before - 被删除子串位置前面的字符串\",\"after - 被删除子串位置后面的字符串\",\"found - 是否找到子串\",\"func TestCut(t *testing.T) { show := func(s, sep string) { before, after, found := strings.Cut(s, sep) fmt.Printf(\\\"Cut(%q, %q) = %q, %q, %v\\\\n\\\", s, sep, before, after, found) } show(\\\"Hello world\\\", \\\" \\\") show(\\\"Hello world\\\", \\\"world\\\") show(\\\"Hello world\\\", \\\"Hello\\\") show(\\\"Hello world\\\", \\\"Hello world\\\") }\",\"=== RUN TestCut Cut(\\\"Hello world\\\", \\\" \\\") = \\\"Hello\\\", \\\"world\\\", true Cut(\\\"Hello world\\\", \\\"world\\\") = \\\"Hello \\\", \\\"\\\", true Cut(\\\"Hello world\\\", \\\"Hello\\\") = \\\"\\\", \\\" world\\\", true Cut(\\\"Hello world\\\", \\\"Hello world\\\") = \\\"\\\", \\\"\\\", true --- PASS: TestCut (0.00s) PASS\"]},\"601\":{\"h\":\"忽略大小写相等\",\"t\":[\"func EqualFold(s, t string) bool\",\"返回字符串s和t在忽略大小写情况下是否相等\",\"func TestEqualFold(t *testing.T) { fmt.Println(strings.EqualFold(\\\"你好\\\", \\\"你好\\\")) fmt.Println(strings.EqualFold(\\\"Hello\\\", \\\"Hello\\\")) fmt.Println(strings.EqualFold(\\\"Hello\\\", \\\"hELLO\\\")) }\",\"=== RUN TestEqualFold true true true --- PASS: TestEqualFold (0.00s) PASS\"]},\"602\":{\"h\":\"分割字符串\",\"t\":[\"func Fields(s string) []string\",\"func FieldsFunc(s string, f func(rune) bool) []string\",\"前者是根据空格来分割字符串，后者是函数f的返回值来决定是否分割字符串。\",\"func TestField(t *testing.T) { fmt.Printf(\\\"%q\\\\n\\\", strings.Fields(\\\" a b c d e f g \\\")) fmt.Printf(\\\"%q\\\\n\\\", strings.FieldsFunc(\\\"a,b,c,d,e,f,g\\\", func(r rune) bool { return r == ',' })) }\",\"=== RUN TestField [\\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\" \\\"e\\\" \\\"f\\\" \\\"g\\\"] [\\\"a\\\" \\\"b\\\" \\\"c\\\" \\\"d\\\" \\\"e\\\" \\\"f\\\" \\\"g\\\"] --- PASS: TestField (0.00s) PASS\"]},\"603\":{\"h\":\"寻找前后缀\",\"t\":[\"func HasPrefix(s, prefix string) bool\",\"func HasSuffix(s, suffix string) bool\",\"前者是寻找前缀，后者是寻找后缀，感兴趣可以去看看这里的源码实现，比较巧妙。\",\"func TestPreSuffix(t *testing.T) { str := \\\"abbc cbba\\\" fmt.Println(strings.HasPrefix(str, \\\"abb\\\")) fmt.Println(strings.HasSuffix(str, \\\"bba\\\")) }\",\"=== RUN TestPreSuffix true true --- PASS: TestPreSuffix (0.00s) PASS\"]},\"604\":{\"h\":\"子串的位置\",\"t\":[\"返回第一次出现的子串的下标\",\"func Index(s, substr string) int\",\"返回第一次出现的子串的下标\",\"func IndexAny(s, chars string) int\",\"返回第一次出现的子串的下标\",\"func IndexRune(s string, r rune) int\",\"示例\",\"func TestIndex(t *testing.T) { fmt.Println(strings.Index(\\\"abcdefg\\\", \\\"bc\\\")) fmt.Println(strings.IndexAny(\\\"abcdefg\\\", \\\"cb\\\")) fmt.Println(strings.IndexRune(\\\"abcdefg\\\", 'g')) }\",\"=== RUN TestIndex 1 1 6 --- PASS: TestIndex (0.00s) PASS\",\"返回最后一次出现的子串的下标\",\"func LastIndex(s, substr string) int\",\"返回最后一次出现的子串任意字符的下标\",\"func LastIndexAny(s, chars string) int\",\"示例\",\"func TestLastIndex(t *testing.T) { fmt.Println(strings.LastIndex(\\\"abcdefga\\\", \\\"a\\\")) fmt.Println(strings.LastIndexAny(\\\"abcdefghisa\\\", \\\"ba\\\")) }\"]},\"605\":{\"h\":\"遍历替换字符串\",\"t\":[\"Map 返回字符串 s 的副本，并根据映射函数修改字符串 s 的所有字符。如果映射返回负值，则从字符串中删除该字符，不进行替换\",\"func Map(mapping func(rune) rune, s string) string\",\"示例\",\"func TestMap(t *testing.T) { fmt.Println(strings.Map(func(r rune) rune { return r - 32 }, \\\"abcdefghijk\\\")) fmt.Println(strings.Map(func(r rune) rune { return r + 32 }, \\\"ABCDEFGHIJK\\\")) fmt.Println(strings.Map(func(r rune) rune { if r < 'F' { return -1 } else { return r } }, \\\"ABCDEFGHIJK\\\")) }\",\"输出\",\"=== RUN TestMap ABCDEFGHIJK abcdefghijk FGHIJK --- PASS: TestMap (0.00s) PASS\"]},\"606\":{\"h\":\"重复复制字符串\",\"t\":[\"根据给定的Count复制字符串，如果为负数会导致panic\",\"func Repeat(s string, count int) string\",\"示例\",\"func TestRepeat(t *testing.T) { fmt.Println(strings.Repeat(\\\"a\\\", 10)) fmt.Println(strings.Repeat(\\\"abc\\\", 10)) }\",\"输出\",\"=== RUN TestRepeat aaaaaaaaaa abcabcabcabcabcabcabcabcabcabc --- PASS: TestRepeat (0.00s) PASS\"]},\"607\":{\"h\":\"替换字符串\",\"t\":[\"s为源字符串，old指要被替换的部分，new指old的替换部分，n指的是替换次数，n小于0时表示不限制替换次数。\",\"func Replace(s, old, new string, n int) string\",\"示例\",\"func TestReplace(t *testing.T) { fmt.Println(strings.Replace(\\\"Hello this is golang\\\", \\\"golang\\\", \\\"c++\\\", 1)) fmt.Println(strings.Replace(\\\"Hello this is golang\\\", \\\"o\\\", \\\"c\\\", -1)) fmt.Println(strings.Replace(\\\"Hello this is golang\\\", \\\"o\\\", \\\"c\\\", 1)) }\",\"输出\",\"=== RUN TestReplace Hello this is c++ Hellc this is gclang Hellc this is golang --- PASS: TestReplace (0.00s) PASS\",\"Replace的方便函数，等价于stings.Replace(s,old,new,-1)\",\"func ReplaceAll(s, old, new string) string\",\"示例\",\"func TestReplaceAll(t *testing.T) { fmt.Println(strings.ReplaceAll(\\\"Hello this is golang\\\", \\\"o\\\", \\\"c++\\\")) }\",\"输出\",\"=== RUN TestReplaceAll Hellc++ this is gc++lang --- PASS: TestReplaceAll (0.00s) PASS\"]},\"608\":{\"h\":\"分隔字符串\",\"t\":[\"根据子串sep将字符串s分隔成一个字符串切片\",\"func Split(s, sep string) []string\",\"根据子串sep将字符串s分隔成一个字符串切片，其分隔次数由n决定\",\"func SplitN(s, sep string, n int) []string\",\"根据子串sep将字符串s分隔成包含sep的字符串元素组成的字符串切片\",\"func SplitAfter(s, sep string) []string\",\"根据子串sep将字符串s分隔成包含sep的字符串元素组成的字符串切片，其分隔次数由n决定\",\"func SplitAfterN(s, sep string, n int) []string\",\"示例\",\"func TestSplit(t *testing.T) { fmt.Printf(\\\"%q\\\\n\\\", strings.Split(\\\"this is go language\\\", \\\" \\\")) fmt.Printf(\\\"%q\\\\n\\\", strings.SplitN(\\\"this is go language\\\", \\\" \\\", 2)) fmt.Printf(\\\"%q\\\\n\\\", strings.SplitAfter(\\\"this is go language\\\", \\\" \\\")) fmt.Printf(\\\"%q\\\\n\\\", strings.SplitAfterN(\\\"this is go language\\\", \\\" \\\", 2)) }\",\"输出\",\"=== RUN TestSplit [\\\"this\\\" \\\"is\\\" \\\"go\\\" \\\"language\\\"] [\\\"this\\\" \\\"is go language\\\"] [\\\"this \\\" \\\"is \\\" \\\"go \\\" \\\"language\\\"] [\\\"this \\\" \\\"is go language\\\"] --- PASS: TestSplit (0.00s) PASS\"]},\"609\":{\"h\":\"大小写转换\",\"t\":[\"将英文字符串英文小写字符串\",\"func ToLower(s string) string\",\"根据传入的对应语言的unicode.SpecialCase ，转换成对应语言的小写字符串\",\"func ToLowerSpecial(c unicode.SpecialCase, s string) string\",\"将英文字符串转换成大写字符串\",\"func ToUpper(s string) string\",\"根据传入对应语言的unicode.SpecialCase，转换成对应语言的大写字符串\",\"func ToUpperSpecial(c unicode.SpecialCase, s string) string\",\"示例\",\"func TestLowerAndUpper(t *testing.T) { fmt.Println(strings.ToLower(\\\"My name is jack,Nice to meet you!\\\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \\\"Önnek İş\\\")) fmt.Println(strings.ToUpper(\\\"My name is jack,Nice to meet you!\\\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \\\"örnek iş\\\")) }\",\"输出\",\"=== RUN TestLowerAndUpper my name is jack,nice to meet you! önnek iş MY NAME IS JACK,NICE TO MEET YOU! ÖRNEK İŞ --- PASS: TestLowerAndUpper (0.00s) PASS\"]},\"610\":{\"h\":\"修剪字符串\",\"t\":[\"修剪字符串两端，将cutset任意匹配的子串删除\",\"func Trim(s, cutset string) string\",\"修剪字符串左端，将cutset任意匹配的子串删除\",\"func TrimLeft(s, cutset string) string\",\"修剪字符串左端前缀，将cutset匹配的子串删除，不匹配就会返回字符串s\",\"func TrimPrefix(s, suffix string) string\",\"修剪字符串右端，将cutset任意匹配的子串删除\",\"func TrimRight(s, cutset string) string\",\"修剪字符串右端后缀，将cutset匹配的子串删除，不匹配就会返回字符串s\",\"func TrimSuffix(s, suffix string) string\",\"示例\",\"func TestTrim(t *testing.T) { fmt.Println(strings.Trim(\\\"!!this is a test statement!!\\\", \\\"!!!\\\")) fmt.Println(strings.TrimLeft(\\\"!!this is a test statement!!\\\", \\\"!!!\\\")) fmt.Println(strings.TrimRight(\\\"!!this is a test statement!!\\\", \\\"!!!\\\")) fmt.Println(strings.TrimPrefix(\\\"!!this is a test statement!!\\\", \\\"!!!\\\")) fmt.Println(strings.TrimSuffix(\\\"!!this is a test statement!!\\\", \\\"!!!\\\")) }\",\"输出\",\"=== RUN TestTrim this is a test statement this is a test statement!! !!this is a test statement !!this is a test statement!! !!this is a test statement!! --- PASS: TestTrim (0.00s) PASS\"]},\"611\":{\"h\":\"字符串Builder\",\"t\":[\"字符串Builder比起直接操作字符串更加节省内存。\",\"type Builder struct { // 内部字段不对外暴露 }\",\"示例\",\"func TestBuilder(t *testing.T) { builder := strings.Builder{} builder.WriteString(\\\"hello\\\") builder.WriteString(\\\" world\\\") fmt.Println(builder.Len()) fmt.Println(builder.String()) }\",\"输出\",\"=== RUN TestBuilder 11 hello world --- PASS: TestBuilder (0.00s) PASS\",\"提示\",\"不要试图将Builder作为值进行传递，例如将strings.Builder作为函数参数传递的时候，程序会panic\",\"strings: illegal use of non-zero Builder copied by value\",\"其内部有如下一段代码\",\"type Builder struct { addr *Builder //自身的地址 buf []byte } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\\\"strings: illegal use of non-zero Builder copied by value\\\") } }\",\"当对Builder 进行值拷贝的同时，也拷贝了内部切片的指针，两个Builder在写入字符串的时候都是在对同一个切片进行操作，这也是为什么不允许被值拷贝的原因。\"]},\"612\":{\"h\":\"字符串Replacer\",\"t\":[\"Replacer转用于替换字符串\",\"func NewReplacer(oldnew ...string) *Replacer\",\"示例\",\"func TestReplacer(t *testing.T) { r := strings.NewReplacer(\\\"<\\\", \\\"&lt;\\\", \\\">\\\", \\\"&gt;\\\") fmt.Println(r.Replace(\\\"This is <b>HTML</b>!\\\")) }\",\"输出\",\"This is &lt;b&gt;HTML&lt;/b&gt;!\"]},\"613\":{\"h\":\"字符串Reader\",\"t\":[\"Reader实现了io.Reader, io.ReaderAt, io.ByteReader, io.ByteScanner, io.RuneReader, io.RuneScanner, io.Seeker, 和 io.WriterTo interfaces。\",\"func NewReader(s string) *Reader\",\"示例\",\"func TestReader(t *testing.T) { reader := strings.NewReader(\\\"abcdefghijk\\\") buffer := make([]byte, 20, 20) read, err := reader.Read(buffer) if err != nil { log.Panic(err) } fmt.Println(read) fmt.Println(string(buffer)) }\",\"输出\",\"=== RUN TestReader 11 abcdefghijk --- PASS: TestReader (0.00s) PASS\"]},\"614\":{\"h\":\"template\",\"t\":[\"官方文档：template package - text/template - Go Packages\",\"在平时我们经常会使用fmt.Sprintf函数来进行字符串格式化，但它只适用于处理小字符串的情况，而且需要使用格式化动词来指定类型，无法做到参数命名，不支持复杂情况下的处理，而这就是模板引擎所需要解决的问题，比如在直接挂到后端的静态HTML页面就需要用到模板引擎。社区里面有很多优秀的第三方模板引擎库，比如pongo2 ,sprig，jet，不过本文要讲述的主角是go内置的模板引擎库text/template，在实际开发中一般用的是html/template，后者基于前者并做了很多关于HTML的安全处理，一般情况使用前者即可，若是涉及到HTML的模板处理建议使用后者会更安全。\"]},\"615\":{\"h\":\"快速开始\",\"t\":[\"下面来看一个关于模板引擎的简单使用示例，如下所示\",\"package main import ( \\\"fmt\\\" \\\"os\\\" \\\"text/template\\\" ) func main() { tmpl := `This is the first template string, {{ .message }}` te, err := template.New(\\\"texTmpl\\\").Parse(tmpl) if err != nil { fmt.Println(err) return } data := map[string]any{ \\\"message\\\": \\\"hello world!\\\", } execErr := te.Execute(os.Stdout, data) if execErr != nil { fmt.Println(err) } }\",\"上述代码的输出为\",\"This is the first template string, hello world!\",\"在案例代码中，tmpl是一个模板字符串，字符串中的{{ .message }}是模板引擎的模板参数。首先通过*Template.Parse方法解析模板字符串，\",\"func (t *Template) Parse(text string) (*Template, error)\",\"解析成功后再通过*Template.Execute方法将data数据应用于模板中，最后输出到传入的Writer中也就是os.Stdout。\",\"func (t *Template) Execute(wr io.Writer, data any) error\",\"在以后模板引擎的使用中，基本上都是这三步：\",\"获取模板\",\"解析模板，\",\"将数据应用到模板中\",\"可见模板引擎的使用其实相当简单，稍微复杂一点的是模板引擎的模板语法，这才是本文主要讲解的内容。\"]},\"616\":{\"h\":\"模板语法\"},\"617\":{\"h\":\"参数\",\"t\":[\"go通过两对花括号{{ }}，来在模板中表示这是一个模板参数，通过.来表示根对象，根对象就是传入的data。就像是访问一个类型的成员变量一样，通过.符号衔接变量名就可以在模板中访问对应的值，例如\",\"{{ .data }}\",\"前提与之同名的成员变量存在，否则就会报错。对于传入的data，一般是结构体或者map，也可以是基本类型，比如数字字符串，这时.所代表的根对象就是其自身。在花括号内，不一定非得去访问根对象来获取值，也可以是基本类型的字面量，例如\",\"{{ 1 }} {{ 3.14 }} {{ \\\"jack\\\" }}\",\"不管什么类型，最终都会通过fmt.Sprintf(\\\"%s\\\", val)来获取其字符串表现形式，看下面的例子。\",\"func main() { out := os.Stdout tmpl := \\\"data-> {{ . }}\\\\n\\\" datas := []any{ \\\"hello world!\\\", 6379, 3.1415926, []any{1, \\\"2*2\\\", 3.6}, map[string]any{\\\"data\\\": \\\"hello world!\\\"}, struct { Data string }{Data: \\\"hello world!\\\"}, } for _, data := range datas { err := ExecTmpl(out, tmpl, data) if err != nil { panic(err) } } } func ExecTmpl(writer io.Writer, tmpl string, data any) error { parsedTmpl, err := template.New(\\\"template\\\").Parse(tmpl) if err != nil { return err } return parsedTmpl.Execute(writer, data) }\",\"输出如下\",\"data-> hello world! data-> 6379 data-> 3.1415926 data-> [1 2*2 3.6] data-> map[data:hello world!] data-> {hello world!}\",\"可以看到其输出形式跟直接使用fmt.Sprintf一致。对于结构体和map，可以通过字段名来访问其值，如下所示\",\"func main() { out := os.Stdout tmpl := \\\"data-> {{ .Data }}\\\\n\\\" datas := []any{ map[string]any{\\\"Data\\\": \\\"hello world!\\\"}, struct { Data string }{Data: \\\"hello world!\\\"}, } for _, data := range datas { err := ExecTmpl(out, tmpl, data) if err != nil { panic(err) } } }\",\"输出如下\",\"data-> hello world! data-> hello world!\",\"对于切片和map，虽然并没有提供特定语法来访问某一个索引的值，但可以通过函数调用的方式来实现，如下所示\",\"func main() { out := os.Stdout tmpl := \\\"data-> {{ index . 1}}\\\\n\\\" datas := []any{ []any{\\\"first\\\", \\\"second\\\"}, map[int]any{1: \\\"first\\\"}, } for _, data := range datas { err := ExecTmpl(out, tmpl, data) if err != nil { panic(err) } } }\",\"输出\",\"data-> second data-> first\",\"如果是多维切片，可以通过如下方式来访问对应下标的值，等同于s[i][j][k]\",\"{{ index . i j k }}\",\"对于嵌套的结构体或map，可以使用.k1.k2.k3这种方式访问，例如\",\"{{ .person.father.name }}\",\"在使用模板参数时，可以在参数前后加上-符号来消除参数前后的空白，看个例子\",\"func main() { out := os.Stdout tmpl := `{{ .x }} {{ - .op - }} {{ .y }}` datas := []any{ map[string]any{\\\"x\\\": \\\"10\\\", \\\"op\\\": \\\">\\\", \\\"y\\\": \\\"2\\\"}, } for _, data := range datas { err := ExecTmpl(out, tmpl, data) if err != nil { panic(err) } } }\",\"正常来说输出结果应该是10 > 2，但由于在op参数前后添加了-符号，所以它前后的空白符都会被消除，所以实际输出为\",\"10>2\",\"需要注意的是，在花括号中，-符号与参数必须相隔一个空格，也就说必须是{{- . -}}这种格式，在例子中之所以会在两边额外加个空格写成{{ - . - }}这种格式纯粹是个人觉得看的顺眼，实际上并没有这个语法限制。\"]},\"618\":{\"h\":\"注释\",\"t\":[\"模板语法支持注释，注释并不会在最终的模板中生成，其语法如下\",\"{{/* this is a comment */}}\",\"注释符号/*和*/必须与花括号相邻，它们之间不能有其它字符，否则将无法正常解析。只有一种情况例外，那就是消除空白符的时候\",\"{{- /* this is a comment */ -}}\"]},\"619\":{\"h\":\"变量\",\"t\":[\"在模板中也可以声明变量，通过$符号来表示这是一个变量，并通过:= 来进行赋值，就跟go代码一样，例子如下。\",\"{{ $name := .Name }} {{ $val := index . 1 }} {{ $val := index .dict key }} // 整型赋值 {{ $numer := 1 }} // 浮点数赋值 {{ $float := 1.234}} // 字符串赋值 {{ $name := \\\"jack\\\" }}\",\"在后续使用时，通过$衔接变量名来访问该变量的值，比如\",\"func main() { out := os.Stdout tmpl := `{{ $name := .name }} {{- $name }}` datas := []any{ map[string]any{\\\"name\\\": \\\"jack\\\"}, } for _, data := range datas { err := ExecTmpl(out, tmpl, data) if err != nil { panic(err) } } }\",\"输出\",\"jack\",\"变量必须先声明才能使用，否则将会提示undefined variable，并且也要在作用域内才能使用。\"]},\"620\":{\"h\":\"函数\",\"t\":[\"模板自身的语法其实并不多，大多数功能都是通过函数来实现的，函数调用的格式为函数名后衔接参数列表，以空格为分隔符，如下所示\",\"{{ funcname arg1 arg2 arg3 ... }}\",\"例如之前用到的index函数\",\"{{ index .s 1 }}\",\"用于比较是否相等的函数eq函数\",\"{{ eq 1 2 }}\",\"每一个*Template都有一个FuncsMap，用于记录函数的映射\",\"type FuncMap map[string]any\",\"在创建模板时从text/template.builtins获取默认的函数映射表，下面是内置的所有函数\",\"函数名\",\"作用\",\"示例\",\"and\",\"与运算\",\"{{ and true false }}\",\"or\",\"或运算\",\"{{ or true false }}\",\"not\",\"取反运算\",\"{{ not true }}\",\"eq\",\"是否相等\",\"{{ eq 1 2 }}\",\"ne\",\"是否不相等\",\"{{ ne 1 2 }}\",\"lt\",\"小于\",\"{{ lt 1 2 }}\",\"le\",\"小于等于\",\"{{ le 1 2 }}\",\"gt\",\"大于\",\"{{ gt 1 2 }}\",\"ge\",\"大于等于\",\"{{ ge 1 2 }}\",\"len\",\"返回长度\",\"{{ len .slice }}\",\"index\",\"获取目标指定索引的元素\",\"{{ index . 0 }}\",\"slice\",\"切片，等价于s[1:2:3]\",\"{{ slice . 1 2 3 }}\",\"html\",\"HTML转义\",\"{{ html .name }}\",\"js\",\"js转义\",\"{{ js .name }}\",\"print\",\"fmt.Sprint\",\"{{ print . }}\",\"printf\",\"fmt.Sprintf\",\"{{ printf \\\"%s\\\" .}}\",\"println\",\"fmt.Sprintln\",\"{{ println . }}\",\"urlquery\",\"url query转义\",\"{{ urlquery .query }}\",\"除了这些之外，还有一个比较特殊的内置函数call，它是用于直接调用通过在Execute时期传入的data中的函数，例如下面的模板\",\"{{ call .string 1024 }}\",\"传入的数据如下\",\"map[string]any{ \\\"string\\\": func(val any) string { return fmt.Sprintf(\\\"%v: 2048\\\", val) }, }\",\"那么在模板中就会生成\",\"1024: 2048\",\"这是自定义函数的途径之一，不过通常建议使用*Template.Funcs方法来添加自定义函数，因为后者可以作用全局，不需要绑定到根对象中。\",\"func (t *Template) Funcs(funcMap FuncMap) *Template\",\"自定义函数的返回值一般有两个，第一个是需要用到的返回值，第二个是error。例如有如下自定义函数\",\"template.FuncMap{ \\\"add\\\": func(val any) (string, error) { return fmt.Sprintf(\\\"%v+1\\\", val), nil }, }\",\"然后在模板中直接使用\",\"{{ add 1024 }}\",\"其结果为\",\"1024 + 1\"]},\"621\":{\"h\":\"管道\",\"t\":[\"这个管道与chan是两个东西，官方文档里面称其为pipeline，任何能够产生数据的操作都称其为pipeline。下面的模板操作都属于管道操作\",\"{{ 1 }} {{ eq 1 2 }} {{ $name }} {{ .name }}\",\"熟悉linux的应该都知道管道运算符|，模板中也支持这样的写法。管道操作在模板中经常出现，例如\",\"{{ $name := 1 }}{{ $name | print | printf \\\"%s+1=?\\\" }}\",\"其结果为\",\"1+1=?\",\"在后续的with，if，range中也会频繁用到。\"]},\"622\":{\"h\":\"with\",\"t\":[\"通过with语句可以控制变量和根对象的作用域，格式如下\",\"{{ with pipeline }} text {{ end }}\",\"with会检查管道操作返回的值，如果值为空的话，中间的text模板就不会生成。如果想要处理空的情况，可以使用with else，格式如下\",\"{{ with pipeline }} text1 {{ else }} text2 {{ end }}\",\"如果管道操作返回的值为空，那么就会执行else这块的逻辑。在with语句中声明的变量，其作用域仅限于with语句内，看下面一个例子\",\"{{ $name := \\\"mike\\\" }} {{ with $name := \\\"jack\\\" }} {{- $name -}} {{ end }} {{- $name -}}\",\"它的输出如下，显然这是由于作用域不同，它们是两个不同的变量。\",\"jackmike\",\"通过with语句还可以在作用域内改写根对象，如下\",\"{{ with .name }} name: {{- .second }}-{{ .first -}} {{ end }} age: {{ .age }} address: {{ .address }}\",\"传入如下的数据\",\"map[string]any{ \\\"name\\\": map[string]any{ \\\"first\\\": \\\"jack\\\", \\\"second\\\": \\\"bob\\\", }, \\\"age\\\": 1, \\\"address\\\": \\\"usa\\\", }\",\"它的输出\",\"name:bob-jack age: 1 address: usa\",\"可以看到在with语句内部，根对象.已经变成了.name。\"]},\"623\":{\"h\":\"条件\",\"t\":[\"条件语句的格式如下所示\",\"{{ if pipeline }} text1 {{ else if pipeline }} text2 {{ else }} text3 {{ end }}\",\"就跟写普通的代码一样，非常好理解。下面看几个简单的例子，\",\"{{ if eq .lang \\\"en\\\" }} {{- .content.en -}} {{ else if eq .lang \\\"zh\\\" }} {{- .content.zh -}} {{ else }} {{- .content.fallback -}} {{ end }}\",\"传入的数据\",\"map[string]any{ \\\"lang\\\": \\\"zh\\\", \\\"content\\\": map[string]any{ \\\"en\\\": \\\"hello, world!\\\", \\\"zh\\\": \\\"你好，世界！\\\", \\\"fallback\\\": \\\"hello, world!\\\", }, }\",\"例子中的模板根据传入的语言lang来决定要以何种方式展示内容，输出结果\",\"你好，世界！\"]},\"624\":{\"h\":\"迭代\",\"t\":[\"迭代语句的格式如下，range所支持的pipeline必须是数组，切片，map，以及channel。\",\"{{ range pipeline }} loop body {{ end }}\",\"结合else使用，当长度为0时，就会执行else块的内容。\",\"{{ range pipeline }} loop body {{ else }} fallback {{ end }}\",\"除此之外，还支持break，continue这类操作，比如\",\"{{ range pipeline }} {{ if pipeline }} {{ break }} {{ end }} {{ if pipeline }} {{ continue }} {{ end }} loop body {{ end }}\",\"下面看一个迭代的例子。\",\"{{ range $index, $val := . }} {{- if eq $index 0 }} {{- continue -}} {{ end -}} {{- $index}}: {{ $val }} {{ end }}\",\"传入数据\",\"[]any{1, \\\"2\\\", 3.14},\",\"输出\",\"1: 2 2: 3.14\",\"迭代map也是同理。\"]},\"625\":{\"h\":\"嵌套\",\"t\":[\"一个模板中可以定义有多个模板，比如\",\"{{ define \\\"t1\\\" }} t1 {{ end }} {{ define \\\"t2\\\" }} t2 {{ end }}\",\"这些定义的模板在并不会生成在最终的模板中，除非在加载时指定了名称或者通过template语句手动指定。\",\"func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error\",\"比如下面的例子\",\"{{ define \\\"t1\\\" }} {{- with .t1 }} {{- .data -}} {{ end -}} {{ end }} {{ define \\\"t2\\\" }} {{- with .t2 }} {{- .data -}} {{ end}} {{ end -}}\",\"传入如下数据\",\"map[string]any{ \\\"t1\\\": map[string]any{\\\"data\\\": \\\"template body 1\\\"}, \\\"t2\\\": map[string]any{\\\"data\\\": \\\"template body 2\\\"}, }\",\"代码\",\"func main() { out := os.Stdout tmpl := `{{ define \\\"t1\\\" }} {{- with .t1 }} {{- .data -}} {{ end -}} {{ end }} {{ define \\\"t2\\\" }} {{- with .t2 }} {{- .data -}} {{ end}} {{ end -}}` datas := []any{ map[string]any{ \\\"t1\\\": map[string]any{\\\"data\\\": \\\"template body 1\\\"}, \\\"t2\\\": map[string]any{\\\"data\\\": \\\"template body 2\\\"}, }, } name := \\\"t1\\\" for _, data := range datas { err := ExecTmpl(out, tmpl, name, data) if err != nil { panic(err) } } } func ExecTmpl(writer io.Writer, tmpl string, name string, data any) error { t := template.New(\\\"template\\\") parsedTmpl, err := t.Parse(tmpl) if err != nil { return err } return parsedTmpl.ExecuteTemplate(writer, name, data) }\",\"输出\",\"template body 1\",\"或者也可以手动指定模板\",\"{{ define \\\"t1\\\" }} {{- with .t1 }} {{- .data -}} {{ end -}} {{ end }} {{ define \\\"t2\\\" }} {{- with .t2 }} {{- .data -}} {{ end}} {{ end -}} {{ template \\\"t2\\\" .}}\",\"那么在解析时是否指定模板名称，t2都会加载。\"]},\"626\":{\"h\":\"关联\",\"t\":[\"子模板只是在一个模板内部声明多个命名的模板，关联是将外部的多个命名的*Template关联起来。然后通过template语句来引用指定的模板。\",\"{{ tempalte \\\"templateName\\\" pipeline}}\",\"pipeline可以根据自己的需求来指定关联模板的根对象，或者也可以直接传入当前模板的根对象。看下面的一段代码例子\",\"func main() { tmpl1 := `name: {{ .name }}` tmpl2 := `age: {{ .age }}` tmpl3 := `Person Info {{template \\\"t1\\\" .}} {{template \\\"t2\\\" .}}` t1, err := template.New(\\\"t1\\\").Parse(tmpl1) if err != nil { panic(err) } t2, err := template.New(\\\"t2\\\").Parse(tmpl2) if err != nil { panic(err) } t3, err := template.New(\\\"t3\\\").Parse(tmpl3) if err != nil { panic(err) } if err := associate(t3, t1, t2); err != nil { panic(err) } err = t3.Execute(os.Stdout, map[string]any{ \\\"name\\\": \\\"jack\\\", \\\"age\\\": 18, }) if err != nil { panic(err) } } func associate(t *template.Template, ts ...*template.Template) error { for _, tt := range ts { _, err := t.AddParseTree(tt.Name(), tt.Tree) if err != nil { return err } } return nil }\",\"在上述的地面中，t3关联了t1，和t2，使用*Template.AddParseTree方法进行关联\",\"func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)\",\"最终的模板生成结果为\",\"Person Info name: jack age: 18\"]},\"627\":{\"h\":\"插槽\",\"t\":[\"通过block语句，可以实现类似vue插槽的效果，其目的是为了复用某一个模板而用的。看一个使用案例就知道怎么用了，在t1模板中定义插槽\",\"Basic Person Info name: {{ .name }} age: {{ .age }} address: {{ .address }} {{ block \\\"slot\\\" . }} default content body {{ end }}\",\"block语句可以插槽中的默认内容，在后续其它模板使用插槽时，会覆盖默认的内容。在t2模板中引用t1模板，并使用define定义嵌入的内容\",\"{{ template \\\"person.txt\\\" . }} {{ define \\\"slot\\\" }} school: {{ .school }} {{ end }}\",\"将两个模板关联以后，传入如下的数据\",\"map[string]any{ \\\"name\\\": \\\"jack\\\", \\\"age\\\": 18, \\\"address\\\": \\\"usa\\\", \\\"company\\\": \\\"google\\\", \\\"school\\\": \\\"mit\\\", }\",\"最终输出的结果为\",\"Basic Person Info name: jack age: 18 address: usa school: mit\"]},\"628\":{\"h\":\"模板文件\",\"t\":[\"在模板语法的案例中，都是使用的字符串字面量来作为模板，在实际的使用情况中大多数都是将模板放在文件中。\",\"func ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\",\"比如template.ParseFs就是从指定的文件系统中加载匹配pattern的模板。下面的例子以embed.FS作为文件系统，准备三个文件\",\"# person.txt Basic Person Info name: {{ .name }} age: {{ .age }} address: {{ .address }} {{ block \\\"slot\\\" . }} {{ end }} # student.txt {{ template \\\"person.txt\\\" . }} {{ define \\\"slot\\\" }} school: {{ .school }} {{ end }} # employee.txt {{ template \\\"person.txt\\\" . }} {{ define \\\"slot\\\" }} company: {{ .company }} {{ end }}\",\"代码如下\",\"import ( \\\"embed\\\" \\\"os\\\" \\\"text/template\\\" ) //go:embed *.txt var fs embed.FS func main() { data := map[string]any{ \\\"name\\\": \\\"jack\\\", \\\"age\\\": 18, \\\"address\\\": \\\"usa\\\", \\\"company\\\": \\\"google\\\", \\\"school\\\": \\\"mit\\\", } t1, err := template.ParseFS(fs, \\\"person.txt\\\", \\\"student.txt\\\") if err != nil { panic(err) } t1.Execute(os.Stdout, data) t2, err := template.ParseFS(fs, \\\"person.txt\\\", \\\"employee.txt\\\") if err != nil { panic(err) } t2.Execute(os.Stdout, data) }\",\"输出为\",\"Basic Person Info name: jack age: 18 address: usa school: mit Basic Person Info name: jack age: 18 address: usa company: google\",\"这是一个很简单的模板文件使用案例，person.txt作为插槽文件，其它两个复用其内容并嵌入自定义的新内容。也可以使用下面两个函数\",\"func ParseGlob(pattern string) (*Template, error) func ParseFiles(filenames ...string) (*Template, error)\",\"ParseGlob基于通配符匹配，ParseFiles基于文件名，它们都是使用的本地文件系统。如果是用于展示在前端的html文件，建议使用html/template包，它提供的API与text/template完全一致，但是针对html，css，js做了安全处理。\"]},\"629\":{\"h\":\"time\",\"t\":[\"time包提供了时间和日历的相关的函数与方法。\",\"time.Now()函数可以获取当前时间\",\"func Now() Time\",\"now := time.Now() fmt.Println(now) //2022-11-17 10:00:18.6983438 +0800 CST m=+0.007095001\",\"其返回的数据类型是Time结构体，其含有非常多的时间操作的方法。\",\"func (t *Time) nsec() int32 //纳秒 func (t *Time) sec() int64 //秒 func (t *Time) unixSec() //返回 Unix时间格式的 秒 func (t *Time) addSec(d int64) //增加秒 func (t *Time) setLoc(loc *Location) //设置地区 func (t *Time) stripMono() //去掉时间的单调时钟读数 func (t Time) After(u Time) //判断一个时间是否在它之后 func (t Time) Before(u Time) bool //判断一个时间是否在它之前 func (t Time) Equal(u Time) bool //判断两个时间是否表示同一瞬间 func (t Time) Sub(u Time) Duration //求两个时间的差值 func (t Time) Add(d Duration) Time //增加一段时间间隔\"]},\"630\":{\"h\":\"时间单位\",\"t\":[\"time包存放了基础的时间单位常量\",\"const ( minDuration Duration = -1 << 63 maxDuration Duration = 1<<63 - 1 ) const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute )\",\"它们的类型是time.Duration，最小的单位是纳秒，最大的是小时。\"]},\"631\":{\"h\":\"格式化\",\"t\":[\"时间类型可以格式化输出，不过需要注意的是在Go中格式化模板不是常见的yyyy-mm-dd这类，而是以Go诞生时间为模板。Go的诞生的时间是 2006年1月2日下午15点04分。\",\"例子\",\"now := time.Now()\",\"24小时格式化输出\",\"fmt.Println(now.Format(\\\"2006-01-02 15:04:05 Monday Jan\\\")) //2022-11-17 10:44:48 Thursday Nov\",\"只输出日期\",\"fmt.Println(now.Format(\\\"2006-01-02\\\")) //2022-11-17\",\"只输入12小时制的时间\",\"fmt.Println(now.Format(\\\"15:04:05 PM\\\")) //10:48:47 AM\"]},\"632\":{\"h\":\"解析时间\",\"t\":[\"通常我们会有一个需求就是，将一个字符串时间按照一定格式转换为Go中的时间结构体，接下来我们要做的就是这件事。\",\"func main() { location, err := time.LoadLocation(\\\"Asia/Shanghai\\\") if err != nil { fmt.Println(err) return } inLocation, err := time.ParseInLocation(\\\"2006/01/02\\\", \\\"2012/10/12\\\", location) if err != nil { fmt.Println(err) return } fmt.Println(inLocation.String()) }\",\"最终输出\",\"2012-10-12 00:00:00 +0800 CST\"]},\"633\":{\"h\":\"Timer\",\"t\":[\"Timer是一个计时器，对外暴露一个channel，当指定时间到了以后，channel就会收到消息并关闭。\",\"func NewTimer(d Duration) *Timer\",\"通过time.NewTimer()可以创建一个新的计时器\",\"func main() { timer := time.NewTimer(time.Second) defer timer.Stop() select { case t := <-timer.C: fmt.Println(t) } }\",\"2023-09-25 21:25:03.5696803 +0800 CST m=+1.007908001\",\"在使用完timer以后，应及时的关闭。\"]},\"634\":{\"h\":\"Ticker\",\"t\":[\"Ticker是一个定时器，与timer的区别在于，timer是一次性的，而Ticker是定时触发。\",\"func NewTicker(d Duration) *Ticker\",\"通过time.NewTicker()可以创建一个新的定时器\",\"func main() { ticker := time.NewTicker(time.Second) defer ticker.Stop() for i := 0; i < 3; i++ { select { case t := <-ticker.C: fmt.Println(t) } } }\",\"2023-09-25 21:29:20.4429256 +0800 CST m=+1.009508401 2023-09-25 21:29:21.4512075 +0800 CST m=+2.017790301 2023-09-25 21:29:22.4501592 +0800 CST m=+3.016742001\",\"同样的，在使用完ticker后，也要及时关闭。\"]},\"635\":{\"h\":\"sleep\",\"t\":[\"time.Sleep()可以使用当前goroutine处于挂起状态一定的时间，在这期间goroutine将被阻塞，直到恢复运行状态。\",\"func Sleep(d Duration)\",\"func main() { start := time.Now() fmt.Println(start) time.Sleep(time.Second * 2) end := time.Now() fmt.Println(end) }\",\"2023-09-25 21:36:35.7229057 +0800 CST m=+0.001627901 2023-09-25 21:36:37.7347742 +0800 CST m=+2.013496401\",\"上面这段程序就会在输出完start后阻塞两秒，然后再输出end。\"]},\"636\":{\"h\":\"unicode\"},\"637\":{\"h\":\"unsafe\",\"t\":[\"官方文档地址：unsafe package - unsafe - Go Packages\",\"unsafe标准库是官方提供的一个可以进行低级编程的库，该包提供的操作可以直接跳过Go的类型系统从而读写内存。该包可能不具有移植性，且官方声称该包不受Go 1 兼容性准则的保护。即便如此，unsafe也还是被大量的项目使用，其中也包括官方提供的标准库。\",\"提示\",\"之所以不可移植的原因是一些操作的结果取决于操作系统实现，不同的系统可能会有不同的结果。\"]},\"638\":{\"h\":\"ArbitraryType\",\"t\":[\"type ArbitraryType int\",\"Arbitrary可以翻译为任意的，在这里代表的是任意类型，且不等同于any，实际上该类型并不属于unsafe包，出现在这里仅仅只是为了文档目的。\"]},\"639\":{\"h\":\"IntegerType\",\"t\":[\"type IntegerType int\",\"IntegerType代表的是任意整数类型，实际上该类型并不属于unsafe包，出现在这里仅仅只是为了文档目的。\",\"上面这两个类型不需要太在意，它们仅仅只是一个代表而已，在使用unsafe包函数时编辑器甚至会提示你类型不匹配，它们的实际类型就是你传入的具体类型。\"]},\"640\":{\"h\":\"Sizeof\",\"t\":[\"func Sizeof(x ArbitraryType) uintptr\",\"以字节为单位返回变量x的大小，不包括其引用内容的大小，例如：\",\"func main() { var ints byte = 1 fmt.Println(unsafe.Sizeof(ints)) var floats float32 = 1.0 fmt.Println(unsafe.Sizeof(floats)) var complexs complex128 = 1 + 2i fmt.Println(unsafe.Sizeof(complexs)) var slice []int = make([]int, 100) fmt.Println(unsafe.Sizeof(slice)) var mp map[string]int = make(map[string]int, 0) fmt.Println(unsafe.Sizeof(mp)) type person struct { name string age int } fmt.Println(unsafe.Sizeof(person{})) type man struct { name string } fmt.Println(unsafe.Sizeof(man{})) }\",\"1 4 16 24 8 24 16\"]},\"641\":{\"h\":\"Offsetof\",\"t\":[\"func Offsetof(x ArbitraryType) uintptr\",\"该函数用于表示结构体内字段偏移量，所以x必须是一个结构体字段，或者说返回值就是结构体地址起始处到字段地址起始处两者之间的字节数，例如\",\"func main() { type person struct { name string age int } p := person{ name: \\\"aa\\\", age: 11, } fmt.Println(unsafe.Sizeof(p)) fmt.Println(unsafe.Offsetof(p.name)) fmt.Println(unsafe.Sizeof(p.name)) fmt.Println(unsafe.Offsetof(p.age)) fmt.Println(unsafe.Sizeof(p.age)) }\",\"24 0 16 16 8\"]},\"642\":{\"h\":\"Alignof\",\"t\":[\"如果不懂什么是内存对齐，可以前往：Go语言内存对齐详解 - 掘金 (juejin.cn)\",\"func Alignof(x ArbitraryType) uintptr\",\"对齐大小通常是以字节为单位的计算机字长与Sizeof的最小值，例如在amd64的机器上，字长为64位，也就是8个字节，例如：\",\"func main() { type person struct { name string age int32 } p := person{ name: \\\"aa\\\", age: 11, } fmt.Println(unsafe.Alignof(p), unsafe.Sizeof(p)) fmt.Println(unsafe.Alignof(p.name), unsafe.Sizeof(p.name)) fmt.Println(unsafe.Alignof(p.age), unsafe.Sizeof(p.age)) }\",\"8 24 8 16 4 4\"]},\"643\":{\"h\":\"Pointer\",\"t\":[\"type Pointer *ArbitraryType\",\"Pointer是一种可以指向任意类型的\\\"指针\\\"，其类型为*ArbitraryType，该类型与uintptr结合使用，才能真正发挥unsafe包的真正威力。在官方文档的描述中，unsafe.Pointer类型可以进行四个特殊操作，分别是：\",\"任何类型的指针都可以转换为unsafe.Pointer\",\"unsafe.Pointer可以转换为任何类型的指针\",\"uintptr可以转换为unsafe.Pointer\",\"unsafe.Pointer可以转换为uintptr\",\"这四个特殊操作构成了整个unsafe包的基石，也正是这四个操作才能写出能够忽略类型系统从而直接读写内存的代码，建议在使用时应当格外注意。\",\"提示\",\"unsafe.Pointer无法解引用，同样的也无法取地址。\",\"(1) 将*T1转换为unsafe.Pointer再转换为*T2\",\"现有类型*T1，*T2，假设T2不大于T1并且两者内存布局等效，就允许将一种T2类型的数据转换为T1。例如：\",\"func main() { fmt.Println(Float64bits(12.3)) fmt.Println(Float64frombits(Float64bits(12.3))) } func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) } func Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(&b)) }\",\"4623113902481840538 12.3\",\"这两个函数实际是math包下的两个函数，过程中的类型变化如下\",\"float64 -> *float64 -> unsafe.Pointer -> *uint64 -> uint64 -> *uint64 -> unsafe.Pointer -> *float64 -> float64\",\"(2) 将unsafe.Pointer转换为uintptr\",\"将unsafe.Pointer转换为uintptr时，会将前者所指向的地址作为后者的值，uintptr保存的是地址，区别在于，前者在语法上是一个指针，是一个引用，后者仅仅是一个整数值。例如\",\"func main() { num := 1 fmt.Println(unsafe.Pointer(&num)) fmt.Printf(\\\"0x%x\\\", uintptr(unsafe.Pointer(&num))) }\",\"0xc00001c088 0xc00001c088\",\"更大的区别在于垃圾回收的处理，由于unsafe.Pointer是一个引用，在需要的时候并不会被回收掉，而后者仅仅作为一个值，自然不会有这种特殊待遇了，另一个需要注意的点是当指针指向的元素地址移动时，GC会去更新指针引用的旧地址，但不会去更新uinptr所保存的值。例如下面的代码就可能会出现问题：\",\"func main() { num := 16 address := uintptr(unsafe.Pointer(&num)) np := (*int64)(unsafe.Pointer(address)) fmt.Println(*np) }\",\"当一些情况下，GC移动变量后，address指向的地址已经无效了，此时再使用该值去创建指针就会引发panic\",\"panic: runtime error: invalid memory address or nil pointer dereference\",\"所以并不建议保存Pointer转换为uintptr后的值。\",\"(3) 通过uintptr转换为unsafe.Pointer\",\"如下方式可以通过uintptr获得一个指针，只要指针是有效的，那么便不会出现例二的无效地址情况。Pointer与类型指针本身是不支持指针运算，但是uintptr只是一个整数值，可以进行数学运算，对uintptr进行数学运算后再转换为Pointer就可以完成指针运算。\",\"p = unsafe.Pointer(uintptr(p) + offset)\",\"这样，可以仅通过一个指针，就能访问到一些类型的内部元素，比如数组和结构体，无论其内部元素是否对外暴露，例如\",\"func main() { type person struct { name string age int32 } p := &person{\\\"jack\\\", 18} pp := unsafe.Pointer(p) fmt.Println(*(*string)(unsafe.Pointer(uintptr(pp) + unsafe.Offsetof(p.name)))) fmt.Println(*(*int32)(unsafe.Pointer(uintptr(pp) + unsafe.Offsetof(p.age)))) s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} ps := unsafe.Pointer(&s[0]) fmt.Println(*(*int)(unsafe.Pointer(uintptr(ps) + 8))) fmt.Println(*(*int)(unsafe.Pointer(uintptr(ps) + 16))) }\",\"jack 18 2\"]},\"644\":{\"h\":\"Add\",\"t\":[\"func Add(ptr Pointer, len IntegerType) Pointer\",\"Add将返回使用偏移量len更新后的Pointer，等价于Pointer(uintptr(ptr) + uintptr(len))\",\"Pointer(uintptr(ptr) + uintptr(len))\",\"例如：\",\"func main() { s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} ps := unsafe.Pointer(&s[0]) fmt.Println(*(*int)(unsafe.Add(ps, 8))) fmt.Println(*(*int)(unsafe.Add(ps, 16))) }\",\"2 3\"]},\"645\":{\"h\":\"SliceData\",\"t\":[\"func SliceData(slice []ArbitraryType) *ArbitraryTyp\",\"该函数接收一个切片，返回其底层数组的其实地址。如果不使用SliceData，那么只能通过取其第一个元素的指针来获取底层数组的地址，如下\",\"func main() { nums := []int{1, 2, 3, 4} for p, i := unsafe.Pointer(&nums[0]), 0; i < len(nums); p, i = unsafe.Add(p, unsafe.Sizeof(nums[0])), i+1 { num := *(*int)(p) fmt.Println(num) } }\",\"当然也可以通过reflect.SliceHeader类型来获取，不过在1.20版本以后它就已经被废弃了，SliceData就是为了替代它的，使用SliceData的例子如下\",\"func main() { nums := []int{1, 2, 3, 4} for p, i := unsafe.Pointer(unsafe.SliceData(nums)), 0; i < len(nums); p, i = unsafe.Add(p, unsafe.Sizeof(int(0))), i+1 { num := *(*int)(p) fmt.Println(num) } }\"]},\"646\":{\"h\":\"Slice\",\"t\":[\"func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType\",\"Slice函数接收一个指针，以及长度偏移量，它会返回该段内存的切片表达形式，过程中不会涉及到内存拷贝，对切片进行修改将会直接影响该地址上的数据，反过来也是如此，它通常和SliceData配合起来使用。\",\"func main() { nums := []int{1, 2, 3, 4} numsRef1 := unsafe.Slice(unsafe.SliceData(nums), len(nums)) numsRef1[0] = 2 fmt.Println(nums) }\",\"[2 2 3 4]\",\"修改numsRef1切片的数据，会导致nums的数据也会发生变化\"]},\"647\":{\"h\":\"StringData\",\"t\":[\"func StringData(str string) *byte\",\"同SliceData函数，只不过因为字符串转字节切片需求比较频繁，所以单独拿出来，使用例子如下\",\"func main() { str := \\\"hello,world!\\\" for ptr, i := unsafe.Pointer(unsafe.StringData(str)), 0; i < len(str); ptr, i = unsafe.Add(ptr, unsafe.Sizeof(byte(0))), i+1 { char := *(*byte)(ptr) fmt.Println(string(char)) } }\",\"由于字符串字面量是存放在进程中的只读段，所以如果你在这里尝试修改字符串底层的数据，程序会直接崩掉报fatal。不过对于存放在堆栈上的字符串变量而言，在运行时修改其底层的数据是完全可行的。\"]},\"648\":{\"h\":\"String\",\"t\":[\"func String(ptr *byte, len IntegerType) string\",\"同Slice函数，接收一个字节类型指针，以及其长度偏移量，返回其字符串表达形式，过程中不涉及内存拷贝。下面是一个字节切片转字符串的例子\",\"func main() { bytes := []byte(\\\"hello world\\\") str := unsafe.String(unsafe.SliceData(bytes), len(bytes)) fmt.Println(str) }\",\"StringData和String在字符串与字节切片的转换过程中不涉及内存拷贝，性能比直接类型转换要好，不过只适用于只读的情况下，如果你打算修改数据，就最好别用这个。\"]},\"649\":{\"h\":\"Runtime\"},\"650\":{\"c\":[\"golang\"]},\"651\":{\"h\":\"并发\"},\"652\":{\"c\":[\"golang\"]},\"653\":{\"h\":\"内置数据结构\"},\"654\":{\"c\":[\"golang\"]},\"655\":{\"h\":\"错误\"},\"656\":{\"c\":[\"golang\"]},\"657\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"658\":{\"h\":\"Computer\"},\"659\":{\"h\":\"Framework\"},\"660\":{\"h\":\"Golang\"},\"661\":{\"h\":\"Middleware\"}},\"dirtCount\":0,\"index\":[[\"兼容性准则的保护\",{\"1\":{\"637\":1}}],[\"纳秒\",{\"1\":{\"629\":1}}],[\"插槽\",{\"0\":{\"627\":1}}],[\"插入元素\",{\"0\":{\"164\":1}}],[\"嵌套\",{\"0\":{\"625\":1}}],[\"嵌入式脚本语言\",{\"0\":{\"49\":1},\"1\":{\"39\":1}}],[\"迭代map也是同理\",{\"1\":{\"624\":1}}],[\"迭代语句的格式如下\",{\"1\":{\"624\":1}}],[\"迭代\",{\"0\":{\"624\":1}}],[\"熟悉linux的应该都知道管道运算符|\",{\"1\":{\"621\":1}}],[\"根对象\",{\"1\":{\"622\":1}}],[\"根对象就是传入的data\",{\"1\":{\"617\":1}}],[\"根据传入对应语言的unicode\",{\"1\":{\"609\":1}}],[\"根据传入的对应语言的unicode\",{\"1\":{\"609\":1}}],[\"根据子串sep将字符串s分隔成包含sep的字符串元素组成的字符串切片\",{\"1\":{\"608\":2}}],[\"根据子串sep将字符串s分隔成一个字符串切片\",{\"1\":{\"608\":2}}],[\"根据给定的count复制字符串\",{\"1\":{\"606\":1}}],[\"根据sha值执行脚本\",{\"1\":{\"485\":1}}],[\"根据测试的结果看来\",{\"1\":{\"394\":1}}],[\"根据依赖压缩包所计算出的哈希值\",{\"1\":{\"379\":1}}],[\"根据go版本的不同\",{\"1\":{\"378\":1}}],[\"根据最小可用版本原则\",{\"1\":{\"377\":1}}],[\"根据一个key读取值\",{\"1\":{\"355\":1}}],[\"根据直觉来讲\",{\"1\":{\"348\":1}}],[\"根据实现的定义\",{\"1\":{\"213\":1}}],[\"根据实际情况判断输出\",{\"1\":{\"140\":1}}],[\"根据规范提供具体的功能\",{\"1\":{\"212\":1}}],[\"根据自家公司的独门技术造出了绝世起重机并交给了建筑公司\",{\"1\":{\"212\":1}}],[\"根据内存对齐规则而言\",{\"1\":{\"192\":1}}],[\"根据格式化的字符串扫描\",{\"1\":{\"143\":1}}],[\"根据空格分隔\",{\"1\":{\"143\":1}}],[\"根据序号值的变化会自动的赋值给后续的常量\",{\"1\":{\"131\":1}}],[\"根据json\",{\"1\":{\"60\":1}}],[\"根据ip获取地理位置信息\",{\"1\":{\"41\":1}}],[\"稍微复杂一点的是模板引擎的模板语法\",{\"1\":{\"615\":1}}],[\"稍微修改下后如下\",{\"1\":{\"340\":1}}],[\"稍微修改了一下\",{\"1\":{\"206\":1}}],[\"修剪字符串右端后缀\",{\"1\":{\"610\":1}}],[\"修剪字符串右端\",{\"1\":{\"610\":1}}],[\"修剪字符串左端前缀\",{\"1\":{\"610\":1}}],[\"修剪字符串左端\",{\"1\":{\"610\":1}}],[\"修剪字符串两端\",{\"1\":{\"610\":1}}],[\"修剪字符串\",{\"0\":{\"610\":1}}],[\"修改numsref1切片的数据\",{\"1\":{\"646\":1}}],[\"修改权值\",{\"0\":{\"483\":1}}],[\"修改元素\",{\"0\":{\"467\":1}}],[\"修改测试次数为2\",{\"1\":{\"390\":1}}],[\"修改go\",{\"1\":{\"382\":1}}],[\"修改main\",{\"1\":{\"372\":1}}],[\"修改完代理后\",{\"1\":{\"371\":1}}],[\"修改数据\",{\"1\":{\"348\":1,\"349\":1}}],[\"修改为如下代码\",{\"1\":{\"339\":1}}],[\"修改后的代码如下\",{\"1\":{\"319\":1,\"393\":1}}],[\"修改值\",{\"1\":{\"287\":1}}],[\"修改字段值\",{\"1\":{\"287\":2}}],[\"修改字段\",{\"0\":{\"287\":1}}],[\"修改字节切片\",{\"1\":{\"173\":1}}],[\"修改过后就可以通过编译了\",{\"1\":{\"259\":1}}],[\"修改一下模拟的函数\",{\"1\":{\"246\":1}}],[\"修改了\",{\"1\":{\"205\":1}}],[\"修改切片会导致原数组内容的变化\",{\"1\":{\"160\":1}}],[\"örnek\",{\"1\":{\"609\":2}}],[\"önnek\",{\"1\":{\"609\":2}}],[\"替换字符串\",{\"0\":{\"607\":1}}],[\"寻找前后缀\",{\"0\":{\"603\":1}}],[\"寻找并切换最快的源\",{\"1\":{\"11\":1}}],[\"忽略大小写相等\",{\"0\":{\"601\":1}}],[\"给出子串substr在字符串s内的出现次数\",{\"1\":{\"599\":1}}],[\"给一个对应的元素增加相应的权值\",{\"1\":{\"483\":1}}],[\"给一个代码块打上标签\",{\"1\":{\"150\":1}}],[\"参考浮点数精度\",{\"1\":{\"592\":1}}],[\"参考浮点数格式化类型\",{\"1\":{\"592\":1}}],[\"参数预计算\",{\"0\":{\"204\":1}}],[\"参数\",{\"0\":{\"198\":1,\"617\":1},\"1\":{\"388\":1}}],[\"参数列表\",{\"1\":{\"197\":2}}],[\"参数列表数量\",{\"1\":{\"140\":2}}],[\"十六进制分数和二进制指数\",{\"1\":{\"590\":2}}],[\"十分建议学习其他框架前先行掌握http包\",{\"1\":{\"529\":1}}],[\"十分新颖的rpc库\",{\"1\":{\"47\":1}}],[\"够转换的字符串如下\",{\"1\":{\"586\":1}}],[\"逆向排序\",{\"0\":{\"579\":1}}],[\"监听地址\",{\"1\":{\"574\":2}}],[\"监督是erlang监督树的完整实现\",{\"1\":{\"56\":1}}],[\"退出\",{\"1\":{\"574\":1}}],[\"退出循环\",{\"1\":{\"340\":1}}],[\"签名\",{\"1\":{\"567\":1,\"568\":1}}],[\"签名如下\",{\"1\":{\"298\":1,\"353\":1,\"570\":1,\"571\":1,\"572\":1}}],[\"立方根\",{\"0\":{\"560\":1}}],[\"立体光刻\",{\"1\":{\"51\":1}}],[\"平方根\",{\"0\":{\"559\":1}}],[\"平时在编写代码的时候也可以稍微注意一下\",{\"1\":{\"107\":1}}],[\"幂\",{\"0\":{\"558\":1}}],[\"四舍五入\",{\"0\":{\"555\":1}}],[\"余数\",{\"0\":{\"549\":1}}],[\"初始值\",{\"1\":{\"541\":1}}],[\"初始化一个新的工作区\",{\"1\":{\"383\":1}}],[\"初始化一个map有两种方法\",{\"1\":{\"178\":1}}],[\"初始化操作只执行了一次\",{\"1\":{\"353\":1}}],[\"初始化animal类型的变量\",{\"1\":{\"206\":1}}],[\"初始化的时候就像map一样指定字段名称再初始化字段值\",{\"1\":{\"187\":1}}],[\"初始化\",{\"0\":{\"130\":1,\"158\":1,\"162\":1,\"178\":1,\"211\":1},\"1\":{\"353\":2}}],[\"短文件名称\",{\"1\":{\"541\":1}}],[\"短变量声明方式无法对一个已存在的变量使用\",{\"1\":{\"125\":1}}],[\"短变量声明可以批量初始化\",{\"1\":{\"125\":1}}],[\"短变量初始化不能使用nil\",{\"1\":{\"125\":1}}],[\"短变量初始化\",{\"1\":{\"125\":1}}],[\"性别\",{\"1\":{\"525\":2,\"528\":2}}],[\"性能比直接类型转换要好\",{\"1\":{\"648\":1}}],[\"性能分析的唯一手段就只能通过benchmark来测试某一个功能单元的平均执行耗时\",{\"1\":{\"234\":1}}],[\"性能分析\",{\"0\":{\"234\":1}}],[\"性能分析等功能\",{\"1\":{\"74\":1}}],[\"性能消耗也是一个问题\",{\"1\":{\"151\":1}}],[\"性能上报到prometheus\",{\"1\":{\"41\":1}}],[\"性能上报到influxdb\",{\"1\":{\"41\":2}}],[\"年龄\",{\"1\":{\"525\":2,\"528\":2}}],[\"年金\",{\"1\":{\"52\":1}}],[\"姓名\",{\"1\":{\"525\":2,\"528\":2}}],[\"缩进\",{\"0\":{\"519\":1}}],[\"散列表\",{\"1\":{\"513\":1}}],[\"掘金\",{\"1\":{\"512\":1,\"642\":1}}],[\"感兴趣的可以自行了解\",{\"1\":{\"512\":1}}],[\"感兴趣可以去看看这里的源码实现\",{\"1\":{\"603\":1}}],[\"感兴趣可以前往toml\",{\"1\":{\"509\":1}}],[\"感兴趣可以看看\",{\"1\":{\"307\":1}}],[\"感兴趣可以在github上自行了解\",{\"1\":{\"254\":1}}],[\"逐渐正在被新的标记语言替代\",{\"1\":{\"510\":1}}],[\"逐渐成为现代云计算\",{\"1\":{\"89\":1}}],[\"低廉的学习成本使其在web领域称为了主流的数据交换格式\",{\"1\":{\"516\":1}}],[\"低\",{\"1\":{\"509\":4}}],[\"低级的结构\",{\"1\":{\"43\":1}}],[\"学习成本\",{\"1\":{\"509\":1}}],[\"快\",{\"1\":{\"509\":1}}],[\"快速开始\",{\"0\":{\"443\":1,\"615\":1}}],[\"快速编译\",{\"1\":{\"83\":1}}],[\"快速且高效的语言\",{\"1\":{\"67\":1}}],[\"快速可靠的arq协议\",{\"1\":{\"64\":1}}],[\"快速自动关键字提取算法\",{\"1\":{\"63\":1}}],[\"快速自然语言检测程序包\",{\"1\":{\"63\":1}}],[\"快速人工神经网络\",{\"1\":{\"61\":1}}],[\"快速\",{\"1\":{\"61\":1,\"64\":1}}],[\"快速和可扩展的rpc库\",{\"1\":{\"47\":1}}],[\"快速内存键\",{\"1\":{\"46\":1}}],[\"快速的环形缓冲区双端队列\",{\"1\":{\"46\":1}}],[\"慢\",{\"1\":{\"509\":1}}],[\"较多\",{\"1\":{\"509\":1}}],[\"较复杂\",{\"1\":{\"509\":1}}],[\"较简单\",{\"1\":{\"509\":2}}],[\"处于实验阶段\",{\"1\":{\"508\":1}}],[\"处理加密的包\",{\"1\":{\"508\":1}}],[\"处理编码的包\",{\"1\":{\"508\":1}}],[\"处理文件路径的包\",{\"1\":{\"508\":1}}],[\"处理文件和文件系统的库\",{\"1\":{\"39\":1}}],[\"处理斜杠分隔路径的包\",{\"1\":{\"508\":1}}],[\"处理\",{\"0\":{\"312\":1}}],[\"处理器\",{\"1\":{\"51\":1}}],[\"压缩算法实现的包\",{\"1\":{\"508\":1}}],[\"环的实现\",{\"1\":{\"508\":1}}],[\"环境引用吗\",{\"1\":{\"201\":1}}],[\"伪随机包\",{\"1\":{\"508\":1}}],[\"伪版本号则可以细化到指定某一个commit\",{\"1\":{\"378\":1}}],[\"伪版本\",{\"1\":{\"378\":1}}],[\"排序操作包\",{\"1\":{\"508\":1}}],[\"功能也十分强大\",{\"1\":{\"508\":1}}],[\"功能类似的还有t\",{\"1\":{\"390\":1}}],[\"订阅指定频道\",{\"1\":{\"486\":1}}],[\"订阅平台\",{\"1\":{\"47\":1}}],[\"验证对应哈希值的脚本是否存在\",{\"1\":{\"485\":1}}],[\"验证项目的依赖合法性\",{\"1\":{\"375\":1}}],[\"杀死当前正在运行的脚本\",{\"1\":{\"485\":1}}],[\"脚本\",{\"0\":{\"485\":1}}],[\"元素排名\",{\"0\":{\"481\":1}}],[\"元素是可比较类型的数组\",{\"1\":{\"128\":1}}],[\"移动元素\",{\"0\":{\"476\":1}}],[\"弹出并删除n给元素\",{\"1\":{\"475\":1}}],[\"弹出并删除该元素\",{\"1\":{\"475\":1}}],[\"往有序集合中加入元素\",{\"1\":{\"480\":1}}],[\"往一个集合里面添加元素\",{\"1\":{\"472\":1}}],[\"往go\",{\"1\":{\"383\":1}}],[\"保存大小\",{\"1\":{\"509\":1}}],[\"保存方式\",{\"1\":{\"509\":1}}],[\"保留指定范围的元素\",{\"1\":{\"470\":1}}],[\"保证了数据的正确性\",{\"1\":{\"350\":1}}],[\"保证与2\",{\"1\":{\"63\":1}}],[\"保证与版本50\",{\"1\":{\"63\":1}}],[\"右边弹出元素\",{\"1\":{\"469\":1}}],[\"右边添加\",{\"1\":{\"467\":1}}],[\"左边弹出元素\",{\"1\":{\"469\":1}}],[\"左边添加\",{\"1\":{\"467\":1}}],[\"批量访问\",{\"1\":{\"460\":1}}],[\"批量设置\",{\"1\":{\"460\":1}}],[\"批量存取\",{\"0\":{\"457\":1}}],[\"批量声明常量可以用\",{\"1\":{\"130\":1}}],[\"扫描\",{\"0\":{\"454\":1}}],[\"扫描从os\",{\"1\":{\"143\":1}}],[\"秒\",{\"1\":{\"444\":3,\"629\":2}}],[\"协议中立\",{\"1\":{\"521\":1}}],[\"协议\",{\"1\":{\"441\":1}}],[\"协程并发执行的的顺序更加可控\",{\"1\":{\"341\":1}}],[\"协程对于管道的操作是同步的\",{\"1\":{\"334\":1}}],[\"协程是并发执行的\",{\"1\":{\"331\":1}}],[\"协程这一概念并非go首次提出\",{\"1\":{\"331\":1}}],[\"协程\",{\"0\":{\"331\":1},\"1\":{\"240\":1,\"331\":1}}],[\"协程状态\",{\"1\":{\"234\":1}}],[\"遵守\",{\"1\":{\"441\":1}}],[\"遵循上述的规范\",{\"1\":{\"386\":1}}],[\"遵循最小版本选择原则\",{\"1\":{\"377\":1}}],[\"赵六\",{\"1\":{\"437\":1}}],[\"广州市\",{\"1\":{\"436\":1}}],[\"李四\",{\"1\":{\"436\":1,\"528\":2}}],[\"王五\",{\"1\":{\"434\":1}}],[\"北京市\",{\"1\":{\"434\":1}}],[\"张三\",{\"1\":{\"434\":1,\"525\":2,\"528\":3}}],[\"聚合操作会用到mongo\",{\"1\":{\"429\":1}}],[\"聚合\",{\"0\":{\"429\":1}}],[\"此操作会先查询文档再进行修改文档\",{\"1\":{\"427\":1}}],[\"此时再使用该值去创建指针就会引发panic\",{\"1\":{\"643\":1}}],[\"此时再次查看go\",{\"1\":{\"372\":1}}],[\"此时输出\",{\"1\":{\"518\":1}}],[\"此时重复加锁解锁都会导致死锁\",{\"1\":{\"348\":1}}],[\"此时访问到的count值为1\",{\"1\":{\"348\":1}}],[\"此时管道还未初始化\",{\"1\":{\"332\":1}}],[\"此时文件内容如下\",{\"1\":{\"321\":1}}],[\"此时打开浏览器访问http\",{\"1\":{\"243\":1}}],[\"此时就需要用括号将返回值围起来\",{\"1\":{\"199\":1}}],[\"位数\",{\"1\":{\"589\":1,\"591\":1,\"592\":1}}],[\"位运算操作包\",{\"1\":{\"508\":1}}],[\"位于bson\",{\"1\":{\"422\":1}}],[\"位整型\",{\"1\":{\"116\":8}}],[\"早期有些社区维护的库\",{\"1\":{\"419\":1}}],[\"早期go提供的内置min\",{\"1\":{\"128\":1}}],[\"驱动对应的方法都也差不多会了\",{\"1\":{\"446\":1}}],[\"驱动内部维护着一个连接池\",{\"1\":{\"446\":1}}],[\"驱动名称就是注册驱动时使用的名称\",{\"1\":{\"433\":1}}],[\"驱动可以是你自己写的\",{\"1\":{\"432\":1}}],[\"驱动examples目录下有着相当多的使用示例\",{\"1\":{\"422\":1}}],[\"驱动\",{\"0\":{\"419\":1}}],[\"松散的结构可以存储不同类型的数据\",{\"1\":{\"418\":1}}],[\"匹配某一字段\",{\"1\":{\"415\":1}}],[\"匹配引擎的限价订单在golang\",{\"1\":{\"52\":1}}],[\"连接池最多等待这个拿出去的连接多长时间\",{\"1\":{\"444\":1}}],[\"连接配置\",{\"0\":{\"444\":1}}],[\"连接到数据库\",{\"0\":{\"433\":1}}],[\"连接\",{\"0\":{\"404\":1,\"421\":1}}],[\"连接和发送\",{\"1\":{\"48\":1}}],[\"待定\",{\"1\":{\"398\":1,\"402\":1,\"418\":1,\"431\":1,\"441\":1,\"488\":1,\"490\":1,\"492\":1,\"494\":1,\"496\":1,\"498\":1}}],[\"待测试函数只有一行输出时\",{\"1\":{\"389\":1}}],[\"究其原因在于go在字符串单位是字节\",{\"1\":{\"396\":1}}],[\"�\",{\"1\":{\"396\":4}}],[\"𐑄\",{\"1\":{\"396\":7}}],[\"取反运算\",{\"1\":{\"620\":1}}],[\"取整\",{\"0\":{\"552\":1}}],[\"取消过期时间\",{\"0\":{\"450\":1},\"1\":{\"450\":1}}],[\"取消的流程除了要额外的关闭timer之外\",{\"1\":{\"347\":1}}],[\"取其中一条数据如下\",{\"1\":{\"395\":1}}],[\"临界区间通常为0\",{\"1\":{\"395\":1}}],[\"临时对象\",{\"1\":{\"354\":1}}],[\"临时对象池\",{\"1\":{\"354\":1}}],[\"临时文件\",{\"1\":{\"319\":1,\"379\":1}}],[\"样本的显著性水平\",{\"1\":{\"395\":1}}],[\"²\",{\"1\":{\"395\":6}}],[\"¹\",{\"1\":{\"395\":41}}],[\"∞\",{\"1\":{\"395\":38}}],[\"±\",{\"1\":{\"395\":38}}],[\"│\",{\"1\":{\"395\":21}}],[\"像一些比较高级的操作比如cluster\",{\"1\":{\"416\":1}}],[\"像上述的例子肯定是无法正常进行的\",{\"1\":{\"392\":1}}],[\"像下面的代码就无法通过编译\",{\"1\":{\"197\":1}}],[\"像下面这样的代码是无法通过编译的\",{\"1\":{\"128\":1}}],[\"像下面这样\",{\"1\":{\"106\":1,\"108\":1,\"111\":1}}],[\"起源于20世纪60年代\",{\"1\":{\"510\":1}}],[\"起到文档作用\",{\"1\":{\"389\":1}}],[\"起重机b\",{\"1\":{\"212\":1}}],[\"起重机a\",{\"1\":{\"212\":1}}],[\"起重机接口\",{\"1\":{\"212\":1}}],[\"统计锁竞争情况并写入文件\",{\"1\":{\"388\":1}}],[\"统计内存分配情况并写入文件\",{\"1\":{\"388\":1}}],[\"统计cpu情况并写入文件\",{\"1\":{\"388\":1}}],[\"统计覆盖率测试的情况并写入文件\",{\"1\":{\"388\":1}}],[\"统计测试中协程阻塞情况并写入文件\",{\"1\":{\"388\":1}}],[\"统计基准测试的内存分配\",{\"1\":{\"388\":1}}],[\"统一使用别名any来替代interface\",{\"1\":{\"267\":1}}],[\"跳过regexp匹配的测试用例\",{\"1\":{\"388\":1}}],[\"跳来跳去的很降低代码可读性\",{\"1\":{\"151\":1}}],[\"规则同上\",{\"1\":{\"388\":1}}],[\"规则如下\",{\"1\":{\"93\":1}}],[\"释义\",{\"1\":{\"388\":1}}],[\"释放写锁\",{\"1\":{\"350\":4,\"351\":4}}],[\"释放读锁\",{\"1\":{\"350\":8,\"351\":8}}],[\"释放内存\",{\"1\":{\"229\":1}}],[\"耗时\",{\"1\":{\"387\":1}}],[\"耗时的不确定的\",{\"1\":{\"331\":1}}],[\"养成良好的测试风格\",{\"1\":{\"386\":1}}],[\"避免的冗杂的其他信息\",{\"1\":{\"391\":1}}],[\"避免后续因维护不及时产生bug而造成的心智负担\",{\"1\":{\"385\":1}}],[\"避免了程序员的复杂操作和管理\",{\"1\":{\"69\":1}}],[\"良好的测试可以提前发现程序的中错误\",{\"1\":{\"385\":1}}],[\"了解命令的更多有关信息\",{\"1\":{\"383\":1}}],[\"哈希值\",{\"1\":{\"379\":1}}],[\"哈希表\",{\"0\":{\"459\":1},\"1\":{\"177\":1}}],[\"假如禁用了gosumdb\",{\"1\":{\"379\":1}}],[\"假设t2不大于t1并且两者内存布局等效\",{\"1\":{\"643\":1}}],[\"假设这是一个占用内存很大的结构体\",{\"1\":{\"354\":1}}],[\"假设在上面例子中不是简单的for\",{\"1\":{\"203\":1}}],[\"假设有如下结构体\",{\"1\":{\"192\":1,\"285\":1}}],[\"假设有下面这样一个结构体\",{\"1\":{\"188\":1}}],[\"假设有一桶水\",{\"1\":{\"162\":1}}],[\"撤回版本范围\",{\"1\":{\"378\":1}}],[\"撤回一些版本\",{\"1\":{\"378\":1}}],[\"真正有效的是其后的12位commitid\",{\"1\":{\"378\":1}}],[\"真正的原子操作是由硬件指令层面支持的\",{\"1\":{\"356\":1}}],[\"仓库名\",{\"1\":{\"378\":1}}],[\"仓库名虽然没有什么特别限制\",{\"1\":{\"364\":1}}],[\"域名\",{\"1\":{\"378\":1}}],[\"域套接字\",{\"1\":{\"319\":1}}],[\"官网中还给出了其他几个例子\",{\"1\":{\"377\":1}}],[\"官方给出了几种格式方法\",{\"1\":{\"590\":1}}],[\"官方给出了很明确的定义\",{\"1\":{\"266\":1}}],[\"官方仓库\",{\"1\":{\"441\":1}}],[\"官方聚合示例\",{\"1\":{\"429\":1}}],[\"官方删除示例\",{\"1\":{\"428\":1}}],[\"官方更新示例\",{\"1\":{\"427\":1}}],[\"官方创建实例\",{\"1\":{\"426\":1}}],[\"官方查询示例\",{\"1\":{\"423\":1}}],[\"官方非常详细的演示了如何使用上述四种类型\",{\"1\":{\"422\":1}}],[\"官方并没有映射成go结构体\",{\"1\":{\"409\":1}}],[\"官方分布式搜索和分析引擎\",{\"1\":{\"402\":1}}],[\"官方网址\",{\"1\":{\"402\":1}}],[\"官方也没说干什么用的\",{\"1\":{\"379\":1}}],[\"官方对于模块的定义为\",{\"1\":{\"374\":1}}],[\"官方对于go模块也编写了非常细致的文档\",{\"1\":{\"361\":1}}],[\"官方保证sync\",{\"1\":{\"354\":1}}],[\"官方有一个简单的介绍\",{\"1\":{\"215\":1}}],[\"官方提出了另一种解决办法\",{\"1\":{\"213\":1}}],[\"官方在参考手册中对于接口的定义为\",{\"1\":{\"208\":1}}],[\"官方文档地址\",{\"1\":{\"637\":1}}],[\"官方文档里面称其为pipeline\",{\"1\":{\"621\":1}}],[\"官方文档\",{\"1\":{\"441\":1,\"582\":1,\"594\":1,\"614\":1}}],[\"官方文档也有解释\",{\"1\":{\"168\":1}}],[\"官方文档中零值称为zero\",{\"1\":{\"121\":1}}],[\"官方推出的依赖管理工具\",{\"1\":{\"85\":1}}],[\"框选的表示最终选择的版本\",{\"1\":{\"377\":1}}],[\"框架\",{\"1\":{\"77\":1}}],[\"列出regexp匹配的测试用例\",{\"1\":{\"388\":1}}],[\"列出模块\",{\"1\":{\"375\":1}}],[\"列表\",{\"0\":{\"466\":1},\"1\":{\"46\":1}}],[\"清除脚本缓存\",{\"1\":{\"485\":1}}],[\"清理项目模块\",{\"1\":{\"375\":1}}],[\"清空\",{\"0\":{\"183\":1}}],[\"老版本的项目升级到新版本大概率没法正常运行\",{\"1\":{\"374\":1}}],[\"补丁版本是1\",{\"1\":{\"374\":1}}],[\"定义\",{\"0\":{\"525\":1}}],[\"定义为\",{\"1\":{\"374\":1}}],[\"定义了一系列文件系统的接口\",{\"1\":{\"508\":1}}],[\"定义了一系列基础的io接口\",{\"1\":{\"508\":1}}],[\"定义了代表go编程语言中词法标记以及基本操作标记\",{\"1\":{\"43\":1}}],[\"定义了数据库驱动所需实现的接口\",{\"1\":{\"43\":1}}],[\"安装依赖\",{\"1\":{\"521\":1}}],[\"安装\",{\"0\":{\"420\":1,\"442\":1}}],[\"安装命令行\",{\"0\":{\"373\":1}}],[\"安全关闭\",{\"1\":{\"64\":1}}],[\"安全地读取\",{\"1\":{\"62\":1}}],[\"安全和低延迟的发布\",{\"1\":{\"47\":1}}],[\"安全的原始类型转换和从复杂结构中获取值\",{\"1\":{\"46\":1}}],[\"安全的类型转换包\",{\"1\":{\"41\":1}}],[\"七牛云\",{\"1\":{\"370\":1}}],[\"七个因条件变量而阻塞的读协程都恢复了运行\",{\"1\":{\"351\":1}}],[\"推送完毕后\",{\"1\":{\"368\":1}}],[\"推荐下面这些开源项目\",{\"1\":{\"250\":1}}],[\"推荐使用make来创建一个空切片\",{\"1\":{\"162\":1}}],[\"准备三个文件\",{\"1\":{\"628\":1}}],[\"准备数据\",{\"0\":{\"434\":1}}],[\"准备\",{\"0\":{\"363\":1}}],[\"准确的来说\",{\"1\":{\"307\":1}}],[\"符合语义化版本规范\",{\"1\":{\"362\":1}}],[\"符号与参数必须相隔一个空格\",{\"1\":{\"617\":1}}],[\"符号\",{\"1\":{\"617\":1}}],[\"符号来消除参数前后的空白\",{\"1\":{\"617\":1}}],[\"符号衔接变量名就可以在模板中访问对应的值\",{\"1\":{\"617\":1}}],[\"符号链接\",{\"1\":{\"319\":1}}],[\"符号之间的间隔会显得更紧凑\",{\"1\":{\"110\":1}}],[\"源代码仓库可公开访问\",{\"1\":{\"362\":1}}],[\"源代码如下\",{\"1\":{\"353\":1}}],[\"版本号\",{\"1\":{\"378\":1,\"379\":1}}],[\"版本号必须遵循语义化规则\",{\"1\":{\"378\":1}}],[\"版本选择\",{\"0\":{\"377\":1}}],[\"版本控制系统\",{\"1\":{\"362\":1}}],[\"版本混乱\",{\"1\":{\"361\":1}}],[\"淘汰掉了曾经老旧的工具\",{\"1\":{\"361\":1}}],[\"期望的结果是4ex\",{\"1\":{\"396\":1}}],[\"期望值\",{\"1\":{\"359\":2}}],[\"期间也不乏出现了一些佼佼者例如vendor\",{\"1\":{\"361\":1}}],[\"局面一时间混乱了起来\",{\"1\":{\"361\":1}}],[\"模板文件\",{\"0\":{\"628\":1}}],[\"模板中也支持这样的写法\",{\"1\":{\"621\":1}}],[\"模板自身的语法其实并不多\",{\"1\":{\"620\":1}}],[\"模板语法支持注释\",{\"1\":{\"618\":1}}],[\"模板语法\",{\"0\":{\"616\":1}}],[\"模式测试运行的最小时间\",{\"1\":{\"388\":1}}],[\"模糊测试将会永远的运行下去\",{\"1\":{\"396\":1}}],[\"模糊测试中失败的用例会输出到当前测试文件夹下的testdata目录下的某个语料文件中\",{\"1\":{\"396\":1}}],[\"模糊测试的好处在于\",{\"1\":{\"396\":1}}],[\"模糊测试是go1\",{\"1\":{\"396\":1}}],[\"模糊测试是fuzzxxxx\",{\"1\":{\"386\":1}}],[\"模糊测试自动结束的时间\",{\"1\":{\"388\":1}}],[\"模糊测试\",{\"0\":{\"396\":1},\"1\":{\"385\":1,\"387\":1}}],[\"模块名\",{\"1\":{\"378\":1}}],[\"模块b的1\",{\"1\":{\"377\":1}}],[\"模块缓存默认存放在$gopath\",{\"1\":{\"376\":1}}],[\"模块存储\",{\"0\":{\"376\":1}}],[\"模块管理\",{\"0\":{\"374\":1}}],[\"模块而生\",{\"1\":{\"370\":1}}],[\"模块的编写就完成了\",{\"1\":{\"368\":1}}],[\"模块\",{\"0\":{\"361\":1}}],[\"模拟计算耗时\",{\"1\":{\"348\":1,\"349\":1}}],[\"模拟访问耗时\",{\"1\":{\"348\":1,\"349\":1}}],[\"模拟随机耗时\",{\"1\":{\"331\":1}}],[\"涉及到的操作并不复杂\",{\"1\":{\"359\":1}}],[\"乐观锁本身并不是锁\",{\"1\":{\"359\":1}}],[\"增加一段时间间隔\",{\"1\":{\"629\":1}}],[\"增加秒\",{\"1\":{\"629\":1}}],[\"增加\",{\"1\":{\"358\":2}}],[\"增值税号验证和欧盟增值税率\",{\"1\":{\"52\":1}}],[\"池中的对象可能会在没有任何通知的情况下被gc移除\",{\"1\":{\"354\":1}}],[\"采用对象池后\",{\"1\":{\"354\":1}}],[\"采集trace的数据也是同样如此\",{\"1\":{\"242\":1}}],[\"采集cpu数据需要单独使用\",{\"1\":{\"242\":1}}],[\"采集\",{\"0\":{\"241\":1}}],[\"采集数据\",{\"1\":{\"240\":1}}],[\"申请一个打印缓冲区\",{\"1\":{\"354\":1}}],[\"申请一个对象\",{\"1\":{\"354\":1}}],[\"申请对象\",{\"1\":{\"354\":1}}],[\"放入一个对象\",{\"1\":{\"354\":1}}],[\"判断两个时间是否表示同一瞬间\",{\"1\":{\"629\":1}}],[\"判断字符串s内是否包含字符r\",{\"1\":{\"598\":1}}],[\"判断字符串chars内任意字符的unicode码是否在字符串s内\",{\"1\":{\"598\":1}}],[\"判断字段是否存在\",{\"1\":{\"462\":1}}],[\"判断一个时间是否在它之前\",{\"1\":{\"629\":1}}],[\"判断一个时间是否在它之后\",{\"1\":{\"629\":1}}],[\"判断一个字符串s是不是包含一个子串substr\",{\"1\":{\"598\":1}}],[\"判断一个切片是否有序\",{\"1\":{\"581\":1}}],[\"判断一个元素是否属于这个集合\",{\"1\":{\"473\":1}}],[\"判断键是否存在\",{\"0\":{\"462\":1}}],[\"判断是否执行\",{\"1\":{\"353\":1}}],[\"判为完全相等\",{\"1\":{\"298\":1}}],[\"唤醒所有因条件变量阻塞的协程\",{\"1\":{\"351\":1}}],[\"唤醒所有因条件阻塞的协程\",{\"1\":{\"351\":1}}],[\"唤醒一个因条件阻塞的协程\",{\"1\":{\"351\":1}}],[\"唤醒通知\",{\"1\":{\"57\":1}}],[\"条件语句的格式如下所示\",{\"1\":{\"623\":1}}],[\"条件\",{\"0\":{\"623\":1}}],[\"条件不满足就一直阻塞\",{\"1\":{\"351\":1}}],[\"条件变量使用起来非常简单\",{\"1\":{\"351\":1}}],[\"条件变量\",{\"0\":{\"351\":1},\"1\":{\"351\":2}}],[\"条件控制语句总共有三种if\",{\"1\":{\"146\":1}}],[\"条件控制\",{\"0\":{\"146\":1}}],[\"获得写锁的时候\",{\"1\":{\"350\":1}}],[\"获取目标指定索引的元素\",{\"1\":{\"620\":1}}],[\"获取模板\",{\"1\":{\"615\":1}}],[\"获取连接\",{\"1\":{\"574\":1}}],[\"获取前缀\",{\"1\":{\"540\":1}}],[\"获取集合中的所有成员\",{\"1\":{\"473\":1}}],[\"获取map长度\",{\"1\":{\"464\":1}}],[\"获取哈希表键长度\",{\"0\":{\"464\":1}}],[\"获取所有的map的键\",{\"1\":{\"463\":1}}],[\"获取所有的键\",{\"0\":{\"463\":1}}],[\"获取整个map\",{\"1\":{\"460\":1}}],[\"获取若干个索引的信息\",{\"1\":{\"407\":1}}],[\"获取\",{\"0\":{\"407\":1,\"412\":1}}],[\"获取结构体反射类型\",{\"1\":{\"289\":2,\"290\":1}}],[\"获取到structfield后\",{\"1\":{\"288\":1}}],[\"获取该指针所指向的元素\",{\"1\":{\"287\":1}}],[\"获取一个集合的元素个数\",{\"1\":{\"473\":1}}],[\"获取一个指定id的文档\",{\"1\":{\"412\":1}}],[\"获取一个私有字段\",{\"1\":{\"287\":1}}],[\"获取一个反射值的指针方式有两种\",{\"1\":{\"279\":1}}],[\"获取一个反射值的元素反射值\",{\"1\":{\"278\":1}}],[\"获取字段\",{\"1\":{\"287\":1}}],[\"获取函数的反射值\",{\"1\":{\"284\":1}}],[\"获取值\",{\"0\":{\"281\":1}}],[\"获取指针指向的元素\",{\"1\":{\"280\":1}}],[\"获取汇率\",{\"1\":{\"52\":1}}],[\"成功加锁会返回true\",{\"1\":{\"350\":1}}],[\"父级取消\",{\"1\":{\"346\":4}}],[\"父协程早已完成的函数的执行\",{\"1\":{\"315\":1}}],[\"父协程善后工作要花费20ms\",{\"1\":{\"315\":1}}],[\"父协程阻塞等待子协程执行完毕\",{\"1\":{\"315\":1}}],[\"尝试直接从版本控制系统中下载\",{\"1\":{\"380\":1}}],[\"尝试加写锁\",{\"1\":{\"350\":1}}],[\"尝试加读锁\",{\"1\":{\"350\":1}}],[\"尝试将自身添加进父级的children中\",{\"1\":{\"346\":1}}],[\"尝试修改字符串元素\",{\"1\":{\"172\":1}}],[\"逻辑也很简单\",{\"1\":{\"345\":1}}],[\"顾名思义\",{\"1\":{\"344\":1,\"353\":1}}],[\"计数完全无法作用到真正的waitgroup上\",{\"1\":{\"341\":1}}],[\"计数10\",{\"1\":{\"341\":1}}],[\"计数就\",{\"1\":{\"341\":1}}],[\"计算相对路径\",{\"1\":{\"329\":1}}],[\"计算所有数字类型的两数之和\",{\"1\":{\"256\":1}}],[\"计算并重新排布结构体字段来最小化结构体占用的内存\",{\"1\":{\"192\":1}}],[\"计算大型文件的消息摘要\",{\"1\":{\"51\":1}}],[\"计算机\",{\"2\":{\"15\":1,\"17\":1}}],[\"属于是单元测试和基准测试的一种增强\",{\"1\":{\"396\":1}}],[\"属于开箱即用\",{\"1\":{\"341\":1}}],[\"属于空间换时间的一种手段\",{\"1\":{\"192\":1}}],[\"永久阻塞\",{\"1\":{\"340\":1}}],[\"永远也不会执行\",{\"1\":{\"345\":1}}],[\"永远也不会被执行\",{\"1\":{\"340\":1}}],[\"永远也不会退出\",{\"1\":{\"152\":1}}],[\"永远也无法精准的预判到它到底会输出什么\",{\"1\":{\"331\":1}}],[\"永远都是以return关键字后的值为最高优先级\",{\"1\":{\"199\":1}}],[\"超时\",{\"1\":{\"340\":2}}],[\"超时过后便会退出循环\",{\"1\":{\"340\":1}}],[\"告诉主协程可以退出了\",{\"1\":{\"340\":1}}],[\"箭头符号<\",{\"1\":{\"338\":2}}],[\"满了\",{\"1\":{\"337\":1}}],[\"阻塞等待下一个连接建立\",{\"1\":{\"574\":1}}],[\"阻塞等待函数f执行完毕后才会返回\",{\"1\":{\"392\":1}}],[\"阻塞等待条件生效\",{\"1\":{\"351\":1}}],[\"阻塞等待其他协程来读取数据\",{\"1\":{\"337\":1}}],[\"阻塞等待其他协程写入数据\",{\"1\":{\"337\":1}}],[\"阻塞等待读取\",{\"1\":{\"336\":1}}],[\"才能真正发挥unsafe包的真正威力\",{\"1\":{\"643\":1}}],[\"才能进行加法运算\",{\"1\":{\"304\":1}}],[\"才会生成该文件\",{\"1\":{\"379\":1}}],[\"才会考虑去初始化\",{\"1\":{\"353\":2}}],[\"才会阻塞的等待协程来向管道中写入数据\",{\"1\":{\"336\":1}}],[\"译为管道\",{\"1\":{\"332\":1}}],[\"幸运的是go提供了非常多的并发控制手段\",{\"1\":{\"331\":1}}],[\"暂停1ms\",{\"1\":{\"331\":1}}],[\"情况如下\",{\"1\":{\"331\":2}}],[\"情况就不同了\",{\"1\":{\"206\":1}}],[\"主版本号要体现在模块名中\",{\"1\":{\"378\":1}}],[\"主版本号是1\",{\"1\":{\"374\":1}}],[\"主模块引用了模块a的1\",{\"1\":{\"377\":1}}],[\"主协程会等待子协程执行完毕后再退出\",{\"1\":{\"341\":1}}],[\"主协程会一直阻塞\",{\"1\":{\"340\":1}}],[\"主协程调用wait\",{\"1\":{\"341\":1}}],[\"主协程就已经结束了\",{\"1\":{\"331\":1}}],[\"主协程早已运行结束\",{\"1\":{\"331\":1}}],[\"主要使用的有如下函数\",{\"1\":{\"516\":1}}],[\"主要方法\",{\"1\":{\"513\":1}}],[\"主要用于实现程序的优雅关闭\",{\"1\":{\"508\":1}}],[\"主要是写测试的时候用\",{\"1\":{\"508\":1}}],[\"主要是拿来给工具分析用的\",{\"1\":{\"243\":1}}],[\"主要是为了及时止损\",{\"1\":{\"313\":1}}],[\"主要是为了减轻gc压力\",{\"1\":{\"239\":1}}],[\"主要是为了解决切片共享底层数组的读写问题\",{\"1\":{\"169\":1}}],[\"主要格式为如下\",{\"1\":{\"169\":1}}],[\"主要分为单精度浮点数与双精度浮点数\",{\"1\":{\"117\":1}}],[\"主要分为无符号整型与有符号整型\",{\"1\":{\"116\":1}}],[\"遇到文件就创建新文件并复制\",{\"1\":{\"329\":1}}],[\"遇到文件夹就创建文件夹\",{\"1\":{\"329\":1}}],[\"检查源文件夹的状态\",{\"1\":{\"329\":1}}],[\"检查错误链中是否有\",{\"1\":{\"312\":1}}],[\"刷盘\",{\"1\":{\"325\":1}}],[\"刷新\",{\"0\":{\"325\":1}}],[\"向上取整\",{\"0\":{\"554\":1}}],[\"向下取整\",{\"0\":{\"553\":1}}],[\"向集合users插入如下数据\",{\"1\":{\"423\":1}}],[\"向对象池申请的一个对象\",{\"1\":{\"354\":1}}],[\"向a管道写入数据\",{\"1\":{\"340\":1}}],[\"向文件写入字节切片也是类似的操作\",{\"1\":{\"321\":1}}],[\"向切片添加完元素后必须覆盖原切片\",{\"1\":{\"206\":1}}],[\"继续读取文件\",{\"1\":{\"320\":1}}],[\"继承\",{\"1\":{\"212\":1}}],[\"继承等传统的\",{\"1\":{\"84\":1}}],[\"扩容\",{\"1\":{\"320\":1}}],[\"扩展和管理容器化应用\",{\"1\":{\"85\":1}}],[\"针对指定索引对文本字符串进行分析\",{\"1\":{\"408\":1}}],[\"针对协程介绍中最开始的例子\",{\"1\":{\"341\":1}}],[\"针对于第一种方法\",{\"1\":{\"320\":1}}],[\"针对x\",{\"1\":{\"59\":1}}],[\"权限为0666\",{\"1\":{\"319\":1}}],[\"权限位\",{\"1\":{\"319\":1}}],[\"权力游戏库\",{\"1\":{\"53\":1}}],[\"什么是多路复用\",{\"1\":{\"340\":1}}],[\"什么是方法集\",{\"1\":{\"208\":1}}],[\"什么都不会设置\",{\"1\":{\"319\":1}}],[\"黏滞位\",{\"1\":{\"319\":1}}],[\"目录下\",{\"1\":{\"365\":1}}],[\"目录\",{\"1\":{\"319\":1}}],[\"目前支持以下几种测试\",{\"1\":{\"385\":1}}],[\"目前国内做的比较好的有以下几家\",{\"1\":{\"370\":1}}],[\"目前为止已分配的所有内存空间\",{\"1\":{\"246\":1}}],[\"目前已分配的所有对象数量\",{\"1\":{\"246\":1}}],[\"剩余逻辑如下\",{\"1\":{\"320\":1}}],[\"剩余的值用于控制行为\",{\"1\":{\"319\":1}}],[\"剩下的内存全都越界了\",{\"1\":{\"225\":1}}],[\"负责读的协程每次读取之前都会等待1毫秒\",{\"1\":{\"336\":1}}],[\"负责读\",{\"1\":{\"336\":1}}],[\"负责写的协程一口气做多也只能写入5个数据\",{\"1\":{\"336\":1}}],[\"负责写\",{\"1\":{\"336\":1}}],[\"负责os文件系统交互的具体实现\",{\"1\":{\"318\":1}}],[\"负载测试库和命令行工具\",{\"1\":{\"64\":1}}],[\"负载平衡\",{\"1\":{\"47\":1}}],[\"恢复\",{\"0\":{\"316\":1}}],[\"碰巧遇到了子协程发生panic\",{\"1\":{\"315\":1}}],[\"综上所述\",{\"1\":{\"315\":1}}],[\"善后\",{\"0\":{\"315\":1}}],[\"肯定会触发panic\",{\"1\":{\"313\":1}}],[\"记录格式为模块名\",{\"1\":{\"379\":1}}],[\"记录发生错误的时间\",{\"1\":{\"312\":1}}],[\"记得要导入这个包\",{\"1\":{\"243\":1}}],[\"被删除子串位置后面的字符串\",{\"1\":{\"600\":1}}],[\"被删除子串位置前面的字符串\",{\"1\":{\"600\":1}}],[\"被监测的可以是网络请求\",{\"1\":{\"340\":1}}],[\"被包裹的错误可能依旧是一个错误链\",{\"1\":{\"312\":1}}],[\"被转换类型必须是可以被目标类型代表的\",{\"1\":{\"304\":1}}],[\"顺便写一个测试文件进行单元测试\",{\"1\":{\"365\":1}}],[\"顺着链表上寻找\",{\"1\":{\"311\":1}}],[\"顺带一提\",{\"1\":{\"219\":1,\"229\":1}}],[\"层层包装下就形成了一条错误链表\",{\"1\":{\"311\":1}}],[\"抛给上一层调用者\",{\"1\":{\"311\":1}}],[\"传递\",{\"0\":{\"311\":1}}],[\"传入如下数据\",{\"1\":{\"625\":1}}],[\"传入如下的数据\",{\"1\":{\"622\":1,\"627\":1}}],[\"传入数据\",{\"1\":{\"624\":1}}],[\"传入的数据\",{\"1\":{\"623\":1}}],[\"传入的数据如下\",{\"1\":{\"620\":1}}],[\"传入上下文\",{\"1\":{\"345\":1}}],[\"传入包装类型和函数体\",{\"1\":{\"297\":1}}],[\"传入指针\",{\"1\":{\"287\":2}}],[\"传入参数数组\",{\"1\":{\"284\":1}}],[\"确实不应该\",{\"1\":{\"307\":1}}],[\"重复复制字符串\",{\"0\":{\"606\":1}}],[\"重复代码多\",{\"1\":{\"307\":1}}],[\"重定向配置\",{\"1\":{\"532\":1}}],[\"重命名成功\",{\"1\":{\"323\":1}}],[\"重命名也可以理解为移动文件\",{\"1\":{\"323\":1}}],[\"重命名\",{\"0\":{\"323\":1,\"452\":1}}],[\"重量轻\",{\"1\":{\"53\":1}}],[\"丑陋\",{\"1\":{\"307\":1}}],[\"心智负担小\",{\"1\":{\"307\":1}}],[\"凡事都是有好有坏的\",{\"1\":{\"307\":1}}],[\"他们不希望干什么事情都需要嵌套一堆try\",{\"1\":{\"307\":1}}],[\"他们会检查你的源代码中的结构体\",{\"1\":{\"192\":1}}],[\"他们会将参数输出到标准错误中\",{\"1\":{\"137\":1}}],[\"说实话不认真看很难知道这是一个什么类型\",{\"1\":{\"301\":1}}],[\"说明只是有bug被修复了\",{\"1\":{\"374\":1}}],[\"说明项目增加了新的特性\",{\"1\":{\"374\":1}}],[\"说明项目发生了不兼容的改动\",{\"1\":{\"374\":1}}],[\"说明\",{\"1\":{\"40\":1,\"42\":1,\"43\":1,\"45\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"375\":1}}],[\"拿到写锁\",{\"1\":{\"350\":4,\"351\":4}}],[\"拿到读锁\",{\"1\":{\"350\":8,\"351\":8}}],[\"拿到指针所指向元素的反射类型\",{\"1\":{\"271\":1}}],[\"拿官方的一个例子展示效果\",{\"1\":{\"301\":1}}],[\"尽管可以存储任意类型\",{\"1\":{\"360\":1}}],[\"尽管可以顺利运行\",{\"1\":{\"336\":1}}],[\"尽管代码很少\",{\"1\":{\"356\":1}}],[\"尽管上下文到期会自动取消\",{\"1\":{\"347\":1}}],[\"尽管父级cancelctx在取消的同时会取消它的子上下文\",{\"1\":{\"346\":1}}],[\"尽管go中的短变量声明有点类似动态语言的写法\",{\"1\":{\"300\":1}}],[\"尽管它只有三个字段\",{\"1\":{\"192\":1}}],[\"完成文件名称\",{\"1\":{\"541\":1}}],[\"完成后查看go\",{\"1\":{\"372\":1}}],[\"完全相等\",{\"0\":{\"298\":1}}],[\"完整标准库列表\",{\"0\":{\"43\":1},\"1\":{\"39\":1}}],[\"管道操作在模板中经常出现\",{\"1\":{\"621\":1}}],[\"管道可能经过层层传递\",{\"1\":{\"337\":1}}],[\"管道为nil\",{\"1\":{\"337\":1}}],[\"管道中的数据流动方式与队列一样\",{\"1\":{\"334\":1}}],[\"管道更适合协程间通信\",{\"1\":{\"331\":1}}],[\"管道\",{\"0\":{\"296\":1,\"332\":1,\"621\":1},\"1\":{\"331\":1}}],[\"管理可调整大小的上下文感知goroutine池以绑定并发\",{\"1\":{\"56\":1}}],[\"管理gob流\",{\"1\":{\"43\":1}}],[\"构建map反射值\",{\"1\":{\"295\":1}}],[\"构建跨平台gui应用\",{\"1\":{\"57\":1}}],[\"构造指向该结构体未导出字段的指针反射值\",{\"1\":{\"287\":1}}],[\"则从字符串中删除该字符\",{\"1\":{\"605\":1}}],[\"则不会分配内存且返回空字符串\",{\"1\":{\"596\":1}}],[\"则字段名优先以json标签为准\",{\"1\":{\"520\":1}}],[\"则表示关闭这个配置项\",{\"1\":{\"444\":1}}],[\"则说明依赖版本不同\",{\"1\":{\"379\":1}}],[\"则说明该字段不存在\",{\"1\":{\"287\":1}}],[\"则其module指令必须与所替换的模块路径匹配\",{\"1\":{\"378\":1}}],[\"则会同时阻塞读协程和写协程\",{\"1\":{\"350\":1}}],[\"则会panic\",{\"1\":{\"213\":1}}],[\"则读取文件夹下所有的内容\",{\"1\":{\"327\":1}}],[\"则必须以o\",{\"1\":{\"321\":1}}],[\"则必须传入一个结构体指针\",{\"1\":{\"287\":1}}],[\"则需要提供一个io\",{\"1\":{\"320\":1}}],[\"索引\",{\"0\":{\"405\":1},\"1\":{\"286\":1,\"289\":1}}],[\"信号量\",{\"1\":{\"331\":1}}],[\"信号和用户账号等\",{\"1\":{\"40\":1}}],[\"信息\",{\"0\":{\"283\":1}}],[\"返回其字符串表达形式\",{\"1\":{\"648\":1}}],[\"返回其底层数组的其实地址\",{\"1\":{\"645\":1}}],[\"返回\",{\"1\":{\"629\":1}}],[\"返回长度\",{\"1\":{\"620\":1}}],[\"返回字符串\",{\"1\":{\"605\":1}}],[\"返回字符串s和t在忽略大小写情况下是否相等\",{\"1\":{\"601\":1}}],[\"返回最后一次出现的子串任意字符的下标\",{\"1\":{\"604\":1}}],[\"返回最后一次出现的子串的下标\",{\"1\":{\"604\":1}}],[\"返回第一次出现的子串的下标\",{\"1\":{\"604\":3}}],[\"返回1\",{\"1\":{\"597\":1}}],[\"返回切片的长度\",{\"1\":{\"580\":1}}],[\"返回命令行参数的个数\",{\"1\":{\"527\":1}}],[\"返回非命令行参数的个数\",{\"1\":{\"527\":1}}],[\"返回所有非命令参数\",{\"1\":{\"527\":1}}],[\"返回sha值\",{\"1\":{\"485\":1}}],[\"返回介于min和max之间的所有成员列表\",{\"1\":{\"482\":1}}],[\"返回介于min和max之间的成员数量\",{\"1\":{\"482\":1}}],[\"返回指定区间的元素\",{\"1\":{\"482\":1}}],[\"返回指向反射值的指针反射值\",{\"1\":{\"292\":1}}],[\"返回对元素的权值\",{\"1\":{\"482\":1}}],[\"返回有序集合中该元素的排名\",{\"1\":{\"481\":2}}],[\"返回给定集合的并集\",{\"1\":{\"474\":1}}],[\"返回给定集合的交集\",{\"1\":{\"474\":1}}],[\"返回给定集合的差集\",{\"1\":{\"474\":1}}],[\"返回结果集的长度\",{\"1\":{\"474\":3}}],[\"返回false时\",{\"1\":{\"355\":1}}],[\"返回了一个cancelctx和cancel函数\",{\"1\":{\"346\":1}}],[\"返回context和一个函数\",{\"1\":{\"346\":1}}],[\"返回nil\",{\"1\":{\"343\":1}}],[\"返回空字符串\",{\"1\":{\"288\":1}}],[\"返回一个管道\",{\"1\":{\"346\":1}}],[\"返回一个指向v的原始值的unsafe\",{\"1\":{\"279\":1}}],[\"返回一个指向v的原始值的uintptr\",{\"1\":{\"279\":1}}],[\"返回一个指向v的原始值的uinptr\",{\"1\":{\"279\":1}}],[\"返回一个表示v地址的指针反射值\",{\"1\":{\"279\":1}}],[\"返回值为是否通过测试\",{\"1\":{\"392\":1}}],[\"返回值会返回对应的值和该值是否存在\",{\"1\":{\"355\":1}}],[\"返回值的数量\",{\"1\":{\"283\":1}}],[\"返回值类型为int\",{\"1\":{\"197\":1}}],[\"返回值组成\",{\"1\":{\"197\":1}}],[\"返回值\",{\"0\":{\"199\":1},\"1\":{\"197\":1}}],[\"返回值是指针\",{\"1\":{\"525\":1}}],[\"返回值是值\",{\"1\":{\"196\":1}}],[\"返回值是类型指针\",{\"1\":{\"196\":1}}],[\"返回值是添加后的切片\",{\"1\":{\"163\":1}}],[\"核心\",{\"0\":{\"268\":1}}],[\"桥梁\",{\"0\":{\"267\":1}}],[\"静态指的是go所有变量的类型早在编译期间就已经确定了\",{\"1\":{\"300\":1}}],[\"静态强类型\",{\"0\":{\"300\":1}}],[\"静态这一词是体现在对外表现的抽象的接口类型是不变的\",{\"1\":{\"266\":1}}],[\"静态接口类型\",{\"1\":{\"266\":1}}],[\"静态链接库调用成功\",{\"1\":{\"232\":1}}],[\"静态链接库\",{\"0\":{\"232\":1}}],[\"很多\",{\"1\":{\"509\":1}}],[\"很多公司都是基于它进行魔改\",{\"1\":{\"42\":1}}],[\"很显然\",{\"1\":{\"394\":1}}],[\"很生动的表示了数据的流动方向\",{\"1\":{\"334\":1}}],[\"很容易就能找到原始错误\",{\"1\":{\"311\":1}}],[\"很少会出现突然冒出一个错误却不知道是从哪里来的这种情况\",{\"1\":{\"307\":1}}],[\"很严重的问题\",{\"1\":{\"307\":1}}],[\"很大程度上是从c语言吸取了教训\",{\"1\":{\"301\":1}}],[\"很大程度上\",{\"1\":{\"265\":1}}],[\"密切相关\",{\"1\":{\"265\":1}}],[\"事务\",{\"0\":{\"439\":1}}],[\"事实上第一种函数读取的文件仅仅只是只读的\",{\"1\":{\"319\":1}}],[\"事实上当初go1\",{\"1\":{\"264\":1}}],[\"事件循环网络库\",{\"1\":{\"64\":1}}],[\"几个方法实现\",{\"1\":{\"263\":1}}],[\"几乎所有的go语言中的web框架\",{\"1\":{\"529\":1}}],[\"几乎没有原生的c程序调用go这种需求\",{\"1\":{\"219\":1}}],[\"几乎每个程序员都能说出属于自己的理由\",{\"1\":{\"108\":1}}],[\"几乎能在几秒钟内完成整个项目的编译\",{\"1\":{\"73\":1}}],[\"借由上面的那种方式就可以返回泛型零值\",{\"1\":{\"262\":1}}],[\"借助接口和结构体代替传统的类继承机制\",{\"1\":{\"69\":1}}],[\"队列中的元素类型可以是任意的\",{\"1\":{\"262\":1}}],[\"队列\",{\"0\":{\"262\":1}}],[\"带有\",{\"1\":{\"378\":1}}],[\"带有方法集的接口无法并入类型集\",{\"1\":{\"260\":1}}],[\"带有堆栈跟踪和源代码片段的golang错误\",{\"1\":{\"50\":1}}],[\"~\",{\"1\":{\"395\":12}}],[\"~uint64\",{\"1\":{\"259\":1,\"260\":2}}],[\"~uint32\",{\"1\":{\"259\":1,\"260\":2}}],[\"~uint\",{\"1\":{\"259\":1,\"260\":2}}],[\"~uint16\",{\"1\":{\"259\":1,\"260\":2}}],[\"~uint8\",{\"1\":{\"259\":1,\"260\":2}}],[\"~int64\",{\"1\":{\"259\":1,\"260\":2,\"390\":1}}],[\"~int32\",{\"1\":{\"259\":1,\"260\":2,\"390\":1}}],[\"~int\",{\"1\":{\"259\":1,\"260\":2,\"390\":1}}],[\"~int16\",{\"1\":{\"259\":1,\"260\":2,\"390\":1}}],[\"~int8\",{\"1\":{\"259\":1,\"260\":2,\"390\":1}}],[\"~r0\",{\"1\":{\"236\":1,\"237\":1}}],[\"底层类型\",{\"1\":{\"259\":1}}],[\"底层所存储的数据是否相等\",{\"1\":{\"213\":1}}],[\"翻译一下就是s是否包含chars内的任意字符串\",{\"1\":{\"598\":1}}],[\"翻译成人话就是\",{\"1\":{\"259\":1}}],[\"翻译过来就是\",{\"1\":{\"206\":1,\"208\":2}}],[\"交集\",{\"1\":{\"259\":2}}],[\"交换方法\",{\"1\":{\"575\":1,\"580\":1}}],[\"交换值\",{\"1\":{\"358\":2}}],[\"交换\",{\"0\":{\"127\":1}}],[\"既然是集合\",{\"1\":{\"259\":1}}],[\"含有类型集的接口又称为general\",{\"1\":{\"259\":1}}],[\"毫无节制的使用泛型会使得代码难以维护\",{\"1\":{\"256\":1}}],[\"随机返回count个元素\",{\"1\":{\"473\":1}}],[\"随机数据可以更好的测试程序的边界条件\",{\"1\":{\"396\":1}}],[\"随着覆盖范围的不断扩大\",{\"1\":{\"396\":1}}],[\"随后使用compareandswapint64来进行比较交换\",{\"1\":{\"359\":1}}],[\"随后协程b又初始化了一遍\",{\"1\":{\"353\":1}}],[\"随后又花费了400毫秒计算\",{\"1\":{\"348\":1}}],[\"随后当读协程将缓冲区所有数据读取完毕后\",{\"1\":{\"336\":1}}],[\"随之而来的是项目复杂度的增加\",{\"1\":{\"256\":1}}],[\"随便都可以找到\",{\"1\":{\"254\":1}}],[\"约束了类型形参的类型范围\",{\"1\":{\"256\":1}}],[\"形参具体是什么类型取决于传进来什么类型\",{\"1\":{\"256\":1}}],[\"形成一个良好的规范\",{\"1\":{\"206\":1}}],[\"难道要每一个类型都要编写一个函数吗\",{\"1\":{\"256\":1}}],[\"作用\",{\"1\":{\"620\":1}}],[\"作用就是将两个int类型的整数相加并返回结果\",{\"1\":{\"256\":1}}],[\"作为\",{\"1\":{\"402\":1}}],[\"作为map的值类型\",{\"1\":{\"193\":1}}],[\"终于go在1\",{\"1\":{\"255\":1}}],[\"社区里面有很多优秀的第三方模板引擎库\",{\"1\":{\"614\":1}}],[\"社区中有关于go错误处理的提案和讨论自从go诞生以来就从未停止过\",{\"1\":{\"307\":1}}],[\"社区关于go呼声最高的事情就是希望加入泛型\",{\"1\":{\"255\":1}}],[\"社区也非常活跃\",{\"1\":{\"85\":1}}],[\"泛型的加入会导致编译器的工作量增加\",{\"1\":{\"264\":1}}],[\"泛型接口\",{\"1\":{\"260\":1}}],[\"泛型要解决的问题是类型无关的\",{\"1\":{\"258\":1}}],[\"泛型类型无法使用类型断言\",{\"1\":{\"258\":1}}],[\"泛型形参t是不能作为基础类型的\",{\"1\":{\"258\":1}}],[\"泛型不能作为一个类型的基本类型\",{\"1\":{\"258\":1}}],[\"泛型结构注意点\",{\"0\":{\"258\":1}}],[\"泛型结构\",{\"0\":{\"257\":1}}],[\"泛型是为了解决执行逻辑与类型无关的问题\",{\"1\":{\"256\":1}}],[\"泛型\",{\"0\":{\"255\":1}}],[\"入门的最佳选择\",{\"1\":{\"253\":1}}],[\"入口函数是main函数\",{\"1\":{\"91\":1}}],[\"入口文件都必须声明为main包\",{\"1\":{\"91\":1}}],[\"光是阅读它们的源代码就需要花费不少时间\",{\"1\":{\"253\":1}}],[\"光学字符识别\",{\"1\":{\"61\":1}}],[\"游戏服务器\",{\"0\":{\"252\":1}}],[\"游戏开发相关库\",{\"1\":{\"39\":1}}],[\"游戏开发\",{\"0\":{\"53\":1},\"1\":{\"39\":1}}],[\"经验丰富的人可能几天就上手了\",{\"1\":{\"248\":1}}],[\"经过cgo包裹了一下就成了go数组\",{\"1\":{\"225\":1}}],[\"展示最近gc的最大耗时\",{\"1\":{\"247\":1}}],[\"展示每组主函数的协程相关统计信息\",{\"1\":{\"247\":1}}],[\"虚线代表着略过了一些调用链\",{\"1\":{\"246\":1}}],[\"线越粗\",{\"1\":{\"246\":1}}],[\"线程池golang\",{\"1\":{\"56\":1}}],[\"线程安全的布隆过滤器\",{\"1\":{\"46\":1}}],[\"占用越高\",{\"1\":{\"246\":2}}],[\"占了一行的位置\",{\"1\":{\"131\":1}}],[\"块的颜色越深\",{\"1\":{\"246\":1}}],[\"块与块之间的变量相互独立\",{\"1\":{\"129\":1}}],[\"正则表达式包\",{\"1\":{\"508\":1}}],[\"正在处理http请求\",{\"1\":{\"346\":6}}],[\"正在使用的内存空间\",{\"1\":{\"246\":1}}],[\"正在使用的对象数量\",{\"1\":{\"246\":1}}],[\"正因为无缓冲管道无法存放数据\",{\"1\":{\"335\":1}}],[\"正因如此\",{\"1\":{\"307\":1}}],[\"正常来说输出结果应该是10\",{\"1\":{\"617\":1}}],[\"正常情况下每一个依赖都会有两条记录\",{\"1\":{\"379\":1}}],[\"正常逻辑\",{\"1\":{\"317\":1}}],[\"正常的流程出错\",{\"1\":{\"307\":1}}],[\"正确结果也确实是10\",{\"1\":{\"348\":1}}],[\"正确来说应该开启一个新的协程来发送数据\",{\"1\":{\"335\":1}}],[\"正确方式\",{\"1\":{\"206\":1}}],[\"正确示例\",{\"1\":{\"108\":1,\"158\":1}}],[\"正确\",{\"1\":{\"98\":2}}],[\"火焰图\",{\"1\":{\"246\":1}}],[\"免去了我们手动操作命令行\",{\"1\":{\"246\":1}}],[\"网页中总共有6个可查看的项\",{\"1\":{\"246\":1}}],[\"网页分析可以可视化结果\",{\"1\":{\"246\":1}}],[\"网页\",{\"0\":{\"246\":1}}],[\"网络类型\",{\"1\":{\"444\":1}}],[\"网络编程\",{\"0\":{\"251\":1,\"574\":1}}],[\"网络编程等领域的主流语言之一\",{\"1\":{\"89\":1}}],[\"网络io的时候建议使用这个包\",{\"1\":{\"139\":1}}],[\"网络服务与\",{\"0\":{\"77\":1}}],[\"网络墨卡托utm\",{\"1\":{\"54\":1}}],[\"网络\",{\"0\":{\"64\":1},\"1\":{\"39\":1}}],[\"互斥量总是悲观的认为共享数据肯定会被修改\",{\"1\":{\"359\":1}}],[\"互斥锁适合读操作与写操作频率都差不多的情况\",{\"1\":{\"350\":1}}],[\"互斥锁\",{\"0\":{\"349\":1},\"1\":{\"331\":1}}],[\"互斥锁相关信息的跟踪\",{\"1\":{\"243\":1}}],[\"互联网出口\",{\"1\":{\"64\":1}}],[\"页面中有几个可供选择的选项\",{\"1\":{\"243\":1}}],[\"手动创建的一个只读或只写的管道没有什么太大的意义\",{\"1\":{\"338\":1}}],[\"手动指定了int类型\",{\"1\":{\"256\":1}}],[\"手动采集就是通过代码来控制\",{\"1\":{\"242\":1}}],[\"手动\",{\"0\":{\"242\":1}}],[\"各种配置文件\",{\"1\":{\"513\":1}}],[\"各种概率分布及相关方法\",{\"1\":{\"61\":1}}],[\"各大社区开发者百家争鸣\",{\"1\":{\"361\":1}}],[\"各有优劣\",{\"1\":{\"241\":1}}],[\"锁的意义在于保护不变量\",{\"1\":{\"348\":1}}],[\"锁\",{\"0\":{\"348\":1},\"1\":{\"240\":1}}],[\"涵盖了cpu\",{\"1\":{\"240\":1}}],[\"涵盖了代码格式化\",{\"1\":{\"74\":1}}],[\"毕竟gc诞生的目的就是为了解放开发者\",{\"1\":{\"239\":1}}],[\"把es学会了\",{\"1\":{\"416\":1}}],[\"把内存分配控制的这么细\",{\"1\":{\"239\":1}}],[\"把动态库放到exe的同级目录下\",{\"1\":{\"231\":1}}],[\"便会退出循环\",{\"1\":{\"339\":1}}],[\"便会发生逃逸现象\",{\"1\":{\"239\":1}}],[\"便可以进行读取操作了\",{\"1\":{\"320\":1}}],[\"便可以直接访问其tag\",{\"1\":{\"288\":1}}],[\"便需要用到reflect\",{\"1\":{\"268\":1}}],[\"便携式\",{\"1\":{\"49\":1}}],[\"栈空间不足时\",{\"1\":{\"238\":1}}],[\"导致原因是因为返回值包含了函数内的局部指针\",{\"1\":{\"236\":1}}],[\"导入了fmt包\",{\"1\":{\"96\":1}}],[\"导入的语法就是import加上包名\",{\"1\":{\"94\":1}}],[\"导入一个包就是导入这个包的所有公有的类型\",{\"1\":{\"94\":1}}],[\"导入\",{\"0\":{\"94\":1,\"523\":1,\"583\":1,\"595\":1}}],[\"禁用内联优化\",{\"1\":{\"236\":1}}],[\"禁止指针运算\",{\"0\":{\"195\":1}}],[\"人工分析就不是那么的轻松了\",{\"1\":{\"236\":1}}],[\"引用\",{\"0\":{\"369\":1}}],[\"引用局部指针\",{\"0\":{\"236\":1}}],[\"引入互斥锁会极大的降低性能\",{\"1\":{\"185\":1}}],[\"引入了泛型\",{\"1\":{\"84\":1}}],[\"逃逸分析便是要分析程序中的内存分配情况\",{\"1\":{\"235\":1}}],[\"逃逸分析\",{\"0\":{\"235\":1}}],[\"好在大多情况下并不需要自行编写汇编\",{\"1\":{\"357\":1}}],[\"好在go工具链集成了许多性能分析工具以供开发者使用\",{\"1\":{\"234\":1}}],[\"好物分享\",{\"0\":{\"3\":1}}],[\"热点代码路径等等\",{\"1\":{\"234\":1}}],[\"堆是一种特殊的数据结构\",{\"1\":{\"263\":1}}],[\"堆\",{\"0\":{\"263\":1}}],[\"堆分配情况\",{\"1\":{\"234\":1}}],[\"堆栈信息等许多方面\",{\"1\":{\"240\":1}}],[\"堆栈\",{\"1\":{\"46\":1}}],[\"然而go在早期并没有一个成熟的依赖管理解决方案\",{\"1\":{\"361\":1}}],[\"然而现实中对程序性能分析的需求远远不止于此\",{\"1\":{\"234\":1}}],[\"然后通过template语句来引用指定的模板\",{\"1\":{\"626\":1}}],[\"然后才能使用\",{\"1\":{\"432\":1}}],[\"然后才会被唤醒\",{\"1\":{\"341\":1}}],[\"然后按照年龄排序\",{\"1\":{\"429\":1}}],[\"然后这次就可以得到一个比较完整的模糊测试输出日志\",{\"1\":{\"396\":1}}],[\"然后使用f\",{\"1\":{\"396\":1}}],[\"然后使用软连接到指定的目录下面\",{\"1\":{\"10\":1}}],[\"然后停止执行\",{\"1\":{\"390\":1}}],[\"然后创建测试文件\",{\"1\":{\"390\":1,\"394\":1}}],[\"然后创建测试文件example\",{\"1\":{\"389\":1}}],[\"然后修改go\",{\"1\":{\"382\":1}}],[\"然后go会将其存放在$gopath\",{\"1\":{\"373\":1}}],[\"然后就可以进行开发工作了\",{\"1\":{\"365\":1}}],[\"然后就会出现一个交互式的命令行\",{\"1\":{\"245\":1}}],[\"然后当父级结束时取消当前上下文\",{\"1\":{\"346\":1}}],[\"然后写入副本文件\",{\"1\":{\"322\":1}}],[\"然后写入目标文件中\",{\"1\":{\"322\":1}}],[\"然后层层上抛\",{\"1\":{\"315\":1}}],[\"然后你需要与数据库交互\",{\"1\":{\"249\":1}}],[\"然后各自运行100w次\",{\"1\":{\"233\":1}}],[\"然后将其克隆到本地\",{\"1\":{\"364\":1}}],[\"然后将其递增\",{\"1\":{\"152\":1}}],[\"然后将目标文件打包成静态链接库\",{\"1\":{\"232\":1}}],[\"然后制作动态链接库\",{\"1\":{\"231\":1}}],[\"然后再输出end\",{\"1\":{\"635\":1}}],[\"然后再将所有测试用例全都执行\",{\"1\":{\"387\":1}}],[\"然后再根据gosumdb所指定的服务器\",{\"1\":{\"379\":1}}],[\"然后再读取数据并输出\",{\"1\":{\"334\":1}}],[\"然后再使用工具对采样的数据进行分析并展示结果\",{\"1\":{\"240\":1}}],[\"然后再转换成对应的指针类型\",{\"1\":{\"229\":1}}],[\"然后再创建sum\",{\"1\":{\"218\":1}}],[\"然后返回一个c指针\",{\"1\":{\"222\":1}}],[\"然后在模板中直接使用\",{\"1\":{\"620\":1}}],[\"然后在之前创建的项目下使用go\",{\"1\":{\"372\":1}}],[\"然后在其中编写相关代码\",{\"1\":{\"365\":1}}],[\"然后在go代码中引入sum\",{\"1\":{\"231\":1}}],[\"然后在go中这段内存被gc掉了或者发生偏移\",{\"1\":{\"219\":1}}],[\"然后在go中导出函数\",{\"1\":{\"219\":1}}],[\"然后在go中的main函数进行调用\",{\"1\":{\"217\":1}}],[\"然后在main\",{\"1\":{\"218\":1}}],[\"然后在尾部插入一些元素\",{\"1\":{\"163\":1}}],[\"然后直接调用\",{\"1\":{\"217\":1}}],[\"然后安装nvm\",{\"1\":{\"10\":1}}],[\"倘若想要对结构体进行排序的话必须实现sort\",{\"1\":{\"575\":1}}],[\"倘若想要传入两个float64类型的浮点数求和的话\",{\"1\":{\"256\":1}}],[\"倘若使用复杂的结构\",{\"1\":{\"512\":1}}],[\"倘若使用复制的值\",{\"1\":{\"341\":1}}],[\"倘若是递归锁的话\",{\"1\":{\"348\":1}}],[\"倘若没有default分支\",{\"1\":{\"340\":1}}],[\"倘若有其他协程已经写入了数据\",{\"1\":{\"336\":1}}],[\"倘若循环中子协程的工作不只是一个简单的输出数字\",{\"1\":{\"331\":1}}],[\"倘若只是想获取该文件的一些信息\",{\"1\":{\"319\":1}}],[\"倘若要修改结构体字段值\",{\"1\":{\"287\":1}}],[\"倘若通过反射来修改反射值\",{\"1\":{\"280\":1}}],[\"倘若你学习完后感到无处施展拳脚\",{\"1\":{\"248\":1}}],[\"倘若执行的不是单纯的两数相加\",{\"1\":{\"233\":1}}],[\"倘若go函数具有多个返回值\",{\"1\":{\"219\":1}}],[\"求两个时间的差值\",{\"1\":{\"629\":1}}],[\"求对数\",{\"0\":{\"556\":1}}],[\"求其平均耗时\",{\"1\":{\"233\":1}}],[\"求字符串长度使用内置函数len\",{\"1\":{\"174\":1}}],[\"到此\",{\"1\":{\"232\":1}}],[\"到此动态链接库调用成功\",{\"1\":{\"231\":1}}],[\"到了1\",{\"1\":{\"128\":1}}],[\"出现在这里仅仅只是为了文档目的\",{\"1\":{\"638\":1,\"639\":1}}],[\"出现的地方\",{\"1\":{\"265\":1}}],[\"出安全考虑\",{\"1\":{\"231\":1}}],[\"出哈希以防止将id发送给客户端\",{\"1\":{\"46\":1}}],[\"制作完成后\",{\"1\":{\"231\":1}}],[\"动态语言则完全相反\",{\"1\":{\"300\":1}}],[\"动态具体类型\",{\"1\":{\"266\":2}}],[\"动态链接库无法单独运行\",{\"1\":{\"231\":1}}],[\"动态链接库\",{\"0\":{\"231\":1}}],[\"动画\",{\"1\":{\"58\":1}}],[\"得益于go的编译速度\",{\"1\":{\"373\":1}}],[\"得益于此\",{\"1\":{\"230\":1,\"565\":1}}],[\"得益于其良好的并发支持和高性能\",{\"1\":{\"81\":1}}],[\"链接库\",{\"0\":{\"230\":1}}],[\"谈到了指针避不开内存\",{\"1\":{\"229\":1}}],[\"加入元素\",{\"0\":{\"480\":1}}],[\"加载脚本\",{\"1\":{\"485\":1}}],[\"加载\",{\"1\":{\"358\":1}}],[\"加载值\",{\"1\":{\"358\":1}}],[\"加载并执行经过python训练的模型\",{\"1\":{\"61\":1}}],[\"加写锁\",{\"1\":{\"350\":1}}],[\"加读锁\",{\"1\":{\"350\":1}}],[\"加锁是希望数据不会被其他协程修改\",{\"1\":{\"348\":1}}],[\"加锁只需要lock\",{\"1\":{\"348\":1}}],[\"加锁\",{\"1\":{\"336\":2,\"349\":2,\"353\":1}}],[\"加上枚举类型名就可以访问c中的枚举类型\",{\"1\":{\"228\":1}}],[\"加上名称就可以访问c中的联合体\",{\"1\":{\"227\":1}}],[\"联合体\",{\"0\":{\"227\":1}}],[\"想让c访问到go中的切片就只能把切片的指针传过去\",{\"1\":{\"225\":1}}],[\"想要了解更多的话可以去百度\",{\"1\":{\"530\":1}}],[\"想要了解更多细节建议使用go\",{\"1\":{\"388\":1}}],[\"想要了解map的原理可以前往map实现\",{\"1\":{\"177\":1}}],[\"想要清空缓存可以执行如下命令\",{\"1\":{\"376\":1}}],[\"想要清空map\",{\"1\":{\"183\":1}}],[\"想要更深一步学习\",{\"1\":{\"248\":1}}],[\"想要直接使用别人写好的库除了直接获取源代码之外\",{\"1\":{\"230\":1}}],[\"想要使用cgo特性\",{\"1\":{\"216\":1}}],[\"想要使用此布局\",{\"1\":{\"0\":1}}],[\"想要练手的话\",{\"1\":{\"145\":1}}],[\"想要访问包中的类型时\",{\"1\":{\"94\":1}}],[\"话虽如此\",{\"1\":{\"222\":1}}],[\"来在模板中表示这是一个模板参数\",{\"1\":{\"617\":1}}],[\"来判断\",{\"1\":{\"581\":1}}],[\"来设置日志的输出路径\",{\"1\":{\"541\":1}}],[\"来解析参数\",{\"1\":{\"526\":1}}],[\"来定义\",{\"1\":{\"525\":2}}],[\"来添加\",{\"1\":{\"396\":1}}],[\"来使输出结果更加详细一点\",{\"1\":{\"387\":1}}],[\"来看看下面的一个例子\",{\"1\":{\"336\":1}}],[\"来看一个对int类型的管道读写的例子\",{\"1\":{\"334\":1}}],[\"来指定其存储的数据是什么类型\",{\"1\":{\"332\":1}}],[\"来获取其字符串表现形式\",{\"1\":{\"617\":1}}],[\"来获取其原始值\",{\"1\":{\"279\":1}}],[\"来获取其类型\",{\"1\":{\"270\":1}}],[\"来进行赋值\",{\"1\":{\"619\":1}}],[\"来进行测试\",{\"1\":{\"396\":1}}],[\"来进行类型转换和断言要优雅和方便很多\",{\"1\":{\"263\":1}}],[\"来进行数字划分\",{\"1\":{\"100\":1}}],[\"来表示根对象\",{\"1\":{\"617\":1}}],[\"来表示底层类型\",{\"1\":{\"259\":1}}],[\"来表示字符串\",{\"1\":{\"222\":1}}],[\"来告诉gc可以将其回收\",{\"1\":{\"239\":1}}],[\"里面持有着一个底层数组的引用\",{\"1\":{\"222\":1}}],[\"已经变成了\",{\"1\":{\"622\":1}}],[\"已经添加语料库中的\",{\"1\":{\"396\":1}}],[\"已经初始化完毕了\",{\"1\":{\"353\":1}}],[\"已经取好了别名\",{\"1\":{\"220\":1}}],[\"已知这些类型的占用字节数\",{\"1\":{\"192\":1}}],[\"方便它们在运行时调用\",{\"1\":{\"220\":1}}],[\"方法返回值\",{\"1\":{\"289\":2}}],[\"方法参数\",{\"1\":{\"289\":2}}],[\"方法对应的函数\",{\"1\":{\"289\":1}}],[\"方法类型\",{\"1\":{\"289\":1}}],[\"方法名\",{\"1\":{\"289\":1}}],[\"方法可以获取反射值原有的值\",{\"1\":{\"281\":1}}],[\"方法是不能拥有泛型形参的\",{\"1\":{\"258\":1}}],[\"方法集\",{\"1\":{\"266\":1}}],[\"方法集等\",{\"1\":{\"266\":1}}],[\"方法集是接口方法集的超集\",{\"1\":{\"212\":1}}],[\"方法集就是一组方法的集合\",{\"1\":{\"208\":1}}],[\"方法在被调用时\",{\"1\":{\"205\":1}}],[\"方法的返回值来自于一个其内部的map\",{\"1\":{\"270\":1}}],[\"方法的接收者是\",{\"1\":{\"206\":1}}],[\"方法的使用就类似于调用一个类的成员方法\",{\"1\":{\"204\":1}}],[\"方法的长相与函数并无太大的区别\",{\"1\":{\"204\":1}}],[\"方法拥有接收者\",{\"1\":{\"204\":1}}],[\"方法与函数的区别在于\",{\"1\":{\"204\":1}}],[\"方法\",{\"1\":{\"89\":1,\"270\":1,\"271\":1,\"310\":1,\"392\":1,\"537\":1,\"541\":1}}],[\"级别越高检查造成运行时开销越大\",{\"1\":{\"219\":1}}],[\"需在函数签名上方加上\",{\"1\":{\"219\":1}}],[\"需要先进行sort\",{\"1\":{\"579\":1}}],[\"需要先了解接口\",{\"1\":{\"206\":1}}],[\"需要保持一致\",{\"1\":{\"433\":1}}],[\"需要结合引用次数和更新时间来决定是否采用该依赖\",{\"1\":{\"372\":1}}],[\"需要结合其他关键字来进行使用\",{\"1\":{\"150\":1}}],[\"需要为这个库编写简洁明了的readme\",{\"1\":{\"367\":1}}],[\"需要为其分配内存\",{\"1\":{\"194\":1}}],[\"需要同时打开两个文件\",{\"1\":{\"322\":1}}],[\"需要自行编写逻辑来进行读取时切片的动态扩容\",{\"1\":{\"320\":1}}],[\"需要第三方包解决或者自己封装\",{\"1\":{\"307\":1}}],[\"需要处理\",{\"1\":{\"307\":1}}],[\"需要进行一些额外的操作\",{\"1\":{\"287\":1}}],[\"需要传入一个自定义的比较器\",{\"1\":{\"263\":1}}],[\"需要返回零值\",{\"1\":{\"262\":1}}],[\"需要安装graphviz\",{\"1\":{\"245\":1}}],[\"需要使用到time包下的sleep函数\",{\"1\":{\"331\":1}}],[\"需要使用c\",{\"1\":{\"222\":1}}],[\"需要使用sync\",{\"1\":{\"185\":1}}],[\"需要使用sync中提供的锁机制\",{\"1\":{\"40\":1}}],[\"需要满足关系low<=\",{\"1\":{\"169\":1}}],[\"需要注意的是c必须是大写字母\",{\"1\":{\"216\":1}}],[\"需要注意的是\",{\"1\":{\"158\":1,\"181\":1,\"315\":1,\"348\":1,\"389\":1,\"617\":1}}],[\"需要开发者手动管理内存\",{\"1\":{\"87\":1}}],[\"首先通过\",{\"1\":{\"615\":1}}],[\"首先定义结构体\",{\"1\":{\"510\":1,\"516\":1}}],[\"首先需要首先自定义一个结构体实现handler接口中的servehttp\",{\"1\":{\"537\":1}}],[\"首先需要给语料种子库添加数据\",{\"1\":{\"396\":1}}],[\"首先需要下载该工具\",{\"1\":{\"395\":1}}],[\"首先需要注意几点规范\",{\"1\":{\"386\":1}}],[\"首先创建user数据库\",{\"1\":{\"423\":1}}],[\"首先创建文件\",{\"1\":{\"394\":1,\"396\":1}}],[\"首先创建\",{\"1\":{\"390\":1}}],[\"首先创建一个hello\",{\"1\":{\"389\":1}}],[\"首先创建一个头文件sum\",{\"1\":{\"218\":1}}],[\"首先创建一个长度为0\",{\"1\":{\"163\":1}}],[\"首先项目下有两个独立的go模块\",{\"1\":{\"382\":1}}],[\"首先使用如下命令下载一个依赖\",{\"1\":{\"379\":1}}],[\"首先你需要一个可公网访问的源代码仓库\",{\"1\":{\"364\":1}}],[\"首先会通过loadint64来获取期望值\",{\"1\":{\"359\":1}}],[\"首先go语言是一个百分之百的静态类型语言\",{\"1\":{\"266\":1}}],[\"首先声明队列类型\",{\"1\":{\"262\":1}}],[\"首先编译生成目标文件\",{\"1\":{\"231\":1}}],[\"首先准备一个lib\",{\"1\":{\"231\":1}}],[\"首先引入errno\",{\"1\":{\"217\":1}}],[\"跟踪所有的协程\",{\"1\":{\"243\":1}}],[\"跟上图一样\",{\"1\":{\"229\":1}}],[\"跟go代码糅杂在一起十分降低可读性\",{\"1\":{\"217\":1}}],[\"跟大多数语言类似\",{\"1\":{\"106\":1}}],[\"另外\",{\"1\":{\"509\":1}}],[\"另外要注意的一个点就是\",{\"1\":{\"216\":1}}],[\"另一种方法就是使用io\",{\"1\":{\"322\":1}}],[\"另一种方法是使用os\",{\"1\":{\"322\":1}}],[\"另一种是通过名称\",{\"1\":{\"286\":1}}],[\"另一种就是通过var关键字来声明\",{\"1\":{\"197\":1}}],[\"另一个需要注意的点是当指针指向的元素地址移动时\",{\"1\":{\"643\":1}}],[\"另一个是转换结果的布尔值\",{\"1\":{\"305\":1}}],[\"另一个是解引用符\",{\"1\":{\"194\":1}}],[\"另一个类则是有方法集的接口\",{\"1\":{\"266\":1}}],[\"另一个注意点是\",{\"1\":{\"219\":1}}],[\"另一个就是比较函数\",{\"1\":{\"200\":1}}],[\"$index\",{\"1\":{\"624\":3}}],[\"$float\",{\"1\":{\"619\":1}}],[\"$numer\",{\"1\":{\"619\":1}}],[\"$name\",{\"1\":{\"619\":4,\"621\":3,\"622\":4}}],[\"$val\",{\"1\":{\"619\":2,\"624\":2}}],[\"$sort\",{\"1\":{\"429\":1}}],[\"$set\",{\"1\":{\"427\":3}}],[\"$match\",{\"1\":{\"429\":1}}],[\"$gomodcache\",{\"1\":{\"379\":1}}],[\"$\",{\"1\":{\"216\":4,\"218\":1,\"231\":6,\"232\":3,\"236\":2,\"237\":1,\"238\":1,\"239\":2,\"245\":2,\"246\":4,\"247\":2,\"363\":2,\"364\":2,\"366\":3,\"368\":11,\"369\":3,\"370\":1,\"372\":8,\"373\":2,\"376\":6,\"379\":2,\"382\":2,\"387\":7,\"389\":1,\"390\":3,\"391\":1,\"392\":3,\"394\":1,\"395\":4,\"396\":5,\"403\":2,\"420\":1,\"432\":2}}],[\"请求超时时间配置\",{\"1\":{\"532\":1}}],[\"请求跟踪等的微服务工具包\",{\"1\":{\"47\":1}}],[\"请先自行了解和学习\",{\"1\":{\"418\":1}}],[\"请先自行学习\",{\"1\":{\"402\":1}}],[\"请查阅官方文档es\",{\"1\":{\"404\":1}}],[\"请移步泛型\",{\"1\":{\"214\":1}}],[\"否\",{\"1\":{\"213\":2}}],[\"否则以结构体属性名为准\",{\"1\":{\"520\":1}}],[\"否则的话什么也不做\",{\"1\":{\"359\":1}}],[\"否则的话编译不通过\",{\"1\":{\"95\":1}}],[\"否则为false\",{\"1\":{\"355\":1}}],[\"否则将会提示undefined\",{\"1\":{\"619\":1}}],[\"否则将无法正常解析\",{\"1\":{\"618\":1}}],[\"否则将无法通过编译\",{\"1\":{\"158\":1}}],[\"否则将新的值存入并返回\",{\"1\":{\"355\":1}}],[\"否则无法成功写入文件\",{\"1\":{\"321\":1}}],[\"否则无法通过编译\",{\"1\":{\"129\":1}}],[\"否则程序立即停止运行并输出堆栈信息\",{\"1\":{\"313\":1}}],[\"否则调用unwrap\",{\"1\":{\"312\":1}}],[\"否则就只是一个普通的函数\",{\"1\":{\"389\":1}}],[\"否则就不会\",{\"1\":{\"387\":1}}],[\"否则就不是完全相等\",{\"1\":{\"298\":1}}],[\"否则就一直向上查找\",{\"1\":{\"346\":1}}],[\"否则就阻塞等待\",{\"1\":{\"349\":1}}],[\"否则就阻塞\",{\"1\":{\"341\":1}}],[\"否则就会报错\",{\"1\":{\"617\":1}}],[\"否则就会一直阻塞\",{\"1\":{\"336\":1}}],[\"否则就会阻塞等待\",{\"1\":{\"335\":1}}],[\"否则就是一个空指针\",{\"1\":{\"194\":1}}],[\"否则会panic\",{\"1\":{\"271\":1,\"279\":2}}],[\"否则这块内存是不会被自动释放掉的\",{\"1\":{\"229\":1}}],[\"否则找不到c文件\",{\"1\":{\"218\":1}}],[\"否则水就溢出来了\",{\"1\":{\"162\":1}}],[\"否则生成的是切片\",{\"1\":{\"158\":1}}],[\"依赖\",{\"0\":{\"403\":1,\"432\":1}}],[\"依赖的代理服务器集合\",{\"1\":{\"380\":1}}],[\"依赖的源码压缩包\",{\"1\":{\"379\":1}}],[\"依赖难以管理\",{\"1\":{\"361\":1}}],[\"依赖问题\",{\"1\":{\"233\":1}}],[\"依旧是同一个锁\",{\"1\":{\"351\":1}}],[\"依旧在原先访问到的值基础上加一\",{\"1\":{\"348\":1}}],[\"依旧可以读取数据\",{\"1\":{\"339\":1}}],[\"依旧可以通过值接收者来修改其内部值\",{\"1\":{\"206\":1}}],[\"依旧采用any进行约束\",{\"1\":{\"263\":1}}],[\"依据\",{\"1\":{\"213\":1}}],[\"组成的元组\",{\"1\":{\"213\":1}}],[\"组合\",{\"0\":{\"189\":1}}],[\"之所以不可移植的原因是一些操作的结果取决于操作系统实现\",{\"1\":{\"637\":1}}],[\"之所以不使用空结构体\",{\"1\":{\"344\":1}}],[\"之所以被称作乐观锁\",{\"1\":{\"359\":1}}],[\"之所以能成功调用\",{\"1\":{\"218\":1}}],[\"之后\",{\"1\":{\"220\":1}}],[\"之前提到过任何自定义类型都可以拥有方法\",{\"1\":{\"212\":1}}],[\"之间通信的机制\",{\"1\":{\"70\":1}}],[\"之间映射值\",{\"1\":{\"46\":1}}],[\"之间进行二进制值交换\",{\"1\":{\"43\":1}}],[\"公司a也跑路了\",{\"1\":{\"212\":1}}],[\"公有\",{\"1\":{\"93\":1}}],[\"绝对值\",{\"0\":{\"548\":1}}],[\"绝世起重机出故障了\",{\"1\":{\"212\":1}}],[\"绝大部分的命令行程序都需要用到这个包\",{\"1\":{\"40\":1}}],[\"过期时间\",{\"0\":{\"449\":1}}],[\"过滤条件\",{\"1\":{\"424\":1,\"425\":2}}],[\"过滤html标签\",{\"1\":{\"41\":1}}],[\"过程中不涉及内存拷贝\",{\"1\":{\"648\":1}}],[\"过程中不会涉及到内存拷贝\",{\"1\":{\"646\":1}}],[\"过程中的类型变化如下\",{\"1\":{\"643\":1}}],[\"过程中会下载很多的依赖\",{\"1\":{\"372\":1}}],[\"过程中会导致其他协程阻塞\",{\"1\":{\"359\":1}}],[\"过程与访问函数信息一致\",{\"1\":{\"289\":1}}],[\"过大的缓冲区就不用放回对象池\",{\"1\":{\"354\":1}}],[\"过了一段时间\",{\"1\":{\"212\":1}}],[\"屏蔽其内部实现\",{\"1\":{\"212\":1}}],[\"于是\",{\"1\":{\"372\":1}}],[\"于是也将错误作为返回值返回\",{\"1\":{\"311\":1}}],[\"于是公司b依据规范造了一台更厉害的巨无霸起重机\",{\"1\":{\"212\":1}}],[\"于是公司a接下了订单\",{\"1\":{\"212\":1}}],[\"于是给出了起重机的特殊规范和图纸\",{\"1\":{\"212\":1}}],[\"于是就有了现在人们所推崇的面向接口编程\",{\"1\":{\"207\":1}}],[\"理解的时候要根据代码来思考\",{\"1\":{\"208\":1}}],[\"概念\",{\"0\":{\"208\":1}}],[\"概率分布函数\",{\"1\":{\"61\":1}}],[\"倒不如无论何时要么都用值接收者\",{\"1\":{\"206\":1}}],[\"显然这是由于作用域不同\",{\"1\":{\"622\":1}}],[\"显然这很可能会触发fatal\",{\"1\":{\"355\":1}}],[\"显然项目的主目录并没有测试文件可供执行\",{\"1\":{\"387\":1}}],[\"显然是不太可能的\",{\"1\":{\"256\":1}}],[\"显然是不可以的\",{\"1\":{\"256\":1}}],[\"显然传递一个指针比起传递一个切片所消耗的资源更小\",{\"1\":{\"206\":1}}],[\"显示每一时刻在os线程上运行的协程时间线\",{\"1\":{\"247\":1}}],[\"显示每一时刻在该处理器上运行的协程时间线\",{\"1\":{\"247\":1}}],[\"显式的创建panic十分简单\",{\"1\":{\"314\":1}}],[\"显式的指明使用哪种类型\",{\"1\":{\"256\":1}}],[\"显式组合的方式\",{\"1\":{\"189\":1}}],[\"显式类型转换为字符串\",{\"1\":{\"173\":1}}],[\"显式类型转换为字节切片\",{\"1\":{\"173\":1}}],[\"遗憾的是\",{\"1\":{\"205\":1}}],[\"遗传算法和粒子群优化库\",{\"1\":{\"61\":1}}],[\"上海市\",{\"1\":{\"434\":1}}],[\"上数的例子中在最后一行输出了test\",{\"1\":{\"390\":1}}],[\"上传\",{\"0\":{\"368\":1}}],[\"上方的代码是一个简单的判断分支\",{\"1\":{\"356\":1}}],[\"上一个例子用到了time\",{\"1\":{\"340\":1}}],[\"上例中使用的普通map\",{\"1\":{\"355\":1}}],[\"上例中通过for循环配合select来一直监测三个管道是否可以用\",{\"1\":{\"340\":1}}],[\"上例开启了一个新的协程来向管道a写入数据\",{\"1\":{\"340\":1}}],[\"上例的接收者就是一个值接收者\",{\"1\":{\"205\":1}}],[\"上下文包\",{\"1\":{\"508\":1}}],[\"上下文也是一种资源\",{\"1\":{\"347\":1}}],[\"上下文取消\",{\"1\":{\"347\":2}}],[\"上下文\",{\"1\":{\"331\":1}}],[\"上游函数同样的也进行善后工作\",{\"1\":{\"315\":1}}],[\"上图最下方的白色叶子节点代表着不同大小的对象占用\",{\"1\":{\"246\":1}}],[\"上面这两个类型不需要太在意\",{\"1\":{\"639\":1}}],[\"上面这段程序就会在输出完start后阻塞两秒\",{\"1\":{\"635\":1}}],[\"上面两段代码就等价于db\",{\"1\":{\"426\":1}}],[\"上面那段查询代码等价于\",{\"1\":{\"424\":1}}],[\"上面三种情况虽然都完成了测试\",{\"1\":{\"387\":1}}],[\"上面队列的例子\",{\"1\":{\"263\":1}}],[\"上面只是列出了比较常见的领域\",{\"1\":{\"254\":1}}],[\"上面的例子执行结果如下\",{\"1\":{\"348\":1}}],[\"上面的例子中创建了一个缓冲区大小为1的int型管道\",{\"1\":{\"334\":1}}],[\"上面的例子中结果输出很完美\",{\"1\":{\"331\":1}}],[\"上面的例子输出都是一样的\",{\"1\":{\"222\":1}}],[\"上面的代码省略了很多细节\",{\"1\":{\"267\":1}}],[\"上面的测试例子就不能使用gotest\",{\"1\":{\"233\":1}}],[\"上面的写法默认是不允许通过编译的\",{\"1\":{\"219\":1}}],[\"上面例子中\",{\"1\":{\"212\":1}}],[\"上述性能测试的样本数只有两组\",{\"1\":{\"395\":1}}],[\"上述操作都只能在主测试中进行\",{\"1\":{\"391\":1}}],[\"上述定义中\",{\"1\":{\"374\":1}}],[\"上述所有的内容都只是在讲述go\",{\"1\":{\"374\":1}}],[\"上述已经介绍过了sync\",{\"1\":{\"352\":1}}],[\"上述代码的输出为\",{\"1\":{\"615\":1}}],[\"上述代码会将所有请求转发到https\",{\"1\":{\"538\":1}}],[\"上述代码便不再会发生死锁\",{\"1\":{\"339\":1}}],[\"上述代码运行过后\",{\"1\":{\"205\":1}}],[\"上述提到了动态具体类型这一词\",{\"1\":{\"266\":1}}],[\"上述这几种字符串传递方法涉及到了一次内存拷贝\",{\"1\":{\"222\":1}}],[\"上述例子中将字符串转换成\",{\"1\":{\"177\":1}}],[\"先准备结构体\",{\"1\":{\"513\":1}}],[\"先准备数据\",{\"1\":{\"415\":1}}],[\"先后顺序\",{\"1\":{\"331\":1}}],[\"先将内容读到缓冲区中\",{\"1\":{\"322\":1}}],[\"先将源文件编译成目标文件\",{\"1\":{\"232\":1}}],[\"先只需要了解这两个类型的存在即可\",{\"1\":{\"267\":1}}],[\"先看一个例子\",{\"1\":{\"205\":1}}],[\"先声明泛型结构体\",{\"1\":{\"263\":1}}],[\"先声明\",{\"1\":{\"204\":1}}],[\"先声明了一个类型intslice\",{\"1\":{\"204\":1}}],[\"先来认识下channel的基本语法\",{\"1\":{\"332\":1}}],[\"先来介绍第一种使用方法\",{\"1\":{\"319\":1}}],[\"先来看看的一个例子\",{\"1\":{\"348\":1}}],[\"先来看看context接口的定义\",{\"1\":{\"343\":1}}],[\"先来看看接口长什么样子\",{\"1\":{\"210\":1}}],[\"先来看一个简单的例子\",{\"1\":{\"256\":1}}],[\"先来看一个例子\",{\"1\":{\"204\":1,\"212\":1}}],[\"先来看一段c++代码\",{\"1\":{\"195\":1}}],[\"先来看下面的一个例子\",{\"1\":{\"168\":1}}],[\"先来初始化一个长度为5的整型数组\",{\"1\":{\"158\":1}}],[\"且不等同于any\",{\"1\":{\"638\":1}}],[\"且不存在时会自动创建\",{\"1\":{\"319\":1}}],[\"且官方声称该包不受go\",{\"1\":{\"637\":1}}],[\"且每个测试用例执行两轮\",{\"1\":{\"394\":1}}],[\"且函数的入参必须是t\",{\"1\":{\"390\":1}}],[\"且其功能也仅限于本地开发\",{\"1\":{\"382\":1}}],[\"且其原始数据不可读\",{\"1\":{\"242\":1}}],[\"且新版本不加以区分的话\",{\"1\":{\"378\":1}}],[\"且vcs属于以下的其中之一\",{\"1\":{\"362\":1}}],[\"且会返回是否成功替换的布尔值\",{\"1\":{\"359\":1}}],[\"且提供了非常简单易用的api\",{\"1\":{\"348\":1}}],[\"且提供了更加完善的错误检查机制\",{\"1\":{\"308\":1}}],[\"且只能进行一种操作\",{\"1\":{\"340\":1}}],[\"且只能是管道\",{\"1\":{\"340\":1}}],[\"且只有自定义类型能够拥有方法\",{\"1\":{\"204\":1}}],[\"且权限为0666向指定写入数据的例子\",{\"1\":{\"321\":1}}],[\"且参数只能是一个有效的error\",{\"1\":{\"311\":1}}],[\"且类型名称不建议与已有的内置标识符重复\",{\"1\":{\"302\":1}}],[\"且返回值为func\",{\"1\":{\"301\":1}}],[\"且导入名称无法被重写\",{\"1\":{\"216\":1}}],[\"且该类型的值可以由该接口类型的变量存储\",{\"1\":{\"208\":2}}],[\"且后续使用过程中可能会频繁的插入和删除元素\",{\"1\":{\"161\":1}}],[\"且后续使用中不会有扩容的需求\",{\"1\":{\"157\":1}}],[\"总而言之\",{\"1\":{\"541\":1}}],[\"总共六个提交并不多\",{\"1\":{\"368\":1}}],[\"总共只有四个方法pop\",{\"1\":{\"262\":1}}],[\"总的来说recover函数有几个注意点\",{\"1\":{\"316\":1}}],[\"总结就是\",{\"1\":{\"204\":1}}],[\"总体来说\",{\"1\":{\"89\":1}}],[\"答案如下\",{\"1\":{\"204\":1}}],[\"答案是\",{\"1\":{\"127\":1}}],[\"半天排查不出来是什么原因\",{\"1\":{\"204\":1}}],[\"笔者以前就因为这个坑\",{\"1\":{\"204\":1}}],[\"循环内计数1\",{\"1\":{\"341\":1}}],[\"循环\",{\"0\":{\"203\":1}}],[\"关联是将外部的多个命名的\",{\"1\":{\"626\":1}}],[\"关联\",{\"0\":{\"626\":1}}],[\"关闭连接\",{\"0\":{\"446\":1},\"1\":{\"421\":1}}],[\"关闭管道\",{\"1\":{\"339\":2}}],[\"关闭已关闭的管道\",{\"1\":{\"337\":1}}],[\"关闭一个nil管道\",{\"1\":{\"337\":1}}],[\"关闭网络连接等操作\",{\"1\":{\"202\":1}}],[\"关键点在于sum\",{\"1\":{\"219\":1}}],[\"关于http相关的知识这里不再赘述\",{\"1\":{\"530\":1}}],[\"关于redis的驱动有很多\",{\"1\":{\"442\":1}}],[\"关于go中的模糊测试可以前往go\",{\"1\":{\"396\":1}}],[\"关于go可用的版本号自行前往官方查阅\",{\"1\":{\"378\":1}}],[\"关于output有以下几种写法\",{\"1\":{\"389\":1}}],[\"关于如何删除模块的信息\",{\"1\":{\"369\":1}}],[\"关于如何分析数据\",{\"1\":{\"246\":1}}],[\"关于上传模块的更多详细信息\",{\"1\":{\"369\":1}}],[\"关于管道关闭的时机\",{\"1\":{\"339\":1}}],[\"关于管道阻塞的条件需要好好掌握和熟悉\",{\"1\":{\"337\":1}}],[\"关于读取文件的操作\",{\"1\":{\"320\":1}}],[\"关于文件权限的则提供了以下常量\",{\"1\":{\"319\":1}}],[\"关于文件描述符\",{\"1\":{\"319\":1}}],[\"关于代表\",{\"1\":{\"304\":1}}],[\"关于折线图\",{\"1\":{\"246\":1}}],[\"关于整数的类型映射还在可以在标准库cmd\",{\"1\":{\"223\":1}}],[\"关于cgo\",{\"1\":{\"215\":1}}],[\"关于接口的定义发生了变化\",{\"1\":{\"208\":1}}],[\"关于指针有两个常用的操作符\",{\"1\":{\"194\":1}}],[\"关于这一点社区也曾激烈讨论过\",{\"1\":{\"180\":1}}],[\"关于字符串的更多细节\",{\"1\":{\"177\":1}}],[\"关于函数后的花括号到底该不该换行\",{\"1\":{\"108\":1}}],[\"关于编码风格这一块go是强制所有人统一同一种风格\",{\"1\":{\"107\":1}}],[\"延迟调用通常用于释放文件资源\",{\"1\":{\"202\":1}}],[\"延迟调用\",{\"0\":{\"202\":1}}],[\"利用管道的阻塞条件\",{\"1\":{\"336\":1}}],[\"利用闭包\",{\"1\":{\"201\":1}}],[\"利率转换\",{\"1\":{\"52\":1}}],[\"每种数据库都可能会不一样\",{\"1\":{\"433\":1}}],[\"每创建一个go\",{\"1\":{\"378\":1}}],[\"每创建一个defer\",{\"1\":{\"203\":1}}],[\"每次增加数字前都会先上锁\",{\"1\":{\"359\":1}}],[\"每次读取数据都需要花费1毫秒\",{\"1\":{\"336\":1}}],[\"每当一个协程执行完毕时调用done\",{\"1\":{\"341\":1}}],[\"每一个\",{\"1\":{\"620\":1}}],[\"每一个标准库的包级注释都会详细说明这个包是干什么用的\",{\"1\":{\"508\":1}}],[\"每一个测试用例的命名风格为testxxxx\",{\"1\":{\"390\":1}}],[\"每一个测试文件中都会有若干个测试函数用于不同的测试\",{\"1\":{\"386\":1}}],[\"每一个现代语言都会有属于自己的一个成熟的依赖管理工具\",{\"1\":{\"361\":1}}],[\"每一个原子类型都会提供以下三个方法\",{\"1\":{\"358\":1}}],[\"每一个协程在访问数据前\",{\"1\":{\"349\":1}}],[\"每一个case只能操作一个管道\",{\"1\":{\"340\":1}}],[\"每一个错误都是通过函数调用的返回值产生的\",{\"1\":{\"307\":1}}],[\"每一个新声明的类型都必须有一个与之对应的基础类型\",{\"1\":{\"302\":1}}],[\"每一个键所映射的值都完全相等\",{\"1\":{\"298\":1}}],[\"每将它调用一次\",{\"1\":{\"201\":1}}],[\"每声明一个变量\",{\"1\":{\"123\":1}}],[\"闭包recover不会恢复外部函数的任何panic\",{\"1\":{\"316\":1}}],[\"闭包函数可以看作调用了一个函数\",{\"1\":{\"316\":1}}],[\"闭包引用了函数外的变量\",{\"1\":{\"237\":1}}],[\"闭包引用\",{\"0\":{\"237\":1}}],[\"闭包的输出是7\",{\"1\":{\"204\":1}}],[\"闭包\",{\"0\":{\"201\":1},\"1\":{\"201\":2}}],[\"变长参数可以接收0个或多个值\",{\"1\":{\"198\":1}}],[\"变量必须先声明才能使用\",{\"1\":{\"619\":1}}],[\"变量遮蔽问题\",{\"1\":{\"307\":1}}],[\"变量的内存分配是由编译器决定的\",{\"1\":{\"235\":1}}],[\"变量的声明会用到var关键字\",{\"1\":{\"124\":1}}],[\"变量e就会以指数级增长一次\",{\"1\":{\"201\":1}}],[\"变量都是有效的\",{\"1\":{\"153\":1}}],[\"变量之间的比较有一个大前提\",{\"1\":{\"128\":1}}],[\"变量a被重新赋值\",{\"1\":{\"125\":1}}],[\"变量名的命名规则必须遵守标识符的命名规则\",{\"1\":{\"124\":1}}],[\"变量名\",{\"1\":{\"124\":1}}],[\"变量以查看更多细节\",{\"1\":{\"123\":1}}],[\"变量是用于保存一个值的存储位置\",{\"1\":{\"123\":1}}],[\"变量命名等等\",{\"1\":{\"97\":1}}],[\"变量\",{\"0\":{\"123\":1,\"619\":1},\"1\":{\"93\":2,\"94\":1}}],[\"缓冲区为空\",{\"1\":{\"337\":1}}],[\"缓冲区已经满了\",{\"1\":{\"336\":1}}],[\"缓冲区有空位了\",{\"1\":{\"336\":1}}],[\"缓冲区满了以后就开始阻塞等待读协程来读取\",{\"1\":{\"336\":1}}],[\"缓冲区满了\",{\"1\":{\"336\":1}}],[\"缓冲区大小为1的管道\",{\"1\":{\"333\":1,\"336\":1}}],[\"缓冲区大小为10的通道\",{\"1\":{\"196\":1}}],[\"缓冲区默认大小为32kb\",{\"1\":{\"322\":1}}],[\"缓存没有大小限制且不会自动删除\",{\"1\":{\"376\":1}}],[\"缓存慢速数据库查询的通用接口\",{\"1\":{\"46\":1}}],[\"缓存库\",{\"1\":{\"46\":1}}],[\"专用\",{\"1\":{\"319\":1}}],[\"专用于给切片\",{\"1\":{\"196\":1}}],[\"专用于给指针分配内存空间\",{\"1\":{\"196\":1}}],[\"专注于时序数据的收集与处理\",{\"1\":{\"85\":1}}],[\"报错如下\",{\"1\":{\"195\":1,\"338\":1}}],[\"试图进行指针运算\",{\"1\":{\"195\":1}}],[\"创建redis连接客户端\",{\"1\":{\"443\":1,\"445\":1}}],[\"创建文档\",{\"0\":{\"426\":1}}],[\"创建文件\",{\"1\":{\"329\":1}}],[\"创建文件夹\",{\"1\":{\"329\":1}}],[\"创建文件夹操作会用到os包下的两个函数\",{\"1\":{\"328\":1}}],[\"创建模糊测试文件\",{\"1\":{\"396\":1}}],[\"创建完成后\",{\"1\":{\"364\":1}}],[\"创建时\",{\"1\":{\"346\":1}}],[\"创建三个管道\",{\"1\":{\"340\":1}}],[\"创建的有缓冲管道\",{\"1\":{\"337\":2}}],[\"创建了一个无缓冲管道\",{\"1\":{\"337\":1}}],[\"创建两个无缓冲管道\",{\"1\":{\"336\":1}}],[\"创建有缓冲管道\",{\"1\":{\"336\":2}}],[\"创建无缓冲管道\",{\"1\":{\"335\":2}}],[\"创建一个http服务器只需要一行代码\",{\"1\":{\"535\":1}}],[\"创建一个新的网络连接且比network和addr有着更高的优先级\",{\"1\":{\"444\":1}}],[\"创建一个如下的文档\",{\"1\":{\"411\":1}}],[\"创建一个索引\",{\"1\":{\"406\":1}}],[\"创建一个无缓冲管道\",{\"1\":{\"336\":1}}],[\"创建一个协程十分的简单\",{\"1\":{\"331\":1}}],[\"创建一个error有以下几种方法\",{\"1\":{\"309\":1}}],[\"创建成功后返回返回一组objectid\",{\"1\":{\"426\":1}}],[\"创建成功后会返回文档的objectid\",{\"1\":{\"426\":1}}],[\"创建成功\",{\"1\":{\"328\":1}}],[\"创建管道反射值\",{\"1\":{\"296\":1}}],[\"创建切片反射值\",{\"1\":{\"294\":1}}],[\"创建切片的事情是由makeslice函数在负责\",{\"1\":{\"245\":1}}],[\"创建结构体反射值\",{\"1\":{\"293\":1}}],[\"创建\",{\"0\":{\"194\":1,\"291\":1,\"309\":1,\"314\":1,\"328\":1,\"333\":1,\"364\":1,\"406\":1,\"411\":1}}],[\"又可以是当作高速缓存存储\",{\"1\":{\"441\":1}}],[\"又或者在运行过程中需要动态调整\",{\"1\":{\"341\":1}}],[\"又或者说常用到的time包下的after函数\",{\"1\":{\"338\":1}}],[\"又或者只有一部分子协程在主协程退出前成功运行\",{\"1\":{\"331\":1}}],[\"又或者是通用接口\",{\"1\":{\"260\":1}}],[\"又或者是作为通道的类型\",{\"1\":{\"193\":1}}],[\"又限制了指针的使用\",{\"1\":{\"193\":1}}],[\"空闲连接\",{\"1\":{\"444\":1}}],[\"空集就是没有交集\",{\"1\":{\"259\":1}}],[\"空集\",{\"1\":{\"259\":1}}],[\"空间不足\",{\"0\":{\"238\":1}}],[\"空接口类型可以代表所有的类型\",{\"1\":{\"305\":1}}],[\"空接口就是连接go类型系统与反射的桥梁\",{\"1\":{\"267\":1}}],[\"空接口是所有类型集的集合\",{\"1\":{\"259\":1}}],[\"空接口与空集并不同\",{\"1\":{\"259\":1}}],[\"空接口\",{\"0\":{\"213\":1},\"1\":{\"259\":1}}],[\"空结构体的使用场景有很多\",{\"1\":{\"193\":1}}],[\"空结构体没有字段\",{\"1\":{\"193\":1}}],[\"空结构体\",{\"0\":{\"193\":1}}],[\"空类型\",{\"1\":{\"46\":1}}],[\"让您飞快完成搜索\",{\"1\":{\"402\":1}}],[\"让其它开发者看一眼就知道怎么使用\",{\"1\":{\"367\":1}}],[\"让编译器自行推断\",{\"1\":{\"256\":1}}],[\"让go调用c\",{\"1\":{\"215\":1}}],[\"让结构体中的字段按照合理的顺序分布\",{\"1\":{\"192\":1}}],[\"让我们从一个最简单的例子开始\",{\"1\":{\"91\":1}}],[\"浪费了6个字节\",{\"1\":{\"192\":1}}],[\"改写刚刚的sum\",{\"1\":{\"219\":1}}],[\"改成指针接收者就正常了\",{\"1\":{\"206\":1}}],[\"改成如下的顺序\",{\"1\":{\"192\":1}}],[\"改为了值接收者\",{\"1\":{\"206\":1}}],[\"改为\",{\"1\":{\"206\":1}}],[\"改进后的google的跳转一致性哈希\",{\"1\":{\"47\":1}}],[\"足足浪费了14个字节\",{\"1\":{\"192\":1}}],[\"明显\",{\"1\":{\"509\":1}}],[\"明白了上面的规则后\",{\"1\":{\"192\":1}}],[\"明明a已经被赋予b的值了\",{\"1\":{\"127\":1}}],[\"再比如\",{\"1\":{\"404\":1}}],[\"再使用benchstat进行对比\",{\"1\":{\"395\":1}}],[\"再与go\",{\"1\":{\"379\":1}}],[\"再为其创建一个release\",{\"1\":{\"368\":1}}],[\"再来进行模糊测试\",{\"1\":{\"396\":1}}],[\"再来一个层级嵌套深一点的示例\",{\"1\":{\"346\":1}}],[\"再来看下面这个结构体\",{\"1\":{\"192\":1}}],[\"再去了解它的具体实现\",{\"1\":{\"343\":1}}],[\"再读取数据也不会导致当前协程阻塞\",{\"1\":{\"339\":1}}],[\"再读取数据\",{\"1\":{\"339\":1}}],[\"再写入到目标文件中\",{\"1\":{\"322\":1}}],[\"再写入目标文件\",{\"1\":{\"322\":1}}],[\"再次运行项目\",{\"1\":{\"372\":1}}],[\"再次运行输出如下\",{\"1\":{\"319\":1}}],[\"再次执行模糊测试看看还有没有问题\",{\"1\":{\"396\":1}}],[\"再次执行\",{\"1\":{\"392\":1}}],[\"再次执行输出如下\",{\"1\":{\"331\":1}}],[\"再次执行就会报错\",{\"1\":{\"226\":1}}],[\"再调用http\",{\"1\":{\"537\":1}}],[\"再调用\",{\"1\":{\"204\":1}}],[\"再初始化\",{\"1\":{\"204\":1}}],[\"再声明了三个方法get\",{\"1\":{\"204\":1}}],[\"再将字符串的内存复制过去\",{\"1\":{\"173\":1}}],[\"相当的强大\",{\"1\":{\"508\":1}}],[\"相比于以上三种更加的轻便\",{\"1\":{\"521\":1}}],[\"相比于固定的测试数据\",{\"1\":{\"396\":1}}],[\"相比于管道和waitgroup\",{\"1\":{\"342\":1}}],[\"相比之下还增加了25\",{\"1\":{\"395\":1}}],[\"相较于关系数据库更为灵活\",{\"1\":{\"418\":1}}],[\"相较于前者该函数会创建一切必要的父目录\",{\"1\":{\"328\":1}}],[\"相较于第一种可以从指定偏移量读取\",{\"1\":{\"320\":1}}],[\"相互调用\",{\"1\":{\"215\":1}}],[\"相应的占用的内存要多一些\",{\"1\":{\"192\":1}}],[\"相关配置文档请见\",{\"1\":{\"2\":1}}],[\"算是对文件系统的抽象\",{\"1\":{\"508\":1}}],[\"算是一种语法糖\",{\"1\":{\"190\":1}}],[\"算法名称\",{\"1\":{\"379\":1}}],[\"算法和数据结构\",{\"1\":{\"46\":1}}],[\"算法\",{\"0\":{\"14\":1}}],[\"拓展性强\",{\"1\":{\"188\":1}}],[\"拓展表达式就是为了解决此类问题而生的\",{\"1\":{\"169\":1}}],[\"拓展表达式\",{\"0\":{\"169\":1}}],[\"选中集合\",{\"1\":{\"424\":1,\"425\":2}}],[\"选中数据库\",{\"1\":{\"424\":1,\"425\":2}}],[\"选中regexp匹配的模糊测试\",{\"1\":{\"388\":1}}],[\"选中regexp匹配的基准测试\",{\"1\":{\"388\":1}}],[\"选项模式是go语言中一种很常见的设计模式\",{\"1\":{\"188\":1}}],[\"选项模式\",{\"0\":{\"188\":1}}],[\"选择图像处理工具\",{\"1\":{\"58\":1}}],[\"要转换的整型数字\",{\"1\":{\"585\":1}}],[\"要转换的字符串\",{\"1\":{\"584\":1,\"586\":1,\"589\":1,\"591\":1}}],[\"要是事务成功提交了\",{\"1\":{\"439\":1}}],[\"要想一直监测管道\",{\"1\":{\"340\":1}}],[\"要花费1ms\",{\"1\":{\"315\":1}}],[\"要修改反射对象\",{\"1\":{\"268\":1}}],[\"要使用对应的数据库\",{\"1\":{\"432\":1}}],[\"要使用errno\",{\"1\":{\"217\":1}}],[\"要使用此布局\",{\"1\":{\"2\":1}}],[\"要么用ca指纹\",{\"1\":{\"404\":1}}],[\"要么使用ca证书\",{\"1\":{\"404\":1}}],[\"要么使用取地址符将其他变量的地址赋值给该指针\",{\"1\":{\"194\":1}}],[\"要么读要么写\",{\"1\":{\"340\":1}}],[\"要么就都用指针接收者\",{\"1\":{\"206\":1}}],[\"要么就都不用\",{\"1\":{\"206\":1}}],[\"要么就使用内置函数new手动分配\",{\"1\":{\"194\":1}}],[\"要么都用\",{\"1\":{\"206\":1}}],[\"要么建议使用options模式\",{\"1\":{\"187\":1}}],[\"要么创建多个构造函数\",{\"1\":{\"187\":1}}],[\"刻意弱化了面向对象的功能\",{\"1\":{\"185\":1}}],[\"读多写少\",{\"1\":{\"350\":1,\"351\":1}}],[\"读\",{\"1\":{\"337\":1}}],[\"读协程读取数据时\",{\"1\":{\"351\":1}}],[\"读协程可以正常获得读锁\",{\"1\":{\"350\":1}}],[\"读协程也执行结束\",{\"1\":{\"336\":1}}],[\"读协程执行完毕\",{\"1\":{\"336\":1}}],[\"读一个\",{\"1\":{\"336\":1}}],[\"读写操作\",{\"0\":{\"460\":1}}],[\"读写锁\",{\"0\":{\"350\":1}}],[\"读写无缓冲管道\",{\"1\":{\"337\":1}}],[\"读写互斥锁内部实现依旧是互斥锁\",{\"1\":{\"350\":1}}],[\"读写互斥锁\",{\"1\":{\"331\":1}}],[\"读写\",{\"0\":{\"334\":1},\"1\":{\"319\":1}}],[\"读写io的抽象层\",{\"1\":{\"318\":1}}],[\"读操作\",{\"1\":{\"185\":1}}],[\"读取值\",{\"1\":{\"443\":1}}],[\"读取或存入\",{\"1\":{\"355\":1}}],[\"读取并删除\",{\"1\":{\"355\":1}}],[\"读取空缓冲区的管道\",{\"1\":{\"337\":1}}],[\"读取空的管道和写入已满的管道都会造成阻塞\",{\"1\":{\"336\":1}}],[\"读取完毕\",{\"1\":{\"336\":2}}],[\"读取有缓冲管道时\",{\"1\":{\"336\":1}}],[\"读取数据时也是同理\",{\"1\":{\"335\":1}}],[\"读取数据\",{\"1\":{\"334\":1,\"335\":2,\"336\":1,\"337\":1,\"355\":1}}],[\"读取\",{\"0\":{\"320\":1,\"327\":1},\"1\":{\"336\":11}}],[\"读取固定长度的数组\",{\"1\":{\"143\":1}}],[\"读取两个数字\",{\"1\":{\"143\":1}}],[\"读取输入内容\",{\"1\":{\"142\":1}}],[\"读取和写入stl\",{\"1\":{\"51\":1}}],[\"读取和写入\",{\"1\":{\"51\":1}}],[\"甚至没法删除该键值对\",{\"1\":{\"181\":1}}],[\"存储数据库\",{\"1\":{\"441\":1}}],[\"存储格式是bson\",{\"1\":{\"418\":1}}],[\"存储值\",{\"1\":{\"358\":2}}],[\"存储一个键值对\",{\"1\":{\"355\":1}}],[\"存入数据\",{\"1\":{\"355\":1}}],[\"存值时使用已存在的键会覆盖原有的值\",{\"1\":{\"180\":1}}],[\"存值\",{\"0\":{\"180\":1}}],[\"存在循环导入的话将会无法通过编译\",{\"1\":{\"94\":1}}],[\"举几个例子\",{\"1\":{\"178\":1}}],[\"举个例子解释一下长度与容量的区别\",{\"1\":{\"162\":1}}],[\"合起来就是v1\",{\"1\":{\"374\":1}}],[\"合法的utf8编码最大字节数只有4个字节\",{\"1\":{\"177\":1}}],[\"合并\",{\"1\":{\"58\":1}}],[\"界\",{\"1\":{\"177\":1}}],[\"世\",{\"1\":{\"177\":1}}],[\"世界\",{\"1\":{\"91\":2,\"96\":1,\"108\":2,\"133\":1,\"177\":4,\"588\":3,\"596\":3,\"623\":2}}],[\"按照规范是在项目cmd\",{\"1\":{\"365\":1}}],[\"按照常理来说应该这样使用\",{\"1\":{\"225\":1}}],[\"按照直觉来说\",{\"1\":{\"225\":1}}],[\"按照使用者的初衷来说\",{\"1\":{\"204\":1}}],[\"按照字节来遍历会把中文字符拆开\",{\"1\":{\"177\":1}}],[\"按照计算机科学的术语来讲是用于表达源代码中一个固定值的符号\",{\"1\":{\"99\":1}}],[\"\",{\"1\":{\"177\":1}}],[\"\",{\"1\":{\"177\":1}}],[\"ç\",{\"1\":{\"177\":1}}],[\"\",{\"1\":{\"177\":1}}],[\"¸\",{\"1\":{\"177\":1}}],[\"拼接目标路径\",{\"1\":{\"329\":1}}],[\"拼接\",{\"0\":{\"176\":1}}],[\"拼音\",{\"1\":{\"41\":1}}],[\"意为检测该函数的输出是不是hello\",{\"1\":{\"389\":1}}],[\"意思非常明确\",{\"1\":{\"338\":1}}],[\"意大利语\",{\"1\":{\"174\":1}}],[\"意味着优先进行运算\",{\"1\":{\"110\":1}}],[\"è\",{\"1\":{\"174\":1}}],[\"刚好能用一个字节表示\",{\"1\":{\"174\":1}}],[\"对切片进行修改将会直接影响该地址上的数据\",{\"1\":{\"646\":1}}],[\"对uintptr进行数学运算后再转换为pointer就可以完成指针运算\",{\"1\":{\"643\":1}}],[\"对齐大小通常是以字节为单位的计算机字长与sizeof的最小值\",{\"1\":{\"642\":1}}],[\"对外暴露一个channel\",{\"1\":{\"633\":1}}],[\"对应的go模块名就是github\",{\"1\":{\"364\":1}}],[\"对只写的管道读取数据也是同理\",{\"1\":{\"338\":1}}],[\"对一个已关闭的管道写入数据会导致panic\",{\"1\":{\"337\":1}}],[\"对一个变量进行取地址\",{\"1\":{\"194\":1}}],[\"对其写入数据会导致该协程阻塞\",{\"1\":{\"337\":1}}],[\"对其写入数据114514\",{\"1\":{\"334\":1}}],[\"对待其它通用接口也是如此\",{\"1\":{\"259\":1}}],[\"对泛型类型使用类型断言将会无法通过编译\",{\"1\":{\"258\":1}}],[\"对象存储\",{\"1\":{\"254\":1}}],[\"对指针类型解引用就能访问到指针所指向的元素\",{\"1\":{\"194\":1}}],[\"对map求长度\",{\"1\":{\"179\":1}}],[\"对字节切片进行修改不会对原字符串产生任何影响\",{\"1\":{\"173\":1}}],[\"对于嵌套的结构体或map\",{\"1\":{\"617\":1}}],[\"对于切片和map\",{\"1\":{\"617\":1}}],[\"对于结构体和map\",{\"1\":{\"617\":1}}],[\"对于结构体指针而言\",{\"1\":{\"190\":1}}],[\"对于传入的data\",{\"1\":{\"617\":1}}],[\"对于大指数采用\",{\"1\":{\"590\":2}}],[\"对于服务端而言就是\",{\"1\":{\"574\":1}}],[\"对于客户端而言就是\",{\"1\":{\"574\":1}}],[\"对于mysql而言就是下面这样\",{\"1\":{\"433\":1}}],[\"对于map而言\",{\"1\":{\"178\":1}}],[\"对于基准测试而言\",{\"1\":{\"394\":1}}],[\"对于单元测试而言\",{\"1\":{\"390\":2}}],[\"对于测试函数而言\",{\"1\":{\"389\":1}}],[\"对于不同的测试类型\",{\"1\":{\"386\":1}}],[\"对于开发者而言\",{\"1\":{\"385\":1}}],[\"对于开发者而言也会减少很多心智负担\",{\"1\":{\"207\":1}}],[\"对于私有项目而言\",{\"1\":{\"380\":1}}],[\"对于命令行程序而言\",{\"1\":{\"365\":1}}],[\"对于工程项目而言十分的不友好\",{\"1\":{\"361\":1}}],[\"对于go中atomic包下的原子操作\",{\"1\":{\"359\":1}}],[\"对于go而言\",{\"1\":{\"213\":1,\"535\":1}}],[\"对于cas而言\",{\"1\":{\"359\":1}}],[\"对于c中的类型\",{\"1\":{\"220\":1}}],[\"对于条件变量\",{\"1\":{\"351\":1}}],[\"对于锁而言\",{\"1\":{\"350\":1}}],[\"对于上面的例子\",{\"1\":{\"348\":1}}],[\"对于有缓冲管道而言\",{\"1\":{\"339\":1}}],[\"对于有缓冲管道写入数据时\",{\"1\":{\"336\":1}}],[\"对于有缓冲管道则不必如此\",{\"1\":{\"336\":1}}],[\"对于无缓冲管道而言\",{\"1\":{\"335\":1}}],[\"对于读取操作而言\",{\"1\":{\"334\":1}}],[\"对于管道而言\",{\"1\":{\"333\":1}}],[\"对于较为传统的锁控制\",{\"1\":{\"331\":1}}],[\"对于并发的程序而言\",{\"1\":{\"331\":1}}],[\"对于文件夹而言\",{\"1\":{\"327\":1}}],[\"对于复制文件而言\",{\"1\":{\"322\":1}}],[\"对于写入文件的操作标准库同样提供了方便函数\",{\"1\":{\"321\":1}}],[\"对于os\",{\"1\":{\"320\":1}}],[\"对于常规文件而言\",{\"1\":{\"319\":1}}],[\"对于修改结构体私有字段而言\",{\"1\":{\"287\":1}}],[\"对于数组\",{\"1\":{\"271\":1}}],[\"对于指针使用elem\",{\"1\":{\"271\":1}}],[\"对于type而言\",{\"1\":{\"270\":1}}],[\"对于接口的简单原理只需要了解到这里就足够满足后续反射的学习\",{\"1\":{\"266\":1}}],[\"对于这两个独立的模块\",{\"1\":{\"382\":1}}],[\"对于这两种类型\",{\"1\":{\"266\":1}}],[\"对于这种情况\",{\"1\":{\"204\":1}}],[\"对于含有方法集的接口来说\",{\"1\":{\"266\":1}}],[\"对于一个协程而言\",{\"1\":{\"350\":1}}],[\"对于一个管道而言\",{\"1\":{\"334\":1}}],[\"对于一个泛型变量\",{\"1\":{\"262\":1}}],[\"对于一些读多写少的数据\",{\"1\":{\"350\":1}}],[\"对于一些不支持取消的上下文\",{\"1\":{\"343\":1}}],[\"对于一些类型需要避免歧义\",{\"1\":{\"304\":1}}],[\"对于一些类型相同的相邻字段\",{\"1\":{\"186\":1}}],[\"对于一些引用类型\",{\"1\":{\"239\":1}}],[\"对于一些十分复杂的任务\",{\"1\":{\"233\":1}}],[\"对于一些十分简单的任务\",{\"1\":{\"233\":1}}],[\"对于一些性能要求更高的场景\",{\"1\":{\"215\":1}}],[\"对于非接口类型\",{\"1\":{\"260\":1}}],[\"对于火焰图而言\",{\"1\":{\"246\":1}}],[\"对于内存而言四个维度可以分析\",{\"1\":{\"246\":1}}],[\"对于图片和源代码而言\",{\"1\":{\"245\":1}}],[\"对于存活对象的内存分配抽样\",{\"1\":{\"243\":1}}],[\"对于项目而言会使得代码更加优雅可读\",{\"1\":{\"207\":1}}],[\"对于defer直接作用的函数而言\",{\"1\":{\"204\":1}}],[\"对于延迟调用有一些反直觉的细节\",{\"1\":{\"204\":1}}],[\"对于类型相同的参数而言\",{\"1\":{\"198\":1}}],[\"对于每一个种数据结构\",{\"1\":{\"153\":1}}],[\"对于函数外的包级变量则没有这个限制\",{\"1\":{\"125\":1}}],[\"对于零内存分配和快速响应的快速重定向到预定义域很有用\",{\"1\":{\"64\":1}}],[\"对于可视化调试很有价值\",{\"1\":{\"43\":1}}],[\"访问集合元素\",{\"0\":{\"473\":1}}],[\"访问指定范围内的元素\",{\"1\":{\"469\":1}}],[\"访问指定下标的元素\",{\"1\":{\"469\":1}}],[\"访问元素\",{\"0\":{\"469\":1,\"482\":1}}],[\"访问列表长度\",{\"1\":{\"468\":1}}],[\"访问长度\",{\"0\":{\"468\":1}}],[\"访问速度对于国内的用户不甚友好\",{\"1\":{\"370\":1}}],[\"访问数据\",{\"1\":{\"348\":1,\"349\":1}}],[\"访问方法信息示例如下\",{\"1\":{\"289\":1}}],[\"访问方法与访问字段的过程很相似\",{\"1\":{\"289\":1}}],[\"访问方法\",{\"0\":{\"289\":1}}],[\"访问tag\",{\"0\":{\"288\":1}}],[\"访问结构体字段的方法有两种\",{\"1\":{\"286\":1}}],[\"访问字段\",{\"0\":{\"286\":1}}],[\"访问一个map的方式就像通过索引访问一个数组一样\",{\"1\":{\"179\":1}}],[\"访问\",{\"0\":{\"172\":1,\"179\":1},\"1\":{\"541\":1}}],[\"访问go语言二进制程序中的调试信息\",{\"1\":{\"43\":1}}],[\"普通字符串由\",{\"1\":{\"171\":1}}],[\"普通字符串\",{\"1\":{\"171\":1}}],[\"限制了切割后的容量\",{\"1\":{\"170\":1}}],[\"却连s1也一起修改了\",{\"1\":{\"169\":1}}],[\"添加新元素\",{\"1\":{\"169\":1}}],[\"二是将dog\",{\"1\":{\"206\":1}}],[\"二维切片\",{\"1\":{\"168\":1}}],[\"二进制指数\",{\"1\":{\"590\":1}}],[\"二进制\",{\"1\":{\"509\":1}}],[\"二进制同理\",{\"1\":{\"140\":1}}],[\"二进制打包程序和解包程序可帮助用户构建自定义二进制流\",{\"1\":{\"46\":1}}],[\"遍历替换字符串\",{\"0\":{\"605\":1}}],[\"遍历集合\",{\"1\":{\"478\":1}}],[\"遍历哈希表的键值对\",{\"0\":{\"465\":1}}],[\"遍历map中的键值对\",{\"1\":{\"465\":1}}],[\"遍历map\",{\"1\":{\"355\":2}}],[\"遍历赋值\",{\"1\":{\"294\":1}}],[\"遍历输出返回值\",{\"1\":{\"290\":1}}],[\"遍历输出方法信息\",{\"1\":{\"289\":2,\"290\":1}}],[\"遍历\",{\"0\":{\"167\":1,\"177\":1,\"182\":1,\"478\":1}}],[\"拷贝\",{\"0\":{\"166\":1,\"175\":1}}],[\"删除在s内第一次出现的子串sep\",{\"1\":{\"600\":1}}],[\"删除权值在min和max区间的元素\",{\"1\":{\"484\":1}}],[\"删除指定子串\",{\"0\":{\"600\":1}}],[\"删除指定排名区间的元素\",{\"1\":{\"484\":1}}],[\"删除指定范围的元素\",{\"1\":{\"470\":1}}],[\"删除指定元素\",{\"1\":{\"470\":1,\"477\":1,\"484\":1}}],[\"删除指定目录的所有文件和目录包括子目录与子文件\",{\"1\":{\"324\":1}}],[\"删除map的一个字段\",{\"1\":{\"461\":1}}],[\"删除键\",{\"0\":{\"448\":1,\"461\":1}}],[\"删除数据\",{\"1\":{\"438\":1}}],[\"删除文档\",{\"0\":{\"428\":1}}],[\"删除若干个指定的索引\",{\"1\":{\"409\":1}}],[\"删除一个键值对\",{\"1\":{\"355\":2}}],[\"删除一个键值对需要用到内置函数delete\",{\"1\":{\"181\":1}}],[\"删除成功\",{\"1\":{\"324\":2}}],[\"删除当前目录下所有的文件与子目录\",{\"1\":{\"324\":2}}],[\"删除单个文件或者空目录\",{\"1\":{\"324\":1}}],[\"删除操作相较于其他操作要简单的多\",{\"1\":{\"324\":1}}],[\"删除\",{\"0\":{\"181\":1,\"324\":1,\"409\":1,\"414\":1,\"438\":1}}],[\"删除所有元素\",{\"1\":{\"165\":1}}],[\"删除元素\",{\"0\":{\"165\":1,\"470\":1,\"475\":1,\"477\":1,\"484\":1}}],[\"小于等于\",{\"1\":{\"620\":1}}],[\"小于\",{\"1\":{\"620\":1}}],[\"小于256的时候\",{\"1\":{\"163\":1}}],[\"小指数采用\",{\"1\":{\"590\":2}}],[\"小写e十进制指数\",{\"1\":{\"590\":1}}],[\"小写字母\",{\"1\":{\"378\":1}}],[\"小\",{\"1\":{\"509\":1}}],[\"小版本号是20\",{\"1\":{\"374\":1}}],[\"小结\",{\"0\":{\"264\":1,\"416\":1}}],[\"小细节\",{\"1\":{\"239\":1}}],[\"小数处理\",{\"1\":{\"41\":1}}],[\"倍\",{\"1\":{\"163\":1}}],[\"预留的\",{\"1\":{\"163\":1}}],[\"预感提供功能\",{\"1\":{\"56\":1}}],[\"新建一个协程去处理该连接\",{\"1\":{\"574\":1}}],[\"新建一个redis连接的时候\",{\"1\":{\"444\":1}}],[\"新建定时器\",{\"1\":{\"345\":1}}],[\"新增元素\",{\"0\":{\"472\":1}}],[\"新增数据\",{\"1\":{\"436\":1}}],[\"新增\",{\"0\":{\"436\":1}}],[\"新值\",{\"1\":{\"359\":2}}],[\"新接口定义就是为了泛型而服务的\",{\"1\":{\"208\":1}}],[\"新slice容量newcap\",{\"1\":{\"163\":1}}],[\"新slice\",{\"1\":{\"163\":1}}],[\"新\",{\"1\":{\"163\":3}}],[\"最小的单位是纳秒\",{\"1\":{\"630\":1}}],[\"最小值\",{\"0\":{\"547\":1}}],[\"最小化的语言了解一下\",{\"1\":{\"509\":1}}],[\"最小堆的实现\",{\"1\":{\"508\":1}}],[\"最小重试时间间隔\",{\"1\":{\"444\":1}}],[\"最大的是小时\",{\"1\":{\"630\":1}}],[\"最大值\",{\"0\":{\"546\":1}}],[\"最大重试时间间隔\",{\"1\":{\"444\":1}}],[\"最大也只有三个字节\",{\"1\":{\"177\":1}}],[\"最重要的一点就是降低gc压力\",{\"1\":{\"354\":1}}],[\"最好手动取消上下文\",{\"1\":{\"347\":1}}],[\"最多只能有一个协程对变量count进行修改\",{\"1\":{\"336\":1}}],[\"最多只有一个数据存放在缓冲区中\",{\"1\":{\"336\":1}}],[\"最简单的做法就是让主协程等一会儿\",{\"1\":{\"331\":1}}],[\"最根本的区别在于它的类型一旦推断出来后不会再发生变化\",{\"1\":{\"300\":1}}],[\"最轻松的当然是直接不要泛型\",{\"1\":{\"264\":1}}],[\"最初的go是没有泛型这一说法的\",{\"1\":{\"255\":1}}],[\"最后依旧需要发布新版本\",{\"1\":{\"382\":1}}],[\"最后再推送到远程仓库\",{\"1\":{\"368\":1}}],[\"最后的最后\",{\"1\":{\"367\":1}}],[\"最后需要注意的是\",{\"1\":{\"354\":1}}],[\"最后会将自身从父级中删除\",{\"1\":{\"346\":1}}],[\"最后输出到传入的writer中也就是os\",{\"1\":{\"615\":1}}],[\"最后输出如下\",{\"1\":{\"345\":1}}],[\"最后输出长度和容量\",{\"1\":{\"163\":1}}],[\"最后主协程退出\",{\"1\":{\"336\":1}}],[\"最后关闭该管道\",{\"1\":{\"334\":1}}],[\"最后\",{\"0\":{\"233\":1}}],[\"最后编译go程序并执行\",{\"1\":{\"231\":1}}],[\"最典型的例子就是fmt\",{\"1\":{\"198\":1}}],[\"最终的模板生成结果为\",{\"1\":{\"626\":1}}],[\"最终的输出为\",{\"1\":{\"169\":1}}],[\"最终都会通过fmt\",{\"1\":{\"617\":1}}],[\"最终结果一定是10\",{\"1\":{\"348\":1}}],[\"最终结果\",{\"1\":{\"348\":2,\"349\":2,\"350\":2,\"351\":2}}],[\"最终输出\",{\"1\":{\"632\":1}}],[\"最终输出的结果为\",{\"1\":{\"627\":1}}],[\"最终输出为\",{\"1\":{\"358\":1}}],[\"最终输出如下\",{\"1\":{\"340\":1}}],[\"最终输出结果为\",{\"1\":{\"168\":1}}],[\"最常用的独立于语言的数据格式有xml\",{\"1\":{\"509\":1}}],[\"最常用的\",{\"1\":{\"158\":1}}],[\"最常见的用法是使用fmt包\",{\"1\":{\"138\":1}}],[\"默认不会关闭过时的连接\",{\"1\":{\"444\":1}}],[\"默认连接池大小等于\",{\"1\":{\"444\":1}}],[\"默认\",{\"1\":{\"444\":1}}],[\"默认0\",{\"1\":{\"444\":1}}],[\"默认是等待\",{\"1\":{\"444\":1}}],[\"默认是0\",{\"1\":{\"444\":1}}],[\"默认是\",{\"1\":{\"444\":6}}],[\"默认是sum\",{\"1\":{\"379\":1}}],[\"默认为go\",{\"1\":{\"388\":1}}],[\"默认种子为系统时间\",{\"1\":{\"388\":1}}],[\"默认1次\",{\"1\":{\"388\":1}}],[\"默认情况下是不会输出堆栈的\",{\"1\":{\"312\":1}}],[\"默认值处理\",{\"1\":{\"188\":1}}],[\"默认值为nil\",{\"1\":{\"162\":1}}],[\"默认缓冲区大小是4kb\",{\"1\":{\"139\":1}}],[\"桶的高度就是桶的容量\",{\"1\":{\"162\":1}}],[\"水的高度一定小于等于桶的高度\",{\"1\":{\"162\":1}}],[\"水并不是满的\",{\"1\":{\"162\":1}}],[\"水印\",{\"1\":{\"58\":1}}],[\"若是涉及到html的模板处理建议使用后者会更安全\",{\"1\":{\"614\":1}}],[\"若要将数组转换为切片类型\",{\"1\":{\"160\":1}}],[\"若你尝试去访问一个私有的类型\",{\"1\":{\"94\":1}}],[\"子模板只是在一个模板内部声明多个命名的模板\",{\"1\":{\"626\":1}}],[\"子串的位置\",{\"0\":{\"604\":1}}],[\"子串出现次数\",{\"0\":{\"599\":1}}],[\"子测试\",{\"0\":{\"392\":1}}],[\"子协程要执行一些逻辑\",{\"1\":{\"315\":1}}],[\"子数组范围\",{\"1\":{\"160\":4}}],[\"子包\",{\"1\":{\"43\":1}}],[\"切割字符串\",{\"1\":{\"172\":1}}],[\"切割的区间为左闭右开\",{\"1\":{\"160\":1}}],[\"切割数组的格式为arr\",{\"1\":{\"160\":1}}],[\"切割\",{\"0\":{\"160\":1}}],[\"切片操作包\",{\"1\":{\"508\":1}}],[\"切片类型\",{\"1\":{\"213\":1}}],[\"切片与数组都可以使用简单表达式来进行切割\",{\"1\":{\"169\":1}}],[\"切片与数组最大的区别在于切片的容量会自动扩张\",{\"1\":{\"162\":1}}],[\"切片初始化部分修改为如下代码即可\",{\"1\":{\"168\":1}}],[\"切片中的每一个切片长度都可能是不相同的\",{\"1\":{\"168\":1}}],[\"切片元素的删除需要结合append函数来使用\",{\"1\":{\"165\":1}}],[\"切片元素的插入也是需要结合append函数来使用\",{\"1\":{\"164\":1}}],[\"切片可以通过append函数实现许多操作\",{\"1\":{\"163\":1}}],[\"切片的情况的实际上跟上面讲到的字符串差不多\",{\"1\":{\"225\":1}}],[\"切片的遍历与数组完全一致\",{\"1\":{\"167\":1}}],[\"切片的基本使用与数组完全一致\",{\"1\":{\"163\":1}}],[\"切片的底层实现依旧是数组\",{\"1\":{\"162\":1}}],[\"切片的容量代表着切片总共能装多少个元素\",{\"1\":{\"162\":1}}],[\"切片的长度代表着切片中元素的个数\",{\"1\":{\"162\":1}}],[\"切片的初始化方式有以下几种\",{\"1\":{\"162\":1}}],[\"切片在拷贝时需要确保目标切片有足够的长度\",{\"1\":{\"166\":1}}],[\"切片在go中的应用范围要比数组广泛的多\",{\"1\":{\"161\":1}}],[\"切片在容量不够时会自行扩容\",{\"1\":{\"156\":1}}],[\"切片不可比较\",{\"1\":{\"128\":1}}],[\"切片\",{\"0\":{\"156\":1,\"161\":1,\"225\":1,\"294\":1},\"1\":{\"120\":1,\"121\":1,\"129\":1,\"153\":1,\"271\":2,\"298\":2,\"620\":1,\"624\":1}}],[\"区块链\",{\"1\":{\"254\":1}}],[\"区别在于\",{\"1\":{\"643\":1}}],[\"区别在于后者会将非ascii字符转通过\",{\"1\":{\"588\":1}}],[\"区别在于前两者的测试数据都需要开发者手动编写\",{\"1\":{\"396\":1}}],[\"区别在于前者无序\",{\"1\":{\"177\":1}}],[\"区别只是切片可以动态变化长度\",{\"1\":{\"163\":1}}],[\"区别只是最后一种得到的值是指针\",{\"1\":{\"158\":1}}],[\"区间数字的代码\",{\"1\":{\"152\":1}}],[\"省略号必须存在\",{\"1\":{\"158\":1}}],[\"长度方法\",{\"1\":{\"575\":1}}],[\"长度范围内的元素完全相等\",{\"1\":{\"298\":1}}],[\"长度未知\",{\"0\":{\"239\":1}}],[\"长度为10\",{\"1\":{\"196\":1}}],[\"长度为5的整型数组\",{\"1\":{\"120\":1}}],[\"长度与容量\",{\"1\":{\"162\":1}}],[\"长度\",{\"0\":{\"174\":1},\"1\":{\"162\":1}}],[\"长度必须为一个常量表达式\",{\"1\":{\"158\":1}}],[\"长度被指定后就不能被改变\",{\"1\":{\"156\":1}}],[\"直线图\",{\"1\":{\"246\":1}}],[\"直接执行脚本\",{\"1\":{\"485\":1}}],[\"直接返回错误\",{\"1\":{\"396\":1}}],[\"直接提供对应的文件名即可\",{\"1\":{\"319\":1}}],[\"直接忽略掉不处理程序也不会崩溃\",{\"1\":{\"307\":1}}],[\"直接的并入了自身\",{\"1\":{\"260\":1}}],[\"直接在代码中使用pprof需要引入runtime\",{\"1\":{\"242\":1}}],[\"直接修改底层数组\",{\"1\":{\"169\":1}}],[\"直接进入下一次迭代\",{\"1\":{\"155\":1}}],[\"直到恢复运行状态\",{\"1\":{\"635\":1}}],[\"直到go1\",{\"1\":{\"361\":1}}],[\"直到成功\",{\"1\":{\"359\":1}}],[\"直到数据大于3\",{\"1\":{\"351\":1}}],[\"直到被唤醒\",{\"1\":{\"351\":1}}],[\"直到释放写锁\",{\"1\":{\"350\":1}}],[\"直到减为0\",{\"1\":{\"341\":1}}],[\"直到至少有一个case可用\",{\"1\":{\"340\":1}}],[\"直到有其他协程向管道中写入数据才会继续读取数据\",{\"1\":{\"339\":1}}],[\"直到缓冲区空出位置来\",{\"1\":{\"336\":1}}],[\"直到缓冲区没数据了\",{\"1\":{\"336\":1}}],[\"直到所有数据发送完毕\",{\"1\":{\"336\":1}}],[\"直到程序停止运行\",{\"1\":{\"315\":1}}],[\"直到用新的const重置\",{\"1\":{\"131\":1}}],[\"直到\",{\"1\":{\"84\":1}}],[\"后面都停止维护了\",{\"1\":{\"419\":1}}],[\"后面就是每当读协程1毫秒读取一个数据\",{\"1\":{\"336\":1}}],[\"后面跟着的是被导入的包名\",{\"1\":{\"91\":1}}],[\"后记\",{\"0\":{\"248\":1}}],[\"后者仅仅是一个整数值\",{\"1\":{\"643\":1}}],[\"后者基于前者并做了很多关于html的安全处理\",{\"1\":{\"614\":1}}],[\"后者是寻找后缀\",{\"1\":{\"603\":1}}],[\"后者是函数f的返回值来决定是否分割字符串\",{\"1\":{\"602\":1}}],[\"后者是直接替换文档\",{\"1\":{\"427\":1}}],[\"后者是指定一个超时的时间间隔\",{\"1\":{\"347\":1}}],[\"后者则会直接停止执行\",{\"1\":{\"390\":1}}],[\"后者openfile能够提供更加细粒度的控制\",{\"1\":{\"319\":1}}],[\"后者使用起来更类似于继承\",{\"1\":{\"189\":1}}],[\"后者有序\",{\"1\":{\"177\":1}}],[\"后续查阅文档时也可以来这里\",{\"1\":{\"372\":1}}],[\"后续会进行深入分析\",{\"1\":{\"177\":1}}],[\"后续也会讲到\",{\"1\":{\"153\":1}}],[\"示例中使用f\",{\"1\":{\"396\":1}}],[\"示例测试在标准库中出现的非常多\",{\"1\":{\"389\":1}}],[\"示例测试并不是一个官方定义的概念\",{\"1\":{\"389\":1}}],[\"示例测试并不像其他三种测试一样是为了发现程序的问题所在\",{\"1\":{\"389\":1}}],[\"示例测试\",{\"0\":{\"389\":1},\"1\":{\"385\":1,\"387\":1}}],[\"示例仓库中的go\",{\"1\":{\"382\":1}}],[\"示例仓库\",{\"1\":{\"362\":1,\"381\":1}}],[\"示例代码如下\",{\"1\":{\"223\":1}}],[\"示例\",{\"0\":{\"256\":1,\"382\":1,\"528\":1},\"1\":{\"152\":1,\"567\":1,\"568\":1,\"604\":2,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"620\":1}}],[\"示例如下\",{\"1\":{\"151\":1,\"272\":1,\"279\":1,\"288\":1,\"305\":1,\"306\":1,\"323\":1,\"328\":1}}],[\"执行耗时等等性能指标\",{\"1\":{\"394\":1}}],[\"执行后结果如下\",{\"1\":{\"392\":1}}],[\"执行后会开启一个web\",{\"1\":{\"247\":1}}],[\"执行上述测试输出如下\",{\"1\":{\"390\":1}}],[\"执行情况\",{\"1\":{\"387\":1}}],[\"执行这些测试有多种方法\",{\"1\":{\"387\":1}}],[\"执行测试命令\",{\"1\":{\"394\":1}}],[\"执行测试后输出信息如下\",{\"1\":{\"391\":1}}],[\"执行测试后输出如下\",{\"1\":{\"390\":1,\"392\":1}}],[\"执行测试主要会用到go\",{\"1\":{\"387\":1}}],[\"执行测试\",{\"0\":{\"387\":1}}],[\"执行如下命令\",{\"1\":{\"396\":1}}],[\"执行如下命令来修改go代理\",{\"1\":{\"370\":1}}],[\"执行如下命令进行编译\",{\"1\":{\"216\":1}}],[\"执行时\",{\"1\":{\"359\":1}}],[\"执行减法\",{\"1\":{\"336\":1}}],[\"执行加法\",{\"1\":{\"336\":1}}],[\"执行过程的耗时等等\",{\"1\":{\"331\":1}}],[\"执行的时机\",{\"1\":{\"331\":1}}],[\"执行完毕后就会解锁\",{\"1\":{\"359\":1}}],[\"执行完毕后修改done\",{\"1\":{\"353\":1}}],[\"执行完毕后文件内容如下\",{\"1\":{\"321\":1}}],[\"执行完毕\",{\"1\":{\"341\":1}}],[\"执行完对应分支后主协程就直接退出了\",{\"1\":{\"340\":1}}],[\"执行完该分支后\",{\"1\":{\"149\":1}}],[\"执行顺序依旧一致\",{\"1\":{\"315\":1}}],[\"执行count\",{\"1\":{\"46\":1}}],[\"应及时的关闭\",{\"1\":{\"633\":1}}],[\"应该使用循环来判断条件是否满足\",{\"1\":{\"351\":1}}],[\"应该使用for而不是if\",{\"1\":{\"351\":1}}],[\"应该使用指针\",{\"1\":{\"350\":1}}],[\"应该使用interface\",{\"1\":{\"258\":1}}],[\"应该尽量在向管道发送数据的那一方关闭管道\",{\"1\":{\"339\":1}}],[\"应该对为什么要使用泛型\",{\"1\":{\"256\":1}}],[\"应对这种情况就需要用到rune类型\",{\"1\":{\"177\":1}}],[\"应当使用括号来显式的表示谁应该优先计算\",{\"1\":{\"147\":1}}],[\"应用的原生支持\",{\"1\":{\"84\":1}}],[\"必要时在加锁的同时立即使用defer语句解锁\",{\"1\":{\"348\":1}}],[\"必要时为了提高可读性\",{\"1\":{\"147\":1}}],[\"必须与花括号相邻\",{\"1\":{\"618\":1}}],[\"必须指定版本号\",{\"1\":{\"373\":1}}],[\"必须立刻有人接收\",{\"1\":{\"336\":1}}],[\"必须在defer中使用\",{\"1\":{\"316\":1}}],[\"必须要在defer语句中运行\",{\"1\":{\"316\":1}}],[\"必须要指定当前文件夹\",{\"1\":{\"218\":1}}],[\"必须使用\",{\"1\":{\"311\":1}}],[\"必须是正整数\",{\"1\":{\"309\":1}}],[\"必须是lib前缀开头\",{\"1\":{\"232\":1}}],[\"必须是一个布尔值\",{\"1\":{\"147\":1}}],[\"必须声明在参数列表的末尾\",{\"1\":{\"198\":1}}],[\"必看项目\",{\"0\":{\"42\":1}}],[\"至此\",{\"1\":{\"266\":1}}],[\"至少在go中你可以仅通过函数名就知道它是干什么的\",{\"1\":{\"197\":1}}],[\"至少32位\",{\"1\":{\"116\":2}}],[\"至多两个判断分支\",{\"1\":{\"147\":1}}],[\"码\",{\"1\":{\"140\":1}}],[\"会导致nums的数据也会发生变化\",{\"1\":{\"646\":1}}],[\"会导致该协程阻塞\",{\"1\":{\"337\":1}}],[\"会覆盖默认的内容\",{\"1\":{\"627\":1}}],[\"会回调这个函数\",{\"1\":{\"444\":1}}],[\"会集中存储您的数据\",{\"1\":{\"402\":1}}],[\"会需要用到在一个测试用例中测试另外测试用例\",{\"1\":{\"392\":1}}],[\"会将前者所指向的地址作为后者的值\",{\"1\":{\"643\":1}}],[\"会将当前用例标记为skip\",{\"1\":{\"390\":1}}],[\"会将接收者的值传入方法中\",{\"1\":{\"205\":1}}],[\"会有好几个版本命名的文件\",{\"1\":{\"379\":1}}],[\"会有两个返回值\",{\"1\":{\"339\":1}}],[\"会造成大量的不必要的协程竞争锁\",{\"1\":{\"350\":1}}],[\"会一直阻塞直到全部计数减为0\",{\"1\":{\"341\":1}}],[\"会先从缓冲区中读取数据\",{\"1\":{\"336\":1}}],[\"会先将数据放入缓冲区里\",{\"1\":{\"336\":1}}],[\"会用到os包下的rename函数\",{\"1\":{\"323\":1}}],[\"会立即退出所在函数\",{\"1\":{\"315\":1}}],[\"会立即告诉程序员不应该这么做\",{\"1\":{\"300\":1}}],[\"会自动调用value\",{\"1\":{\"279\":1}}],[\"会获得其指向元素的反射类型\",{\"1\":{\"271\":1}}],[\"会分析一段时间并下载一个文件\",{\"1\":{\"243\":1}}],[\"会返回一个指针与错误\",{\"1\":{\"530\":1}}],[\"会返回一个err来解释为什么会关闭\",{\"1\":{\"343\":1}}],[\"会返回一个unsafe\",{\"1\":{\"222\":1}}],[\"会返回错误\",{\"1\":{\"321\":1}}],[\"会返回map的键反射类型\",{\"1\":{\"271\":1}}],[\"会返回对应类型的指针\",{\"1\":{\"194\":1}}],[\"会对其底层类型进行比较\",{\"1\":{\"213\":1}}],[\"会发现myint的值依旧是1\",{\"1\":{\"205\":1}}],[\"会继续执行下一个分支\",{\"1\":{\"149\":1}}],[\"会去掉多余的0\",{\"1\":{\"140\":1}}],[\"会计和财务软件包\",{\"1\":{\"39\":1}}],[\"积累到了一定阈值再输出到指定的writer中\",{\"1\":{\"139\":1}}],[\"输入的总数\",{\"1\":{\"396\":1}}],[\"输入help\",{\"1\":{\"245\":1}}],[\"输入\",{\"0\":{\"141\":1}}],[\"输入输出\",{\"0\":{\"133\":1}}],[\"输出更详细的测试日志\",{\"1\":{\"388\":1}}],[\"输出模块依赖图\",{\"1\":{\"375\":1}}],[\"输出都如下\",{\"1\":{\"341\":1}}],[\"输出timeerror的时间\",{\"1\":{\"312\":1}}],[\"输出文件名\",{\"1\":{\"307\":1}}],[\"输出错误信息\",{\"1\":{\"307\":1}}],[\"输出方法个数\",{\"1\":{\"289\":2,\"290\":1}}],[\"输出第一个返回值的类型\",{\"1\":{\"283\":1}}],[\"输出第一个参数的类型\",{\"1\":{\"283\":1}}],[\"输出参数\",{\"1\":{\"283\":1}}],[\"输出函数名称\",{\"1\":{\"283\":1}}],[\"输出其名称\",{\"1\":{\"271\":1}}],[\"输出包路径\",{\"1\":{\"271\":1}}],[\"输出又变回3了\",{\"1\":{\"204\":1}}],[\"输出的结果就会变得非常有迷惑性\",{\"1\":{\"315\":1}}],[\"输出的是7\",{\"1\":{\"204\":1}}],[\"输出的字符串两端有双引号\",{\"1\":{\"140\":1}}],[\"输出为\",{\"1\":{\"201\":1,\"213\":1,\"271\":1,\"315\":3,\"320\":1,\"628\":1}}],[\"输出是字节而不是字符\",{\"1\":{\"172\":1}}],[\"输出结构体\",{\"1\":{\"287\":2}}],[\"输出结构体字段的数量\",{\"1\":{\"286\":2}}],[\"输出结构体时将加上字段名\",{\"1\":{\"140\":1}}],[\"输出结果\",{\"1\":{\"270\":1,\"274\":1,\"339\":1,\"424\":1,\"623\":1}}],[\"输出结果如下\",{\"1\":{\"219\":1}}],[\"输出结果为\",{\"1\":{\"168\":1,\"269\":1,\"272\":1,\"276\":1}}],[\"输出如下\",{\"1\":{\"152\":1,\"166\":1,\"177\":1,\"203\":1,\"236\":1,\"273\":1,\"280\":1,\"319\":2,\"320\":1,\"346\":2,\"347\":1,\"353\":1,\"355\":1,\"394\":1,\"519\":1,\"617\":2}}],[\"输出指针所指向的地址\",{\"1\":{\"140\":1}}],[\"输出字符对应的unicode码\",{\"1\":{\"140\":1}}],[\"输出unicode码对应的字符\",{\"1\":{\"140\":1}}],[\"输出值对应的go语言类型值\",{\"1\":{\"140\":1}}],[\"输出值原本的形式\",{\"1\":{\"140\":1}}],[\"输出布尔值\",{\"1\":{\"140\":1}}],[\"输出完整go语法格式的值\",{\"1\":{\"140\":1}}],[\"输出整型的大写十六进制表示\",{\"1\":{\"140\":1}}],[\"输出整型的完整大写十六进制表示\",{\"1\":{\"140\":1}}],[\"输出整型的完整小写十六进制表示\",{\"1\":{\"140\":1}}],[\"输出整型的完整八进制表示\",{\"1\":{\"140\":1}}],[\"输出整型的小写十六进制表示\",{\"1\":{\"140\":1}}],[\"输出整型的八进制表示\",{\"1\":{\"140\":1}}],[\"输出整型的二进制表现形式\",{\"1\":{\"140\":1}}],[\"输出二进制完整的表现形式\",{\"1\":{\"140\":1}}],[\"输出科学计数法形式\",{\"1\":{\"140\":1}}],[\"输出浮点数\",{\"1\":{\"140\":1}}],[\"输出十进制整型值\",{\"1\":{\"140\":1}}],[\"输出string\",{\"1\":{\"140\":1}}],[\"输出百分号\",{\"1\":{\"140\":1}}],[\"输出\",{\"0\":{\"135\":1},\"1\":{\"154\":2,\"155\":2,\"160\":3,\"170\":1,\"183\":1,\"193\":1,\"201\":1,\"202\":1,\"206\":2,\"211\":1,\"212\":1,\"213\":1,\"217\":2,\"220\":1,\"221\":1,\"222\":2,\"225\":2,\"226\":1,\"227\":2,\"228\":1,\"229\":2,\"237\":1,\"238\":1,\"239\":2,\"263\":1,\"275\":1,\"277\":1,\"278\":1,\"279\":2,\"281\":1,\"283\":1,\"284\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"293\":1,\"297\":1,\"298\":2,\"312\":1,\"315\":1,\"316\":1,\"317\":1,\"336\":2,\"355\":1,\"404\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"425\":2,\"427\":2,\"429\":1,\"460\":1,\"511\":1,\"512\":1,\"514\":1,\"515\":1,\"520\":1,\"521\":1,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"617\":1,\"619\":1,\"624\":1,\"625\":1}}],[\"我建议使用slices标准库来进行排序\",{\"1\":{\"575\":1}}],[\"我比较推荐github\",{\"1\":{\"364\":1}}],[\"我推荐下面几个开源库\",{\"1\":{\"249\":1}}],[\"我推荐下面几个开源框架\",{\"1\":{\"249\":1}}],[\"我可以给出下面几个学习路线和示例项目以供参考\",{\"1\":{\"248\":1}}],[\"我可以告诉你大可不必担心\",{\"1\":{\"198\":1}}],[\"我认为这绝对是利大于弊的\",{\"1\":{\"132\":1}}],[\"我们通常会使用更加完善的第三方日志包\",{\"1\":{\"541\":1}}],[\"我们只需要写处理函数即可\",{\"1\":{\"537\":1}}],[\"我们只想要第一个\",{\"1\":{\"126\":1}}],[\"我们都不会直接使用上述的方法\",{\"1\":{\"532\":1}}],[\"我们需要使用第三方包\",{\"1\":{\"513\":1}}],[\"我们之所以要进行逃逸分析\",{\"1\":{\"239\":1}}],[\"我们对它的要求不仅仅只是能运行\",{\"1\":{\"234\":1}}],[\"我们就可以在go程序中导入别人写好的库\",{\"1\":{\"230\":1}}],[\"我们就可以直接传递匿名函数\",{\"1\":{\"200\":1}}],[\"我们依然可以直接传递指针给c函数\",{\"1\":{\"222\":1}}],[\"我们可以通过结构体标签来达到重命名的效果\",{\"1\":{\"518\":1}}],[\"我们可以通过unsafe\",{\"1\":{\"193\":1}}],[\"我们可以这样编写go\",{\"1\":{\"382\":1}}],[\"我们可以自己写函数递归遍历整个文件夹\",{\"1\":{\"329\":1}}],[\"我们可以将转换可视化的格式\",{\"1\":{\"245\":1}}],[\"我们可以将其置为nil\",{\"1\":{\"239\":1}}],[\"我们可以很明显的看到整个调用栈的内存占用是117\",{\"1\":{\"245\":1}}],[\"我们可以保证程序大部分的稳定性\",{\"1\":{\"234\":1}}],[\"我们可以把go指针通过c函数参数传递给c\",{\"1\":{\"219\":1}}],[\"我们可以使用fmt包提供的几个函数\",{\"1\":{\"143\":1}}],[\"我们有一个函数sum可以计算两个数字的返回值\",{\"1\":{\"127\":1}}],[\"我们在进行流式读写\",{\"1\":{\"40\":1}}],[\"表格风格\",{\"0\":{\"393\":1}}],[\"表格打印\",{\"1\":{\"41\":1}}],[\"表面上看该测试函数就是一个普通的函数\",{\"1\":{\"389\":1}}],[\"表达能力不足\",{\"1\":{\"310\":1}}],[\"表达能力弱\",{\"1\":{\"132\":1}}],[\"表示关闭空闲连接检测\",{\"1\":{\"444\":1}}],[\"表示关闭\",{\"1\":{\"444\":2}}],[\"表示次数\",{\"1\":{\"388\":1}}],[\"表示当前目录\",{\"1\":{\"387\":1}}],[\"表示取消的原因\",{\"1\":{\"346\":1}}],[\"表示是否从父上下文中删除自身\",{\"1\":{\"346\":1}}],[\"表示对一个管道读取数据\",{\"1\":{\"334\":1}}],[\"表示对一个管道写入数据\",{\"1\":{\"334\":1}}],[\"表示为所有人都可以对该文件进行读写\",{\"1\":{\"319\":1}}],[\"表示十分严重的程序问题\",{\"1\":{\"313\":1}}],[\"表示这是匿名的\",{\"1\":{\"262\":1}}],[\"表示打印panic风格的堆栈信息\",{\"1\":{\"242\":1}}],[\"表示在函数调用期间发生了错误\",{\"1\":{\"217\":1}}],[\"表示仅做通知类型的通道\",{\"1\":{\"193\":1}}],[\"繁琐\",{\"1\":{\"132\":1,\"509\":1}}],[\"枚举\",{\"0\":{\"132\":1,\"228\":1}}],[\"看个例子\",{\"1\":{\"617\":1}}],[\"看个人喜好\",{\"1\":{\"307\":1}}],[\"看一个使用案例就知道怎么用了\",{\"1\":{\"627\":1}}],[\"看一个简单的使用例子\",{\"1\":{\"341\":1}}],[\"看一个例子\",{\"1\":{\"233\":1}}],[\"看到这里后\",{\"1\":{\"256\":1}}],[\"看两个例子\",{\"1\":{\"229\":1}}],[\"看下面的一段代码例子\",{\"1\":{\"626\":1}}],[\"看下面的一个例子\",{\"1\":{\"217\":1,\"225\":1,\"304\":1,\"339\":1,\"359\":1}}],[\"看下面的例子\",{\"1\":{\"131\":1,\"206\":1,\"217\":1,\"222\":1,\"336\":1,\"617\":1}}],[\"看下面一个例子\",{\"1\":{\"201\":1,\"202\":1,\"206\":1,\"216\":1,\"622\":1}}],[\"看起来似乎是要比try\",{\"1\":{\"307\":1}}],[\"看起来中文字符串比英文字符串短\",{\"1\":{\"174\":1}}],[\"看起来长度是7\",{\"1\":{\"174\":1}}],[\"看起来长度是16\",{\"1\":{\"174\":1}}],[\"看几个例子\",{\"1\":{\"140\":1}}],[\"看几个使用案例\",{\"1\":{\"131\":1}}],[\"达到分组的效果\",{\"1\":{\"130\":1}}],[\"括起来以提升可读性\",{\"1\":{\"130\":1}}],[\"括起来或者反引号\",{\"1\":{\"105\":1}}],[\"除非在加载时指定了名称或者通过template语句手动指定\",{\"1\":{\"625\":1}}],[\"除非手动调用c\",{\"1\":{\"229\":1}}],[\"除了这些之外\",{\"1\":{\"620\":1}}],[\"除了这种情况外还有其它情况可能会发生逃逸现象\",{\"1\":{\"236\":1}}],[\"除了g\",{\"1\":{\"590\":1}}],[\"除了使用update\",{\"1\":{\"427\":1}}],[\"除了use指令外\",{\"1\":{\"384\":1}}],[\"除了profile和trace两个选项之外\",{\"1\":{\"243\":1}}],[\"除了极端的性能要求情况下\",{\"1\":{\"239\":1}}],[\"除了第一个元素\",{\"1\":{\"225\":1}}],[\"除基本类型以外的其它类型\",{\"1\":{\"129\":1}}],[\"除此之外\",{\"1\":{\"128\":1,\"216\":1,\"233\":1,\"316\":1,\"320\":1,\"352\":1,\"357\":1,\"360\":1,\"624\":1}}],[\"结合else使用\",{\"1\":{\"624\":1}}],[\"结合上面所讲的内容也就非常好懂\",{\"1\":{\"268\":1}}],[\"结合反射可以做出很多奇妙的功能\",{\"1\":{\"191\":1}}],[\"结合标签使用可以达到跳过外层循环的效果\",{\"1\":{\"155\":1}}],[\"结合标签一起使用可以达到终止外层循环的效果\",{\"1\":{\"154\":1}}],[\"结束了先前的混乱局面\",{\"1\":{\"361\":1}}],[\"结束子协程\",{\"1\":{\"340\":1}}],[\"结束\",{\"1\":{\"171\":2}}],[\"结果\",{\"1\":{\"517\":1}}],[\"结果也提示了删除成功\",{\"1\":{\"372\":1}}],[\"结果大概率会如下\",{\"1\":{\"355\":1}}],[\"结果又不一样了\",{\"1\":{\"204\":1}}],[\"结果如下\",{\"1\":{\"145\":1}}],[\"结果是常量的类型转换\",{\"1\":{\"129\":1}}],[\"结果没有变化\",{\"1\":{\"127\":1}}],[\"结构体是临时声明的匿名结构体\",{\"1\":{\"393\":1}}],[\"结构体如下\",{\"1\":{\"360\":1}}],[\"结构体来进行表示\",{\"1\":{\"266\":1}}],[\"结构体的创建同样用到reflect\",{\"1\":{\"293\":1}}],[\"结构体的内存占用长度至少是最大字段的整数倍\",{\"1\":{\"192\":1}}],[\"结构体的声明非常简单\",{\"1\":{\"186\":1}}],[\"结构体标签最广泛的应用就是在各种序列化格式中的别名定义\",{\"1\":{\"191\":1}}],[\"结构体标签的容错性很低\",{\"1\":{\"191\":1}}],[\"结构体标签是一种元编程的形式\",{\"1\":{\"191\":1}}],[\"结构体之间的关系是通过组合来表示的\",{\"1\":{\"189\":1}}],[\"结构体本身以及其内部的字段都遵守大小写命名的暴露方式\",{\"1\":{\"186\":1}}],[\"结构体可以存储一组不同类型的数据\",{\"1\":{\"185\":1}}],[\"结构体\",{\"0\":{\"226\":1,\"285\":1,\"293\":1},\"1\":{\"120\":1,\"121\":1,\"213\":1,\"298\":2,\"532\":1}}],[\"结构定义\",{\"1\":{\"60\":1}}],[\"结构化日志处理\",{\"1\":{\"41\":1}}],[\"就最好别用这个\",{\"1\":{\"648\":1}}],[\"就允许将一种t2类型的数据转换为t1\",{\"1\":{\"643\":1}}],[\"就允许有交集\",{\"1\":{\"260\":1}}],[\"就必须实现三个方法\",{\"1\":{\"580\":1}}],[\"就必须初始化所有字段\",{\"1\":{\"187\":1}}],[\"就请自行探索\",{\"1\":{\"416\":1}}],[\"就换个版本\",{\"1\":{\"403\":1}}],[\"就跳过测试\",{\"1\":{\"396\":1}}],[\"就将其命名为function\",{\"1\":{\"386\":1}}],[\"就返回原有的值\",{\"1\":{\"355\":1}}],[\"就如context\",{\"1\":{\"346\":1}}],[\"就像是访问一个类型的成员变量一样\",{\"1\":{\"617\":1}}],[\"就像是一个阻塞队列一样\",{\"1\":{\"336\":1}}],[\"就像下面这样\",{\"1\":{\"187\":1}}],[\"就能访问到一些类型的内部元素\",{\"1\":{\"643\":1}}],[\"就能够快速开启一个协程\",{\"1\":{\"331\":1}}],[\"就能正常修改myint的值\",{\"1\":{\"206\":1}}],[\"就没有必要使用类型声明了\",{\"1\":{\"303\":1}}],[\"就跟写普通的代码一样\",{\"1\":{\"623\":1}}],[\"就跟go代码一样\",{\"1\":{\"619\":1}}],[\"就跟发http请求一样差不多\",{\"1\":{\"406\":1}}],[\"就跟内存分配后不回收会造成内存泄漏一样\",{\"1\":{\"347\":1}}],[\"就跟c中的void\",{\"1\":{\"229\":1}}],[\"就跟import\",{\"1\":{\"222\":1}}],[\"就需要实现数据库驱动\",{\"1\":{\"432\":1}}],[\"就需要使用额外加入version来解决问题\",{\"1\":{\"359\":1}}],[\"就需要用到reflect\",{\"1\":{\"268\":1}}],[\"就需要先将其类型转换为interface\",{\"1\":{\"267\":1}}],[\"就需要先将其转为unsafe\",{\"1\":{\"229\":1}}],[\"就需要我们对其进行性能分析\",{\"1\":{\"234\":1}}],[\"就需要在当前协程申请一片内存空间\",{\"1\":{\"203\":1}}],[\"就不再需要操作符了\",{\"1\":{\"427\":1}}],[\"就不再赘述\",{\"1\":{\"321\":1}}],[\"就不太可能再去声明变量来创建测试数据\",{\"1\":{\"393\":1}}],[\"就不太适合这么做\",{\"1\":{\"217\":1}}],[\"就不存在上述问题了\",{\"1\":{\"349\":1}}],[\"就不用再进行之前的操作了\",{\"1\":{\"183\":1}}],[\"就掌握了通用接口\",{\"1\":{\"214\":1}}],[\"就是指定模块的源代码\",{\"1\":{\"376\":1}}],[\"就是只写通道\",{\"1\":{\"338\":1}}],[\"就是只读通道\",{\"1\":{\"338\":1}}],[\"就是一组方法的集合\",{\"1\":{\"209\":1}}],[\"就是当值接收者是可寻址的时候\",{\"1\":{\"206\":1}}],[\"就是append最原始的用法\",{\"1\":{\"164\":1}}],[\"就只需要拷贝这个指针\",{\"1\":{\"206\":1}}],[\"就只能对每一个map的key进行delete\",{\"1\":{\"183\":1}}],[\"就可能会发生如下情况\",{\"1\":{\"348\":1}}],[\"就可能会导致内存占用突然暴涨\",{\"1\":{\"203\":1}}],[\"就可以打开一个数据库连接\",{\"1\":{\"433\":1}}],[\"就可以看到正常的执行结果了\",{\"1\":{\"392\":1}}],[\"就可以看到堆栈信息了\",{\"1\":{\"312\":1}}],[\"就可以直接在test目录下执行如下命令\",{\"1\":{\"387\":1}}],[\"就可以直接传递一个匿名函数\",{\"1\":{\"200\":1}}],[\"就可以将修改提交并推送到远程仓库\",{\"1\":{\"368\":1}}],[\"就可以用到单向管道来限制另一方的行为\",{\"1\":{\"338\":1}}],[\"就可以做到原本无法通过编译的类型转换操作\",{\"1\":{\"306\":1}}],[\"就可以访问c结构体\",{\"1\":{\"226\":1}}],[\"就可以访问数组中对应的元素\",{\"1\":{\"159\":1}}],[\"就可以通过c\",{\"1\":{\"220\":1}}],[\"就可以很好的解决上述的问题\",{\"1\":{\"218\":1}}],[\"就可以初始化接口了\",{\"1\":{\"212\":1}}],[\"就可以考虑使用数组\",{\"1\":{\"157\":1}}],[\"就可以使用下划线\",{\"1\":{\"126\":1}}],[\"就会让人十分头疼\",{\"1\":{\"512\":1}}],[\"就会回滚\",{\"1\":{\"439\":1}}],[\"就会panic\",{\"1\":{\"388\":1}}],[\"就会拒绝构建\",{\"1\":{\"379\":1}}],[\"就会更新go\",{\"1\":{\"379\":1}}],[\"就会加上incompatible注释\",{\"1\":{\"378\":1}}],[\"就会执行else块的内容\",{\"1\":{\"624\":1}}],[\"就会执行后续的操作\",{\"1\":{\"359\":1}}],[\"就会执行default分支\",{\"1\":{\"149\":1,\"340\":1}}],[\"就会停止遍历\",{\"1\":{\"355\":1}}],[\"就会启动一个协程等待父级取消\",{\"1\":{\"346\":1}}],[\"就会将自身添加进父级的children中\",{\"1\":{\"346\":1}}],[\"就会返回nil\",{\"1\":{\"343\":1}}],[\"就会永久阻塞\",{\"1\":{\"340\":1}}],[\"就会阻塞等待\",{\"1\":{\"339\":1}}],[\"就会发生panic\",{\"1\":{\"337\":1}}],[\"就会有反射\",{\"1\":{\"265\":1}}],[\"就会有空集\",{\"1\":{\"259\":1}}],[\"就会出现这样的页面\",{\"1\":{\"243\":1}}],[\"就会出现错误\",{\"1\":{\"206\":1}}],[\"就会像栈一样先进后出的顺序执行\",{\"1\":{\"202\":1}}],[\"就会变为切片类型\",{\"1\":{\"160\":1}}],[\"就变成了while\",{\"1\":{\"152\":1}}],[\"就建议使用bufio\",{\"1\":{\"144\":1}}],[\"就等同于下面这段代码\",{\"1\":{\"127\":1}}],[\"思考下面这一段代码\",{\"1\":{\"127\":1}}],[\"三种方法有着不同的适用情况\",{\"1\":{\"331\":1}}],[\"三种必须指定一个\",{\"1\":{\"319\":1}}],[\"三个变量在计算后的值分别是什么\",{\"1\":{\"127\":1}}],[\"三个变量也是同样如此\",{\"1\":{\"127\":1}}],[\"三元表达式\",{\"0\":{\"112\":1}}],[\"未使用的变量是无法通过编译的\",{\"1\":{\"126\":1}}],[\"匿名结构体是不支持泛型的\",{\"1\":{\"258\":1}}],[\"匿名结构不支持泛型\",{\"1\":{\"258\":1}}],[\"匿名函数不支持自定义泛型\",{\"1\":{\"258\":1}}],[\"匿名函数就是没有签名的函数\",{\"1\":{\"200\":1}}],[\"匿名函数\",{\"0\":{\"200\":1}}],[\"匿名字段的名称默认为类型名\",{\"1\":{\"189\":1}}],[\"匿名\",{\"0\":{\"126\":1}}],[\"匿名导入的包无法被使用\",{\"1\":{\"94\":1}}],[\"那时所有的代码都存放在gopath目录下\",{\"1\":{\"361\":1}}],[\"那如果有特别多的函数调用\",{\"1\":{\"307\":1}}],[\"那如果把延迟调用和闭包结合起来呢\",{\"1\":{\"204\":1}}],[\"那就拷贝这个切片\",{\"1\":{\"206\":1}}],[\"那就拷贝这个整型\",{\"1\":{\"206\":1}}],[\"那就是消除空白符的时候\",{\"1\":{\"618\":1}}],[\"那就是使用内置函数make\",{\"1\":{\"333\":1}}],[\"那就是panic\",{\"1\":{\"316\":1}}],[\"那就是必须是可以排序的类型\",{\"1\":{\"263\":1}}],[\"那就是实现了该接口\",{\"1\":{\"212\":1}}],[\"那就是键为math\",{\"1\":{\"180\":1}}],[\"那就是它们之间的类型必须相同\",{\"1\":{\"128\":1}}],[\"那就是所有在函数中的变量都必须要被使用\",{\"1\":{\"125\":1}}],[\"那就是在赋值旧变量的同时声明一个新的变量\",{\"1\":{\"125\":1}}],[\"那么只能通过取其第一个元素的指针来获取底层数组的地址\",{\"1\":{\"645\":1}}],[\"那么便不会出现例二的无效地址情况\",{\"1\":{\"643\":1}}],[\"那么上例中下载的依赖包存放的路径就位于\",{\"1\":{\"379\":1}}],[\"那么模块名就需要修改成如下\",{\"1\":{\"378\":1}}],[\"那么它就是不是原子操作\",{\"1\":{\"356\":1}}],[\"那么它就是取反运算符\",{\"1\":{\"98\":1}}],[\"那么1000个协程都需要各自实例化对象\",{\"1\":{\"354\":1}}],[\"那么问题就来了\",{\"1\":{\"353\":1}}],[\"那么问题来了\",{\"1\":{\"256\":1}}],[\"那么依旧会重现之前的问题\",{\"1\":{\"331\":1}}],[\"那么并发的问题解决了吗\",{\"1\":{\"331\":1}}],[\"那么程序将会直接停止运行\",{\"1\":{\"315\":1}}],[\"那么target就必须是\",{\"1\":{\"312\":1}}],[\"那么t的值也实现了该接口\",{\"1\":{\"208\":1}}],[\"那么你才是个合格的gopher了\",{\"1\":{\"307\":1}}],[\"那么你会认识到go的语法其实并不难\",{\"1\":{\"248\":1}}],[\"那么其值必须是可取址的\",{\"1\":{\"280\":1}}],[\"那么该类型就属于该类型集\",{\"1\":{\"259\":1}}],[\"那么该接口就是这些类型集的交集\",{\"1\":{\"259\":1}}],[\"那么该变量也会逃逸到堆上\",{\"1\":{\"237\":1}}],[\"那么就会执行else这块的逻辑\",{\"1\":{\"622\":1}}],[\"那么就不会再向下执行\",{\"1\":{\"379\":1}}],[\"那么就不应该取一样的名字\",{\"1\":{\"197\":1}}],[\"那么就根本不应该使用泛型\",{\"1\":{\"258\":1}}],[\"那么这种情况就称之为逃逸\",{\"1\":{\"235\":1}}],[\"那么这样一来\",{\"1\":{\"229\":1}}],[\"那么这么做就会有一个明显的问题\",{\"1\":{\"169\":1}}],[\"那么编译就会失败\",{\"1\":{\"221\":1}}],[\"那么c调用时将返回一个结构体\",{\"1\":{\"219\":1}}],[\"那么会panic\",{\"1\":{\"213\":1}}],[\"那么根据实现的定义\",{\"1\":{\"212\":1}}],[\"那么称该类型实现了该接口\",{\"1\":{\"208\":2}}],[\"那么如果通过指针调用会如何呢\",{\"1\":{\"205\":1}}],[\"那么在解析时是否指定模板名称\",{\"1\":{\"625\":1}}],[\"那么在模板中就会生成\",{\"1\":{\"620\":1}}],[\"那么在短时间内就会创建大量的defer\",{\"1\":{\"203\":1}}],[\"那么在编译时就会报错\",{\"1\":{\"125\":1}}],[\"那么内存分布如下图所示\",{\"1\":{\"192\":1}}],[\"那么将会导致无法正常读取\",{\"1\":{\"191\":1}}],[\"那么性能开销就会很高\",{\"1\":{\"173\":1}}],[\"那么s2的容量就是cap\",{\"1\":{\"169\":1}}],[\"那么变量存储的值就是对应类型的零值\",{\"1\":{\"124\":1}}],[\"还支持break\",{\"1\":{\"624\":1}}],[\"还支持简单的消息队列\",{\"1\":{\"441\":1}}],[\"还请自行了解\",{\"1\":{\"534\":1}}],[\"还提供了许多函数来方便操作\",{\"1\":{\"357\":1}}],[\"还希望它是一个稳定高效的应用\",{\"1\":{\"234\":1}}],[\"还是老老实实用go吧\",{\"1\":{\"233\":1}}],[\"还是拿sum\",{\"1\":{\"232\":1}}],[\"还需要确保本地拥有c\",{\"1\":{\"216\":1}}],[\"还需要注意的是\",{\"1\":{\"125\":1}}],[\"还得初始化\",{\"1\":{\"194\":1}}],[\"还可以使用两个方便函数来进行文件读取\",{\"1\":{\"320\":1}}],[\"还可以使用uft8包下的工具\",{\"1\":{\"177\":1}}],[\"还可以用web和weblist命令在浏览器中查看图片和源代码\",{\"1\":{\"245\":1}}],[\"还可以通过内置函数len来访问数组元素的数量\",{\"1\":{\"159\":1}}],[\"还可以通过new函数获得一个指针\",{\"1\":{\"158\":1}}],[\"还可以通过导入标准库cmp来判断\",{\"1\":{\"128\":1}}],[\"还可以在表达式之前编写一些简单语句\",{\"1\":{\"149\":1}}],[\"还可以自动补零\",{\"1\":{\"140\":1}}],[\"还可以\",{\"1\":{\"131\":1}}],[\"还有base64这种\",{\"1\":{\"508\":1}}],[\"还有第二个返回值\",{\"1\":{\"334\":1}}],[\"还有个办法就是静态链接库和动态链接库\",{\"1\":{\"230\":1}}],[\"还有一些基础的io操作函数\",{\"1\":{\"508\":1}}],[\"还有一种很极端的情况\",{\"1\":{\"316\":1}}],[\"还有一种特殊情况便是函数参数为\",{\"1\":{\"239\":1}}],[\"还有一种情况\",{\"1\":{\"206\":1}}],[\"还有一个比较特殊的内置函数call\",{\"1\":{\"620\":1}}],[\"还有一个用法是捕获panic\",{\"1\":{\"202\":1}}],[\"还有一个用途就是声明一个指针\",{\"1\":{\"194\":1}}],[\"还有一个非常重要的点\",{\"1\":{\"197\":1}}],[\"还有一点就是\",{\"1\":{\"98\":1}}],[\"还有另一种特殊的使用方法就是匿名导入包\",{\"1\":{\"94\":1}}],[\"赋值指针\",{\"1\":{\"271\":1}}],[\"赋值给原字符串\",{\"1\":{\"173\":1}}],[\"赋值会用到运算符=\",{\"1\":{\"125\":1}}],[\"赋值\",{\"0\":{\"125\":1},\"1\":{\"270\":1}}],[\"格式\",{\"1\":{\"444\":1}}],[\"格式是require\",{\"1\":{\"378\":1}}],[\"格式如下\",{\"1\":{\"178\":1,\"191\":1,\"622\":2}}],[\"格式化类型\",{\"1\":{\"592\":1}}],[\"格式化字符数量\",{\"1\":{\"140\":2}}],[\"格式化字符串\",{\"1\":{\"41\":1,\"140\":1}}],[\"格式化\",{\"0\":{\"140\":1,\"631\":1},\"1\":{\"140\":1,\"510\":1}}],[\"格式为var\",{\"1\":{\"124\":1}}],[\"声明一个新类型通常需要一个类型名称以及一个基础类型\",{\"1\":{\"302\":1}}],[\"声明一个any类型的变量\",{\"1\":{\"270\":1}}],[\"声明一个personoptions类型\",{\"1\":{\"188\":1}}],[\"声明函数有两种办法\",{\"1\":{\"197\":1}}],[\"声明\",{\"0\":{\"124\":1,\"186\":1,\"197\":1,\"210\":1}}],[\"声明了用于展示go包中的语法树类型\",{\"1\":{\"43\":1}}],[\"固定长度的对应类型的零值集合\",{\"1\":{\"121\":1}}],[\"零值或未初始化的map可以访问\",{\"1\":{\"178\":1}}],[\"零值并不仅仅只是字面上的数字零\",{\"1\":{\"121\":1}}],[\"零值\",{\"0\":{\"121\":1},\"1\":{\"121\":1}}],[\"键的类型必须是可比较的\",{\"1\":{\"257\":1}}],[\"键值数据库\",{\"1\":{\"253\":2}}],[\"键为字符串类型\",{\"1\":{\"120\":1}}],[\"键盘等\",{\"1\":{\"57\":1}}],[\"例1s\",{\"1\":{\"388\":1}}],[\"例子输出如下\",{\"1\":{\"350\":1}}],[\"例子通过unsafe\",{\"1\":{\"222\":1}}],[\"例子中的模板根据传入的语言lang来决定要以何种方式展示内容\",{\"1\":{\"623\":1}}],[\"例子中的t\",{\"1\":{\"390\":1}}],[\"例子中的\",{\"1\":{\"378\":1}}],[\"例子中的交集肯定就是signedint\",{\"1\":{\"259\":1}}],[\"例子中开启了1000个协程不断的在池中申请和释放对象\",{\"1\":{\"354\":1}}],[\"例子中创建了3个cancelctx\",{\"1\":{\"346\":1}}],[\"例子中编写了一个名为printsum的函数\",{\"1\":{\"217\":1}}],[\"例子中分别输出了字节的十进制形式和十六进制形式\",{\"1\":{\"177\":1}}],[\"例子中使用了匿名标识符\",{\"1\":{\"131\":1}}],[\"例子如下\",{\"1\":{\"127\":1,\"147\":1,\"150\":1,\"154\":1,\"155\":1,\"160\":1,\"173\":1,\"174\":1,\"178\":1,\"186\":1,\"190\":1,\"213\":1,\"219\":1,\"220\":1,\"259\":2,\"273\":1,\"290\":1,\"304\":2,\"312\":2,\"315\":1,\"331\":3,\"333\":1,\"340\":1,\"349\":1,\"619\":1}}],[\"例子\",{\"1\":{\"120\":1,\"312\":1,\"378\":1,\"540\":1,\"541\":1,\"631\":1}}],[\"例如有如下自定义函数\",{\"1\":{\"620\":1}}],[\"例如之前用到的index函数\",{\"1\":{\"620\":1}}],[\"例如将strings\",{\"1\":{\"611\":1}}],[\"例如zap等等\",{\"1\":{\"541\":1}}],[\"例如url之类的\",{\"1\":{\"508\":1}}],[\"例如常用的closer\",{\"1\":{\"508\":1}}],[\"例如上述例子中的\",{\"1\":{\"396\":1}}],[\"例如标准库context\",{\"1\":{\"389\":1}}],[\"例如200x\",{\"1\":{\"388\":1}}],[\"例如只运行所有的基准测试的命令如下\",{\"1\":{\"387\":1}}],[\"例如示例测试是examplexxxx\",{\"1\":{\"386\":1}}],[\"例如benchmark\",{\"1\":{\"386\":1}}],[\"例如要测试某一个功能\",{\"1\":{\"386\":1}}],[\"例如在amd64的机器上\",{\"1\":{\"642\":1}}],[\"例如在一个新的版本发布后发现了一个重大问题\",{\"1\":{\"378\":1}}],[\"例如在defer中再次闭包使用recover\",{\"1\":{\"316\":1}}],[\"例如打开gin依赖的go\",{\"1\":{\"378\":1}}],[\"例如google\",{\"1\":{\"378\":1}}],[\"例如go的版本号v1\",{\"1\":{\"374\":1}}],[\"例如java的gradle\",{\"1\":{\"361\":1}}],[\"例如int64类型的cas\",{\"1\":{\"359\":1}}],[\"例如int可以被int64类型所代表\",{\"1\":{\"304\":1}}],[\"例如事先知晓协程的数量\",{\"1\":{\"341\":1}}],[\"例如用于关闭通道的内置函数close的函数签名就用到了单向通道\",{\"1\":{\"338\":1}}],[\"例如修改文件描述符和文件权限\",{\"1\":{\"319\":1}}],[\"例如defer\",{\"1\":{\"315\":1}}],[\"例如执行defer语句\",{\"1\":{\"315\":1}}],[\"例如erros包下的errorstring就是一个很简单的实现\",{\"1\":{\"310\":1}}],[\"例如现在有一个类型map\",{\"1\":{\"303\":1}}],[\"例如性能问题等等\",{\"1\":{\"265\":1}}],[\"例如闭包中\",{\"1\":{\"258\":1}}],[\"例如切片是可寻址\",{\"1\":{\"206\":1}}],[\"例如访问字符串第一个元素\",{\"1\":{\"172\":1}}],[\"例如使用for\",{\"1\":{\"153\":1}}],[\"例如声明新变量\",{\"1\":{\"149\":1}}],[\"例如下面例子中的v0\",{\"1\":{\"378\":1}}],[\"例如下面的模板\",{\"1\":{\"620\":1}}],[\"例如下面的例子\",{\"1\":{\"331\":1}}],[\"例如下面的错误示范\",{\"1\":{\"331\":1}}],[\"例如下面的函数func\",{\"1\":{\"200\":1}}],[\"例如下面的代码就可能会出现问题\",{\"1\":{\"643\":1}}],[\"例如下面的代码\",{\"1\":{\"129\":1,\"427\":1}}],[\"例如下载由go语言编写的调试器delve\",{\"1\":{\"373\":1}}],[\"例如下例中的tinyint与~int8有交集\",{\"1\":{\"260\":1}}],[\"例如下列情况有非常大的可能性会触发fatal\",{\"1\":{\"185\":1}}],[\"例如下方节选自os\",{\"1\":{\"309\":1}}],[\"例如下方代码无论执行多少次都只会输出timeout\",{\"1\":{\"340\":1}}],[\"例如下方代码例子\",{\"1\":{\"307\":1}}],[\"例如下方代码\",{\"1\":{\"177\":1,\"331\":1}}],[\"例如下方的命令\",{\"1\":{\"387\":2}}],[\"例如下方的代码\",{\"1\":{\"177\":1,\"341\":1,\"356\":1}}],[\"例如下方的例子中省略了max\",{\"1\":{\"169\":1}}],[\"例如下方的数学运算\",{\"1\":{\"110\":1}}],[\"例如^a\",{\"1\":{\"98\":1}}],[\"例如a^b\",{\"1\":{\"98\":1}}],[\"例如包a导入了包b\",{\"1\":{\"94\":1}}],[\"例如一个常见的场景就是注册数据库驱动\",{\"1\":{\"94\":1}}],[\"例如\",{\"1\":{\"69\":1,\"96\":1,\"125\":1,\"130\":1,\"140\":1,\"147\":1,\"166\":1,\"177\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":2,\"189\":1,\"194\":5,\"195\":1,\"213\":1,\"270\":1,\"311\":1,\"340\":1,\"378\":4,\"387\":2,\"617\":3,\"621\":1,\"640\":1,\"641\":1,\"642\":1,\"643\":3,\"644\":1}}],[\"例如没有类和继承\",{\"1\":{\"69\":1}}],[\"例如拉丁语\",{\"1\":{\"63\":1}}],[\"例如theano\",{\"1\":{\"61\":1}}],[\"例如os\",{\"1\":{\"51\":1}}],[\"例如md5和sha256\",{\"1\":{\"51\":1}}],[\"例如阿里巴巴dubbo\",{\"1\":{\"47\":1}}],[\"例如hilbert和peano曲线\",{\"1\":{\"46\":1}}],[\"派生类型\",{\"0\":{\"120\":1}}],[\"浮点排序\",{\"0\":{\"577\":1}}],[\"浮点常量\",{\"0\":{\"544\":1}}],[\"浮点数赋值\",{\"1\":{\"619\":1}}],[\"浮点数转字符串\",{\"0\":{\"590\":1}}],[\"浮点数\",{\"0\":{\"224\":1}}],[\"浮点数字面量\",{\"0\":{\"101\":1}}],[\"浮点\",{\"1\":{\"140\":4}}],[\"浮点型\",{\"0\":{\"117\":1}}],[\"序列化时默认是没有任何缩进的\",{\"1\":{\"519\":1}}],[\"序列化\",{\"0\":{\"511\":1,\"514\":1,\"517\":1},\"1\":{\"513\":1,\"521\":1}}],[\"序列和数据整理方法的实现\",{\"1\":{\"46\":1}}],[\"序号从0开始\",{\"1\":{\"444\":1}}],[\"序号\",{\"1\":{\"116\":1}}],[\"两种方法都需要修改go\",{\"1\":{\"382\":1}}],[\"两种输出的结果不一致\",{\"1\":{\"213\":1}}],[\"两个builder在写入字符串的时候都是在对同一个切片进行操作\",{\"1\":{\"611\":1}}],[\"两个函数的签名如下\",{\"1\":{\"347\":1}}],[\"两个函数如下\",{\"1\":{\"344\":1}}],[\"两个计数\",{\"1\":{\"341\":1}}],[\"两个无缓冲管道用于同步父子协程的执行顺序\",{\"1\":{\"336\":1}}],[\"两个叫法都是一个意思\",{\"1\":{\"99\":1}}],[\"两者的区别在于前者是更新文档字段\",{\"1\":{\"427\":1}}],[\"两者都会将字符串转换为带引号的go字符串\",{\"1\":{\"588\":1}}],[\"两者都是在elaticsearch服务端生成的\",{\"1\":{\"404\":1}}],[\"两者都需要借助pprof命令行工具\",{\"1\":{\"244\":1}}],[\"两者功能类似\",{\"1\":{\"347\":1}}],[\"两者完全等价\",{\"1\":{\"303\":1}}],[\"两者是都是同一个类型\",{\"1\":{\"303\":1}}],[\"两者是完全等价的\",{\"1\":{\"213\":1}}],[\"两者是完全不同的类型\",{\"1\":{\"115\":1}}],[\"两者其实都一样\",{\"1\":{\"222\":1}}],[\"两者内容是完全一样的\",{\"1\":{\"215\":1}}],[\"两者有点类似\",{\"1\":{\"196\":1}}],[\"两者之间毫无关联\",{\"1\":{\"173\":1}}],[\"整数常量\",{\"0\":{\"543\":1}}],[\"整数\",{\"0\":{\"223\":1}}],[\"整数0并不代表假值\",{\"1\":{\"115\":1}}],[\"整个过程中也只创建了5个对象\",{\"1\":{\"354\":1}}],[\"整个程序都会崩溃\",{\"1\":{\"313\":1}}],[\"整个结构体的内存占用似乎是8+4+2+1+4=19个字节吗\",{\"1\":{\"192\":1}}],[\"整个if语句的判断是从上到下\",{\"1\":{\"148\":1}}],[\"整型赋值\",{\"1\":{\"619\":1}}],[\"整型转字符串\",{\"0\":{\"585\":1}}],[\"整型排序\",{\"0\":{\"576\":1}}],[\"整型切片指针\",{\"1\":{\"196\":1}}],[\"整型通道\",{\"1\":{\"120\":1}}],[\"整型\",{\"0\":{\"116\":1},\"1\":{\"116\":1,\"140\":3}}],[\"整型字面量\",{\"0\":{\"100\":1}}],[\"描述\",{\"1\":{\"115\":1,\"118\":1,\"119\":1,\"140\":1}}],[\"布尔值\",{\"1\":{\"587\":1}}],[\"布尔值转字符串\",{\"0\":{\"587\":1}}],[\"布尔\",{\"1\":{\"128\":1,\"140\":1}}],[\"布尔类型的参数必须使用等号\",{\"1\":{\"526\":1}}],[\"布尔类型只有真值和假值\",{\"1\":{\"115\":1}}],[\"布尔类型\",{\"0\":{\"115\":1},\"1\":{\"121\":1}}],[\"布隆过滤器实现\",{\"1\":{\"41\":1}}],[\"花括号省略\",{\"0\":{\"111\":1}}],[\"代理修改成功后\",{\"1\":{\"370\":1}}],[\"代指当前路径的绝对路径\",{\"1\":{\"231\":1}}],[\"代表键是否存在\",{\"1\":{\"179\":1}}],[\"代表着当前模块名为golearn\",{\"1\":{\"378\":1}}],[\"代表着当前函数所消耗的资源\",{\"1\":{\"245\":1}}],[\"代表着总共能装多少高度的水\",{\"1\":{\"162\":1}}],[\"代表着较后进行运算\",{\"1\":{\"110\":1}}],[\"代替\",{\"1\":{\"126\":1}}],[\"代码\",{\"1\":{\"408\":1,\"411\":1,\"413\":1,\"625\":1}}],[\"代码引用\",{\"0\":{\"372\":1}}],[\"代码相比复制文件有点多但算不上复杂\",{\"1\":{\"329\":1}}],[\"代码无法通过编译\",{\"1\":{\"260\":1}}],[\"代码行数有好几万\",{\"1\":{\"236\":1}}],[\"代码示例如下\",{\"1\":{\"224\":1,\"269\":1,\"271\":1,\"276\":1,\"319\":1,\"322\":1}}],[\"代码中res是go中的一个变量\",{\"1\":{\"218\":1}}],[\"代码调用\",{\"0\":{\"216\":1}}],[\"代码风格逐渐形成了规范\",{\"1\":{\"207\":1}}],[\"代码如下\",{\"1\":{\"201\":1,\"262\":1,\"319\":1,\"320\":1,\"394\":1,\"628\":1}}],[\"代码块彼此之间的变量作用域是相互独立的\",{\"1\":{\"129\":1}}],[\"代码块\",{\"0\":{\"129\":1}}],[\"代码间隔\",{\"0\":{\"110\":1}}],[\"代码缩进\",{\"0\":{\"109\":1}}],[\"代码分析\",{\"1\":{\"91\":1}}],[\"乘法的优先级比加法要高\",{\"1\":{\"110\":1}}],[\"众所周知直接使用字符串进行+拼接性能是很低的\",{\"1\":{\"394\":1}}],[\"众所周知\",{\"1\":{\"110\":1}}],[\"仅通过几行代码就可以搭建一个非常简单的http服务器\",{\"1\":{\"529\":1}}],[\"仅使用net\",{\"1\":{\"508\":1}}],[\"仅=>左边的版本被替换\",{\"1\":{\"378\":1}}],[\"仅当最后几行为output注释才会被视为示例测试\",{\"1\":{\"389\":1}}],[\"仅当发现数据未被修改时才会去执行对应操作\",{\"1\":{\"359\":1}}],[\"仅当v的kind为\",{\"1\":{\"279\":2}}],[\"仅需要一个go关键字\",{\"1\":{\"331\":1}}],[\"仅仅叫法不一样\",{\"1\":{\"303\":1}}],[\"仅仅叫的名字不同\",{\"1\":{\"303\":1}}],[\"仅仅只是比较值是无法做到并发安全的\",{\"1\":{\"359\":1}}],[\"仅仅只是简单的数字相加\",{\"1\":{\"359\":1}}],[\"仅仅只是当作一台普通起重机来用\",{\"1\":{\"212\":1}}],[\"仅仅只是少了一个初始化长度\",{\"1\":{\"162\":1}}],[\"仅仅只有接口是无法被初始化的\",{\"1\":{\"211\":1}}],[\"仅goroutine可用\",{\"1\":{\"242\":1}}],[\"仅做调试用\",{\"1\":{\"137\":1}}],[\"仅支持相同长度的数组间的比较\",{\"1\":{\"128\":1}}],[\"仅支持判断是否相等\",{\"1\":{\"128\":3}}],[\"仅在一些特殊情况会使用空格\",{\"1\":{\"109\":1}}],[\"仅有的两个参数也只是输出格式化过程\",{\"1\":{\"107\":1}}],[\"仅限英语\",{\"1\":{\"63\":1}}],[\"风格的搜索和数据分析引擎\",{\"1\":{\"402\":1}}],[\"风格\",{\"0\":{\"107\":1}}],[\"第五列10000\",{\"1\":{\"394\":1}}],[\"第五行\",{\"1\":{\"131\":1}}],[\"第四列4040056736\",{\"1\":{\"394\":1}}],[\"第四行\",{\"1\":{\"131\":1}}],[\"第三列277771375\",{\"1\":{\"394\":1}}],[\"第三种是无序输出\",{\"1\":{\"389\":1}}],[\"第三个写协程执行完毕\",{\"1\":{\"351\":1}}],[\"第三行\",{\"1\":{\"131\":1}}],[\"第七行\",{\"1\":{\"131\":1}}],[\"第六行\",{\"1\":{\"131\":1}}],[\"第一次执行结果\",{\"1\":{\"395\":1}}],[\"第一次测试失败后\",{\"1\":{\"388\":1}}],[\"第一列benchmarkconcatdirect\",{\"1\":{\"394\":1}}],[\"第一种方式是使用os\",{\"1\":{\"327\":1}}],[\"第一种方法是将原文件中的数据读取出来\",{\"1\":{\"322\":1}}],[\"第一种是只有一行输出\",{\"1\":{\"389\":1}}],[\"第一种是使用errors包下的new函数\",{\"1\":{\"309\":1}}],[\"第一种是往类型集中并入该类型\",{\"1\":{\"259\":1}}],[\"第一种是字面量\",{\"1\":{\"178\":1}}],[\"第一种用法\",{\"1\":{\"256\":1}}],[\"第一种写法\",{\"1\":{\"148\":1}}],[\"第一行\",{\"1\":{\"131\":1}}],[\"第一个参数是监听的地址\",{\"1\":{\"535\":1}}],[\"第一个参数是接收者\",{\"1\":{\"289\":1}}],[\"第一个是需要用到的返回值\",{\"1\":{\"620\":1}}],[\"第一个是驱动名称\",{\"1\":{\"433\":1}}],[\"第一个是压缩包的哈希值\",{\"1\":{\"379\":1}}],[\"第一个是索引\",{\"1\":{\"339\":1}}],[\"第一个是管道的类型\",{\"1\":{\"333\":1}}],[\"第一个是c指针引用go变量的例子\",{\"1\":{\"229\":1}}],[\"第一个是访问指针所指向的元素\",{\"1\":{\"194\":1}}],[\"第一个是参数类型后置\",{\"1\":{\"106\":1}}],[\"第一个返回值对应类型的值\",{\"1\":{\"179\":1}}],[\"第一个常量使用iota值的表达式\",{\"1\":{\"131\":1}}],[\"第二次执行结果\",{\"1\":{\"395\":1}}],[\"第二列的4代表了代码中b\",{\"1\":{\"394\":1}}],[\"第二个参数是处理器\",{\"1\":{\"535\":1}}],[\"第二个就是数据源\",{\"1\":{\"433\":1}}],[\"第二个值是是否设置deadline\",{\"1\":{\"343\":1}}],[\"第二个返回值指的是能否成功读取数据\",{\"1\":{\"339\":1}}],[\"第二个返回值一个布尔值\",{\"1\":{\"179\":1}}],[\"第二个元素值\",{\"1\":{\"339\":1}}],[\"第二个是error\",{\"1\":{\"620\":1}}],[\"第二个是依赖包的go\",{\"1\":{\"379\":1}}],[\"第二个是可选参数为管道的缓冲大小\",{\"1\":{\"333\":1}}],[\"第二个是go指针引用c变量\",{\"1\":{\"229\":1}}],[\"第二个不同的点就是多返回值\",{\"1\":{\"106\":1}}],[\"第二种是多行输出\",{\"1\":{\"389\":1}}],[\"第二种是使用fmt包下的errorf函数\",{\"1\":{\"309\":1}}],[\"第二种用法\",{\"1\":{\"256\":1}}],[\"第二种写法利用了if语句是从上到下的判断的前提\",{\"1\":{\"148\":1}}],[\"第二种方式是使用\",{\"1\":{\"327\":1}}],[\"第二种方式每次都要指定类型\",{\"1\":{\"125\":1}}],[\"第二种方法是使用内置函数make\",{\"1\":{\"178\":1}}],[\"第二种方法在实践中更加常用\",{\"1\":{\"94\":1}}],[\"第二行\",{\"1\":{\"131\":1}}],[\"函数可以获取当前时间\",{\"1\":{\"629\":1}}],[\"函数可以将变量转换成reflect\",{\"1\":{\"269\":1,\"276\":1}}],[\"函数调用的格式为函数名后衔接参数列表\",{\"1\":{\"620\":1}}],[\"函数即可\",{\"1\":{\"537\":1}}],[\"函数中output注释表明了检测函数输出是否为hello\",{\"1\":{\"389\":1}}],[\"函数os\",{\"1\":{\"321\":1}}],[\"函数open就是对openfile函数的一个简单封装\",{\"1\":{\"319\":1}}],[\"函数进行操作\",{\"1\":{\"319\":1}}],[\"函数内部发生了panic\",{\"1\":{\"316\":1}}],[\"函数用于解包一个错误链\",{\"1\":{\"312\":1}}],[\"函数类型也可以实现接口\",{\"1\":{\"212\":1}}],[\"函数重载会让代码变得混淆和难以理解\",{\"1\":{\"197\":1}}],[\"函数签名由函数名称\",{\"1\":{\"197\":1}}],[\"函数签名如下\",{\"1\":{\"163\":1,\"314\":1,\"396\":1,\"569\":1}}],[\"函数体\",{\"1\":{\"197\":1}}],[\"函数名称为sum\",{\"1\":{\"197\":1}}],[\"函数名\",{\"1\":{\"197\":1,\"620\":1}}],[\"函数的第一个入参必须是t\",{\"1\":{\"396\":1}}],[\"函数的作用是在错误链中寻找第一个类型匹配的错误\",{\"1\":{\"312\":1}}],[\"函数的参数名变得不再重要\",{\"1\":{\"210\":1}}],[\"函数的参数传递过程中\",{\"1\":{\"206\":1}}],[\"函数的声明格式如下\",{\"1\":{\"197\":1}}],[\"函数的返回值\",{\"1\":{\"129\":1}}],[\"函数是go最基础的组成部分\",{\"1\":{\"196\":1}}],[\"函数是一等公民\",{\"1\":{\"196\":1}}],[\"函数会为该指针分配内存\",{\"1\":{\"194\":1}}],[\"函数式选项模式只适合于复杂的实例化\",{\"1\":{\"188\":1}}],[\"函数式选项模式在很多开源项目中都能看见\",{\"1\":{\"188\":1}}],[\"函数花括号换行\",{\"0\":{\"108\":1}}],[\"函数\",{\"0\":{\"106\":1,\"282\":1,\"297\":1,\"620\":1},\"1\":{\"120\":1,\"121\":1,\"201\":1,\"298\":1}}],[\"函数命名\",{\"1\":{\"97\":1}}],[\"日期\",{\"1\":{\"541\":1}}],[\"日志\",{\"1\":{\"539\":1,\"540\":1,\"541\":1}}],[\"日后下载依赖就会非常的迅速\",{\"1\":{\"370\":1}}],[\"日本語\",{\"1\":{\"105\":1}}],[\"日语等\",{\"1\":{\"63\":1}}],[\"今天天气不错\",{\"1\":{\"105\":1}}],[\"`person\",{\"1\":{\"626\":1}}],[\"`properties\",{\"1\":{\"191\":1}}],[\"`name\",{\"1\":{\"626\":1}}],[\"`name`\",{\"1\":{\"434\":1}}],[\"`this\",{\"1\":{\"615\":1}}],[\"`toml\",{\"1\":{\"191\":1}}],[\"`xml\",{\"1\":{\"510\":4}}],[\"`db\",{\"1\":{\"435\":4}}],[\"`age\",{\"1\":{\"626\":1}}],[\"`age`\",{\"1\":{\"434\":1}}],[\"`address`\",{\"1\":{\"434\":1}}],[\"`abc`\",{\"1\":{\"105\":1}}],[\"`id`\",{\"1\":{\"434\":2}}],[\"`user`\",{\"1\":{\"434\":4}}],[\"`bson\",{\"1\":{\"424\":3,\"425\":6}}],[\"```go\",{\"1\":{\"367\":1}}],[\"````\",{\"1\":{\"367\":1}}],[\"````bash\",{\"1\":{\"367\":1}}],[\"```\",{\"1\":{\"367\":2}}],[\"```bash\",{\"1\":{\"367\":1}}],[\"`yaml\",{\"1\":{\"191\":1,\"513\":5}}],[\"`json\",{\"1\":{\"191\":1,\"285\":3,\"293\":3,\"518\":4}}],[\"`key1\",{\"1\":{\"191\":1}}],[\"`这是一个原生字符串\",{\"1\":{\"171\":1}}],[\"`\",{\"1\":{\"105\":3,\"171\":1,\"191\":5,\"285\":3,\"293\":3,\"406\":2,\"408\":2,\"411\":2,\"413\":2,\"415\":6,\"424\":3,\"425\":6,\"435\":4,\"510\":4,\"513\":5,\"518\":4,\"615\":1,\"617\":2,\"619\":2,\"625\":2,\"626\":3}}],[\"反序列化\",{\"0\":{\"512\":1,\"515\":1,\"520\":1},\"1\":{\"424\":1,\"510\":1,\"513\":1,\"521\":1}}],[\"反射操作包\",{\"1\":{\"508\":1}}],[\"反射创建函数\",{\"1\":{\"297\":1}}],[\"反射创建管道\",{\"1\":{\"296\":1}}],[\"反射创建map\",{\"1\":{\"295\":1}}],[\"反射创建切片\",{\"1\":{\"294\":1}}],[\"反射可以将反射对象还原成interface\",{\"1\":{\"268\":1}}],[\"反射可以将interface\",{\"1\":{\"268\":1}}],[\"反射与interface\",{\"1\":{\"265\":1}}],[\"反射是一种在运行时检查语言自身结构的机制\",{\"1\":{\"265\":1}}],[\"反射\",{\"0\":{\"265\":1}}],[\"反汇编查看\",{\"1\":{\"246\":1}}],[\"反过来也是如此\",{\"1\":{\"646\":1}}],[\"反过来则不可以\",{\"1\":{\"338\":1}}],[\"反过来编译器轻松了\",{\"1\":{\"264\":1}}],[\"反过来signedint就是它们的超集\",{\"1\":{\"259\":1}}],[\"反过来\",{\"1\":{\"225\":1}}],[\"反而还可以存在多个\",{\"1\":{\"180\":1}}],[\"反引号字符串不允许转义\",{\"1\":{\"105\":1}}],[\"反斜杠转义\",{\"1\":{\"104\":1}}],[\"双线链表的实现\",{\"1\":{\"508\":1}}],[\"双向管道可以转换为单向管道\",{\"1\":{\"338\":1}}],[\"双向管道指的是既可以写\",{\"1\":{\"338\":1}}],[\"双引号表示\",{\"1\":{\"171\":1}}],[\"双引号转义\",{\"1\":{\"104\":1}}],[\"双循环打印九九乘法表\",{\"1\":{\"152\":1}}],[\"双端队列\",{\"1\":{\"46\":1}}],[\"纵向制表符号\",{\"1\":{\"104\":1}}],[\"横向制表符号\",{\"1\":{\"104\":1}}],[\"回滚一个事务\",{\"1\":{\"439\":1}}],[\"回车符号\",{\"1\":{\"104\":1}}],[\"回退符号\",{\"1\":{\"104\":1}}],[\"换成一个map再来一遍\",{\"1\":{\"279\":1}}],[\"换行\",{\"1\":{\"171\":4}}],[\"换行也被当作空格\",{\"1\":{\"143\":1}}],[\"换行符号\",{\"1\":{\"104\":1}}],[\"换页符号\",{\"1\":{\"104\":1}}],[\"换源工具\",{\"0\":{\"11\":1}}],[\"响应体也是需要自己手动处理的\",{\"1\":{\"409\":1}}],[\"响应协议\",{\"1\":{\"43\":1}}],[\"响铃符号\",{\"1\":{\"104\":1}}],[\"转换成对应语言的大写字符串\",{\"1\":{\"609\":1}}],[\"转换成对应语言的小写字符串\",{\"1\":{\"609\":1}}],[\"转换成go字符串\",{\"0\":{\"588\":1}}],[\"转换函数\",{\"1\":{\"590\":1}}],[\"转换为float64类型\",{\"1\":{\"304\":1}}],[\"转换\",{\"0\":{\"173\":1}}],[\"转换后的切片与原数组指向的是同一片内存\",{\"1\":{\"160\":1}}],[\"转义字符\",{\"0\":{\"104\":1}}],[\"转到开放神经网络交换\",{\"1\":{\"61\":1}}],[\"转到基于gopher\",{\"1\":{\"49\":1}}],[\"转到其他语言\",{\"1\":{\"39\":1}}],[\"ä\",{\"1\":{\"103\":1,\"177\":1}}],[\"复杂\",{\"1\":{\"509\":1}}],[\"复制字符串\",{\"0\":{\"596\":1}}],[\"复制后的值也不应该继续使用\",{\"1\":{\"341\":1}}],[\"复制文件内容\",{\"1\":{\"329\":1}}],[\"复制成功\",{\"1\":{\"322\":1}}],[\"复制\",{\"0\":{\"322\":1,\"329\":1},\"1\":{\"322\":1}}],[\"复制human文件\",{\"1\":{\"51\":1}}],[\"复数\",{\"1\":{\"592\":1}}],[\"复数转字符串\",{\"0\":{\"592\":1}}],[\"复数操作包\",{\"1\":{\"508\":1}}],[\"复数类型\",{\"0\":{\"118\":1}}],[\"复数字面量\",{\"0\":{\"102\":1}}],[\"9406564584124654417656879286822137236505980e\",{\"1\":{\"544\":1}}],[\"9200\",{\"1\":{\"404\":1}}],[\"9s\",{\"1\":{\"396\":1}}],[\"9129452507276277\",{\"1\":{\"562\":1}}],[\"91\",{\"1\":{\"396\":1}}],[\"937mi\",{\"1\":{\"395\":6}}],[\"9375\",{\"1\":{\"101\":1}}],[\"9µ\",{\"1\":{\"395\":1}}],[\"9527671\",{\"1\":{\"396\":1}}],[\"952\",{\"1\":{\"395\":1}}],[\"953028750\",{\"1\":{\"395\":1}}],[\"953802700\",{\"1\":{\"395\":1}}],[\"95\",{\"1\":{\"177\":1,\"395\":3}}],[\"959中所述的ftp客户端\",{\"1\":{\"64\":1}}],[\"98\",{\"1\":{\"173\":1,\"395\":1}}],[\"978213\",{\"1\":{\"395\":1}}],[\"974\",{\"1\":{\"395\":1}}],[\"97\",{\"1\":{\"173\":1}}],[\"96\",{\"1\":{\"173\":1,\"177\":1}}],[\"993\",{\"1\":{\"395\":1}}],[\"993764\",{\"1\":{\"395\":1}}],[\"99\",{\"1\":{\"164\":2,\"173\":1,\"221\":1,\"576\":1,\"577\":1,\"579\":1}}],[\"999k\",{\"1\":{\"395\":2}}],[\"99999\",{\"1\":{\"577\":1,\"579\":1}}],[\"9999\",{\"1\":{\"394\":1,\"395\":8,\"577\":1,\"579\":1}}],[\"999\",{\"1\":{\"164\":4}}],[\"9090\",{\"1\":{\"246\":3}}],[\"90\",{\"1\":{\"148\":5}}],[\"9\",{\"1\":{\"110\":1,\"140\":1,\"143\":2,\"152\":14,\"154\":3,\"155\":6,\"164\":4,\"165\":3,\"166\":7,\"167\":2,\"169\":10,\"195\":1,\"225\":1,\"237\":1,\"263\":3,\"294\":1,\"312\":1,\"331\":2,\"336\":2,\"339\":1,\"341\":1,\"349\":1,\"355\":2,\"372\":7,\"378\":8,\"390\":2,\"395\":2,\"404\":1,\"408\":1,\"521\":1,\"643\":1,\"644\":1}}],[\"写完后关闭管道\",{\"1\":{\"339\":1}}],[\"写\",{\"1\":{\"337\":1}}],[\"写协程执行结束\",{\"1\":{\"336\":1}}],[\"写协程执行完毕\",{\"1\":{\"336\":1}}],[\"写协程就写入一个数据\",{\"1\":{\"336\":1}}],[\"写一个\",{\"1\":{\"336\":1}}],[\"写入如下代码\",{\"1\":{\"389\":2,\"390\":1,\"396\":2}}],[\"写入已关闭的管道\",{\"1\":{\"337\":1}}],[\"写入满缓冲区的管道\",{\"1\":{\"337\":1}}],[\"写入完毕\",{\"1\":{\"336\":2}}],[\"写入数据\",{\"1\":{\"334\":1,\"335\":2,\"336\":1}}],[\"写入目标文件\",{\"1\":{\"322\":1}}],[\"写入字符串\",{\"1\":{\"321\":1}}],[\"写入字节切片\",{\"1\":{\"321\":1}}],[\"写入\",{\"0\":{\"321\":1},\"1\":{\"336\":12}}],[\"写入文本格式的数据\",{\"1\":{\"242\":1}}],[\"写入压缩后的protobuf数据\",{\"1\":{\"242\":1}}],[\"写入器接口的网络链接速度模拟\",{\"1\":{\"64\":1}}],[\"写入器和验证器\",{\"1\":{\"58\":1}}],[\"写操作\",{\"1\":{\"185\":1}}],[\"写了什么东西\",{\"1\":{\"99\":1}}],[\"字长为64位\",{\"1\":{\"642\":1}}],[\"字节切片操作包\",{\"1\":{\"508\":1}}],[\"字段重命名\",{\"0\":{\"518\":1}}],[\"字段重置后释放对象到池中\",{\"1\":{\"354\":1}}],[\"字段必须是对外暴露的\",{\"1\":{\"509\":1}}],[\"字段的字节偏移\",{\"1\":{\"286\":1}}],[\"字段名称\",{\"1\":{\"286\":1}}],[\"字段名不能与方法名重复\",{\"1\":{\"186\":1}}],[\"字段值是否全部相等\",{\"1\":{\"213\":1}}],[\"字段类型都是可比较类型的结构体\",{\"1\":{\"128\":1}}],[\"字母t\",{\"1\":{\"174\":1}}],[\"字符设备\",{\"1\":{\"319\":1}}],[\"字符类型\",{\"0\":{\"119\":1}}],[\"字符串赋值\",{\"1\":{\"619\":1}}],[\"字符串中的\",{\"1\":{\"615\":1}}],[\"字符串reader\",{\"0\":{\"613\":1}}],[\"字符串replacer\",{\"0\":{\"612\":1}}],[\"字符串builder比起直接操作字符串更加节省内存\",{\"1\":{\"611\":1}}],[\"字符串builder\",{\"0\":{\"611\":1}}],[\"字符串追加数据\",{\"0\":{\"593\":1}}],[\"字符串在转换浮点数时\",{\"1\":{\"590\":1}}],[\"字符串转复数\",{\"0\":{\"591\":1}}],[\"字符串转浮点数\",{\"0\":{\"589\":1}}],[\"字符串转布尔值\",{\"0\":{\"586\":1}}],[\"字符串转整型\",{\"0\":{\"584\":1}}],[\"字符串转换包\",{\"1\":{\"508\":1}}],[\"字符串排序\",{\"0\":{\"578\":1}}],[\"字符串操作包\",{\"1\":{\"508\":1}}],[\"字符串拷贝其实是字节切片拷贝\",{\"1\":{\"175\":1}}],[\"字符串的拼接使用+操作符\",{\"1\":{\"176\":1}}],[\"字符串的长度\",{\"1\":{\"174\":1}}],[\"字符串的内容是只读的不可变的\",{\"1\":{\"173\":1}}],[\"字符串可以转换为字节切片\",{\"1\":{\"173\":1}}],[\"字符串本质上是一个不可变的只读的字节数组\",{\"1\":{\"170\":1}}],[\"字符串表现形式需要自己实现\",{\"1\":{\"132\":1}}],[\"字符串\",{\"0\":{\"222\":1,\"455\":1},\"1\":{\"128\":1,\"153\":1,\"222\":1}}],[\"字符串类型的变量\",{\"1\":{\"125\":1}}],[\"字符串类型\",{\"1\":{\"121\":1,\"213\":1}}],[\"字符串即字节序列\",{\"1\":{\"119\":1}}],[\"字符串字面量必须使用双引号\",{\"1\":{\"105\":1}}],[\"字符串字面量\",{\"0\":{\"105\":1}}],[\"字符串格式处理\",{\"1\":{\"41\":1}}],[\"字符字面量必须使用单引号括起来\",{\"1\":{\"103\":1}}],[\"字符字面量\",{\"0\":{\"103\":1}}],[\"字面意义上\",{\"1\":{\"99\":1}}],[\"字面量函数的类型没有名称\",{\"1\":{\"283\":1}}],[\"字面量\",{\"0\":{\"99\":1,\"171\":1},\"1\":{\"99\":1,\"129\":1,\"130\":3,\"153\":1}}],[\"因该传递指针而不是值\",{\"1\":{\"341\":1}}],[\"因系统调用而阻塞的协程信息\",{\"1\":{\"247\":1}}],[\"因同步原语而阻塞的协程信息\",{\"1\":{\"247\":1}}],[\"因网络io而阻塞的协程信息\",{\"1\":{\"247\":1}}],[\"因此在正常的go开发过程中\",{\"1\":{\"382\":1}}],[\"因此熟悉go\",{\"1\":{\"378\":1}}],[\"因此ctx\",{\"1\":{\"345\":1}}],[\"因此\",{\"1\":{\"336\":1,\"529\":1}}],[\"因此time\",{\"1\":{\"331\":1}}],[\"因此让每次循环都稍微的等一下\",{\"1\":{\"331\":1}}],[\"因此上下文切换开销非常小\",{\"1\":{\"331\":1}}],[\"因此num1的转换结果就是0\",{\"1\":{\"304\":1}}],[\"因此不同类型的变量无法进行运算\",{\"1\":{\"304\":1}}],[\"因此下面这种写法是错误的\",{\"1\":{\"219\":1}}],[\"因此无法赋值给变量an\",{\"1\":{\"206\":1}}],[\"因此无法用于初始化数组长度\",{\"1\":{\"158\":1}}],[\"因此结果就是任何数字都不等于nan\",{\"1\":{\"180\":1}}],[\"因此a\",{\"1\":{\"98\":1}}],[\"因为后者可以作用全局\",{\"1\":{\"620\":1}}],[\"因为后续的代码无法保证同步运行\",{\"1\":{\"392\":1}}],[\"因为两者的数据类型不同\",{\"1\":{\"593\":1}}],[\"因为两者类型不同\",{\"1\":{\"300\":1}}],[\"因为其内容都是依赖于本地的文件\",{\"1\":{\"382\":1}}],[\"因为replace指令所指定的target是一个文件路径而非网络url\",{\"1\":{\"381\":1}}],[\"因为这样的编码风格看起来就跟表格一样\",{\"1\":{\"393\":1}}],[\"因为这会影响到模块名\",{\"1\":{\"364\":1}}],[\"因为这两个数据结构本质上都是指针\",{\"1\":{\"198\":1}}],[\"因为原子操作的粒度过细\",{\"1\":{\"357\":1}}],[\"因为原始错误是被结构体包裹起来的\",{\"1\":{\"312\":1}}],[\"因为协程被唤醒时并不能保证当前条件就已经满足了\",{\"1\":{\"351\":1}}],[\"因为在这里条件变量作用的是读协程\",{\"1\":{\"351\":1}}],[\"因为在这种情况下cgo没法判断其是否被引用\",{\"1\":{\"219\":1}}],[\"因为hello函数内部对一个形参waitgroup调用done并不会作用到原来的mainwait上\",{\"1\":{\"341\":1}}],[\"因为大多数情况下接收方只知道接收数据\",{\"1\":{\"339\":1}}],[\"因为子协程已经执行完毕了\",{\"1\":{\"339\":1}}],[\"因为不能对管道读写就失去了其存在的作用\",{\"1\":{\"338\":1}}],[\"因为管道缓冲区最大只有5\",{\"1\":{\"336\":1}}],[\"因为没有其他协程来向管道中写入或读取数据\",{\"1\":{\"336\":1}}],[\"因为没有数据库程序就运行的毫无意义\",{\"1\":{\"314\":1}}],[\"因为缓冲区容量为0\",{\"1\":{\"335\":1}}],[\"因为io错误的类型有很多\",{\"1\":{\"319\":1}}],[\"因为errorstring实现太过于简单\",{\"1\":{\"310\":1}}],[\"因为处理的方式非常简单\",{\"1\":{\"307\":1}}],[\"因为也就无法进行类型转换\",{\"1\":{\"304\":1}}],[\"因为前者是声明了一个新的类型\",{\"1\":{\"303\":1}}],[\"因为前者仅仅只是一个类型别名\",{\"1\":{\"213\":1}}],[\"因为a是int类型的变量\",{\"1\":{\"300\":1}}],[\"因为tinyint在类型集int内\",{\"1\":{\"259\":1}}],[\"因为tinyint与int8底层类型就是一致的\",{\"1\":{\"259\":1}}],[\"因为无符号整数和有符号整数两个肯定没有交集\",{\"1\":{\"259\":1}}],[\"因为类型不匹配\",{\"1\":{\"256\":1}}],[\"因为c中没有字符串这个类型\",{\"1\":{\"222\":1}}],[\"因为const仅支持基本数据类型\",{\"1\":{\"132\":1}}],[\"因为该头文件生成的前提是所有go源文件能够通过编译\",{\"1\":{\"219\":1}}],[\"因为所有类型的方法集都是空集的超集\",{\"1\":{\"213\":1}}],[\"因为它没有堆栈信息\",{\"1\":{\"312\":1}}],[\"因为它通过语法糖的方式解决了这类问题\",{\"1\":{\"307\":1}}],[\"因为它的参数必须是绝对路径\",{\"1\":{\"231\":1}}],[\"因为它仅仅只是一组规范\",{\"1\":{\"211\":1}}],[\"因为它支持高效的并发处理\",{\"1\":{\"78\":1}}],[\"因为通过指针可以找到dog结构体\",{\"1\":{\"206\":1}}],[\"因为dog没有实现animal\",{\"1\":{\"206\":1}}],[\"因为defer是在函数返回前执行的\",{\"1\":{\"202\":1}}],[\"因为我们要在闭包中对person赋值\",{\"1\":{\"188\":1}}],[\"因为可读性很糟糕\",{\"1\":{\"187\":1}}],[\"因为nan是iee754标准所定义的\",{\"1\":{\"180\":1}}],[\"因为nil不属于任何类型\",{\"1\":{\"125\":1}}],[\"因为go会新分配一片内存空间给字节切片\",{\"1\":{\"173\":1}}],[\"因为字符串本质是字节数组\",{\"1\":{\"172\":1}}],[\"因为标准输出本身就是一个文件\",{\"1\":{\"136\":1}}],[\"因为season是自定义类型\",{\"1\":{\"132\":1}}],[\"因为数组长度也是类型的一部分\",{\"1\":{\"128\":1}}],[\">go\",{\"1\":{\"219\":1}}],[\">cgo\",{\"1\":{\"219\":1}}],[\">=\",{\"1\":{\"98\":1,\"148\":6,\"149\":3,\"201\":1,\"263\":4,\"363\":1,\"395\":3}}],[\">\",{\"1\":{\"98\":1,\"112\":1,\"140\":1,\"147\":4,\"149\":3,\"155\":2,\"160\":4,\"200\":1,\"247\":1,\"262\":3,\"263\":2,\"283\":1,\"354\":1,\"368\":3,\"423\":2,\"612\":1,\"617\":15,\"643\":8}}],[\">>\",{\"1\":{\"98\":1,\"543\":1}}],[\"||\",{\"1\":{\"98\":1,\"217\":1,\"263\":4,\"309\":1,\"314\":1,\"437\":1,\"438\":1}}],[\"|\",{\"1\":{\"98\":1,\"216\":1,\"256\":2,\"257\":17,\"258\":11,\"259\":61,\"260\":33,\"368\":1,\"372\":1,\"390\":4,\"395\":2,\"402\":1,\"541\":5,\"621\":2}}],[\"+1的结果是\",{\"1\":{\"593\":1}}],[\"+18\",{\"1\":{\"415\":1}}],[\"+i\",{\"1\":{\"415\":1}}],[\"+25\",{\"1\":{\"395\":2}}],[\"+offset\",{\"1\":{\"320\":1}}],[\"+0800\",{\"1\":{\"245\":1,\"629\":1,\"632\":1,\"633\":1,\"634\":3,\"635\":2}}],[\"+6\",{\"1\":{\"147\":1}}],[\"+3\",{\"1\":{\"147\":1}}],[\"+v\",{\"1\":{\"140\":2,\"226\":1,\"287\":1,\"312\":1,\"319\":1,\"424\":1,\"425\":2,\"427\":4,\"435\":2,\"520\":1}}],[\"+=\",{\"1\":{\"98\":1,\"149\":7,\"177\":1,\"233\":1,\"336\":1,\"359\":1,\"394\":1}}],[\"+\",{\"1\":{\"98\":1,\"110\":1,\"127\":3,\"130\":1,\"131\":3,\"132\":2,\"143\":1,\"144\":1,\"147\":1,\"158\":3,\"176\":1,\"195\":1,\"197\":3,\"199\":5,\"200\":1,\"201\":2,\"202\":1,\"204\":1,\"217\":1,\"218\":1,\"219\":3,\"221\":2,\"231\":1,\"233\":2,\"256\":3,\"258\":3,\"263\":3,\"300\":2,\"302\":2,\"303\":1,\"304\":1,\"309\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"368\":6,\"390\":1,\"415\":1,\"444\":1,\"544\":2,\"574\":1,\"605\":1,\"620\":1,\"640\":1,\"643\":5,\"644\":2}}],[\"++a\",{\"1\":{\"98\":1}}],[\"++库的ocr\",{\"1\":{\"61\":1}}],[\"++\",{\"1\":{\"46\":1}}],[\"^uint\",{\"1\":{\"543\":1}}],[\"^$\",{\"1\":{\"387\":1}}],[\"^~~~~~~~~~~~~~~\",{\"1\":{\"219\":1}}],[\"^=\",{\"1\":{\"98\":1}}],[\"^\",{\"1\":{\"98\":2}}],[\"运行时操作包\",{\"1\":{\"508\":1}}],[\"运行时管理的轻量级线程\",{\"1\":{\"70\":1}}],[\"运行的输入总数\",{\"1\":{\"396\":1}}],[\"运行测试n次\",{\"1\":{\"388\":1}}],[\"运行如下命令\",{\"1\":{\"382\":1}}],[\"运行命令行程序\",{\"1\":{\"366\":1}}],[\"运算符查看更多细节\",{\"1\":{\"98\":1}}],[\"运算符\",{\"0\":{\"98\":1}}],[\"严格区分大小写\",{\"1\":{\"97\":1}}],[\"数学常量\",{\"0\":{\"545\":1}}],[\"数学操作包\",{\"1\":{\"508\":1}}],[\"数组中的每一个元素都完全相等\",{\"1\":{\"298\":1}}],[\"数组的全部元素是否相等\",{\"1\":{\"213\":1}}],[\"数组的容量等于数组长度\",{\"1\":{\"159\":1}}],[\"数组类型\",{\"1\":{\"213\":1}}],[\"数组在初始化时\",{\"1\":{\"168\":1}}],[\"数组在切割后\",{\"1\":{\"160\":1}}],[\"数组在声明是长度只能是一个常量\",{\"1\":{\"158\":1}}],[\"数组作为值类型\",{\"1\":{\"157\":1}}],[\"数组是定长的数据结构\",{\"1\":{\"156\":1}}],[\"数组和切片两者看起来长得几乎一模一样\",{\"1\":{\"156\":1}}],[\"数组等\",{\"1\":{\"129\":1}}],[\"数组\",{\"0\":{\"157\":1},\"1\":{\"120\":1,\"121\":1,\"271\":1,\"298\":1}}],[\"数字增减\",{\"0\":{\"458\":1}}],[\"数字类型\",{\"1\":{\"121\":1,\"213\":1}}],[\"数字\",{\"1\":{\"97\":1,\"128\":1,\"140\":6}}],[\"数据存储等等\",{\"1\":{\"510\":1}}],[\"数据交换\",{\"1\":{\"509\":3,\"510\":1}}],[\"数据不会被其他协程修改\",{\"1\":{\"348\":1}}],[\"数据采集的方式有两种\",{\"1\":{\"241\":1}}],[\"数据类型\",{\"0\":{\"114\":1},\"1\":{\"266\":1}}],[\"数据分析等领域\",{\"1\":{\"81\":1}}],[\"数据查询\",{\"1\":{\"81\":1}}],[\"数据库连接这类存入sync\",{\"1\":{\"354\":1}}],[\"数据库开发需要一定的技术功底\",{\"1\":{\"253\":1}}],[\"数据库开发\",{\"0\":{\"253\":1}}],[\"数据库与大数据处理\",{\"0\":{\"81\":1}}],[\"数据库操作\",{\"1\":{\"41\":1}}],[\"数据驱动的模板引擎\",{\"1\":{\"43\":1}}],[\"数据编码\",{\"1\":{\"43\":1}}],[\"数据结构除外\",{\"1\":{\"508\":1}}],[\"数据结构是泛型最常见的使用场景\",{\"1\":{\"261\":1}}],[\"数据结构\",{\"0\":{\"46\":1},\"1\":{\"39\":1,\"46\":1,\"509\":1}}],[\"注释符号\",{\"1\":{\"618\":1}}],[\"注释并不会在最终的模板中生成\",{\"1\":{\"618\":1}}],[\"注释与内容之间建议隔一个空格\",{\"1\":{\"96\":1}}],[\"注释\",{\"0\":{\"96\":1,\"618\":1}}],[\"注意点\",{\"0\":{\"337\":1}}],[\"注意\",{\"0\":{\"185\":1},\"1\":{\"94\":1,\"319\":1,\"321\":1}}],[\"yml也在许多项目里以配置文件的形式存在\",{\"1\":{\"513\":1}}],[\"yml\",{\"0\":{\"513\":1},\"1\":{\"515\":1}}],[\"yyyymmddhhmmss\",{\"1\":{\"378\":1}}],[\"you\",{\"1\":{\"372\":2,\"396\":4,\"404\":1,\"609\":4}}],[\"y\",{\"1\":{\"95\":1,\"106\":1,\"298\":1,\"378\":2,\"617\":2}}],[\"yaml的语法和其他高级语言类似\",{\"1\":{\"513\":1}}],[\"yaml\",{\"1\":{\"41\":3,\"372\":2,\"378\":1,\"509\":2,\"513\":2,\"514\":1,\"515\":1}}],[\"外界对于go最诟病的点就在错误处理上\",{\"1\":{\"307\":1}}],[\"外部包将无法访问内部包中的任何内容\",{\"1\":{\"95\":1}}],[\"外设i\",{\"1\":{\"59\":1}}],[\"标量等数据形态\",{\"1\":{\"513\":1}}],[\"标签的使用需要结合反射才能完整发挥出其功能\",{\"1\":{\"191\":1}}],[\"标签是一种键值对的形式\",{\"1\":{\"191\":1}}],[\"标签\",{\"0\":{\"191\":1}}],[\"标签语句\",{\"1\":{\"150\":1}}],[\"标准错误\",{\"1\":{\"134\":1}}],[\"标准输出\",{\"1\":{\"134\":1}}],[\"标准输入\",{\"1\":{\"134\":1}}],[\"标准库的log包提供的功能并不够完善\",{\"1\":{\"541\":1}}],[\"标准库fmt包下就有一个对象池的使用案例\",{\"1\":{\"354\":1}}],[\"标准库unsafe提供了许多用于低级编程的操作\",{\"1\":{\"195\":1}}],[\"标准库缺乏\",{\"1\":{\"84\":1}}],[\"标准库\",{\"1\":{\"77\":1}}],[\"标识符查看更多细节\",{\"1\":{\"97\":1}}],[\"标识符就是一个名称\",{\"1\":{\"97\":1}}],[\"标识符\",{\"0\":{\"97\":1}}],[\"标识符去访问即可\",{\"1\":{\"94\":1}}],[\"当指定时间到了以后\",{\"1\":{\"633\":1}}],[\"当长度为0时\",{\"1\":{\"624\":1}}],[\"当对builder\",{\"1\":{\"611\":1}}],[\"当对一个无缓冲管道直接进行同步读写操作都会导致该协程阻塞\",{\"1\":{\"337\":1}}],[\"当开启一个事务后\",{\"1\":{\"439\":1}}],[\"当反转函数返回error时\",{\"1\":{\"396\":1}}],[\"当参数不带\",{\"1\":{\"396\":1}}],[\"当数据量小的时候无伤大雅\",{\"1\":{\"393\":1}}],[\"当单位为x时\",{\"1\":{\"388\":1}}],[\"当测试的标志参数位于以下集合中时\",{\"1\":{\"387\":1}}],[\"当执行的参数有多个包时\",{\"1\":{\"387\":1}}],[\"当包名为testdata时\",{\"1\":{\"386\":1}}],[\"当user模块测试完毕后\",{\"1\":{\"382\":1}}],[\"当这个项目在另一个人的环境中构建时\",{\"1\":{\"379\":1}}],[\"当主版本大于1时\",{\"1\":{\"378\":1}}],[\"当patch版本发生变化时\",{\"1\":{\"374\":1}}],[\"当minor版本变化时\",{\"1\":{\"374\":1}}],[\"当major版本变化时\",{\"1\":{\"374\":1}}],[\"当不再需要某一个依赖时\",{\"1\":{\"372\":1}}],[\"当一些情况下\",{\"1\":{\"643\":1}}],[\"当一切代码都编写并测试完毕过后\",{\"1\":{\"368\":1}}],[\"当一个库被引用过后\",{\"1\":{\"369\":1}}],[\"当一个程序编写完毕后\",{\"1\":{\"234\":1}}],[\"当一个类型位于一个接口的类型集内\",{\"1\":{\"208\":1}}],[\"当一个类型的方法集是一个接口的方法集的超集时\",{\"1\":{\"208\":1}}],[\"当f\",{\"1\":{\"355\":1}}],[\"当使用go\",{\"1\":{\"376\":1}}],[\"当使用完对象后\",{\"1\":{\"354\":1}}],[\"当使用type关键字声明了一个新的类型时\",{\"1\":{\"259\":1}}],[\"当真正用到切片的时候\",{\"1\":{\"353\":2}}],[\"当在使用一些数据结构时\",{\"1\":{\"353\":1}}],[\"当第三个写协程更新完数据后\",{\"1\":{\"351\":1}}],[\"当调用cancelfunc时\",{\"1\":{\"346\":1}}],[\"当done管道没有关闭时\",{\"1\":{\"343\":1}}],[\"当上下文所做的工作应该取消时\",{\"1\":{\"343\":1}}],[\"当上层调用者想要判断错误的类型来做出不同的处理时\",{\"1\":{\"311\":1}}],[\"当计数变为负数\",{\"1\":{\"341\":1}}],[\"当select语句中什么都没有时\",{\"1\":{\"340\":1}}],[\"当无法成功读取数据时\",{\"1\":{\"339\":1}}],[\"当尝试对只读的管道写入数据时\",{\"1\":{\"338\":1}}],[\"当管道a可用时\",{\"1\":{\"340\":1}}],[\"当管道缓冲区为空或无缓冲时\",{\"1\":{\"339\":1}}],[\"当管道为nil时\",{\"1\":{\"337\":2}}],[\"当管道的缓冲区已满\",{\"1\":{\"337\":1}}],[\"当管道有了缓冲区\",{\"1\":{\"336\":1}}],[\"当读取一个缓冲区为空的管道时\",{\"1\":{\"337\":1}}],[\"当目录不为空时会返回错误\",{\"1\":{\"324\":1}}],[\"当以os\",{\"1\":{\"321\":1}}],[\"当容量不足时\",{\"1\":{\"320\":1}}],[\"当成功读取到值时\",{\"1\":{\"355\":1}}],[\"当成功的打开文件后\",{\"1\":{\"320\":1}}],[\"当成while来使用\",{\"1\":{\"152\":1}}],[\"当打开的时候截断可写的文件\",{\"1\":{\"319\":1}}],[\"当写入文件时\",{\"1\":{\"319\":1}}],[\"当发生fatal时\",{\"1\":{\"317\":1}}],[\"当发生panic时\",{\"1\":{\"315\":1,\"316\":1}}],[\"当子协程发生panic时\",{\"1\":{\"315\":2}}],[\"当初始化数据库连接失败时\",{\"1\":{\"314\":1}}],[\"当输出错误堆栈信息时\",{\"1\":{\"314\":1}}],[\"当程序中存在多个协程时\",{\"1\":{\"313\":1}}],[\"当类型变得越来越复杂时\",{\"1\":{\"301\":1}}],[\"当需要升级最新版本时\",{\"1\":{\"372\":1}}],[\"当需要修改反射值时\",{\"1\":{\"268\":1}}],[\"当需要访问类型相关信息时\",{\"1\":{\"268\":1}}],[\"当队列为空时\",{\"1\":{\"262\":1}}],[\"当传入时也依旧会无法通过编译\",{\"1\":{\"259\":1}}],[\"当确认以后不会再用到它时\",{\"1\":{\"239\":1}}],[\"当切片的长度是一个变量的时候\",{\"1\":{\"239\":1}}],[\"当栈空间不足时会进行增长\",{\"1\":{\"229\":1}}],[\"当然一般情况都是使用f直接转换小数的格式最多\",{\"1\":{\"590\":1}}],[\"当然也可以通过reflect\",{\"1\":{\"645\":1}}],[\"当然也可以使用log\",{\"1\":{\"541\":1}}],[\"当然也可以自定义配置一个服务端\",{\"1\":{\"536\":1}}],[\"当然也可以单独指定某一个测试文件来执行\",{\"1\":{\"387\":1}}],[\"当然也可以忽略不管\",{\"1\":{\"308\":1}}],[\"当然如果想加上参数名和返回值名也是允许的\",{\"1\":{\"210\":1}}],[\"当然不是这样\",{\"1\":{\"192\":1}}],[\"当如下情况时\",{\"1\":{\"208\":1}}],[\"当外部请求数突然激增时\",{\"1\":{\"203\":1}}],[\"当有多个case可用时\",{\"1\":{\"340\":1}}],[\"当有多个defer描述的函数时\",{\"1\":{\"202\":1}}],[\"当有多个同类型的具名返回值时\",{\"1\":{\"199\":1}}],[\"当它的参数是一个函数类型时\",{\"1\":{\"200\":1}}],[\"当函数没有返回值时\",{\"1\":{\"199\":1}}],[\"当省略字段名称时\",{\"1\":{\"187\":1}}],[\"当原slice容量\",{\"1\":{\"163\":1}}],[\"当原\",{\"1\":{\"163\":1}}],[\"当只保留循环条件时\",{\"1\":{\"152\":1}}],[\"当所有case都不匹配后\",{\"1\":{\"149\":1}}],[\"当涉及到函数调用时\",{\"1\":{\"127\":1}}],[\"当你从redis连接池获取一个连接之后\",{\"1\":{\"444\":1}}],[\"当你在下载依赖时\",{\"1\":{\"362\":1}}],[\"当你不需要某一个变量时\",{\"1\":{\"126\":1}}],[\"当你导入后\",{\"1\":{\"94\":1}}],[\"当要声明多个不同类型的变量时\",{\"1\":{\"124\":1}}],[\"当要声明多个相同类型的变量时\",{\"1\":{\"124\":1}}],[\"当两个数字使用^时\",{\"1\":{\"98\":1}}],[\"当导入多个包时\",{\"1\":{\"94\":1}}],[\"当前上下文找不到就去父上下文找\",{\"1\":{\"345\":1}}],[\"当前协程就必须阻塞等待\",{\"1\":{\"336\":1}}],[\"当前计数为\",{\"1\":{\"336\":2}}],[\"当前目录\",{\"1\":{\"327\":2}}],[\"当前函数及其后续调用链所消耗的资源总和\",{\"1\":{\"245\":1}}],[\"当前程序执行情况的跟踪\",{\"1\":{\"243\":1}}],[\"当前程序的命令行调用\",{\"1\":{\"243\":1}}],[\"当前\",{\"1\":{\"60\":1}}],[\"私有模块的模块路径前缀的通用模式列表\",{\"1\":{\"380\":1}}],[\"私有模块\",{\"0\":{\"380\":1}}],[\"私有\",{\"1\":{\"93\":1}}],[\"=>\",{\"1\":{\"378\":5,\"381\":1,\"384\":1}}],[\"===\",{\"1\":{\"366\":1,\"387\":3,\"389\":3,\"390\":8,\"391\":2,\"392\":24,\"396\":12,\"546\":1,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"596\":1,\"597\":1,\"598\":3,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"613\":1}}],[\"========================\",{\"1\":{\"245\":1}}],[\"==\",{\"1\":{\"98\":1,\"101\":9,\"102\":7,\"122\":1,\"128\":3,\"145\":1,\"148\":2,\"151\":1,\"199\":1,\"213\":2,\"263\":2,\"312\":1,\"314\":2,\"317\":1,\"320\":1,\"345\":1,\"346\":1,\"353\":6,\"356\":1,\"365\":1,\"382\":1,\"390\":1,\"437\":1,\"438\":1,\"443\":1,\"602\":1,\"611\":1}}],[\"=\",{\"1\":{\"93\":2,\"98\":3,\"111\":1,\"112\":1,\"125\":15,\"126\":1,\"127\":15,\"128\":2,\"129\":5,\"130\":9,\"131\":8,\"132\":1,\"134\":3,\"139\":2,\"140\":1,\"142\":1,\"143\":4,\"144\":2,\"145\":2,\"147\":3,\"148\":16,\"149\":6,\"150\":2,\"151\":1,\"152\":53,\"153\":8,\"154\":4,\"155\":4,\"158\":7,\"159\":1,\"160\":8,\"162\":3,\"163\":3,\"164\":4,\"165\":5,\"166\":2,\"167\":4,\"168\":6,\"169\":17,\"170\":3,\"172\":6,\"173\":8,\"174\":4,\"175\":5,\"176\":7,\"177\":13,\"178\":5,\"179\":4,\"180\":13,\"181\":5,\"182\":7,\"183\":3,\"184\":3,\"185\":5,\"187\":2,\"188\":9,\"189\":2,\"190\":1,\"194\":7,\"195\":4,\"197\":1,\"199\":6,\"200\":1,\"201\":14,\"202\":2,\"203\":2,\"204\":19,\"205\":3,\"206\":14,\"212\":3,\"213\":11,\"217\":3,\"218\":1,\"219\":6,\"221\":2,\"222\":6,\"225\":10,\"226\":2,\"227\":2,\"229\":6,\"231\":1,\"232\":1,\"233\":5,\"236\":5,\"237\":4,\"238\":2,\"239\":7,\"241\":3,\"242\":11,\"243\":2,\"245\":2,\"246\":5,\"256\":2,\"257\":3,\"258\":4,\"262\":5,\"263\":17,\"269\":2,\"270\":3,\"271\":5,\"274\":1,\"275\":1,\"276\":2,\"277\":2,\"278\":3,\"279\":4,\"280\":4,\"281\":3,\"283\":3,\"284\":3,\"286\":5,\"287\":8,\"288\":2,\"289\":8,\"290\":5,\"292\":1,\"293\":2,\"294\":2,\"295\":1,\"296\":1,\"297\":2,\"298\":5,\"300\":2,\"302\":2,\"303\":5,\"304\":4,\"305\":3,\"306\":1,\"307\":13,\"309\":9,\"311\":2,\"312\":6,\"313\":1,\"316\":6,\"319\":30,\"320\":16,\"321\":12,\"322\":16,\"323\":2,\"324\":4,\"325\":6,\"327\":8,\"328\":2,\"329\":18,\"331\":4,\"333\":3,\"334\":2,\"335\":4,\"336\":12,\"337\":7,\"338\":2,\"339\":10,\"340\":29,\"341\":1,\"344\":2,\"345\":1,\"346\":6,\"347\":1,\"348\":5,\"349\":5,\"350\":5,\"351\":6,\"353\":5,\"354\":14,\"355\":6,\"356\":2,\"359\":1,\"365\":8,\"367\":1,\"382\":5,\"389\":2,\"390\":32,\"391\":8,\"392\":8,\"393\":8,\"394\":6,\"396\":24,\"404\":5,\"406\":6,\"407\":5,\"408\":6,\"409\":5,\"411\":6,\"412\":5,\"413\":6,\"414\":5,\"415\":20,\"421\":3,\"422\":4,\"424\":3,\"425\":9,\"426\":5,\"427\":9,\"428\":4,\"429\":5,\"433\":1,\"434\":6,\"435\":8,\"436\":4,\"437\":6,\"438\":5,\"439\":2,\"443\":3,\"445\":1,\"511\":3,\"512\":4,\"514\":3,\"515\":4,\"517\":3,\"519\":3,\"520\":4,\"521\":13,\"525\":3,\"530\":3,\"531\":5,\"533\":3,\"534\":3,\"536\":1,\"538\":5,\"541\":2,\"543\":16,\"544\":4,\"545\":11,\"567\":2,\"568\":2,\"569\":4,\"570\":4,\"571\":4,\"572\":2,\"573\":4,\"574\":13,\"576\":1,\"577\":1,\"578\":1,\"579\":1,\"580\":2,\"581\":1,\"584\":1,\"585\":1,\"586\":3,\"589\":2,\"590\":1,\"593\":4,\"596\":2,\"600\":7,\"603\":1,\"611\":3,\"612\":1,\"613\":4,\"615\":6,\"617\":26,\"619\":14,\"621\":1,\"622\":2,\"624\":1,\"625\":10,\"626\":16,\"628\":5,\"629\":1,\"630\":8,\"631\":1,\"632\":4,\"633\":2,\"634\":3,\"635\":2,\"640\":5,\"641\":1,\"642\":1,\"643\":9,\"644\":2,\"645\":8,\"646\":3,\"647\":4,\"648\":2}}],[\"名称\",{\"1\":{\"509\":1}}],[\"名称大写字母开头\",{\"1\":{\"93\":1}}],[\"名字小写或下划线开头\",{\"1\":{\"93\":1}}],[\"即首字母大写\",{\"1\":{\"509\":1}}],[\"即直接执行的测试用例\",{\"1\":{\"391\":1}}],[\"即不按照顺序多行输出匹配\",{\"1\":{\"389\":1}}],[\"即不同的人在不同的环境中使用同一个的项目构建时所引用的依赖包必须是完全相同的\",{\"1\":{\"379\":1}}],[\"即按顺序检测输出是否匹配\",{\"1\":{\"389\":1}}],[\"即真正要用到它的时候才会初始化该数据结构\",{\"1\":{\"353\":1}}],[\"即读写互斥锁\",{\"1\":{\"350\":1}}],[\"即上下文应该取消的时间\",{\"1\":{\"343\":1}}],[\"即只能在管道的一边进行操作\",{\"1\":{\"338\":1}}],[\"即先进先出\",{\"1\":{\"334\":1}}],[\"即通过消息来进行内存共享\",{\"1\":{\"332\":1}}],[\"即便如此\",{\"1\":{\"637\":1}}],[\"即便开启了1000个协程\",{\"1\":{\"354\":1}}],[\"即便缓冲区为空\",{\"1\":{\"339\":1}}],[\"即便管道已经关闭\",{\"1\":{\"339\":1}}],[\"即便go的函数参数是值传递\",{\"1\":{\"338\":1}}],[\"即便两个类型可以相互代表\",{\"1\":{\"304\":1}}],[\"即便基础类型是相同的\",{\"1\":{\"302\":1}}],[\"即便其底层类型属于int类型集的范围内\",{\"1\":{\"259\":1}}],[\"即便其底层类型包含在类型集内\",{\"1\":{\"259\":1}}],[\"即便cgo在大多数情况可以避免内存移动\",{\"1\":{\"229\":1}}],[\"即便c中的数组只是一个头指针\",{\"1\":{\"225\":1}}],[\"即包含所有类型\",{\"1\":{\"259\":1}}],[\"即包内唯一的存在\",{\"1\":{\"97\":1}}],[\"即可以构造查询sql\",{\"1\":{\"422\":1}}],[\"即可以在管道两边进行操作\",{\"1\":{\"338\":1}}],[\"即可开启\",{\"1\":{\"216\":1}}],[\"即可实现一个爬虫或者一个web服务器\",{\"1\":{\"40\":1}}],[\"即comparable\",{\"1\":{\"213\":1}}],[\"即使exp函数的生命周期已经结束了\",{\"1\":{\"201\":1}}],[\"即使map中不存在\",{\"1\":{\"179\":1}}],[\"即在传递参数时会拷贝实参的值\",{\"1\":{\"198\":1}}],[\"即go中的函数不支持重载\",{\"1\":{\"197\":1}}],[\"即结果要么为真要么为假\",{\"1\":{\"147\":1}}],[\"即数字无法代替布尔值进行逻辑判断\",{\"1\":{\"115\":1}}],[\"即为私有类型\",{\"1\":{\"93\":1}}],[\"即为公有类型\",{\"1\":{\"93\":1}}],[\"所代表的根对象就是其自身\",{\"1\":{\"617\":1}}],[\"所有结果是根据年龄的大小来排序\",{\"1\":{\"580\":1}}],[\"所有关于索引操作的api都位于esapi\",{\"1\":{\"405\":1}}],[\"所有管道都不可用\",{\"1\":{\"340\":1}}],[\"所有的字符串操作都是建立在utf8的基础之上\",{\"1\":{\"594\":1}}],[\"所有的原子类型都不应该复制值\",{\"1\":{\"360\":1}}],[\"所有的数据等正常添加进切片\",{\"1\":{\"353\":1}}],[\"所有的数据都读完了\",{\"1\":{\"336\":1}}],[\"所有的数据都发送完毕\",{\"1\":{\"336\":1}}],[\"所有的错误都需要通过返回值显式地处理\",{\"1\":{\"84\":1}}],[\"所有变量的类型都会在编译期确定好\",{\"1\":{\"299\":1}}],[\"所有字段都完全相等\",{\"1\":{\"298\":1}}],[\"所有类型都是any接口的的实现\",{\"1\":{\"213\":1}}],[\"所以如果你在这里尝试修改字符串底层的数据\",{\"1\":{\"647\":1}}],[\"所以如果你想要分享你编写的库\",{\"1\":{\"362\":1}}],[\"所以单独拿出来\",{\"1\":{\"647\":1}}],[\"所以单向通道的语法如下\",{\"1\":{\"338\":1}}],[\"所以x必须是一个结构体字段\",{\"1\":{\"641\":1}}],[\"所以实际输出为\",{\"1\":{\"617\":1}}],[\"所以实际上是占用24个字节\",{\"1\":{\"192\":1}}],[\"所以这三个类型可以不用我们自己实现直接使用即可\",{\"1\":{\"575\":1}}],[\"所以这些枚举值也只能用字符串和数字来进行表示\",{\"1\":{\"132\":1}}],[\"所以本文采用mysql来讲解\",{\"1\":{\"432\":1}}],[\"所以再次修改待测源代码\",{\"1\":{\"396\":1}}],[\"所以通过模糊测试就发现了这个问题所在\",{\"1\":{\"396\":1}}],[\"所以将待测试的源代码修改为如下\",{\"1\":{\"396\":1}}],[\"所以将其修改为表格风格\",{\"1\":{\"393\":1}}],[\"所以将读锁作为互斥锁传入\",{\"1\":{\"351\":1}}],[\"所以称为table\",{\"1\":{\"393\":1}}],[\"所以称为伪版本\",{\"1\":{\"378\":1}}],[\"所以一般情况下都是尽量采用结构体切片的形式\",{\"1\":{\"393\":1}}],[\"所以需要用到strconv下的append函数\",{\"1\":{\"593\":1}}],[\"所以需要使用\",{\"1\":{\"387\":1}}],[\"所以需要手动的去判断文件是否存在\",{\"1\":{\"319\":1}}],[\"所以写好测试非常有必要\",{\"1\":{\"385\":1}}],[\"所以对于当前项目而言就是间接引用\",{\"1\":{\"378\":1}}],[\"所以go\",{\"1\":{\"378\":1}}],[\"所以go强制所有程序员花函数后的括号不换行\",{\"1\":{\"108\":1}}],[\"所以我们大多数会用一个第三方开源库etree来解析xml\",{\"1\":{\"512\":1}}],[\"所以我们需要修改默认的模块代理地址\",{\"1\":{\"370\":1}}],[\"所以我们只能在它的函数体后紧跟括号来进行调用\",{\"1\":{\"200\":1}}],[\"所以hello命令行程序的文件存放在cmd\",{\"1\":{\"365\":1}}],[\"所以完全可以考虑无锁化实现\",{\"1\":{\"359\":1}}],[\"所以完全不支持自定义\",{\"1\":{\"107\":1}}],[\"所以执行结果要么成功要么失败\",{\"1\":{\"356\":1}}],[\"所以new函数的并发安全性要由使用者自己来维护\",{\"1\":{\"354\":1}}],[\"所以并不建议保存pointer转换为uintptr后的值\",{\"1\":{\"643\":1}}],[\"所以并不建议将网络链接\",{\"1\":{\"354\":1}}],[\"所以并不推荐\",{\"1\":{\"258\":1}}],[\"所以有些人可能会误称为条件锁\",{\"1\":{\"351\":1}}],[\"所以重复加锁或重复解锁都会导致fatal\",{\"1\":{\"348\":1}}],[\"所以最后的输出如下\",{\"1\":{\"351\":1}}],[\"所以最好避免此种情况的发生\",{\"1\":{\"347\":1}}],[\"所以最终输出为default分支的执行结果\",{\"1\":{\"340\":1}}],[\"所以可以将其单独放到新协程中\",{\"1\":{\"340\":1}}],[\"所以可以直接使用\",{\"1\":{\"329\":1}}],[\"所以会倾向于更相信go\",{\"1\":{\"379\":1}}],[\"所以会一直阻塞等待直到有case可用\",{\"1\":{\"340\":1}}],[\"所以会将整个数组拷贝\",{\"1\":{\"157\":1}}],[\"所以该示例输出如下\",{\"1\":{\"336\":1}}],[\"所以自然会返回一个错误\",{\"1\":{\"319\":1}}],[\"所以输出如下\",{\"1\":{\"316\":2,\"339\":1,\"349\":1}}],[\"所以程序就直接退出运行\",{\"1\":{\"315\":1}}],[\"所以此处应该抛出panic\",{\"1\":{\"314\":1}}],[\"所以error实际上\",{\"1\":{\"312\":1}}],[\"所以只能使用fmt\",{\"1\":{\"311\":1}}],[\"所以很多开源库包括官方库都会选择自定义error\",{\"1\":{\"310\":1}}],[\"所以大多数情况会将其作为函数的返回值来返回\",{\"1\":{\"307\":1}}],[\"所以无法使用类型转换\",{\"1\":{\"305\":1}}],[\"所以下例自然也就可以通过编译\",{\"1\":{\"303\":1}}],[\"所以下面的代码无法通过编译\",{\"1\":{\"300\":1}}],[\"所以下面的代码完全无法通过编译\",{\"1\":{\"300\":1}}],[\"所以类型约束为any\",{\"1\":{\"262\":1,\"263\":1}}],[\"所以基本上都是单独使用\",{\"1\":{\"260\":1}}],[\"所以又间接的并入了自身\",{\"1\":{\"260\":1}}],[\"所以交集就是个空集\",{\"1\":{\"259\":1}}],[\"所以使用者并不能区分主版本变化所带来的不兼容变动\",{\"1\":{\"378\":1}}],[\"所以使用comparable接口\",{\"1\":{\"257\":1}}],[\"所以使用int32来存储是理所当然\",{\"1\":{\"177\":1}}],[\"所以泛型的写法如下\",{\"1\":{\"256\":1}}],[\"所以为什么需要泛型\",{\"1\":{\"256\":1}}],[\"所以其flat指标是100\",{\"1\":{\"245\":1}}],[\"所以其flat的指标是0\",{\"1\":{\"245\":1}}],[\"所以pprof的使用步骤就只有两步\",{\"1\":{\"240\":1}}],[\"所以逃逸分析也是由编译器来完成\",{\"1\":{\"236\":1}}],[\"所以理解起来不需要花费太多力气\",{\"1\":{\"236\":1}}],[\"所以编译器就将其分配到了堆上\",{\"1\":{\"236\":1}}],[\"所以编译器就会认为dog\",{\"1\":{\"206\":1}}],[\"所以是静态分析的一种\",{\"1\":{\"235\":1}}],[\"所以c的内存管理是非常稳定的\",{\"1\":{\"229\":1}}],[\"所以应该使用指针来进行传递\",{\"1\":{\"341\":1}}],[\"所以应该管道在写入完毕后将其关闭\",{\"1\":{\"339\":1}}],[\"所以应该在正确的地方使用泛型\",{\"1\":{\"256\":1}}],[\"所以应该对数组头部元素取址\",{\"1\":{\"225\":1}}],[\"所以应当尽量避免使用nan作为map的键\",{\"1\":{\"180\":1}}],[\"所以any接口可以保存任何类型的值\",{\"1\":{\"213\":1}}],[\"所以man也实现了接口person\",{\"1\":{\"212\":1}}],[\"所以能够访问到的方法只有jackup\",{\"1\":{\"212\":1}}],[\"所以在本文也只会介绍go\",{\"1\":{\"361\":1}}],[\"所以在一些实现中失败达到了一定次数可能会放弃操作\",{\"1\":{\"359\":1}}],[\"所以在操作时会加锁\",{\"1\":{\"359\":1}}],[\"所以在编写代码时应该避免上述情况\",{\"1\":{\"348\":1}}],[\"所以在写入文件时会将数据添加到文件尾部\",{\"1\":{\"321\":1}}],[\"所以在判断错误时\",{\"1\":{\"312\":1}}],[\"所以在堆的初始化时\",{\"1\":{\"263\":1}}],[\"所以在go中\",{\"1\":{\"212\":1}}],[\"所以在这一块追求个性显然是一个不太明智的选择\",{\"1\":{\"107\":1}}],[\"所以第二种解决办法就是赋值dog指针给变量an\",{\"1\":{\"206\":1}}],[\"所以方法的接收者为指针时\",{\"1\":{\"206\":1}}],[\"所以它前后的空白符都会被消除\",{\"1\":{\"617\":1}}],[\"所以它们之间可以进行显式的类型转换\",{\"1\":{\"304\":1}}],[\"所以它们无法被回收\",{\"1\":{\"201\":1}}],[\"所以它对元素有一个要求\",{\"1\":{\"263\":1}}],[\"所以它输出的内容可读性比较高\",{\"1\":{\"138\":1}}],[\"所以仅做了解即可\",{\"1\":{\"192\":1}}],[\"所以你可能会看到如下的目录结构\",{\"1\":{\"379\":1}}],[\"所以你可以直接将字符串写入到标准输出中\",{\"1\":{\"136\":1}}],[\"所以你只需要正常使用vcs开发\",{\"1\":{\"362\":1}}],[\"所以你无法为同一个函数或方法定义不同的参数\",{\"1\":{\"187\":1}}],[\"所以也不存在什么序列化格式化的问题了\",{\"1\":{\"514\":1}}],[\"所以也就可以进行运算\",{\"1\":{\"303\":1}}],[\"所以也算实现\",{\"1\":{\"212\":1}}],[\"所以也可以使用map来替代set\",{\"1\":{\"184\":1}}],[\"所以也是无序的\",{\"1\":{\"177\":1}}],[\"所以就不会有第二条哈希记录\",{\"1\":{\"379\":1}}],[\"所以就有了第二种解决办法\",{\"1\":{\"259\":1}}],[\"所以就可能会看到以下结果\",{\"1\":{\"177\":1}}],[\"所以就需要控制可见性\",{\"1\":{\"93\":1}}],[\"所以结果恰巧每一个字节对应一个字符\",{\"1\":{\"177\":1}}],[\"所以恰好与字面量长度相等\",{\"1\":{\"174\":1}}],[\"所以字符串的访问形式跟数组切片完全一致\",{\"1\":{\"172\":1}}],[\"所以没有扩容\",{\"1\":{\"169\":1}}],[\"所以必须要为其分配内存\",{\"1\":{\"178\":1}}],[\"所以必须要单独初始化\",{\"1\":{\"168\":1}}],[\"所以必须使用强制类型转换\",{\"1\":{\"128\":1}}],[\"所以不会临时存放任何数据\",{\"1\":{\"335\":1}}],[\"所以不会为其分配内存\",{\"1\":{\"162\":1}}],[\"所以不需要额外下载\",{\"1\":{\"244\":1}}],[\"所以不用再去纠结i++和++i这样的问题\",{\"1\":{\"98\":1}}],[\"所以\",{\"1\":{\"162\":1}}],[\"所以代码要更简洁些\",{\"1\":{\"148\":1}}],[\"所以代码应该这样分开写\",{\"1\":{\"127\":1}}],[\"所以像下面的代码是无法通过编译的\",{\"1\":{\"112\":1}}],[\"前者在语法上是一个指针\",{\"1\":{\"643\":1}}],[\"前者是寻找前缀\",{\"1\":{\"603\":1}}],[\"前者是根据空格来分割字符串\",{\"1\":{\"602\":1}}],[\"前者是指定一个具体的超时时间\",{\"1\":{\"347\":1}}],[\"前提与之同名的成员变量存在\",{\"1\":{\"617\":1}}],[\"前提是你将这些路径添加到了环境变量中\",{\"1\":{\"373\":1}}],[\"前提是设置了\",{\"1\":{\"319\":1}}],[\"前缀\",{\"0\":{\"540\":1},\"1\":{\"541\":1}}],[\"前缀加上结构体名称\",{\"1\":{\"226\":1}}],[\"前缀树的实现\",{\"1\":{\"46\":1}}],[\"前面提到了go\",{\"1\":{\"381\":1}}],[\"前面提到过主板变化时要体现在模块名上\",{\"1\":{\"378\":1}}],[\"前面提到过读取管道是有两个返回值的\",{\"1\":{\"339\":1}}],[\"前面提到过内存的分配是由编译器主导的\",{\"1\":{\"236\":1}}],[\"前面提到过字符串有两种字面量表达方式\",{\"1\":{\"171\":1}}],[\"前面提到过包内共享所有变量\",{\"1\":{\"93\":1}}],[\"前面讲到了基本接口就是方法集\",{\"1\":{\"209\":1}}],[\"前往update\",{\"1\":{\"413\":1}}],[\"前往\",{\"1\":{\"383\":1}}],[\"前往go\",{\"1\":{\"375\":1}}],[\"前往removing\",{\"1\":{\"369\":1}}],[\"前往add\",{\"1\":{\"369\":1}}],[\"前往pprof\",{\"1\":{\"246\":1}}],[\"前往内存分配文章了解go具体是如分配内存的\",{\"1\":{\"235\":1}}],[\"前往cgo\",{\"1\":{\"219\":1,\"231\":1}}],[\"前往标准库\",{\"1\":{\"195\":1}}],[\"前往参考手册\",{\"1\":{\"123\":1}}],[\"常见的两种打开文件的方式是使用os包提供的两个函数\",{\"1\":{\"319\":1}}],[\"常量在声明时就必须初始化一个值\",{\"1\":{\"130\":1}}],[\"常量的声明需要用到const关键字\",{\"1\":{\"130\":1}}],[\"常量的值无法被修改\",{\"1\":{\"129\":1}}],[\"常量的值无法在运行时改变\",{\"1\":{\"129\":1}}],[\"常量只能是基本数据类型\",{\"1\":{\"129\":1}}],[\"常量表达式即表达式的最终结果是一个常量\",{\"1\":{\"158\":1}}],[\"常量表达式\",{\"1\":{\"129\":1,\"130\":1,\"158\":2}}],[\"常量myname就是公开的\",{\"1\":{\"93\":1}}],[\"常量\",{\"1\":{\"92\":1,\"93\":3,\"94\":1,\"153\":1,\"158\":1,\"541\":1}}],[\"常用参数\",{\"0\":{\"388\":1}}],[\"常用命令\",{\"0\":{\"375\":1}}],[\"常用的并发控制方法有三种\",{\"1\":{\"331\":1}}],[\"常用第三方包\",{\"0\":{\"41\":1}}],[\"常用第三方包说明\",{\"1\":{\"39\":1}}],[\"常用包\",{\"0\":{\"40\":1},\"1\":{\"40\":1}}],[\"常用包和第三方包介绍\",{\"0\":{\"39\":1}}],[\"常用机器学习库\",{\"1\":{\"39\":1}}],[\"常用框架\",{\"1\":{\"39\":1}}],[\"常用官方包说明\",{\"1\":{\"39\":1}}],[\"英文名package\",{\"1\":{\"92\":1}}],[\"程序会直接崩掉报fatal\",{\"1\":{\"647\":1}}],[\"程序会panic\",{\"1\":{\"611\":1}}],[\"程序将无法正常运行\",{\"1\":{\"341\":1}}],[\"程序开始时调用add初始化计数\",{\"1\":{\"341\":1}}],[\"程序需要立刻停止运行\",{\"1\":{\"317\":1}}],[\"程序需要立即停止来处理该问题\",{\"1\":{\"313\":1}}],[\"程序执行剩下的逻辑后正常退出\",{\"1\":{\"316\":1}}],[\"程序正常退出\",{\"1\":{\"316\":5}}],[\"程序就直接退出了\",{\"1\":{\"315\":1}}],[\"程序就不应该启动\",{\"1\":{\"314\":1}}],[\"程序因为panic退出之前会做一些善后工作\",{\"1\":{\"315\":1}}],[\"程序应该立即退出\",{\"1\":{\"307\":1}}],[\"程序应该在处理完问题后立即退出\",{\"1\":{\"307\":1}}],[\"程序是通过将包链接在一起来构建的\",{\"1\":{\"92\":1}}],[\"程序包sftp实现ssh文件传输协议\",{\"1\":{\"64\":1}}],[\"程序包ftp实现rfc\",{\"1\":{\"64\":1}}],[\"程序包ethernet实施ieee\",{\"1\":{\"64\":1}}],[\"下载mysql驱动库\",{\"1\":{\"432\":1}}],[\"下载sqlx库\",{\"1\":{\"432\":1}}],[\"下载官方的依赖库\",{\"1\":{\"403\":1}}],[\"下载当前项目的依赖包\",{\"1\":{\"375\":1}}],[\"下载依赖的话使用下面的地址就行了\",{\"1\":{\"420\":1}}],[\"下载依赖\",{\"0\":{\"371\":1}}],[\"下文中为了方便\",{\"1\":{\"267\":1}}],[\"下图很形象的描述了其过程\",{\"1\":{\"267\":1}}],[\"下方是一个简单示例\",{\"1\":{\"378\":1}}],[\"下方是一个向nil的map写入值的例子\",{\"1\":{\"313\":1}}],[\"下方是一个使用示例\",{\"1\":{\"191\":1}}],[\"下方例子中不管传什么类型都无法通过编译\",{\"1\":{\"259\":1}}],[\"下方列出所有的内置关键字\",{\"1\":{\"97\":1}}],[\"下列是一些普通字符串\",{\"1\":{\"171\":1}}],[\"下列代码就属于这种情况\",{\"1\":{\"169\":1}}],[\"下划线组成\",{\"1\":{\"97\":1}}],[\"下面来看一个关于模板引擎的简单使用示例\",{\"1\":{\"615\":1}}],[\"下面来看一个读写互斥锁的使用案例\",{\"1\":{\"350\":1}}],[\"下面将以示例的形式讲解常用的函数\",{\"1\":{\"595\":1}}],[\"下面将会以例子的形式演示如何使用\",{\"1\":{\"583\":1}}],[\"下面将通过一个示例进行讲解\",{\"1\":{\"381\":1}}],[\"下面将通过示例来演示进行模块开发的几个步骤\",{\"1\":{\"362\":1}}],[\"下面一个例子是解析域名的ip地址\",{\"1\":{\"573\":1}}],[\"下面逐一讲解\",{\"1\":{\"566\":1}}],[\"下面会简单演示用法\",{\"1\":{\"415\":1}}],[\"下面会简单列举一些规则\",{\"1\":{\"107\":1}}],[\"下面加上\",{\"1\":{\"396\":1}}],[\"下面拿官方教程的例子来讲解\",{\"1\":{\"396\":1}}],[\"下面拿实际的代码举例\",{\"1\":{\"387\":1}}],[\"下面的模板操作都属于管道操作\",{\"1\":{\"621\":1}}],[\"下面的每一个测试用例的结果由每一个基准测试的名称分隔\",{\"1\":{\"394\":1}}],[\"下面的例子以embed\",{\"1\":{\"628\":1}}],[\"下面的例子是一个普通管道的模样\",{\"1\":{\"332\":1}}],[\"下面的例子演示了在c中修改go中的字符串\",{\"1\":{\"222\":1}}],[\"下面解释一下基准测试的输出结果\",{\"1\":{\"394\":1}}],[\"下面举一些常用的标准库的作用\",{\"1\":{\"508\":1}}],[\"下面举个例子\",{\"1\":{\"393\":1}}],[\"下面举几个比较特殊的例子\",{\"1\":{\"212\":1}}],[\"下面依旧通过例子来演示\",{\"1\":{\"390\":1}}],[\"下面只会介绍常用的参数\",{\"1\":{\"388\":1}}],[\"下面只是一些参考项目\",{\"1\":{\"254\":1}}],[\"下面两个例子都无法通过编译\",{\"1\":{\"360\":1}}],[\"下面以一个字符串拼接的例子的性能比较来当作基准测试的例子\",{\"1\":{\"394\":1}}],[\"下面以一个int64类型演示为例\",{\"1\":{\"358\":1}}],[\"下面以一个例子演示\",{\"1\":{\"354\":1}}],[\"下面用一个简单的示例来演示下sync\",{\"1\":{\"355\":1}}],[\"下面用泛型实现一个简单的队列\",{\"1\":{\"262\":1}}],[\"下面稍微修改一下代码\",{\"1\":{\"315\":1}}],[\"下面借由两个数据结构来展示下泛型如何使用\",{\"1\":{\"261\":1}}],[\"下面例子中的integer就是一个类型空集\",{\"1\":{\"259\":1}}],[\"下面推荐几个命令行开发框架或库\",{\"1\":{\"254\":1}}],[\"下面给出一些参考的开源项目\",{\"1\":{\"251\":1}}],[\"下面创建的切片申请了1<<15的容量\",{\"1\":{\"238\":1}}],[\"下面就来逐一讲解\",{\"1\":{\"234\":1}}],[\"下面就来略微细致地去了解里面的概念\",{\"1\":{\"91\":1}}],[\"下面演示制作一个简单的动态链接库\",{\"1\":{\"231\":1}}],[\"下面再改一下\",{\"1\":{\"204\":1}}],[\"下面复习下\",{\"1\":{\"196\":1}}],[\"下面看几个简单的例子\",{\"1\":{\"623\":1}}],[\"下面看几个例子\",{\"1\":{\"163\":1}}],[\"下面看一个迭代的例子\",{\"1\":{\"624\":1}}],[\"下面看一个valuectx的简单使用案例\",{\"1\":{\"345\":1}}],[\"下面看一个例子\",{\"1\":{\"95\":1}}],[\"下面看看一个select语句长什么样\",{\"1\":{\"340\":1}}],[\"下面介绍常见的输入方法\",{\"1\":{\"141\":1}}],[\"下面几个比较常见的\",{\"1\":{\"135\":1}}],[\"下面是内置的所有函数\",{\"1\":{\"620\":1}}],[\"下面是更新多个文档的示例\",{\"1\":{\"427\":1}}],[\"下面是更新单个文档的示例\",{\"1\":{\"427\":1}}],[\"下面是创建多个文档的例子\",{\"1\":{\"426\":1}}],[\"下面是创建一个文档的例子\",{\"1\":{\"426\":1}}],[\"下面是详细些的解释\",{\"1\":{\"374\":1}}],[\"下面是该结构体对外暴露的方法\",{\"1\":{\"355\":1}}],[\"下面是可能的情况之一\",{\"1\":{\"331\":1}}],[\"下面是删除多个文档的例子\",{\"1\":{\"428\":1}}],[\"下面是删除一个文档的例子\",{\"1\":{\"428\":1}}],[\"下面是删除单个文件的例子\",{\"1\":{\"324\":1}}],[\"下面是删除目录的例子\",{\"1\":{\"324\":1}}],[\"下面是代码示例\",{\"1\":{\"271\":1}}],[\"下面是一些工作区的命令\",{\"1\":{\"383\":1}}],[\"下面是一些总结\",{\"1\":{\"337\":1}}],[\"下面是一些类型判断方式\",{\"1\":{\"298\":1}}],[\"下面是一些例子\",{\"1\":{\"196\":1,\"298\":1}}],[\"下面是一个字节切片转字符串的例子\",{\"1\":{\"648\":1}}],[\"下面是一个例子\",{\"1\":{\"392\":1}}],[\"下面是一个官网给的例子\",{\"1\":{\"377\":1}}],[\"下面是一个以os\",{\"1\":{\"321\":1}}],[\"下面是一个以读写模式打开一个文件的代码例子\",{\"1\":{\"319\":1}}],[\"下面是一个比较复杂的例子\",{\"1\":{\"315\":1}}],[\"下面是一个修改字段的例子\",{\"1\":{\"287\":1}}],[\"下面是一个简单二项堆的实现\",{\"1\":{\"263\":1}}],[\"下面是一个简单的mongo客户端与服务端建立连接的例子\",{\"1\":{\"421\":1}}],[\"下面是一个简单的timerctx的使用示例\",{\"1\":{\"347\":1}}],[\"下面是一个简单的示例\",{\"1\":{\"346\":1}}],[\"下面是一个简单的c结构体的例子\",{\"1\":{\"226\":1}}],[\"下面是一个简单的函数返回值的例子\",{\"1\":{\"199\":1}}],[\"下面是一个简单的结构体的例子\",{\"1\":{\"185\":1}}],[\"下面是一个简单的例子\",{\"1\":{\"132\":1,\"140\":1,\"227\":1,\"228\":1,\"574\":1}}],[\"下面是一个完整的例子\",{\"1\":{\"197\":1,\"309\":1}}],[\"下面是go目前所有的格式化动词\",{\"1\":{\"140\":1}}],[\"下面是go语言中支持的运算符号的优先级排列\",{\"1\":{\"98\":1}}],[\"下面这个例子的情况就更加明显了\",{\"1\":{\"204\":1}}],[\"下面这个代码就可以通过编译\",{\"1\":{\"125\":1}}],[\"下面这种代码无法通过编译\",{\"1\":{\"125\":1}}],[\"下面列出go语言中全部的内置类型\",{\"1\":{\"114\":1}}],[\"下拉更换为标准库的错误包和github\",{\"1\":{\"50\":1}}],[\"调用过后必须将其手动关闭\",{\"1\":{\"530\":1}}],[\"调用者或许也不知道到底该由谁来关闭管道\",{\"1\":{\"337\":1}}],[\"调用者完全不知道dangerop\",{\"1\":{\"316\":1}}],[\"调用者调用的函数返回了一个错误\",{\"1\":{\"311\":1}}],[\"调用者可以直接访问该类型的字段和方法\",{\"1\":{\"189\":1}}],[\"调用方法与调用函数的过程相似\",{\"1\":{\"290\":1}}],[\"调用方法\",{\"0\":{\"290\":1},\"1\":{\"290\":1}}],[\"调用\",{\"0\":{\"284\":1}}],[\"调用了fmt包下的println函数进行输出\",{\"1\":{\"91\":1}}],[\"调整图像大小\",{\"1\":{\"58\":1}}],[\"调整大小\",{\"1\":{\"58\":1}}],[\"基础操作差不多就是这些\",{\"1\":{\"416\":1}}],[\"基础面试\",{\"0\":{\"398\":1}}],[\"基准测试又称为性能测试\",{\"1\":{\"394\":1}}],[\"基准测试是benchmarkxxxx\",{\"1\":{\"386\":1}}],[\"基准测试\",{\"0\":{\"394\":1},\"1\":{\"385\":1}}],[\"基本上都是这三步\",{\"1\":{\"615\":1}}],[\"基本上只要知道redis命令怎么用\",{\"1\":{\"446\":1}}],[\"基本操作\",{\"0\":{\"447\":1}}],[\"基本与cancelctx一致\",{\"1\":{\"347\":1}}],[\"基本类型\",{\"0\":{\"292\":1}}],[\"基本类型之类的\",{\"1\":{\"220\":1}}],[\"基本数据类型如此\",{\"1\":{\"259\":1}}],[\"基本接口\",{\"0\":{\"209\":1},\"1\":{\"208\":1}}],[\"基本语法\",{\"0\":{\"91\":1}}],[\"基于它进行命令行开发的项目非常多\",{\"1\":{\"254\":1}}],[\"基于sqlite的分布式数据库\",{\"1\":{\"253\":1}}],[\"基于go语言的数据库或引擎同样也不少\",{\"1\":{\"253\":1}}],[\"基于go编写的协作过滤的离线推荐系统后端\",{\"1\":{\"61\":1}}],[\"基于kcp协议的极其简单和快速的udp隧道\",{\"1\":{\"64\":1}}],[\"基于字典和goram语言的bigram语言模型的标记器\",{\"1\":{\"63\":1}}],[\"基于libsvm\",{\"1\":{\"61\":1}}],[\"基于图形的计算库\",{\"1\":{\"61\":1}}],[\"基于软件交易内存\",{\"1\":{\"56\":1}}],[\"基于cas的快速可调整大小的信号量实现\",{\"1\":{\"56\":1}}],[\"基于通道和上下文的具有锁定\",{\"1\":{\"56\":1}}],[\"基于http\",{\"1\":{\"47\":1}}],[\"基于流的编程包\",{\"1\":{\"47\":1}}],[\"基于drmaa标准的集群调度程序的作业提交库\",{\"1\":{\"47\":1}}],[\"基于ringbuffer实现的队列\",{\"1\":{\"41\":1}}],[\"基于ringbuffer的无锁golang\",{\"1\":{\"41\":1}}],[\"消除了\",{\"1\":{\"89\":1}}],[\"启动速度更快\",{\"1\":{\"89\":1}}],[\"启动和销毁的成本低\",{\"1\":{\"70\":1}}],[\"丰富\",{\"1\":{\"88\":1}}],[\"而后者仅仅作为一个值\",{\"1\":{\"643\":1}}],[\"而模糊测试可以通过语料库来生成随机的测试数据\",{\"1\":{\"396\":1}}],[\"而使用strings\",{\"1\":{\"394\":1}}],[\"而测试用例的函数必须为benchmarkxxxx格式\",{\"1\":{\"394\":1}}],[\"而ticker是定时触发\",{\"1\":{\"634\":1}}],[\"而testequal则没有\",{\"1\":{\"390\":1}}],[\"而trace更适合跟踪程序的运行细节\",{\"1\":{\"247\":1}}],[\"而工作区的存在就是为了能够在不修改go\",{\"1\":{\"382\":1}}],[\"而版本则是要遵循语义化版本号\",{\"1\":{\"374\":1}}],[\"而前面了解到的互斥量就是悲观锁\",{\"1\":{\"359\":1}}],[\"而写协程在更新数据后都会尝试唤醒所有因条件变量而阻塞的协程\",{\"1\":{\"351\":1}}],[\"而创建条件变量的函数签名如下\",{\"1\":{\"351\":1}}],[\"而这就是模板引擎所需要解决的问题\",{\"1\":{\"614\":1}}],[\"而这就是sync\",{\"1\":{\"353\":1}}],[\"而这只是众多可能结果中的一种\",{\"1\":{\"348\":1}}],[\"而这两个结构体在reflect包下都有与其对应的结构体类型\",{\"1\":{\"266\":1}}],[\"而主协程还在阻塞等待其他协程来向管道中写入数据\",{\"1\":{\"339\":1}}],[\"而在go语言中这样的操作是不被允许的\",{\"1\":{\"593\":1}}],[\"而在此期间\",{\"1\":{\"341\":1}}],[\"而在此之前\",{\"1\":{\"331\":1}}],[\"而在使用make进行初始化时\",{\"1\":{\"162\":1}}],[\"而对于每一个版本而言\",{\"1\":{\"379\":1}}],[\"而对于io\",{\"1\":{\"320\":1}}],[\"而对于没有方法集接口来说\",{\"1\":{\"266\":1}}],[\"而对一个错误链使用类型断言是无效的\",{\"1\":{\"312\":1}}],[\"而链式错误正是为了解决这种情况而出现的\",{\"1\":{\"311\":1}}],[\"而类型断言就可以判断其底层类型是否为想要的类型\",{\"1\":{\"305\":1}}],[\"而动态表示是接口底层存储的具体实现的类型是可以变化的\",{\"1\":{\"266\":1}}],[\"而eface对应的是emptyinterface\",{\"1\":{\"266\":1}}],[\"而double又并入了floats\",{\"1\":{\"260\":1}}],[\"而客户端则较少\",{\"1\":{\"254\":1}}],[\"而程序是否高效\",{\"1\":{\"234\":1}}],[\"而go就不一样了\",{\"1\":{\"229\":1}}],[\"而且需要使用格式化动词来指定类型\",{\"1\":{\"614\":1}}],[\"而且会自己配置一个客户端来达到更加细致化的需求\",{\"1\":{\"532\":1}}],[\"而且在解包封包的时候更加的快速\",{\"1\":{\"521\":1}}],[\"而且并不需要手动传入接收者\",{\"1\":{\"290\":1}}],[\"而且性能低下\",{\"1\":{\"256\":1}}],[\"而且还对变量做了修改\",{\"1\":{\"229\":1}}],[\"而且其命名风格也与go非常相似\",{\"1\":{\"223\":1}}],[\"而且可以带名字\",{\"1\":{\"106\":1}}],[\"而非原生的c程序调用go\",{\"1\":{\"219\":1}}],[\"而非引用\",{\"1\":{\"157\":1}}],[\"而cgo可以将两者联系起来\",{\"1\":{\"215\":1}}],[\"而修改一个形参的值\",{\"1\":{\"205\":1}}],[\"而函数没有\",{\"1\":{\"204\":1}}],[\"而匿名组合可以不用显式的指定字段\",{\"1\":{\"189\":1}}],[\"而字节切片或字节数组也可以转换为字符串\",{\"1\":{\"173\":1}}],[\"而多出来的max则指的是最大容量\",{\"1\":{\"169\":1}}],[\"而切片的长度是不固定的\",{\"1\":{\"168\":1}}],[\"而切片是不定长的\",{\"1\":{\"156\":1}}],[\"而数组不会\",{\"1\":{\"162\":1}}],[\"而桶中水的高度就是代表着长度\",{\"1\":{\"162\":1}}],[\"而不要在接收方关闭管道\",{\"1\":{\"339\":1}}],[\"而不建议大转小\",{\"1\":{\"304\":1}}],[\"而不需要源代码\",{\"1\":{\"230\":1}}],[\"而不需要去找它到底是哪一个重载\",{\"1\":{\"197\":1}}],[\"而不提供具体的实现\",{\"1\":{\"207\":1}}],[\"而不同的const分组则相互不会影响\",{\"1\":{\"131\":1}}],[\"而不同类型不可比较\",{\"1\":{\"128\":1}}],[\"而不是字符\",{\"1\":{\"396\":1}}],[\"而不是进行依赖管理\",{\"1\":{\"382\":1}}],[\"而不是管道是否已经关闭\",{\"1\":{\"339\":1}}],[\"而不是像动态语言一样去尝试推断可能的结果\",{\"1\":{\"300\":1}}],[\"而不是直接尝试修改元素的值\",{\"1\":{\"280\":1}}],[\"而不是为了泛型而泛型\",{\"1\":{\"256\":1}}],[\"而不是dog结构体\",{\"1\":{\"206\":1}}],[\"而不是\",{\"1\":{\"92\":1}}],[\"而不是排队的任务数\",{\"1\":{\"56\":1}}],[\"而b是新声明的\",{\"1\":{\"125\":1}}],[\"而是以go诞生时间为模板\",{\"1\":{\"631\":1}}],[\"而是通过循环调用less\",{\"1\":{\"581\":1}}],[\"而是会使用orm框架\",{\"1\":{\"431\":1}}],[\"而是会将其转义为\",{\"1\":{\"378\":1}}],[\"而是会将常用的error当作全局变量使用\",{\"1\":{\"309\":1}}],[\"而是一串不知所云的字符串\",{\"1\":{\"378\":1}}],[\"而是一个非常巨大复杂的任务\",{\"1\":{\"331\":1}}],[\"而是一个比较耗时的任务\",{\"1\":{\"233\":1}}],[\"而是一个较为复杂的数据处理流程\",{\"1\":{\"203\":1}}],[\"而是一个类型的空值或者说默认值更为准确\",{\"1\":{\"121\":1}}],[\"而是应该使用它们的指针\",{\"1\":{\"360\":1}}],[\"而是应该使用errors\",{\"1\":{\"312\":1}}],[\"而是为了表示泛型零值\",{\"1\":{\"262\":1}}],[\"而是逃逸到了堆上\",{\"1\":{\"201\":1}}],[\"而是字节数组的长度\",{\"1\":{\"174\":1}}],[\"而是复用了^符号\",{\"1\":{\"98\":1}}],[\"而+符号附近的间隔则较大\",{\"1\":{\"110\":1}}],[\"而常量mysalary就是私有的\",{\"1\":{\"93\":1}}],[\"而\",{\"1\":{\"87\":1,\"88\":3,\"89\":2,\"178\":1}}],[\"语义\",{\"1\":{\"509\":1}}],[\"语义化版本通常指的是某一个release\",{\"1\":{\"378\":1}}],[\"语句可以在if\",{\"1\":{\"148\":1}}],[\"语句格式如下\",{\"1\":{\"147\":1,\"148\":1,\"149\":1,\"152\":1,\"153\":1}}],[\"语法上像是\",{\"1\":{\"509\":1}}],[\"语法上看起来非常直观\",{\"1\":{\"127\":1}}],[\"语法简洁\",{\"1\":{\"87\":1}}],[\"语言支持\",{\"1\":{\"509\":1}}],[\"语言编写\",{\"1\":{\"441\":1}}],[\"语言编写的\",{\"1\":{\"79\":1}}],[\"语言以其简洁\",{\"1\":{\"89\":1}}],[\"语言\",{\"1\":{\"85\":1}}],[\"语言那么底层\",{\"1\":{\"80\":1}}],[\"语言特别适用于以下场景\",{\"1\":{\"76\":1}}],[\"语言中的\",{\"1\":{\"69\":1}}],[\"语言的设计简洁\",{\"1\":{\"83\":1}}],[\"语言的设计强调简洁性和高效性\",{\"1\":{\"67\":1}}],[\"语言的优点与缺点\",{\"0\":{\"82\":1}}],[\"语言的基础上\",{\"1\":{\"77\":1}}],[\"语言的应用场景\",{\"0\":{\"76\":1}}],[\"语言的程序编译后通常会生成一个静态链接的单一可执行文件\",{\"1\":{\"75\":1}}],[\"语言的语法设计简洁\",{\"1\":{\"69\":1}}],[\"工作区便应运而生\",{\"1\":{\"381\":1}}],[\"工作区\",{\"0\":{\"381\":1},\"1\":{\"381\":1}}],[\"工作更加复杂\",{\"1\":{\"264\":1}}],[\"工具和库\",{\"1\":{\"85\":1}}],[\"工业物联网消息和设备管理服务器\",{\"1\":{\"59\":1}}],[\"教程\",{\"1\":{\"85\":1}}],[\"全球有大量开发者参与其中\",{\"1\":{\"85\":1}}],[\"全部在纯go中进行\",{\"1\":{\"47\":1}}],[\"开n方\",{\"0\":{\"561\":1}}],[\"开始一个事务\",{\"1\":{\"439\":1}}],[\"开源仓库\",{\"1\":{\"419\":1}}],[\"开源的监控和报警工具\",{\"1\":{\"85\":1}}],[\"开源的容器编排平台\",{\"1\":{\"85\":1}}],[\"开了10个协程不断的存入数据\",{\"1\":{\"355\":1}}],[\"开箱即用\",{\"1\":{\"355\":1}}],[\"开启测试覆盖率分析\",{\"1\":{\"388\":1}}],[\"开启了十个协程来对count进行+1操作\",{\"1\":{\"348\":1}}],[\"开启了cgo以后编译时间是要比纯go要更久的\",{\"1\":{\"216\":1}}],[\"开启一个新的协程去异步处理该连接\",{\"1\":{\"574\":1}}],[\"开启一个新的协程\",{\"1\":{\"340\":1}}],[\"开启cgo以后\",{\"1\":{\"216\":1}}],[\"开发难度\",{\"1\":{\"509\":1}}],[\"开发人员不太需要关注底层实现就能做出一个相当不错的并发应用\",{\"1\":{\"330\":1}}],[\"开发者就难受了\",{\"1\":{\"264\":1}}],[\"开发者用的顺手\",{\"1\":{\"264\":1}}],[\"开发上确实会比较方便\",{\"1\":{\"256\":1}}],[\"开发\",{\"0\":{\"77\":1}}],[\"开发的开源编程语言\",{\"1\":{\"67\":1}}],[\"系统创建协程需要时间\",{\"1\":{\"331\":1}}],[\"系统工具等\",{\"1\":{\"84\":1}}],[\"系统编程\",{\"0\":{\"80\":1}}],[\"特性也并不多\",{\"1\":{\"248\":1}}],[\"特性\",{\"1\":{\"84\":1}}],[\"特别适合用来表达或编辑数据结构\",{\"1\":{\"513\":1}}],[\"特别适合构建用于云计算的工具和服务\",{\"1\":{\"79\":1}}],[\"特别适用于并发编程\",{\"1\":{\"67\":1}}],[\"没有特殊需求一般都用这个\",{\"1\":{\"590\":1}}],[\"没有指数\",{\"1\":{\"590\":1}}],[\"没有就采用默认的策略\",{\"1\":{\"532\":1}}],[\"没有orm功能那么丰富但是胜在简洁\",{\"1\":{\"431\":1}}],[\"没有太大区别\",{\"1\":{\"409\":1}}],[\"没有增加任何新功能\",{\"1\":{\"374\":1}}],[\"没有具体实现\",{\"1\":{\"357\":1}}],[\"没有第三种情况可言\",{\"1\":{\"356\":1}}],[\"没有deadline\",{\"1\":{\"344\":1}}],[\"没有遗漏\",{\"1\":{\"331\":1}}],[\"没有实现说明是一个基础的error\",{\"1\":{\"312\":1}}],[\"没有可读性\",{\"1\":{\"242\":1}}],[\"没有闭包了\",{\"1\":{\"204\":1}}],[\"没有返回值的函数类型\",{\"1\":{\"120\":1}}],[\"没有异常处理机制\",{\"1\":{\"84\":1}}],[\"没有类\",{\"1\":{\"84\":1}}],[\"没有依赖库\",{\"1\":{\"75\":1}}],[\"虽然并没有提供特定语法来访问某一个索引的值\",{\"1\":{\"617\":1}}],[\"虽然下列的写法是允许的\",{\"1\":{\"258\":1}}],[\"虽然使用cgo的出发点是为了性能\",{\"1\":{\"233\":1}}],[\"虽然这放在其他语言中看起来很离谱\",{\"1\":{\"212\":1}}],[\"虽然myint是一个值类型\",{\"1\":{\"206\":1}}],[\"虽然没法修改字符串\",{\"1\":{\"172\":1}}],[\"虽然没有明令禁止\",{\"1\":{\"203\":1}}],[\"虽然没有\",{\"1\":{\"80\":1}}],[\"虽然可以不用指定类型\",{\"1\":{\"125\":1}}],[\"虽然可以通过结构体和接口来模拟\",{\"1\":{\"84\":1}}],[\"虽然也有线程和并发支持\",{\"1\":{\"89\":1}}],[\"虽然灵活\",{\"1\":{\"88\":1}}],[\"虽然开发速度较快\",{\"1\":{\"88\":1}}],[\"虽然在快速增长\",{\"1\":{\"88\":1}}],[\"虽然在\",{\"1\":{\"84\":1}}],[\"缺少格式化动词\",{\"1\":{\"140\":1}}],[\"缺少泛型\",{\"1\":{\"84\":1}}],[\"缺乏对图形用户界面\",{\"1\":{\"84\":1}}],[\"缺点\",{\"0\":{\"84\":1}}],[\"减少内存的分配与释放频率\",{\"1\":{\"354\":1}}],[\"减少外部依赖\",{\"1\":{\"83\":1}}],[\"减少了8个字节的内存浪费\",{\"1\":{\"192\":1}}],[\"减少了程序员手动管理内存的负担\",{\"1\":{\"83\":1}}],[\"减少了传统编程语言中许多复杂的特性\",{\"1\":{\"83\":1}}],[\"能简化开发流程\",{\"1\":{\"83\":1}}],[\"能够熟练运用标准库对日常开发将会有非常大的帮助\",{\"1\":{\"508\":1}}],[\"能够解决不断涌现出的各种用例\",{\"1\":{\"402\":1}}],[\"能够阅读\",{\"1\":{\"242\":1}}],[\"能够在不同操作系统上编译和运行\",{\"1\":{\"83\":1}}],[\"能够帮助开发者更快速地迭代和开发\",{\"1\":{\"83\":1}}],[\"能够帮助开发者快速构建\",{\"1\":{\"77\":1}}],[\"能够快速处理多个请求\",{\"1\":{\"78\":1}}],[\"能够隐藏图像中的任何文件\",{\"1\":{\"58\":1}}],[\"能够从音频流生成波形图像\",{\"1\":{\"45\":1}}],[\"拥有丰富的标准库\",{\"1\":{\"83\":1}}],[\"优先应用options\",{\"1\":{\"188\":1}}],[\"优点\",{\"0\":{\"83\":1}}],[\"优秀的第三方库\",{\"1\":{\"39\":1}}],[\"具名管道\",{\"1\":{\"319\":1}}],[\"具体行为与gonoproxy和gonosumdb一致\",{\"1\":{\"380\":1}}],[\"具体的参数与上面对于的数据转换函数一致\",{\"1\":{\"593\":1}}],[\"具体的sql知识这里不会做过多的赘述\",{\"1\":{\"431\":1}}],[\"具体的实现是由plan9汇编编写\",{\"1\":{\"357\":1}}],[\"具体的分析工作要留到后面再进行\",{\"1\":{\"243\":1}}],[\"具体是什么类型交给编译器自行推断\",{\"1\":{\"125\":1}}],[\"具备一定的系统编程能力\",{\"1\":{\"80\":1}}],[\"具有返回值的内置函数不允许跟随在go关键字后面\",{\"1\":{\"331\":1}}],[\"具有更简洁的语法\",{\"1\":{\"89\":1}}],[\"具有更好的性能\",{\"1\":{\"88\":1}}],[\"具有自动垃圾回收机制\",{\"1\":{\"87\":1}}],[\"具有强大的\",{\"1\":{\"77\":1}}],[\"具有同步全双工通信\",{\"1\":{\"64\":1}}],[\"具有灵活的标记器和go的存储后端\",{\"1\":{\"61\":1}}],[\"具有jsonpath支持的golang的抽象json\",{\"1\":{\"60\":1}}],[\"具有可变存储后端的图像代理和侧重于速度和弹性的图像处理引擎\",{\"1\":{\"58\":1}}],[\"具有可自定义的编辑费用和通用前缀的类似于winkler的奖金\",{\"1\":{\"46\":1}}],[\"具有简单双向javascript绑定的跨平台webview窗口\",{\"1\":{\"57\":1}}],[\"具有简单api的文件系统事件通知库\",{\"1\":{\"51\":1}}],[\"具有上下文和支持的例程控制\",{\"1\":{\"56\":1}}],[\"具有空间索引和实时地理围栏的地理位置数据库\",{\"1\":{\"54\":1}}],[\"具有空间实体框架和热插拔功能\",{\"1\":{\"53\":1}}],[\"具有群集支持和通过c\",{\"1\":{\"53\":1}}],[\"具有高级市场分析和交易策略的技术分析库\",{\"1\":{\"52\":1}}],[\"具有堆栈跟踪\",{\"1\":{\"50\":1}}],[\"具有渐进式输入功能的快速\",{\"1\":{\"49\":1}}],[\"具有中间件的超高性能api网关框架\",{\"1\":{\"47\":1}}],[\"具有luajit的高性能结合go的高并发\",{\"1\":{\"47\":1}}],[\"具有受限负载的一致哈希\",{\"1\":{\"47\":1}}],[\"具有过期的键\",{\"1\":{\"46\":1}}],[\"具有扇入和扇出的管线的实现\",{\"1\":{\"46\":1}}],[\"具有最小完美散列的ma\",{\"1\":{\"46\":1}}],[\"具有稀疏\",{\"1\":{\"46\":1}}],[\"具有多个存储\",{\"1\":{\"46\":1}}],[\"具有有效点定位和邻居发现功能的区域四叉树\",{\"1\":{\"46\":1}}],[\"具有额外的位旋转功能的golang设置数据结构\",{\"1\":{\"46\":1}}],[\"都会有如下的文件\",{\"1\":{\"379\":1}}],[\"都会为其分配一块内存以存储对应类型的值\",{\"1\":{\"123\":1}}],[\"都先上锁\",{\"1\":{\"349\":1}}],[\"都不为nil时\",{\"1\":{\"298\":1}}],[\"都为nil时\",{\"1\":{\"298\":2}}],[\"都无法当作类型实参\",{\"1\":{\"260\":1}}],[\"都无法通过编译\",{\"1\":{\"260\":1}}],[\"都无法并入类型集中\",{\"1\":{\"260\":1}}],[\"都只不过是将两个数相加而已\",{\"1\":{\"256\":1}}],[\"都推荐使用指针接收者\",{\"1\":{\"206\":1}}],[\"都可以修改内部的值\",{\"1\":{\"206\":1}}],[\"都是使用的字符串字面量来作为模板\",{\"1\":{\"628\":1}}],[\"都是对已有的http包做的封装与修改\",{\"1\":{\"529\":1}}],[\"都是指向头部元素的指针\",{\"1\":{\"222\":1}}],[\"都是通过自定义类型\",{\"1\":{\"132\":1}}],[\"都是用\",{\"1\":{\"79\":1}}],[\"都建立在\",{\"1\":{\"77\":1}}],[\"许多并发安全的数据结构都采用了cas来进行实现\",{\"1\":{\"359\":1}}],[\"许多go配套工具链将无法使用\",{\"1\":{\"233\":1}}],[\"许多流行的云平台工具\",{\"1\":{\"79\":1}}],[\"许多知名的开源项目和工具都采用了\",{\"1\":{\"85\":1}}],[\"许多知名的\",{\"1\":{\"77\":1}}],[\"宠儿\",{\"1\":{\"79\":1}}],[\"等同于s\",{\"1\":{\"617\":1}}],[\"等其他关系数据库\",{\"1\":{\"432\":1}}],[\"等其他协程来读\",{\"1\":{\"336\":1}}],[\"等待取消中\",{\"1\":{\"346\":6,\"347\":6}}],[\"等待所有的协程执行完毕\",{\"1\":{\"341\":1}}],[\"等待所有goroutine结束等等\",{\"1\":{\"56\":1}}],[\"等待当前循环的协程执行完毕\",{\"1\":{\"341\":1}}],[\"等待子协程结束\",{\"1\":{\"350\":1,\"351\":1}}],[\"等待子协程\",{\"1\":{\"341\":1}}],[\"等于也要开启cgo\",{\"1\":{\"233\":1}}],[\"等价于pointer\",{\"1\":{\"644\":1}}],[\"等价于s\",{\"1\":{\"620\":1}}],[\"等价于stings\",{\"1\":{\"607\":1}}],[\"等价于go\",{\"1\":{\"388\":1}}],[\"等价于nums\",{\"1\":{\"158\":1}}],[\"等价于\",{\"1\":{\"149\":2,\"279\":1,\"304\":2,\"425\":2,\"427\":1}}],[\"等价于无符号64位整型\",{\"1\":{\"116\":1}}],[\"等价\",{\"1\":{\"119\":2}}],[\"等\",{\"1\":{\"77\":1}}],[\"服务端建立新连接时\",{\"1\":{\"574\":1}}],[\"服务端接收数据\",{\"1\":{\"574\":1}}],[\"服务端代码\",{\"1\":{\"574\":1}}],[\"服务端\",{\"0\":{\"535\":1}}],[\"服务和\",{\"1\":{\"77\":1}}],[\"服务器库\",{\"1\":{\"64\":1}}],[\"服务器实施\",{\"1\":{\"64\":1}}],[\"尤其会发生这样的问题\",{\"1\":{\"348\":1}}],[\"尤其是将其作为函数参数传递时\",{\"1\":{\"341\":1}}],[\"尤其是在并发量特别大和实例化对象成本特别高的时候更能体现出优势\",{\"1\":{\"354\":1}}],[\"尤其是在扩容后\",{\"1\":{\"206\":1}}],[\"尤其是在延迟调用中将函数返回值作为参数的情况尤其需要注意\",{\"1\":{\"204\":1}}],[\"尤其是在业务中一些结构体的字段数可能多大几十个或者数百个\",{\"1\":{\"192\":1}}],[\"尤其是在需要处理大量并发请求的场景中表现出色\",{\"1\":{\"77\":1}}],[\"尤其在处理高并发任务时表现优异\",{\"1\":{\"67\":1}}],[\"天生适合开发高性能的网络服务\",{\"1\":{\"77\":1}}],[\"单个访问\",{\"1\":{\"460\":1}}],[\"单个设置\",{\"1\":{\"460\":1}}],[\"单元的大小定义取决于开发者\",{\"1\":{\"390\":1}}],[\"单元测试就是对软件中的最小可测试单元进行测试\",{\"1\":{\"390\":1}}],[\"单元测试是testxxxx\",{\"1\":{\"386\":1}}],[\"单元测试\",{\"0\":{\"390\":1},\"1\":{\"385\":1}}],[\"单向管道通常是用来限制通道的行为\",{\"1\":{\"338\":1}}],[\"单向管道指的是只读或只写的管道\",{\"1\":{\"338\":1}}],[\"单向管道\",{\"0\":{\"338\":1}}],[\"单体web项目我比较推荐参考该项目进行学习\",{\"1\":{\"249\":1}}],[\"单纯的使用标签是没有任何意义的\",{\"1\":{\"150\":1}}],[\"单引号转义\",{\"1\":{\"104\":1}}],[\"单一可执行文件\",{\"0\":{\"75\":1}}],[\"单独运行或分发\",{\"1\":{\"47\":1}}],[\"测试代码也需要稍作修改\",{\"1\":{\"396\":1}}],[\"测试的输入数据都是手动声明的一个个变量\",{\"1\":{\"393\":1}}],[\"测试有着非常多的标志参数\",{\"1\":{\"388\":1}}],[\"测试函数的命名的风格也不同\",{\"1\":{\"386\":1}}],[\"测试函数\",{\"1\":{\"386\":1}}],[\"测试文件通常以bench\",{\"1\":{\"394\":1}}],[\"测试文件通常以\",{\"1\":{\"386\":1}}],[\"测试文件\",{\"1\":{\"386\":1}}],[\"测试文件最好单独放在一个包中\",{\"1\":{\"386\":1}}],[\"测试包\",{\"1\":{\"386\":1,\"508\":1}}],[\"测试结果如下\",{\"1\":{\"233\":1}}],[\"测试\",{\"0\":{\"366\":1,\"385\":1},\"1\":{\"74\":1}}],[\"内容如下\",{\"1\":{\"218\":1,\"231\":1,\"382\":1}}],[\"内置数据结构\",{\"0\":{\"653\":1}}],[\"内置数据类型是否可比较的情况如下\",{\"1\":{\"213\":1}}],[\"内置类型any就是interface\",{\"1\":{\"303\":1}}],[\"内置函数cap来访问数组容量\",{\"1\":{\"159\":1}}],[\"内置工具\",{\"0\":{\"74\":1}}],[\"内部字段不对外暴露\",{\"1\":{\"611\":1}}],[\"内部字段都是零值的结构体\",{\"1\":{\"121\":1}}],[\"内部的其他方法例如work和boot都无法访问\",{\"1\":{\"212\":1}}],[\"内部的字段不同代表内部细节不一样\",{\"1\":{\"212\":1}}],[\"内部实现改变而功能不变\",{\"1\":{\"212\":1}}],[\"内部包\",{\"0\":{\"95\":1}}],[\"内存值\",{\"1\":{\"359\":1}}],[\"内存火焰图\",{\"1\":{\"246\":1}}],[\"内存分析图\",{\"1\":{\"246\":1}}],[\"内存分配抽样\",{\"1\":{\"243\":1}}],[\"内存分配的最终决定权依旧掌握在编译器手里\",{\"1\":{\"239\":1}}],[\"内存分配情况等\",{\"1\":{\"234\":1}}],[\"内存占用和内存分配次数\",{\"1\":{\"395\":1}}],[\"内存占用\",{\"1\":{\"234\":1}}],[\"内存安全问题\",{\"1\":{\"233\":1}}],[\"内存地址就可能发生了变化\",{\"1\":{\"229\":1}}],[\"内存对齐\",{\"0\":{\"192\":1}}],[\"内存管理\",{\"1\":{\"83\":1}}],[\"内存中的lru字符串接口\",{\"1\":{\"46\":1}}],[\"内存中的地理索引\",{\"1\":{\"46\":1}}],[\"内存\",{\"1\":{\"46\":1,\"240\":1}}],[\"适用范围\",{\"1\":{\"509\":1}}],[\"适用于大部分情况\",{\"1\":{\"138\":1}}],[\"适用于高并发\",{\"1\":{\"88\":1}}],[\"适用于开发需要高效执行的系统级应用\",{\"1\":{\"80\":1}}],[\"适用于go的飞利浦hue扩展客户端库\",{\"1\":{\"59\":1}}],[\"适用于基于地理位置的应用程序的内存中缓存\",{\"1\":{\"54\":1}}],[\"适合用于容器化和云原生应用\",{\"1\":{\"78\":1}}],[\"适合大规模开发和快速迭代\",{\"1\":{\"73\":1}}],[\"大于等于\",{\"1\":{\"620\":1}}],[\"大于\",{\"1\":{\"620\":1}}],[\"大小写转换\",{\"0\":{\"609\":1}}],[\"大小是有一定规律的\",{\"1\":{\"163\":1}}],[\"大写e的十进制指数\",{\"1\":{\"590\":1}}],[\"大\",{\"1\":{\"509\":1}}],[\"大致如下\",{\"1\":{\"379\":1}}],[\"大部分可以直接开箱即用\",{\"1\":{\"575\":1}}],[\"大部分开源项目都是在托管在gitub上的\",{\"1\":{\"378\":1}}],[\"大部分情况\",{\"1\":{\"309\":1}}],[\"大部分情况下都很容易读懂代码\",{\"1\":{\"307\":1}}],[\"大部分情况下会以c为主导\",{\"1\":{\"226\":1}}],[\"大部分情况下\",{\"1\":{\"220\":1}}],[\"大部分情况下可以通过\",{\"1\":{\"220\":1}}],[\"大体意思都差不多\",{\"1\":{\"377\":1}}],[\"大内存\",{\"1\":{\"354\":1}}],[\"大概第一眼就可以知道这是一个函数\",{\"1\":{\"301\":1}}],[\"大多数功能都是通过函数来实现的\",{\"1\":{\"620\":1}}],[\"大多数情况第一种使用的较多\",{\"1\":{\"320\":1}}],[\"大多数情况都是被动触发\",{\"1\":{\"317\":1}}],[\"大多数情况下使用默认的处理器defaultservemux即可\",{\"1\":{\"535\":1}}],[\"大多数情况下\",{\"1\":{\"359\":1}}],[\"大多数情况下这些问题隐藏的十分隐蔽\",{\"1\":{\"337\":1}}],[\"大多数情况下应该对其进行处理\",{\"1\":{\"308\":1}}],[\"大多数情况下采用如下的方式来实例化结构体\",{\"1\":{\"187\":1}}],[\"大多数时候我们也无需太过于专注内存分配的细节\",{\"1\":{\"239\":1}}],[\"大大减少了内存泄漏和野指针的风险\",{\"1\":{\"71\":1}}],[\"大数高精度计算包\",{\"1\":{\"508\":1}}],[\"大数\",{\"1\":{\"43\":1}}],[\"不包括其引用内容的大小\",{\"1\":{\"640\":1}}],[\"不包含重复元素的集合\",{\"1\":{\"184\":1}}],[\"不一定非得去访问根对象来获取值\",{\"1\":{\"617\":1}}],[\"不要试图将builder作为值进行传递\",{\"1\":{\"611\":1}}],[\"不要在项目中引入cgo\",{\"1\":{\"233\":1}}],[\"不匹配就会返回字符串s\",{\"1\":{\"610\":2}}],[\"不进行替换\",{\"1\":{\"605\":1}}],[\"不进行gosumdb公共校验的模块路径前缀的通用模式列表\",{\"1\":{\"380\":1}}],[\"不从代理中下载的模块路径前缀的通用模式列表\",{\"1\":{\"380\":1}}],[\"不应该依赖retract所指定依赖的版本或版本范围\",{\"1\":{\"378\":1}}],[\"不应该将其作为值传递和存储\",{\"1\":{\"350\":1}}],[\"不应该使用==操作符\",{\"1\":{\"312\":1}}],[\"不传递任何数据\",{\"1\":{\"343\":1}}],[\"不\",{\"1\":{\"331\":1}}],[\"不受操作系统直接调度\",{\"1\":{\"331\":1}}],[\"不受干扰\",{\"1\":{\"129\":1}}],[\"不会对redis本身做任何讲解\",{\"1\":{\"441\":1}}],[\"不会被go执行\",{\"1\":{\"389\":1}}],[\"不会被其他的任何协程打断\",{\"1\":{\"356\":1}}],[\"不会开始新的测试\",{\"1\":{\"388\":1}}],[\"不会执行任何善后工作\",{\"1\":{\"317\":1}}],[\"不会触发当前协程的善后工作\",{\"1\":{\"315\":1}}],[\"不会冲突\",{\"1\":{\"220\":1}}],[\"不知道为什么没有并入标准库\",{\"1\":{\"312\":1}}],[\"不处理就返回\",{\"1\":{\"307\":1}}],[\"不存在隐式类型转换\",{\"1\":{\"304\":1}}],[\"不严谨的说\",{\"1\":{\"267\":1}}],[\"不可预知\",{\"1\":{\"354\":1}}],[\"不可以直接使用\",{\"1\":{\"332\":1}}],[\"不可控的因素非常多\",{\"1\":{\"331\":1}}],[\"不可能返回具体的类型\",{\"1\":{\"262\":1}}],[\"不可比较\",{\"1\":{\"213\":2}}],[\"不论是基本接口\",{\"1\":{\"260\":1}}],[\"不被允许\",{\"1\":{\"258\":2}}],[\"不指定类型\",{\"1\":{\"256\":1}}],[\"不然会找不到\",{\"1\":{\"232\":1}}],[\"不建议c长期持有其指针引用\",{\"1\":{\"225\":1}}],[\"不影响之前的使用\",{\"1\":{\"212\":1}}],[\"不考虑复用的话\",{\"1\":{\"200\":1}}],[\"不管什么类型\",{\"1\":{\"617\":1}}],[\"不管执行多少次\",{\"1\":{\"341\":1}}],[\"不管调用者是不是指针\",{\"1\":{\"206\":1}}],[\"不管具名返回值如何声明\",{\"1\":{\"199\":1}}],[\"不管是直接的还是间接的\",{\"1\":{\"94\":1}}],[\"不带返回值即可\",{\"1\":{\"199\":1}}],[\"不带参数进行切片即可\",{\"1\":{\"160\":1}}],[\"不定长参数根据传入类型的不同而不同\",{\"1\":{\"196\":1}}],[\"不是指针\",{\"1\":{\"196\":1}}],[\"不是数组\",{\"1\":{\"158\":1}}],[\"不占用内存空间\",{\"1\":{\"193\":1}}],[\"不足的则补齐\",{\"1\":{\"192\":1}}],[\"不像其它语言通常会有一个enum来表示\",{\"1\":{\"132\":1}}],[\"不能定位\",{\"1\":{\"312\":1}}],[\"不能赋值字符串\",{\"1\":{\"300\":1}}],[\"不能用作类型声明\",{\"1\":{\"259\":1}}],[\"不能是变量\",{\"1\":{\"158\":1}}],[\"不能是\",{\"1\":{\"129\":1}}],[\"不能与参数名重复\",{\"1\":{\"199\":1}}],[\"不能与go任何内置的关键字冲突\",{\"1\":{\"97\":1}}],[\"不能与任何已存在的标识符重复\",{\"1\":{\"97\":1}}],[\"不想要第二个\",{\"1\":{\"126\":1}}],[\"不过只适用于只读的情况下\",{\"1\":{\"648\":1}}],[\"不过对于存放在堆栈上的字符串变量而言\",{\"1\":{\"647\":1}}],[\"不过需要注意的是在go中格式化模板不是常见的yyyy\",{\"1\":{\"631\":1}}],[\"不过需要明白的一点是\",{\"1\":{\"382\":1}}],[\"不过通常建议使用\",{\"1\":{\"620\":1}}],[\"不过通常我们不会去手动序列化\",{\"1\":{\"521\":1}}],[\"不过本文要讲述的主角是go内置的模板引擎库text\",{\"1\":{\"614\":1}}],[\"不过已经足够满足日常使用\",{\"1\":{\"564\":1}}],[\"不过传统的xml解析方式经常需要新建结构体\",{\"1\":{\"512\":1}}],[\"不过一般下载的驱动库都会自动注册驱动\",{\"1\":{\"432\":1}}],[\"不过一点也不影响之前接口的使用\",{\"1\":{\"208\":1}}],[\"不过官方的mongo驱动库已经完全足够使用了\",{\"1\":{\"419\":1}}],[\"不过官方提供的errors包其实并不够用\",{\"1\":{\"312\":1}}],[\"不过示例测试主要是由output注释来体现的\",{\"1\":{\"389\":1}}],[\"不过大部分情况并不需要手动的修改go\",{\"1\":{\"378\":1}}],[\"不过由于yml本身有着严格的缩进语法\",{\"1\":{\"514\":1}}],[\"不过由于其服务器部署在国外\",{\"1\":{\"370\":1}}],[\"不过由于内部用到了反射\",{\"1\":{\"138\":1}}],[\"不过真正的效率要结合具体使用场景来看\",{\"1\":{\"359\":1}}],[\"不过filepath标准库已经提供了类似功能的函数\",{\"1\":{\"329\":1}}],[\"不过panic在退出之前会做好程序的善后工作\",{\"1\":{\"313\":1}}],[\"不过标准库已经提供好了类似的函数\",{\"1\":{\"312\":1}}],[\"不过缺点也不少\",{\"1\":{\"307\":1}}],[\"不过我们看待事物要辩证的来看\",{\"1\":{\"307\":1}}],[\"不过毫无意义而且可能会造成数值溢出的问题\",{\"1\":{\"258\":1}}],[\"不过有一点怪\",{\"1\":{\"255\":1}}],[\"不过区别在于cgo没有提供伪函数来对切片进行拷贝\",{\"1\":{\"225\":1}}],[\"不过区别在于指针无法偏移\",{\"1\":{\"195\":1}}],[\"不过可以使用c中的typedef关键字来给类型取个别名\",{\"1\":{\"220\":1}}],[\"不过可以被声明\",{\"1\":{\"211\":1}}],[\"不过是一个匿名空接口\",{\"1\":{\"213\":1}}],[\"不过这种场景比较少见\",{\"1\":{\"215\":1}}],[\"不过这更像是一种\",{\"1\":{\"212\":1}}],[\"不过这是错误处理一节中才会涉及到的东西\",{\"1\":{\"202\":1}}],[\"不过两者并不应该混合使用\",{\"1\":{\"206\":1}}],[\"不过条件是它们必须相邻\",{\"1\":{\"198\":1}}],[\"不过为了可读性一般还是建议尽量给参数加上名称\",{\"1\":{\"198\":1}}],[\"不过指针不能光声明\",{\"1\":{\"194\":1}}],[\"不过实际编码过程中\",{\"1\":{\"192\":1}}],[\"不过在1\",{\"1\":{\"645\":1}}],[\"不过在go1\",{\"1\":{\"208\":1}}],[\"不过在go语言中没有这些\",{\"1\":{\"93\":1}}],[\"不过在使用值接收者时\",{\"1\":{\"206\":1}}],[\"不过在编码的时候可以省去\",{\"1\":{\"190\":1}}],[\"不过go也对私有模块进行了支持\",{\"1\":{\"380\":1}}],[\"不过go并不是c语言\",{\"1\":{\"239\":1}}],[\"不过go并不支持函数与方法重载\",{\"1\":{\"187\":1}}],[\"不过go中的函数有两个不同的点\",{\"1\":{\"106\":1}}],[\"不过也可以省略字段名称\",{\"1\":{\"187\":1}}],[\"不过背后的安全问题需要自己承担\",{\"1\":{\"173\":1}}],[\"不过你也可以通过unsafe库来实现无复制转换\",{\"1\":{\"173\":1}}],[\"不过它是按行读取的\",{\"1\":{\"145\":1}}],[\"不过它有以下缺点\",{\"1\":{\"132\":1}}],[\"不过仅支持有序类型的参数\",{\"1\":{\"128\":1}}],[\"不支持复杂情况下的处理\",{\"1\":{\"614\":1}}],[\"不支持泛型方法\",{\"1\":{\"258\":1}}],[\"不支持转义\",{\"1\":{\"171\":1}}],[\"不支持多行书写\",{\"1\":{\"171\":1}}],[\"不支持指针算术操作\",{\"1\":{\"87\":1}}],[\"不支持传统的面向对象编程\",{\"1\":{\"84\":1}}],[\"不需要绑定到根对象中\",{\"1\":{\"620\":1}}],[\"不需要阻塞\",{\"1\":{\"574\":1}}],[\"不需要操作一次就关闭一次连接\",{\"1\":{\"446\":1}}],[\"不需要你来手动注册\",{\"1\":{\"432\":1}}],[\"不需要开发者做什么工作\",{\"1\":{\"369\":1}}],[\"不需要void\",{\"1\":{\"199\":1}}],[\"不需要解引用就可以直接访问结构体的内容\",{\"1\":{\"190\":1}}],[\"不需要使用指针\",{\"1\":{\"127\":1}}],[\"不需要手动内存管理\",{\"1\":{\"87\":1}}],[\"不需要程序员手动管理内存\",{\"1\":{\"71\":1}}],[\"不同的系统可能会有不同的结果\",{\"1\":{\"637\":1}}],[\"不同的类型可能还会有其他的额外方法\",{\"1\":{\"358\":1}}],[\"不同的类型无法进行运算\",{\"1\":{\"302\":1}}],[\"不同于动态链接库\",{\"1\":{\"232\":1}}],[\"不同\",{\"1\":{\"71\":1}}],[\"不仅是一个命令行工具\",{\"1\":{\"11\":1}}],[\"类似的\",{\"1\":{\"340\":1}}],[\"类似数组切片的拷贝方式\",{\"1\":{\"175\":1}}],[\"类似于os\",{\"1\":{\"51\":1}}],[\"类似于count\",{\"1\":{\"46\":1}}],[\"类型支持\",{\"0\":{\"397\":1}}],[\"类型位的掩码\",{\"1\":{\"319\":1}}],[\"类型判断\",{\"0\":{\"306\":1}}],[\"类型断言语句有两个返回值\",{\"1\":{\"305\":1}}],[\"类型断言通常用于判断某一接口类型的变量是否属于某一个类型\",{\"1\":{\"305\":1}}],[\"类型断言\",{\"0\":{\"305\":1},\"1\":{\"312\":1}}],[\"类型别名对于一些特别复杂的类型有很大的用处\",{\"1\":{\"303\":1}}],[\"类型别名仅仅只是一个别名\",{\"1\":{\"303\":1}}],[\"类型别名与类型声明则不同\",{\"1\":{\"303\":1}}],[\"类型别名\",{\"0\":{\"303\":1}}],[\"类型声明\",{\"0\":{\"302\":1}}],[\"类型在后面的原则\",{\"1\":{\"301\":1}}],[\"类型后置在可读性上要好得多\",{\"1\":{\"301\":1}}],[\"类型后置\",{\"0\":{\"301\":1}}],[\"类型变量\",{\"1\":{\"268\":1}}],[\"类型变量转换成反射对象\",{\"1\":{\"268\":1}}],[\"类型哈希\",{\"1\":{\"266\":1}}],[\"类型并集中不能有交集\",{\"1\":{\"260\":1}}],[\"类型集不能直接或间接的并入自身\",{\"1\":{\"260\":1}}],[\"类型集中的交集问题\",{\"1\":{\"260\":1}}],[\"类型集无法当作类型实参使用\",{\"1\":{\"260\":1}}],[\"类型集注意点\",{\"0\":{\"260\":1}}],[\"类型集主要用于类型约束\",{\"1\":{\"259\":1}}],[\"类型集\",{\"0\":{\"259\":1}}],[\"类型集就是一组类型的集合\",{\"1\":{\"208\":1}}],[\"类型实参\",{\"1\":{\"256\":1}}],[\"类型约束为t\",{\"1\":{\"257\":1}}],[\"类型约束为int\",{\"1\":{\"257\":1}}],[\"类型约束\",{\"1\":{\"256\":1}}],[\"类型形参\",{\"1\":{\"256\":1}}],[\"类型转换的结果也不总是正确的\",{\"1\":{\"304\":1}}],[\"类型转换的另一个前提是\",{\"1\":{\"304\":1}}],[\"类型转换适用的前提是知晓被转换变量的类型和要转换成的目标类型\",{\"1\":{\"304\":1}}],[\"类型转换\",{\"0\":{\"220\":1,\"304\":1}}],[\"类型number的底层类型是int\",{\"1\":{\"212\":1}}],[\"类型的变量\",{\"1\":{\"212\":1}}],[\"类型不匹配\",{\"1\":{\"140\":1}}],[\"类型不安全\",{\"1\":{\"132\":1}}],[\"类型必须保持一致\",{\"1\":{\"125\":1}}],[\"类型名\",{\"1\":{\"124\":1,\"286\":1}}],[\"类型和描述\",{\"1\":{\"116\":1,\"117\":1}}],[\"类型\",{\"0\":{\"269\":1,\"299\":1,\"357\":1,\"524\":1},\"1\":{\"114\":1,\"115\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"162\":1,\"213\":1,\"266\":1,\"305\":1}}],[\"类型是静态检查的\",{\"1\":{\"71\":1}}],[\"配置http客户端数据传输相关的配置项\",{\"1\":{\"532\":1}}],[\"配置\",{\"1\":{\"509\":1}}],[\"配置文件\",{\"1\":{\"509\":1,\"510\":1,\"513\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"0\":1}}],[\"配合\",{\"1\":{\"70\":1}}],[\"强类型则指的是在程序中执行严格的类型检查\",{\"1\":{\"300\":1}}],[\"强类型与垃圾回收\",{\"0\":{\"71\":1}}],[\"强烈推荐使用cobra进行cli开发\",{\"1\":{\"254\":1}}],[\"强调通过组合来实现代码复用\",{\"1\":{\"69\":1}}],[\"强大灵活的命令行解析库\",{\"1\":{\"254\":1}}],[\"强大的websocket框架\",{\"1\":{\"64\":1}}],[\"强大的gltf\",{\"1\":{\"58\":1}}],[\"强大而灵活的合并库\",{\"1\":{\"46\":1}}],[\"易于调试\",{\"1\":{\"307\":1}}],[\"易于使用的tensorflow绑定\",{\"1\":{\"61\":1}}],[\"易于使用的可扩展的分布式大数据处理\",{\"1\":{\"47\":1}}],[\"易学易用\",{\"1\":{\"69\":1}}],[\"旨在更好的进行本地的多模块开发工作\",{\"1\":{\"381\":1}}],[\"旨在提供一种简单\",{\"1\":{\"67\":1}}],[\"旨在与gnu\",{\"1\":{\"51\":1}}],[\"多用于rpc领域通信相关\",{\"1\":{\"521\":1}}],[\"多用于数据结构的输出\",{\"1\":{\"140\":1}}],[\"多\",{\"1\":{\"509\":1}}],[\"多长时间检测一下\",{\"1\":{\"444\":1}}],[\"多个是select\",{\"1\":{\"435\":1}}],[\"多个协程读取和访问一个共享数据时\",{\"1\":{\"348\":1}}],[\"多次使用也只会有一个能恢复panic\",{\"1\":{\"316\":1}}],[\"多维切片\",{\"0\":{\"168\":1}}],[\"多播dns\",{\"1\":{\"64\":1}}],[\"多线程的决策树集合\",{\"1\":{\"61\":1}}],[\"受python\",{\"1\":{\"64\":1}}],[\"套接字服务器变得简单\",{\"1\":{\"64\":1}}],[\"无论其内部元素是否对外暴露\",{\"1\":{\"643\":1}}],[\"无论是使用本地路径还是模块路径指定替换\",{\"1\":{\"378\":1}}],[\"无论怎样读写都会导致当前协程阻塞\",{\"1\":{\"337\":1}}],[\"无缓冲管道中会造成死锁例子在这里可以顺利运行\",{\"1\":{\"336\":1}}],[\"无缓冲管道在发送数据时\",{\"1\":{\"336\":1}}],[\"无缓冲管道不应该同步的使用\",{\"1\":{\"335\":1}}],[\"无缓冲\",{\"0\":{\"335\":1}}],[\"无法做到参数命名\",{\"1\":{\"614\":1}}],[\"无法预知这个对象是新创建的还是复用的\",{\"1\":{\"354\":1}}],[\"无法预判的\",{\"1\":{\"331\":1}}],[\"无法获得锁时并不会阻塞而是返回false\",{\"1\":{\"350\":1}}],[\"无法被取消\",{\"1\":{\"345\":1}}],[\"无法被修改\",{\"1\":{\"319\":1}}],[\"无法作为参数传递\",{\"1\":{\"304\":1}}],[\"无法作为该函数的参数\",{\"1\":{\"303\":1}}],[\"无法进行运算\",{\"1\":{\"300\":1}}],[\"无法通过dog结构体找到dog指针\",{\"1\":{\"206\":1}}],[\"无法通过编译\",{\"1\":{\"125\":1,\"172\":1,\"259\":2,\"260\":4}}],[\"无法使用dog\",{\"1\":{\"206\":1}}],[\"无法正常使用\",{\"1\":{\"194\":1}}],[\"无法修改\",{\"1\":{\"173\":1}}],[\"无法访问\",{\"1\":{\"129\":1}}],[\"无符号整型\",{\"1\":{\"116\":1}}],[\"无符号\",{\"1\":{\"116\":4}}],[\"无阻塞的tcp网络库\",{\"1\":{\"64\":1}}],[\"无反射json编码器\",{\"1\":{\"60\":1}}],[\"允许将普通函数用作http的处理器\",{\"1\":{\"537\":1}}],[\"允许调用了t\",{\"1\":{\"388\":1}}],[\"允许其存储的值在运行时动态的变化\",{\"1\":{\"123\":1}}],[\"允许使用下划线\",{\"1\":{\"100\":1}}],[\"允许指定设置的每秒查询负载\",{\"1\":{\"64\":1}}],[\"允许一个人轻松地同时通过文件系统\",{\"1\":{\"51\":1}}],[\"允许一个程序以任意类型操作对象\",{\"1\":{\"43\":1}}],[\"7347742\",{\"1\":{\"635\":1}}],[\"7334\",{\"1\":{\"569\":1}}],[\"7366827\",{\"1\":{\"396\":1}}],[\"736\",{\"1\":{\"395\":1}}],[\"736455\",{\"1\":{\"395\":1}}],[\"736177\",{\"1\":{\"394\":1}}],[\"79769313486231570814527423731704356798070e+308\",{\"1\":{\"544\":1}}],[\"790421300\",{\"1\":{\"395\":1}}],[\"763gi\",{\"1\":{\"395\":6}}],[\"76e8c1e\",{\"1\":{\"368\":2}}],[\"7µ\",{\"1\":{\"395\":1}}],[\"7ms\",{\"1\":{\"395\":1}}],[\"7m\",{\"1\":{\"395\":3}}],[\"789s\",{\"1\":{\"396\":1}}],[\"780614\",{\"1\":{\"395\":1}}],[\"783599\",{\"1\":{\"395\":1}}],[\"785830400\",{\"1\":{\"395\":1}}],[\"74\",{\"1\":{\"395\":1}}],[\"744885\",{\"1\":{\"395\":1}}],[\"742s\",{\"1\":{\"395\":1}}],[\"743634000\",{\"1\":{\"395\":1}}],[\"712991800\",{\"1\":{\"395\":1}}],[\"717285\",{\"1\":{\"395\":1}}],[\"71828182845904523536028747135266249775724709369995957496696763\",{\"1\":{\"545\":1}}],[\"71828i\",{\"1\":{\"102\":1}}],[\"71828\",{\"1\":{\"101\":1}}],[\"750\",{\"1\":{\"395\":1}}],[\"750513\",{\"1\":{\"395\":1}}],[\"759537\",{\"1\":{\"395\":1}}],[\"754c\",{\"1\":{\"177\":1}}],[\"754\",{\"1\":{\"117\":2}}],[\"754浮点数\",{\"1\":{\"117\":1}}],[\"7个读协程\",{\"1\":{\"350\":1}}],[\"77245385090551602729816748334114518279754945612238712821380779\",{\"1\":{\"545\":1}}],[\"77\",{\"1\":{\"177\":1}}],[\"77代码转换为go代码\",{\"1\":{\"55\":1}}],[\"706\",{\"1\":{\"395\":1}}],[\"706605350\",{\"1\":{\"395\":1}}],[\"704798\",{\"1\":{\"395\":1}}],[\"700824\",{\"1\":{\"395\":1}}],[\"70\",{\"1\":{\"148\":3,\"396\":1}}],[\"7229057\",{\"1\":{\"635\":1}}],[\"729821\",{\"1\":{\"395\":1}}],[\"72\",{\"1\":{\"101\":2,\"152\":1,\"177\":1}}],[\"7252\",{\"1\":{\"64\":1}}],[\"7\",{\"0\":{\"75\":1},\"1\":{\"140\":1,\"143\":2,\"152\":11,\"154\":1,\"155\":6,\"163\":2,\"164\":4,\"165\":4,\"166\":6,\"167\":2,\"169\":5,\"172\":1,\"195\":1,\"225\":5,\"239\":13,\"294\":1,\"331\":3,\"336\":2,\"339\":1,\"341\":1,\"349\":1,\"350\":1,\"351\":1,\"355\":2,\"372\":4,\"378\":3,\"395\":1,\"404\":2,\"408\":1,\"543\":1,\"557\":1,\"592\":1,\"643\":1,\"644\":1}}],[\"西里尔字母等\",{\"1\":{\"63\":1}}],[\"书写系统\",{\"1\":{\"63\":1}}],[\"句子标记器\",{\"1\":{\"63\":1}}],[\"命令手册\",{\"1\":{\"446\":1}}],[\"命令中开启了详细日志和内存分析\",{\"1\":{\"394\":1}}],[\"命令\",{\"0\":{\"383\":1},\"1\":{\"375\":1,\"383\":1}}],[\"命令如下\",{\"1\":{\"372\":1}}],[\"命令行参数解析包\",{\"1\":{\"508\":1}}],[\"命令行工具\",{\"0\":{\"254\":1}}],[\"命令行\",{\"0\":{\"245\":1}}],[\"命令行或网页\",{\"1\":{\"244\":1}}],[\"命令行用的是gitbash\",{\"1\":{\"215\":1}}],[\"命令行程序框架\",{\"1\":{\"41\":2}}],[\"命名可以为unit\",{\"1\":{\"390\":1}}],[\"命名规则如下\",{\"1\":{\"97\":1}}],[\"命名实体提取等\",{\"1\":{\"63\":1}}],[\"词性标记\",{\"1\":{\"63\":1}}],[\"彼得罗维奇\",{\"1\":{\"63\":1}}],[\"潜在语义分析\",{\"1\":{\"63\":1}}],[\"也正是这四个操作才能写出能够忽略类型系统从而直接读写内存的代码\",{\"1\":{\"643\":1}}],[\"也要及时关闭\",{\"1\":{\"634\":1}}],[\"也拷贝了内部切片的指针\",{\"1\":{\"611\":1}}],[\"也提供了一些三角函数的工具函数\",{\"1\":{\"508\":1}}],[\"也最为简单\",{\"1\":{\"432\":1}}],[\"也可能是一个函数\",{\"1\":{\"390\":1}}],[\"也可以通过new方法创建自己的实例\",{\"1\":{\"541\":1}}],[\"也可以直接http\",{\"1\":{\"537\":1}}],[\"也可以是基本类型的字面量\",{\"1\":{\"617\":1}}],[\"也可以是基本类型\",{\"1\":{\"617\":1}}],[\"也可以是第三方库\",{\"1\":{\"432\":1}}],[\"也可以是char数组类型\",{\"1\":{\"222\":1}}],[\"也可以修改$gomodcache来指定存放在另外一个位置\",{\"1\":{\"376\":1}}],[\"也可以使用下面两个函数\",{\"1\":{\"628\":1}}],[\"也可以使用flag\",{\"1\":{\"525\":1}}],[\"也可以使用options\",{\"1\":{\"425\":1}}],[\"也可以使用go\",{\"1\":{\"372\":1}}],[\"也可以使用strings\",{\"1\":{\"175\":1}}],[\"也可以读\",{\"1\":{\"338\":1}}],[\"也可以被float64类型代表\",{\"1\":{\"304\":1}}],[\"也可以反射调用函数\",{\"1\":{\"282\":1}}],[\"也可以声明泛型变量的方式来解决零值问题\",{\"1\":{\"262\":1}}],[\"也可以声明的时候直接赋值\",{\"1\":{\"125\":1}}],[\"也可以如下\",{\"1\":{\"257\":1}}],[\"也可以将这些接口集成到自己的路由中而不是使用默认路由\",{\"1\":{\"243\":1}}],[\"也可以在c中直接修改go中的字符串\",{\"1\":{\"222\":1}}],[\"也可以传递字节切片\",{\"1\":{\"222\":1}}],[\"也可以根据上述的方法自己定义\",{\"1\":{\"220\":1}}],[\"也可以减少后续维护的负担\",{\"1\":{\"206\":1}}],[\"也可以匿名组合\",{\"1\":{\"189\":1}}],[\"也可以转换为字节切片再进行添加元素\",{\"1\":{\"176\":1}}],[\"也可以把表达式写的更复杂些\",{\"1\":{\"147\":1}}],[\"也可以用来映射数据\",{\"1\":{\"422\":1}}],[\"也可以用traces命令不过它的输出很冗长\",{\"1\":{\"245\":1}}],[\"也可以用元素初始化\",{\"1\":{\"158\":1}}],[\"也可以用于复数\",{\"1\":{\"140\":1}}],[\"也可以用括号括起来\",{\"1\":{\"94\":1}}],[\"也可以这么写\",{\"1\":{\"131\":1}}],[\"也可以前往参考手册\",{\"1\":{\"97\":1,\"98\":1}}],[\"也会被忽略掉\",{\"1\":{\"378\":1}}],[\"也会发生逃逸现象\",{\"1\":{\"238\":1}}],[\"也有部分的是自行搭建仓库\",{\"1\":{\"378\":1}}],[\"也多了一个方法unwrap\",{\"1\":{\"311\":1}}],[\"也无法知晓池中有几个对象\",{\"1\":{\"354\":1}}],[\"也无法并入类型约束中\",{\"1\":{\"260\":1}}],[\"也无法判断其是否存在\",{\"1\":{\"180\":1}}],[\"也能其集成到其它的web框架中\",{\"1\":{\"243\":1}}],[\"也不是一个硬性的规范\",{\"1\":{\"389\":1}}],[\"也不建议手动修改该文件\",{\"1\":{\"379\":1}}],[\"也不能取值\",{\"1\":{\"344\":1}}],[\"也不好固定内存\",{\"1\":{\"219\":1}}],[\"也不太建议这么做\",{\"1\":{\"215\":1}}],[\"也不在乎什么绝世起重机\",{\"1\":{\"212\":1}}],[\"也对应了官方对于基本接口实现的定义\",{\"1\":{\"212\":1}}],[\"也印证了map是无序存储\",{\"1\":{\"182\":1}}],[\"也就说必须是\",{\"1\":{\"617\":1}}],[\"也就是8个字节\",{\"1\":{\"642\":1}}],[\"也就是基准测试中的循环次数\",{\"1\":{\"394\":1}}],[\"也就是cas\",{\"1\":{\"359\":1}}],[\"也就是不可重入锁\",{\"1\":{\"348\":1}}],[\"也就是接收者类型\",{\"1\":{\"289\":1}}],[\"也就是要修改的字段\",{\"1\":{\"287\":1}}],[\"也就是interface\",{\"1\":{\"267\":1}}],[\"也就是一个字符数组的指针\",{\"1\":{\"222\":1}}],[\"也就是gcc\",{\"1\":{\"216\":1}}],[\"也就是解引用\",{\"1\":{\"194\":1}}],[\"也就是说指针无法偏移\",{\"1\":{\"195\":1}}],[\"也就是说字符串的组成单位是字节而不是字符\",{\"1\":{\"177\":1}}],[\"也就是说所有通过此工具的格式化后的代码都是同一种代码风格\",{\"1\":{\"107\":1}}],[\"也就无法正常取值\",{\"1\":{\"180\":1}}],[\"也就无法作为map的键\",{\"1\":{\"178\":1}}],[\"也是必须要熟练掌握和使用的库\",{\"1\":{\"542\":1}}],[\"也是同样的道理\",{\"1\":{\"247\":1}}],[\"也是go的核心\",{\"1\":{\"196\":1}}],[\"也是一种哈希表\",{\"1\":{\"177\":1}}],[\"也是一片连续的内存空间\",{\"1\":{\"170\":1}}],[\"也是静态类型但是解释型语言\",{\"1\":{\"89\":1}}],[\"也是web框架\",{\"1\":{\"42\":1}}],[\"也广泛应用于数据库连接\",{\"1\":{\"81\":1}}],[\"也没有头文件\",{\"1\":{\"69\":1}}],[\"也叫字面值\",{\"1\":{\"99\":1}}],[\"也叫\",{\"1\":{\"67\":1}}],[\"也称为unidecode\",{\"1\":{\"63\":1}}],[\"雪球库libstemmer库的绑定\",{\"1\":{\"63\":1}}],[\"搬运程序阻止算法的实现\",{\"1\":{\"63\":1}}],[\"俄罗斯形态分析仪\",{\"1\":{\"63\":1}}],[\"简介\",{\"0\":{\"508\":1}}],[\"简化了包管理\",{\"1\":{\"85\":1}}],[\"简化了官方tensorflow\",{\"1\":{\"61\":1}}],[\"简洁的语法\",{\"0\":{\"69\":1},\"1\":{\"83\":1}}],[\"简单来说就是操作字符串的工具包\",{\"1\":{\"594\":1}}],[\"简单存取\",{\"0\":{\"456\":1}}],[\"简单介绍一些其中的一些指标\",{\"1\":{\"245\":1}}],[\"简单的用一句话概括\",{\"1\":{\"340\":1}}],[\"简单的例子如下\",{\"1\":{\"302\":1,\"303\":1}}],[\"简单的tun\",{\"1\":{\"64\":1}}],[\"简单的tcp代理\",{\"1\":{\"64\":1}}],[\"简单的cli电子邮件解析器\",{\"1\":{\"60\":1}}],[\"简单的go包\",{\"1\":{\"60\":1}}],[\"简单的go图像处理包\",{\"1\":{\"58\":1}}],[\"简单的http微服务\",{\"1\":{\"58\":1}}],[\"简单和异步goroutine池库\",{\"1\":{\"56\":1}}],[\"简单和易于使用的库\",{\"1\":{\"53\":1}}],[\"简单golang错误处理与分类元\",{\"1\":{\"50\":1}}],[\"简单\",{\"1\":{\"47\":1,\"509\":3}}],[\"建筑完成\",{\"1\":{\"212\":3}}],[\"建筑得以顺利完成\",{\"1\":{\"212\":1}}],[\"建筑公司结构体内部声明了一个crane类型的成员变量\",{\"1\":{\"212\":1}}],[\"建筑公司不在乎是用什么技术实现的\",{\"1\":{\"212\":1}}],[\"建筑公司并不负责造起重机\",{\"1\":{\"212\":1}}],[\"建议在使用时应当格外注意\",{\"1\":{\"643\":1}}],[\"建议使用html\",{\"1\":{\"628\":1}}],[\"建议使用<stdint\",{\"1\":{\"223\":1}}],[\"建议使用下面这种方式进行转换\",{\"1\":{\"160\":1}}],[\"建议还是用普通的构造函数来解决\",{\"1\":{\"188\":1}}],[\"建议预分配一个足够的容量\",{\"1\":{\"162\":1}}],[\"建议和协作过滤引擎\",{\"1\":{\"61\":1}}],[\"建立连接\",{\"0\":{\"445\":1},\"1\":{\"574\":2}}],[\"建立在termbox之上\",{\"1\":{\"53\":1}}],[\"建立用于支持为golang服务定义异步服务运行状况检查的库\",{\"1\":{\"47\":1}}],[\"贝叶斯文本分类器\",{\"1\":{\"61\":1}}],[\"贝叶斯推断\",{\"1\":{\"61\":1}}],[\"贝叶斯分类为golang天真\",{\"1\":{\"61\":1}}],[\"库的go绑定\",{\"1\":{\"61\":1}}],[\"库坐标转换和变换\",{\"1\":{\"54\":1}}],[\"原字符为\",{\"1\":{\"396\":1}}],[\"原因是字符串反转后变成了非utf8格式\",{\"1\":{\"396\":1}}],[\"原始压缩包等\",{\"1\":{\"376\":1}}],[\"原始错误\",{\"1\":{\"312\":2}}],[\"原子的存储值\",{\"1\":{\"358\":1}}],[\"原子的交换值\",{\"1\":{\"358\":1}}],[\"原子的获取值\",{\"1\":{\"358\":1}}],[\"原子或原语操作\",{\"1\":{\"356\":1}}],[\"原子\",{\"0\":{\"356\":1}}],[\"原子加载数据\",{\"1\":{\"353\":1}}],[\"原文为dynamic\",{\"1\":{\"266\":1}}],[\"原本不可排序的类型传入比较器后也可以使用堆了\",{\"1\":{\"263\":1}}],[\"原生字符串里面所有的字符都会原封不动的输出\",{\"1\":{\"171\":1}}],[\"原生字符串由反引号表示\",{\"1\":{\"171\":1}}],[\"原生字符串\",{\"1\":{\"171\":1}}],[\"原slice容量超过256\",{\"1\":{\"163\":1}}],[\"原\",{\"1\":{\"163\":1}}],[\"原型聚类算法的go实现\",{\"1\":{\"61\":1}}],[\"原理\",{\"1\":{\"10\":1}}],[\"进阶面试\",{\"0\":{\"400\":1}}],[\"进入对应的页面后\",{\"1\":{\"372\":1}}],[\"进入了善后工作\",{\"1\":{\"315\":1}}],[\"进入winrm客户端以在windows计算机上远程执行命令\",{\"1\":{\"64\":1}}],[\"进行值拷贝的同时\",{\"1\":{\"611\":1}}],[\"进行强大的分析\",{\"1\":{\"402\":1}}],[\"进行包裹\",{\"1\":{\"124\":1}}],[\"进行了整合\",{\"1\":{\"67\":1}}],[\"进行有效的文本分割\",{\"1\":{\"63\":1}}],[\"进化优化库\",{\"1\":{\"61\":1}}],[\"进程管理\",{\"1\":{\"40\":1}}],[\"灵活\",{\"1\":{\"61\":1,\"242\":1}}],[\"突出显示格式和获取json的结构查询的控制台工具\",{\"1\":{\"60\":1}}],[\"物理计算和物联网的框架\",{\"1\":{\"59\":1}}],[\"物联网设备编程库\",{\"1\":{\"39\":1}}],[\"物联网\",{\"0\":{\"59\":1},\"1\":{\"39\":1}}],[\"盖特是一个围棋包构建低功耗蓝牙外设\",{\"1\":{\"59\":1}}],[\"量化自我和物联网的开源平台\",{\"1\":{\"59\":1}}],[\"裁切\",{\"1\":{\"58\":1}}],[\"绑定到imagemagick的magickwand\",{\"1\":{\"58\":1}}],[\"绑定portmidi\",{\"1\":{\"45\":1}}],[\"纯go中的2d渲染\",{\"1\":{\"58\":1}}],[\"纯go中图像处理算法的集合\",{\"1\":{\"58\":1}}],[\"控制内存分配统计的频率\",{\"1\":{\"388\":1}}],[\"控制协程阻塞统计频率\",{\"1\":{\"388\":1}}],[\"控制鼠标\",{\"1\":{\"57\":1}}],[\"控制goroutine的执行顺序\",{\"1\":{\"56\":1}}],[\"活动\",{\"1\":{\"57\":1}}],[\"q\",{\"1\":{\"140\":2,\"262\":18,\"396\":15,\"600\":4,\"602\":2,\"608\":4}}],[\"qt\",{\"1\":{\"57\":1}}],[\"quotetoascii\",{\"1\":{\"588\":1}}],[\"quote\",{\"1\":{\"588\":1}}],[\"query转义\",{\"1\":{\"620\":1}}],[\"query\",{\"1\":{\"382\":2,\"415\":2,\"435\":4,\"439\":2,\"620\":1}}],[\"queue\",{\"1\":{\"41\":1,\"56\":1,\"262\":7}}],[\"quux\",{\"1\":{\"95\":1}}],[\"quic\",{\"1\":{\"64\":1}}],[\"quick\",{\"1\":{\"43\":1}}],[\"跨平台支持\",{\"0\":{\"72\":1},\"1\":{\"83\":1}}],[\"跨平台的go库\",{\"1\":{\"57\":2}}],[\"跨平台\",{\"1\":{\"57\":3}}],[\"跨多种文件系统类型\",{\"1\":{\"51\":1}}],[\"由go语言自身的调度器进行运行时调度\",{\"1\":{\"331\":1}}],[\"由go\",{\"1\":{\"247\":1}}],[\"由runtime\",{\"1\":{\"229\":1}}],[\"由redis\",{\"1\":{\"46\":1}}],[\"由于字符串字面量是存放在进程中的只读段\",{\"1\":{\"647\":1}}],[\"由于unsafe\",{\"1\":{\"643\":1}}],[\"由于官方已经帮我们实现了float64slicestringsliceintslice三个类型\",{\"1\":{\"575\":1}}],[\"由于mysql比较流行\",{\"1\":{\"432\":1}}],[\"由于一些字符占用并不止一个字节\",{\"1\":{\"396\":1}}],[\"由于传入的字符串是不可预知的\",{\"1\":{\"396\":1}}],[\"由于其vx\",{\"1\":{\"378\":1}}],[\"由于其长度未知\",{\"1\":{\"239\":1}}],[\"由于无锁化实现的并发安全效率相对于锁要高一些\",{\"1\":{\"359\":1}}],[\"由于这些操作无法再细化为更小的步骤\",{\"1\":{\"356\":1}}],[\"由于每个协程访问和计算所需的时间不同\",{\"1\":{\"348\":1}}],[\"由于上例中没有对管道写入数据\",{\"1\":{\"340\":1}}],[\"由于管道已经关闭了\",{\"1\":{\"339\":1}}],[\"由于管道的缓冲区大小为1\",{\"1\":{\"336\":1}}],[\"由于缓冲区大小为1\",{\"1\":{\"336\":1}}],[\"由于是根据年龄比较的\",{\"1\":{\"580\":1}}],[\"由于是以os\",{\"1\":{\"321\":1}}],[\"由于是crane\",{\"1\":{\"212\":1}}],[\"由于项目下并没有文件readme\",{\"1\":{\"319\":1}}],[\"由于在创建结构体时返回的是结构体指针\",{\"1\":{\"312\":1}}],[\"由于该结构体并不对外暴露\",{\"1\":{\"311\":1}}],[\"由于该数组的内存是由go管理\",{\"1\":{\"225\":1}}],[\"由于interface\",{\"1\":{\"305\":1}}],[\"由于对元素没有任何的要求\",{\"1\":{\"263\":1}}],[\"由于采用了泛型\",{\"1\":{\"262\":1}}],[\"由于do函数本身什么都没做\",{\"1\":{\"245\":1}}],[\"由于它是函数内创建的\",{\"1\":{\"236\":1}}],[\"由于它是在编译期进行\",{\"1\":{\"235\":1}}],[\"由于cobra十分常用\",{\"1\":{\"254\":1}}],[\"由于c\",{\"1\":{\"222\":1}}],[\"由于go语言本身的并发特性\",{\"1\":{\"565\":1}}],[\"由于go并不支持联合体\",{\"1\":{\"227\":1}}],[\"由于go需要gc\",{\"1\":{\"215\":1}}],[\"由于go函数是传值传递\",{\"1\":{\"157\":1}}],[\"由于同样具有起重和吊货的功能\",{\"1\":{\"212\":1}}],[\"由于例子中的字符都是属于ascii字符\",{\"1\":{\"177\":1}}],[\"由于容量为6\",{\"1\":{\"169\":1}}],[\"由文件结构中可知\",{\"1\":{\"95\":1}}],[\"由vlc媒体播放器使用\",{\"1\":{\"65\":1}}],[\"由electron支持\",{\"1\":{\"57\":1}}],[\"打乱测试的执行顺序\",{\"1\":{\"388\":1}}],[\"打开方式有两种\",{\"1\":{\"327\":1}}],[\"打开文件时\",{\"1\":{\"322\":1}}],[\"打开\",{\"0\":{\"319\":1}}],[\"打开一个名为readme\",{\"1\":{\"307\":1}}],[\"打开一个文件后永远要记得关闭该文件\",{\"1\":{\"319\":1}}],[\"打开一个文件\",{\"1\":{\"307\":1}}],[\"打开后页面大概如下所示\",{\"1\":{\"247\":1}}],[\"打印出代码优化建议\",{\"1\":{\"236\":1}}],[\"打印go的详细数据结构\",{\"1\":{\"41\":1}}],[\"打包以使用go\",{\"1\":{\"57\":1}}],[\"帮助函数不会单独作为一个测试用例用于执行\",{\"1\":{\"391\":1}}],[\"帮助您节流和限制goroutine\",{\"1\":{\"56\":1}}],[\"帮助测试使用通道的代码\",{\"1\":{\"43\":1}}],[\"有关protobuf的讲解可以前往protobuf\",{\"1\":{\"521\":1}}],[\"有关es\",{\"1\":{\"404\":1}}],[\"有序集合\",{\"0\":{\"479\":1}}],[\"有趣的输入指的是该输入能够将代码覆盖率扩大到现有语料库所能覆盖的范围之外\",{\"1\":{\"396\":1}}],[\"有趣\",{\"1\":{\"396\":1}}],[\"有助于后续生成随机的测试数据\",{\"1\":{\"396\":1}}],[\"有多个引用时可以使用括号括起来\",{\"1\":{\"378\":1}}],[\"有着非常多关于它的详细信息\",{\"1\":{\"372\":1}}],[\"有三个参数\",{\"1\":{\"359\":1}}],[\"有且仅有一个返回值\",{\"1\":{\"339\":1}}],[\"有且只有一种方法\",{\"1\":{\"333\":1}}],[\"有缓冲io读写包\",{\"1\":{\"508\":1}}],[\"有缓冲\",{\"0\":{\"336\":1}}],[\"有些比较古老的依赖包可能没有go\",{\"1\":{\"379\":1}}],[\"有些时候使用defer来关闭管道可能会更好\",{\"1\":{\"333\":1}}],[\"有些情况下需要将error类型的错误转换为具体的错误实现类型\",{\"1\":{\"312\":1}}],[\"有这么一句玩笑话\",{\"1\":{\"307\":1}}],[\"有错误就处理\",{\"1\":{\"307\":1}}],[\"有泛型的加持\",{\"1\":{\"263\":1}}],[\"有许多著名项目都是基于cobra\",{\"1\":{\"254\":1}}],[\"有越来越多的企业转到go这个方向\",{\"1\":{\"252\":1}}],[\"有几个点要注意\",{\"1\":{\"246\":1}}],[\"有两种解决办法\",{\"1\":{\"259\":1}}],[\"有两种方式进行分析\",{\"1\":{\"244\":1}}],[\"有两个对外暴露的方法walk和say\",{\"1\":{\"210\":1}}],[\"有两个int类型的参数a\",{\"1\":{\"197\":1}}],[\"有时候我们需要分析程序整体的cpu占用\",{\"1\":{\"234\":1}}],[\"有时候你并不想让别人访问某一个类型\",{\"1\":{\"93\":1}}],[\"有了自己的地址\",{\"1\":{\"225\":1}}],[\"有了实现之后\",{\"1\":{\"212\":1}}],[\"有可能会影响的s1的数据\",{\"1\":{\"169\":1}}],[\"有仅有一种循环语句\",{\"1\":{\"151\":1}}],[\"有一个需要注意的点是\",{\"1\":{\"378\":1}}],[\"有一个tag就足矣\",{\"1\":{\"368\":1}}],[\"有一个规则\",{\"1\":{\"125\":1}}],[\"有一点需要稍微注意下\",{\"1\":{\"98\":1}}],[\"有符号整数类型的并集就是signedint\",{\"1\":{\"259\":1}}],[\"有符号\",{\"1\":{\"116\":4}}],[\"有丰富的第三方库\",{\"1\":{\"88\":1}}],[\"有垃圾回收机制\",{\"1\":{\"83\":1}}],[\"有自动垃圾回收机制\",{\"1\":{\"71\":1}}],[\"有限的消费者goroutine池或无限制的goroutine池\",{\"1\":{\"56\":1}}],[\"有用\",{\"1\":{\"46\":1}}],[\"异步简单函数实用程序\",{\"1\":{\"56\":1}}],[\"轻巧的goroutine池\",{\"1\":{\"56\":1}}],[\"轻松编排goroutine\",{\"1\":{\"56\":1}}],[\"轻量级的命令行框架\",{\"1\":{\"254\":1}}],[\"轻量级的协程池\",{\"1\":{\"41\":1}}],[\"轻量级游戏服务器框架\",{\"1\":{\"53\":1}}],[\"轻量级mp3解码器库\",{\"1\":{\"45\":1}}],[\"轻量级web框架\",{\"1\":{\"42\":1}}],[\"使得并发操作变得更加容易理解和维护\",{\"1\":{\"70\":1}}],[\"使执行流程可中断的灵活机制\",{\"1\":{\"56\":1}}],[\"使用flag\",{\"1\":{\"525\":1}}],[\"使用fmt\",{\"1\":{\"140\":1}}],[\"使用默认db\",{\"1\":{\"443\":1,\"445\":1}}],[\"使用函数elasticsearch\",{\"1\":{\"404\":1}}],[\"使用output注释来检测输出\",{\"1\":{\"389\":1}}],[\"使用opencv\",{\"1\":{\"58\":1}}],[\"使用xprog运行测试\",{\"1\":{\"388\":1}}],[\"使用uri建立连接\",{\"1\":{\"421\":1}}],[\"使用use指令\",{\"1\":{\"382\":1}}],[\"使用unsafe\",{\"1\":{\"272\":1}}],[\"使用slicedata的例子如下\",{\"1\":{\"645\":1}}],[\"使用strings\",{\"1\":{\"394\":1}}],[\"使用sync\",{\"1\":{\"355\":1}}],[\"使用smtp保持活动状态和两个超时发送电子邮件的非常简单的程序包\",{\"1\":{\"48\":1}}],[\"使用完毕后释放\",{\"1\":{\"354\":1}}],[\"使用完毕后记得使用free释放内存\",{\"1\":{\"222\":1}}],[\"使用对象\",{\"1\":{\"354\":1}}],[\"使用互斥锁可以非常完美的解决上述问题\",{\"1\":{\"349\":1}}],[\"使用它可以很轻易的实现等待一组协程的效果\",{\"1\":{\"341\":1}}],[\"使用示例如下\",{\"1\":{\"316\":1,\"322\":2,\"569\":1,\"570\":1,\"571\":1,\"572\":1}}],[\"使用示例命令行客户端\",{\"1\":{\"52\":1}}],[\"使用例子如下\",{\"1\":{\"314\":1,\"320\":2,\"321\":2,\"647\":1}}],[\"使用时\",{\"1\":{\"311\":1}}],[\"使用的前提是入参必须是接口类型\",{\"1\":{\"306\":1}}],[\"使用类型别名后看起来会简洁一些\",{\"1\":{\"303\":1}}],[\"使用类型别名后的例子如下\",{\"1\":{\"303\":1}}],[\"使用type\",{\"1\":{\"271\":1}}],[\"使用tesseract\",{\"1\":{\"61\":1}}],[\"使用reflect\",{\"1\":{\"269\":1,\"276\":1}}],[\"使用redis的简化分布式锁定实现\",{\"1\":{\"47\":1}}],[\"使用~符号\",{\"1\":{\"259\":1}}],[\"使用起来十分的简单\",{\"1\":{\"324\":1,\"355\":1}}],[\"使用起来十分简单\",{\"1\":{\"236\":1}}],[\"使用起来如下\",{\"1\":{\"263\":1}}],[\"使用起重机a\",{\"1\":{\"212\":1}}],[\"使用close函数对其进行关闭操作会导致panic`\",{\"1\":{\"337\":1}}],[\"使用convertibleto方法可以判断一个类型是否可以被转换为另一个指定的类型\",{\"1\":{\"275\":1}}],[\"使用c\",{\"1\":{\"227\":1}}],[\"使用cgo确实可以带来好处\",{\"1\":{\"233\":1}}],[\"使用cgo还有以下缺点\",{\"1\":{\"233\":1}}],[\"使用cgo导入静态链接库时\",{\"1\":{\"232\":1}}],[\"使用cgo\",{\"1\":{\"45\":1}}],[\"使用技术b\",{\"1\":{\"212\":3}}],[\"使用技术a\",{\"1\":{\"212\":3}}],[\"使用具名返回值时\",{\"1\":{\"199\":1}}],[\"使用空格进行分隔\",{\"1\":{\"191\":1}}],[\"使用内置函数close来关闭一个管道\",{\"1\":{\"333\":1}}],[\"使用内置函数copy\",{\"1\":{\"175\":1}}],[\"使用内置函数recover\",{\"1\":{\"316\":1}}],[\"使用内置函数panic即可\",{\"1\":{\"314\":1}}],[\"使用内置os\",{\"1\":{\"57\":1}}],[\"使用拓展表达式切割的切片容量为max\",{\"1\":{\"169\":1}}],[\"使用标签\",{\"1\":{\"155\":1}}],[\"使用标签来中断外层循环\",{\"1\":{\"154\":1}}],[\"使用标签加载csv文件\",{\"1\":{\"51\":1}}],[\"使用其它进制时\",{\"1\":{\"140\":1}}],[\"使用max函数比较最大值\",{\"1\":{\"128\":1}}],[\"使用mqtt\",{\"1\":{\"47\":1}}],[\"使用gnmi和gnoi协议的网络管理工具的集合\",{\"1\":{\"64\":1}}],[\"使用go进行im开发\",{\"1\":{\"250\":1}}],[\"使用go编程语言实现的bgp\",{\"1\":{\"64\":1}}],[\"使用go\",{\"1\":{\"57\":1}}],[\"使用go和html\",{\"1\":{\"57\":1}}],[\"使用golang实现的游戏服务器框架\",{\"1\":{\"53\":1}}],[\"使用dns的go库\",{\"1\":{\"64\":1}}],[\"使用一行代码获取json值\",{\"1\":{\"60\":1}}],[\"使用常见的插值方法为go\",{\"1\":{\"58\":1}}],[\"使用libvips进行快速有效的图像处理的小包装\",{\"1\":{\"58\":1}}],[\"使用linkedhashmap的围棋设置简单的数据结构实现\",{\"1\":{\"46\":1}}],[\"使用efl呈现\",{\"1\":{\"57\":1}}],[\"使用带有简单api的轻量级库管理goroutine池\",{\"1\":{\"56\":1}}],[\"使用操作转换\",{\"1\":{\"47\":1}}],[\"使用树堆的持久快速排序的地图\",{\"1\":{\"46\":1}}],[\"使用近似计数器进行近似计数\",{\"1\":{\"46\":1}}],[\"使用\",{\"0\":{\"159\":1,\"163\":1,\"261\":1,\"358\":1},\"1\":{\"11\":1,\"74\":1,\"257\":3,\"626\":1}}],[\"使用nvm命令下载并使用node\",{\"1\":{\"10\":1}}],[\"使用前还是要卸载node\",{\"1\":{\"10\":1}}],[\"发布订阅\",{\"0\":{\"486\":1}}],[\"发布新版本\",{\"1\":{\"382\":1}}],[\"发布到postgis和geoserver\",{\"1\":{\"54\":1}}],[\"发送消息到指定频道\",{\"1\":{\"486\":1}}],[\"发送数据或读取数据\",{\"1\":{\"574\":1}}],[\"发送数据\",{\"1\":{\"337\":1,\"338\":1,\"574\":1}}],[\"发送者\",{\"1\":{\"43\":1}}],[\"发生这种情况时\",{\"1\":{\"378\":1,\"379\":1}}],[\"发生错误时\",{\"1\":{\"320\":1}}],[\"发生panic\",{\"1\":{\"316\":4}}],[\"发生panic时后续的逻辑将无法执行\",{\"1\":{\"315\":1}}],[\"矢量数据\",{\"1\":{\"54\":1}}],[\"去掉时间的单调时钟读数\",{\"1\":{\"629\":1}}],[\"去除注释真正的代码逻辑只有16行\",{\"1\":{\"353\":1}}],[\"去除utf编码中的bom\",{\"1\":{\"41\":1}}],[\"去洛谷做几道简单的acm模式算法题就能上手熟悉了\",{\"1\":{\"145\":1}}],[\"去绑定raylib\",{\"1\":{\"53\":1}}],[\"设置地区\",{\"1\":{\"629\":1}}],[\"设置\",{\"1\":{\"541\":1}}],[\"设置前缀\",{\"1\":{\"540\":1}}],[\"设置指定下标的元素的值\",{\"1\":{\"467\":1}}],[\"设置过期时间\",{\"1\":{\"449\":1}}],[\"设置键值对\",{\"1\":{\"443\":1}}],[\"设置统计n个协程竞争一个互斥锁的情况\",{\"1\":{\"388\":1}}],[\"设置覆盖率分析的模式\",{\"1\":{\"388\":1}}],[\"设置代理\",{\"0\":{\"370\":1}}],[\"设置1秒的超时时间\",{\"1\":{\"340\":1}}],[\"设置值\",{\"0\":{\"280\":1},\"1\":{\"295\":1}}],[\"设备文件\",{\"1\":{\"319\":1}}],[\"设备\",{\"1\":{\"53\":1}}],[\"设计模式\",{\"0\":{\"16\":1}}],[\"路径查找算法的go实现\",{\"1\":{\"53\":1}}],[\"路由\",{\"1\":{\"41\":1}}],[\"或运算\",{\"1\":{\"620\":1}}],[\"或者说返回值就是结构体地址起始处到字段地址起始处两者之间的字节数\",{\"1\":{\"641\":1}}],[\"或者说是用户态的线程\",{\"1\":{\"331\":1}}],[\"或者是一个类型\",{\"1\":{\"390\":1}}],[\"或者是一个包\",{\"1\":{\"390\":1}}],[\"或者可以单独指定某一个测试文件的某一个测试用例\",{\"1\":{\"387\":1}}],[\"或者可以自行查询可用的release版本号\",{\"1\":{\"372\":1}}],[\"或者example\",{\"1\":{\"386\":1}}],[\"或者使用go\",{\"1\":{\"369\":1}}],[\"或者不支持该方法\",{\"1\":{\"343\":1}}],[\"或者不用框架\",{\"1\":{\"249\":1}}],[\"或者计数数量大于子协程数量时\",{\"1\":{\"341\":1}}],[\"或者都不为空时\",{\"1\":{\"298\":1}}],[\"或者any\",{\"1\":{\"258\":1}}],[\"或者也可以手动指定模板\",{\"1\":{\"625\":1}}],[\"或者也可以直接传入当前模板的根对象\",{\"1\":{\"626\":1}}],[\"或者也可以直接使用函数\",{\"1\":{\"358\":1}}],[\"或者也可以直接看文档cgo\",{\"1\":{\"215\":1}}],[\"或者也可以使用any类型加反射来判断\",{\"1\":{\"256\":1}}],[\"或者\",{\"1\":{\"147\":1,\"444\":1}}],[\"或者这样也可以\",{\"1\":{\"125\":1}}],[\"或者包名比较复杂\",{\"1\":{\"94\":1}}],[\"或者从json字符串反序列化出一个具体的对象等\",{\"1\":{\"40\":1}}],[\"或解析响应\",{\"1\":{\"52\":1}}],[\"查询记录值\",{\"1\":{\"573\":1}}],[\"查询类型\",{\"0\":{\"453\":1}}],[\"查询过期时间\",{\"0\":{\"451\":1}}],[\"查询一个是get\",{\"1\":{\"435\":1}}],[\"查询\",{\"0\":{\"435\":1},\"1\":{\"435\":1}}],[\"查询多个\",{\"0\":{\"425\":1}}],[\"查询单个\",{\"0\":{\"424\":1}}],[\"查询文档\",{\"0\":{\"423\":1}}],[\"查询所有文档\",{\"1\":{\"415\":1}}],[\"查询该依赖包的哈希值\",{\"1\":{\"379\":1}}],[\"查询ofx服务器和\",{\"1\":{\"52\":1}}],[\"查看订阅状态\",{\"1\":{\"486\":1}}],[\"查看源代码\",{\"1\":{\"246\":1}}],[\"查看可用源\",{\"1\":{\"11\":1}}],[\"查找适合任何图像和尺寸的优质作物\",{\"1\":{\"58\":1}}],[\"债券和折旧计算\",{\"1\":{\"52\":1}}],[\"现如今的泛型就是这两者之间妥协后的产物\",{\"1\":{\"264\":1}}],[\"现有类型\",{\"1\":{\"643\":1}}],[\"现有一个函数参数是map\",{\"1\":{\"303\":1}}],[\"现有如下切片\",{\"1\":{\"165\":1}}],[\"现有切片如下\",{\"1\":{\"164\":1}}],[\"现代化的标准库\",{\"1\":{\"83\":1}}],[\"现在解析的都是简单的xml结构\",{\"1\":{\"512\":1}}],[\"现在有待测试文件\",{\"1\":{\"387\":1}}],[\"现在的输出已经是正常的顺序了\",{\"1\":{\"331\":1}}],[\"现在的接收者就是一个指针接收者\",{\"1\":{\"206\":1}}],[\"现在c中使用的sum函数实际上是go提供的\",{\"1\":{\"219\":1}}],[\"现在进行编译的话\",{\"1\":{\"218\":1}}],[\"现在得到的结果就是正常的\",{\"1\":{\"169\":1}}],[\"现在可以使用min函数比较最小值\",{\"1\":{\"128\":1}}],[\"现在仅支持中文细分\",{\"1\":{\"63\":1}}],[\"现在支持25种以上的语言\",{\"1\":{\"47\":1}}],[\"现金流量\",{\"1\":{\"52\":1}}],[\"任何类型的指针都可以转换为unsafe\",{\"1\":{\"643\":1}}],[\"任何能够产生数据的操作都称其为pipeline\",{\"1\":{\"621\":1}}],[\"任何实现了driver\",{\"1\":{\"432\":1}}],[\"任何自定义类型都可以实现接口\",{\"1\":{\"212\":1}}],[\"任意\",{\"1\":{\"140\":5}}],[\"任意精度定点十进制数字\",{\"1\":{\"52\":1}}],[\"任务和事件的库\",{\"1\":{\"47\":1}}],[\"提交一个事务\",{\"1\":{\"439\":1}}],[\"提交user模块的修改并推送到远程仓库\",{\"1\":{\"382\":1}}],[\"提交完毕后为最新提交创建一个tag\",{\"1\":{\"368\":1}}],[\"提高了开发人员的下限\",{\"1\":{\"330\":1}}],[\"提示你这个变量声明了但没有使用\",{\"1\":{\"125\":1}}],[\"提示\",{\"1\":{\"98\":1,\"115\":1,\"145\":1,\"157\":1,\"162\":1,\"169\":1,\"177\":2,\"178\":1,\"184\":1,\"186\":1,\"192\":1,\"195\":1,\"206\":1,\"208\":1,\"213\":1,\"215\":1,\"235\":1,\"246\":1,\"257\":1,\"264\":1,\"267\":1,\"272\":1,\"279\":1,\"303\":1,\"304\":1,\"306\":1,\"307\":1,\"313\":1,\"331\":1,\"336\":1,\"338\":1,\"339\":1,\"340\":1,\"341\":1,\"347\":1,\"350\":1,\"351\":1,\"354\":1,\"357\":1,\"359\":1,\"373\":1,\"378\":1,\"379\":1,\"385\":1,\"386\":1,\"387\":2,\"391\":1,\"396\":2,\"403\":1,\"404\":1,\"422\":1,\"509\":1,\"564\":1,\"575\":1,\"594\":1,\"611\":1,\"637\":1,\"643\":1}}],[\"提取器\",{\"1\":{\"63\":1}}],[\"提取尽可能多的元数据\",{\"1\":{\"51\":1}}],[\"提供可手动分配和释放内存的功能\",{\"1\":{\"508\":1}}],[\"提供可以解析多个json文档并创建适合所有json的结构的包\",{\"1\":{\"60\":1}}],[\"提供的是一系列具体的函数\",{\"1\":{\"508\":1}}],[\"提供的功能包括文件操作\",{\"1\":{\"40\":1}}],[\"提供没有类型限制的指针操作\",{\"1\":{\"508\":1}}],[\"提供文档\",{\"1\":{\"85\":1}}],[\"提供单词词干提取功能snowball本机\",{\"1\":{\"63\":1}}],[\"提供简单错误处理原语的软件包\",{\"1\":{\"50\":1}}],[\"提供各种错误处理原语\",{\"1\":{\"50\":1}}],[\"提供http\",{\"1\":{\"48\":1}}],[\"提供一系列网络操作的包\",{\"1\":{\"508\":1}}],[\"提供一系列测试目的的类型\",{\"1\":{\"43\":1}}],[\"提供一些做图函数\",{\"1\":{\"43\":1}}],[\"提供测量和显示时间的功能\",{\"1\":{\"43\":1}}],[\"提供对zip压缩文档的读和写支持\",{\"1\":{\"43\":1}}],[\"提供对自动测试go包的支持\",{\"1\":{\"43\":1}}],[\"提供对集合排序的基础函数集\",{\"1\":{\"43\":1}}],[\"提供最基本的日志功能\",{\"1\":{\"43\":1}}],[\"提供了非常完善的http客户端与服务端的实现\",{\"1\":{\"529\":1}}],[\"提供了非常简洁且高效的并发支持\",{\"1\":{\"83\":1}}],[\"提供了许多可用的方法\",{\"1\":{\"390\":1}}],[\"提供了内建的单元测试支持\",{\"1\":{\"74\":1}}],[\"提供了简洁且高效的方式来进行并发编程\",{\"1\":{\"70\":1}}],[\"提供了原生支持的轻量级线程\",{\"1\":{\"70\":1}}],[\"提供了低级的用于实现同步算法的原子级的内存机制\",{\"1\":{\"43\":1}}],[\"提供了http客户端和服务器的实现\",{\"1\":{\"43\":1}}],[\"提供了构建go包的工具\",{\"1\":{\"43\":1}}],[\"提供了实现heap\",{\"1\":{\"43\":1}}],[\"提供了基本的同步机制\",{\"1\":{\"43\":1}}],[\"提供了一套完整的内置工具链\",{\"1\":{\"74\":1}}],[\"提供了一些http应用函数\",{\"1\":{\"43\":1}}],[\"提供了一些http测试应用\",{\"1\":{\"43\":1}}],[\"提供了一些基本的常量和数学函数\",{\"1\":{\"43\":1}}],[\"提供了一个对unix网络套接字的可移植接口\",{\"1\":{\"43\":1}}],[\"提供了对导入器的访问\",{\"1\":{\"508\":1}}],[\"提供了对一个来自网络或其他i\",{\"1\":{\"43\":1}}],[\"提供了对系统日志服务的简单接口\",{\"1\":{\"43\":1}}],[\"提供了对从可执行文件加载的dwarf调试信息的访问\",{\"1\":{\"43\":1}}],[\"提供了对i\",{\"1\":{\"43\":1}}],[\"提供了对字节切片操作的函数\",{\"1\":{\"43\":1}}],[\"提供了哈希函数接口\",{\"1\":{\"43\":1}}],[\"提供字符串与基本数据类型互转的能力\",{\"1\":{\"40\":1}}],[\"云计算等等\",{\"1\":{\"254\":1}}],[\"云计算与\",{\"0\":{\"79\":1}}],[\"云计算\",{\"1\":{\"67\":1}}],[\"云\",{\"1\":{\"51\":1}}],[\"行和堆栈\",{\"1\":{\"50\":1}}],[\"错误日志\",{\"1\":{\"539\":1}}],[\"错误提示所有的协程都已经退出\",{\"1\":{\"341\":1}}],[\"错误在传递的过程中可能会层层包装\",{\"1\":{\"311\":1}}],[\"错误中没有堆栈信息\",{\"1\":{\"307\":1}}],[\"错误例子如下\",{\"1\":{\"158\":1}}],[\"错误情况\",{\"1\":{\"140\":1}}],[\"错误示例\",{\"1\":{\"108\":1,\"125\":2,\"158\":1}}],[\"错误\",{\"0\":{\"307\":1,\"655\":1},\"1\":{\"98\":1,\"311\":1}}],[\"错误包装程序为go中的错误类型创建了一个包装程序\",{\"1\":{\"50\":1}}],[\"错误组成等的功能丰富的错误包\",{\"1\":{\"50\":1}}],[\"错误处理中的最后一步就是如何处理和检查错误\",{\"1\":{\"312\":1}}],[\"错误处理机制繁琐\",{\"1\":{\"84\":1}}],[\"错误处理\",{\"0\":{\"50\":1},\"1\":{\"39\":1,\"217\":1}}],[\"与timer的区别在于\",{\"1\":{\"634\":1}}],[\"与运算\",{\"1\":{\"620\":1}}],[\"与数据库进行交互的包\",{\"1\":{\"508\":1}}],[\"与之前的区别在于test\",{\"1\":{\"391\":1}}],[\"与互斥锁一同出现和使用\",{\"1\":{\"351\":1}}],[\"与switch类似\",{\"1\":{\"340\":1}}],[\"与scan类似\",{\"1\":{\"143\":1}}],[\"与o\",{\"1\":{\"319\":1}}],[\"与rust相比之下\",{\"1\":{\"307\":1}}],[\"与reflect\",{\"1\":{\"267\":1}}],[\"与匿名函数一起使用\",{\"1\":{\"201\":1}}],[\"与格式化动词之间加上一个空格便可以达到分隔符的效果\",{\"1\":{\"140\":1}}],[\"与其他语言的比较\",{\"0\":{\"86\":1}}],[\"与\",{\"0\":{\"87\":1,\"88\":1,\"89\":1},\"1\":{\"71\":1,\"140\":1}}],[\"与cpython\",{\"1\":{\"49\":1}}],[\"与网络各层配合使用的库\",{\"1\":{\"39\":1}}],[\"非法的数据链接参数\",{\"1\":{\"314\":2}}],[\"非空接口的类型集是其所有元素的类型集的交集\",{\"1\":{\"259\":1}}],[\"非零整数也不能代表真值\",{\"1\":{\"115\":1}}],[\"非阻塞\",{\"1\":{\"64\":1}}],[\"非常好理解\",{\"1\":{\"623\":1}}],[\"非常多\",{\"1\":{\"509\":1}}],[\"非常规文件\",{\"1\":{\"319\":1}}],[\"非常致命的问题\",{\"1\":{\"307\":1}}],[\"非常快的porter\",{\"1\":{\"63\":1}}],[\"非常快的go\",{\"1\":{\"46\":1}}],[\"非常容易被docker和heroku部署\",{\"1\":{\"61\":1}}],[\"非图灵完整表达评估\",{\"1\":{\"49\":1}}],[\"容量100的整型切片\",{\"1\":{\"196\":1}}],[\"容量不足\",{\"1\":{\"169\":1}}],[\"容量为10的映射表\",{\"1\":{\"196\":1}}],[\"容量为原来的2倍\",{\"1\":{\"163\":1}}],[\"容量为0的空切片\",{\"1\":{\"163\":1}}],[\"容量超过\",{\"1\":{\"163\":1}}],[\"容量变成原来的1\",{\"1\":{\"163\":1}}],[\"容量变成原来的\",{\"1\":{\"163\":1}}],[\"容量小于\",{\"1\":{\"163\":1}}],[\"容量\",{\"1\":{\"162\":1}}],[\"容量对于切片才有意义\",{\"1\":{\"159\":1}}],[\"容错应用程序层分片\",{\"1\":{\"47\":1}}],[\"容错消息流\",{\"1\":{\"47\":1}}],[\"容器化平台\",{\"1\":{\"85\":1}}],[\"容器\",{\"1\":{\"46\":1}}],[\"013496401\",{\"1\":{\"635\":1}}],[\"016742001\",{\"1\":{\"634\":1}}],[\"017790301\",{\"1\":{\"634\":1}}],[\"01\",{\"1\":{\"631\":2,\"632\":1}}],[\"0123i\",{\"1\":{\"102\":1}}],[\"0+0i\",{\"1\":{\"591\":1}}],[\"0+1\",{\"1\":{\"127\":1}}],[\"0db8\",{\"1\":{\"569\":1}}],[\"0就是永不过期\",{\"1\":{\"443\":1}}],[\"08\",{\"1\":{\"404\":1}}],[\"0s\",{\"1\":{\"396\":6}}],[\"05t10\",{\"1\":{\"404\":1}}],[\"05就不太可信\",{\"1\":{\"395\":1}}],[\"05\",{\"1\":{\"395\":1,\"404\":1,\"631\":2}}],[\"0µ\",{\"1\":{\"395\":1}}],[\"0m\",{\"1\":{\"395\":2}}],[\"03\",{\"1\":{\"633\":1}}],[\"0370\",{\"1\":{\"569\":1}}],[\"037s\",{\"1\":{\"390\":1}}],[\"033s\",{\"1\":{\"396\":1}}],[\"038s\",{\"1\":{\"387\":1}}],[\"0并不存在\",{\"1\":{\"378\":1}}],[\"079\",{\"1\":{\"395\":1}}],[\"0755\",{\"1\":{\"329\":1}}],[\"072\",{\"1\":{\"101\":1}}],[\"0时\",{\"1\":{\"327\":1}}],[\"0666\",{\"1\":{\"319\":1,\"320\":2,\"321\":4,\"322\":5,\"328\":1}}],[\"040s\",{\"1\":{\"387\":1}}],[\"04\",{\"1\":{\"247\":3,\"395\":1,\"407\":1,\"631\":2}}],[\"0不能作为被除数\",{\"1\":{\"199\":1}}],[\"09\",{\"1\":{\"407\":1,\"633\":1,\"634\":3,\"635\":2}}],[\"099a8bf\",{\"1\":{\"368\":2}}],[\"09b\",{\"1\":{\"140\":1}}],[\"09d\",{\"1\":{\"140\":1}}],[\"001627901\",{\"1\":{\"635\":1}}],[\"009508401\",{\"1\":{\"634\":1}}],[\"00i\",{\"1\":{\"592\":1}}],[\"008\",{\"1\":{\"395\":7}}],[\"00s\",{\"1\":{\"366\":1,\"387\":3,\"389\":3,\"390\":8,\"391\":2,\"392\":10,\"396\":8,\"546\":1,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"596\":1,\"597\":1,\"598\":3,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"613\":1}}],[\"00\",{\"1\":{\"188\":1,\"347\":1,\"395\":9,\"567\":1,\"629\":1,\"632\":3}}],[\"007908001\",{\"1\":{\"633\":1}}],[\"007095001\",{\"1\":{\"629\":1}}],[\"007\",{\"1\":{\"103\":1}}],[\"0000\",{\"1\":{\"569\":2}}],[\"000001000\",{\"1\":{\"140\":1}}],[\"000000001\",{\"1\":{\"140\":1}}],[\"000\",{\"1\":{\"93\":1,\"100\":2,\"103\":1,\"233\":1,\"394\":2,\"395\":6}}],[\"0o777\",{\"1\":{\"319\":1}}],[\"0o123\",{\"1\":{\"102\":1}}],[\"0o123i\",{\"1\":{\"102\":1}}],[\"0o24\",{\"1\":{\"100\":1}}],[\"0i\",{\"1\":{\"102\":1}}],[\"0xd\",{\"1\":{\"590\":2}}],[\"0xc00010e4b0\",{\"1\":{\"279\":4}}],[\"0xc00005e5e0\",{\"1\":{\"596\":1}}],[\"0xc00005e5d0\",{\"1\":{\"596\":1}}],[\"0xc0000a6058\",{\"1\":{\"279\":5}}],[\"0xc00007a7b0\",{\"1\":{\"213\":1}}],[\"0xc0000080d8\",{\"1\":{\"213\":1}}],[\"0xc00001c088\",{\"1\":{\"194\":1,\"643\":2}}],[\"0xe69720\",{\"1\":{\"213\":1}}],[\"0xe61a00\",{\"1\":{\"213\":1}}],[\"0xe62e00\",{\"1\":{\"213\":1}}],[\"0xe62ac0\",{\"1\":{\"213\":1}}],[\"0xe63d80\",{\"1\":{\"213\":1}}],[\"0xe63580\",{\"1\":{\"213\":1}}],[\"0xeb8b00\",{\"1\":{\"213\":1}}],[\"0xeb8b08\",{\"1\":{\"213\":1}}],[\"0xeb8c58\",{\"1\":{\"213\":1}}],[\"0xeb8c48\",{\"1\":{\"213\":1}}],[\"0xe27bb2\",{\"1\":{\"173\":2}}],[\"0x31d99ff884\",{\"1\":{\"195\":2}}],[\"0x31d99ff880\",{\"1\":{\"195\":2}}],[\"0xabc\",{\"1\":{\"102\":1}}],[\"0xabci\",{\"1\":{\"102\":1}}],[\"0x\",{\"1\":{\"101\":2,\"643\":1}}],[\"0x1dd043b6e30\",{\"1\":{\"226\":1}}],[\"0x10ffff之间\",{\"1\":{\"177\":1}}],[\"0x15e\",{\"1\":{\"101\":2}}],[\"0x1\",{\"1\":{\"101\":1,\"590\":1}}],[\"0x1p1023\",{\"1\":{\"544\":1}}],[\"0x1p127\",{\"1\":{\"544\":1}}],[\"0x1p\",{\"1\":{\"101\":1,\"102\":2,\"544\":6}}],[\"0x2\",{\"1\":{\"101\":1}}],[\"0x0\",{\"1\":{\"100\":1}}],[\"0x00\",{\"1\":{\"100\":1}}],[\"0b00\",{\"1\":{\"100\":1}}],[\"023s\",{\"1\":{\"366\":1}}],[\"024\",{\"1\":{\"100\":1}}],[\"02\",{\"1\":{\"64\":1,\"631\":2,\"632\":1}}],[\"0读取器\",{\"1\":{\"58\":1}}],[\"0\",{\"1\":{\"47\":2,\"100\":5,\"101\":9,\"102\":2,\"111\":1,\"121\":1,\"127\":2,\"131\":3,\"140\":1,\"148\":2,\"149\":6,\"152\":2,\"154\":7,\"155\":26,\"159\":2,\"160\":8,\"162\":2,\"163\":2,\"164\":2,\"165\":1,\"166\":13,\"167\":1,\"168\":76,\"170\":6,\"172\":4,\"174\":3,\"177\":5,\"178\":2,\"179\":5,\"181\":2,\"182\":2,\"184\":2,\"185\":3,\"188\":2,\"193\":1,\"194\":6,\"195\":3,\"199\":1,\"200\":4,\"201\":3,\"202\":2,\"203\":1,\"204\":2,\"206\":3,\"217\":4,\"225\":37,\"227\":8,\"228\":1,\"233\":1,\"237\":6,\"238\":5,\"241\":1,\"242\":2,\"243\":2,\"245\":10,\"246\":8,\"247\":4,\"257\":1,\"262\":4,\"263\":15,\"272\":4,\"283\":2,\"286\":3,\"287\":6,\"289\":6,\"293\":2,\"294\":2,\"296\":1,\"302\":2,\"304\":4,\"309\":2,\"314\":3,\"317\":1,\"319\":10,\"320\":2,\"321\":2,\"331\":8,\"336\":5,\"339\":7,\"340\":5,\"341\":2,\"348\":2,\"349\":2,\"350\":7,\"351\":3,\"353\":7,\"354\":2,\"355\":6,\"356\":2,\"364\":4,\"366\":2,\"368\":13,\"369\":4,\"372\":39,\"373\":16,\"376\":12,\"378\":37,\"379\":9,\"381\":1,\"384\":2,\"387\":7,\"389\":4,\"390\":11,\"391\":3,\"392\":13,\"394\":4,\"395\":9,\"396\":23,\"404\":4,\"408\":2,\"411\":2,\"412\":1,\"413\":1,\"414\":1,\"415\":1,\"427\":2,\"433\":2,\"434\":2,\"435\":2,\"437\":1,\"438\":1,\"443\":2,\"445\":1,\"448\":1,\"449\":1,\"454\":1,\"456\":1,\"458\":1,\"465\":1,\"467\":1,\"469\":1,\"470\":3,\"478\":1,\"482\":1,\"485\":2,\"512\":1,\"513\":2,\"515\":2,\"521\":1,\"536\":5,\"543\":1,\"545\":1,\"546\":3,\"547\":3,\"548\":1,\"549\":1,\"550\":1,\"551\":2,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":2,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":3,\"562\":4,\"563\":3,\"564\":3,\"568\":1,\"570\":4,\"571\":4,\"574\":8,\"577\":1,\"579\":1,\"584\":1,\"585\":1,\"586\":2,\"587\":1,\"588\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"596\":1,\"597\":2,\"598\":3,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"613\":1,\"620\":1,\"624\":1,\"634\":1,\"640\":2,\"641\":1,\"643\":1,\"644\":1,\"645\":5,\"646\":1,\"647\":2}}],[\"0解析器\",{\"1\":{\"43\":1}}],[\"支持的命令行参数格式有如下几种\",{\"1\":{\"526\":1}}],[\"支持网络\",{\"1\":{\"441\":1}}],[\"支持多行书写\",{\"1\":{\"171\":1}}],[\"支持转义\",{\"1\":{\"171\":1}}],[\"支持包括\",{\"1\":{\"72\":1}}],[\"支持84种语言和24种脚本\",{\"1\":{\"63\":1}}],[\"支持标记化\",{\"1\":{\"63\":1}}],[\"支持lsa\",{\"1\":{\"63\":1}}],[\"支持英语\",{\"1\":{\"63\":1}}],[\"支持windows\",{\"1\":{\"57\":1}}],[\"支持\",{\"1\":{\"57\":2,\"65\":1,\"84\":1}}],[\"支持golang的读写锁的trylock\",{\"1\":{\"56\":1}}],[\"支持使用http\",{\"1\":{\"51\":1}}],[\"支持在retro中编写脚本\",{\"1\":{\"49\":1}}],[\"支持服务发现\",{\"1\":{\"47\":1}}],[\"支持flac流的native\",{\"1\":{\"45\":1}}],[\"一些详细的配置请自行了解\",{\"1\":{\"536\":1}}],[\"一些详细的配置这里不会做过多的赘述\",{\"1\":{\"534\":1}}],[\"一目了然\",{\"1\":{\"513\":1}}],[\"一对键值\",{\"1\":{\"422\":2}}],[\"一下写了5个\",{\"1\":{\"336\":1}}],[\"一点也没有\",{\"1\":{\"331\":1}}],[\"一旦样本多了起来人工分析就会十分的费时费力\",{\"1\":{\"395\":1}}],[\"一旦加锁以后就必须保证不变量的不变性\",{\"1\":{\"348\":1}}],[\"一旦管道缓冲区空了或者满了\",{\"1\":{\"336\":1}}],[\"一旦主线程退出\",{\"1\":{\"331\":1}}],[\"一旦赋值过后就无法修改\",{\"1\":{\"129\":1}}],[\"一定要释放回池中\",{\"1\":{\"354\":1}}],[\"一定要记得关闭文件\",{\"1\":{\"329\":1}}],[\"一定会觉得很熟悉\",{\"1\":{\"140\":1}}],[\"一类是没有方法集的接口\",{\"1\":{\"266\":1}}],[\"一样会造成上下文泄露\",{\"1\":{\"347\":1}}],[\"一样\",{\"1\":{\"222\":1,\"229\":1}}],[\"一组被版本标记的包集合\",{\"1\":{\"374\":1}}],[\"一组类型的集合\",{\"1\":{\"208\":1}}],[\"一组方法的集合\",{\"1\":{\"208\":1}}],[\"一是将指针接收者改为值接收者\",{\"1\":{\"206\":1}}],[\"一般是结构体或者map\",{\"1\":{\"617\":1}}],[\"一般情况使用前者即可\",{\"1\":{\"614\":1}}],[\"一般情况下\",{\"1\":{\"379\":1,\"532\":1}}],[\"一般情况下可以使用\",{\"1\":{\"176\":1}}],[\"一般简称dsn\",{\"1\":{\"433\":1}}],[\"一般不建议这么做\",{\"1\":{\"379\":1}}],[\"一般不推荐使用\",{\"1\":{\"137\":1,\"142\":1}}],[\"一般会在函数的形参和返回值中出现\",{\"1\":{\"338\":1}}],[\"一般会比较推荐使用官方的另一个增强包\",{\"1\":{\"312\":1}}],[\"一般都不会临时创建error\",{\"1\":{\"309\":1}}],[\"一般都是在括号中使用\",{\"1\":{\"131\":1}}],[\"一般就分配到栈上和堆上这两个地方\",{\"1\":{\"235\":1}}],[\"一般建议不要在for循环中使用defer\",{\"1\":{\"203\":1}}],[\"一般这种是在接口或函数类型声明时才会用到\",{\"1\":{\"198\":1}}],[\"一般来说\",{\"1\":{\"177\":1}}],[\"一般在go中\",{\"1\":{\"132\":1}}],[\"一切都会被优化\",{\"1\":{\"61\":1}}],[\"一种类似json的结构\",{\"1\":{\"418\":1}}],[\"一种是通过索引来进行访问\",{\"1\":{\"286\":1}}],[\"一种是通过func关键字直接声明\",{\"1\":{\"197\":1}}],[\"一种解决办法就是再定义一个新的函数\",{\"1\":{\"256\":1}}],[\"一种用于不同\",{\"1\":{\"70\":1}}],[\"一种由\",{\"1\":{\"70\":1}}],[\"一种异步执行功能的安全方法\",{\"1\":{\"56\":1}}],[\"一种软件包\",{\"1\":{\"51\":1}}],[\"一个模板中可以定义有多个模板\",{\"1\":{\"625\":1}}],[\"一个例子如下\",{\"1\":{\"404\":1}}],[\"一个轮次完成后已经流逝的时间\",{\"1\":{\"396\":1}}],[\"一个完整的go\",{\"1\":{\"384\":1}}],[\"一个go\",{\"1\":{\"378\":1}}],[\"一个全球代理\",{\"1\":{\"370\":1}}],[\"一个好的依赖管理工具可以为开发者省去不少时间并且可以提升开发效率\",{\"1\":{\"361\":1}}],[\"一个有缓冲管道用于协程间通信\",{\"1\":{\"336\":1}}],[\"一个布尔类型的值\",{\"1\":{\"334\":1}}],[\"一个关闭管道的例子如下\",{\"1\":{\"333\":1}}],[\"一个只写\",{\"1\":{\"322\":1}}],[\"一个只读\",{\"1\":{\"322\":1}}],[\"一个建筑公司想一种特殊规格的起重机\",{\"1\":{\"212\":1}}],[\"一个是类型转换过后的值\",{\"1\":{\"305\":1}}],[\"一个是切片\",{\"1\":{\"200\":1}}],[\"一个是取地址符\",{\"1\":{\"194\":1}}],[\"一个空的结构体不会占用内存\",{\"1\":{\"184\":1}}],[\"一个中文字符会占用3个字节\",{\"1\":{\"177\":1}}],[\"一个英文字符只占一个字节\",{\"1\":{\"174\":1}}],[\"一个汉字在大多数情况下占3个字节\",{\"1\":{\"174\":1}}],[\"一个根据成绩打分的例子如下\",{\"1\":{\"148\":1}}],[\"一个变量如果只是声明而不赋值\",{\"1\":{\"124\":1}}],[\"一个没有参数\",{\"1\":{\"120\":1}}],[\"一个整型指针\",{\"1\":{\"120\":1}}],[\"一个包内名为internal\",{\"1\":{\"95\":1}}],[\"一个简单的文件夹复制的代码示例如下\",{\"1\":{\"329\":1}}],[\"一个简单的例子如下\",{\"1\":{\"149\":1}}],[\"一个简单的ocr\",{\"1\":{\"61\":1}}],[\"一个简单而轻便的阅读器\",{\"1\":{\"62\":1}}],[\"一个简单但功能强大的错误处理软件包\",{\"1\":{\"50\":1}}],[\"一个小型\",{\"1\":{\"46\":1}}],[\"一致性哈希函数的端口\",{\"1\":{\"47\":1}}],[\"用起来跟http\",{\"1\":{\"416\":1}}],[\"用起来跟c差不多\",{\"1\":{\"143\":1}}],[\"用户\",{\"1\":{\"378\":1}}],[\"用户定义代码区域的相关协程信息\",{\"1\":{\"247\":1}}],[\"用户定义任务的相关协程信息\",{\"1\":{\"247\":1}}],[\"用完之后再释放对象\",{\"1\":{\"354\":1}}],[\"用指定的权限创建指定名称的目录\",{\"1\":{\"328\":1}}],[\"用web\",{\"1\":{\"245\":1}}],[\"用malloc\",{\"1\":{\"229\":1}}],[\"用下划线可以表示不需要某一个变量\",{\"1\":{\"126\":1}}],[\"用纯围棋轻便\",{\"1\":{\"64\":1}}],[\"用纯围棋和luajit快速和可扩展的分布式的map\",{\"1\":{\"47\":1}}],[\"用纯go语言编写的jp形态分析仪\",{\"1\":{\"63\":1}}],[\"用纯go语言编写\",{\"1\":{\"61\":1}}],[\"用go自带的原生http标准库\",{\"1\":{\"249\":1}}],[\"用go\",{\"1\":{\"61\":1}}],[\"用go语言编写的神经网络\",{\"1\":{\"61\":1}}],[\"用go语言编写的路径跟踪引擎\",{\"1\":{\"58\":1}}],[\"用go语言编写的2d游戏引擎\",{\"1\":{\"53\":1}}],[\"用go语言编写的3d游戏引擎\",{\"1\":{\"53\":1}}],[\"用go语言编写的可编写脚本的解释器\",{\"1\":{\"49\":1}}],[\"用go编写的linux视频捕获库\",{\"1\":{\"65\":1}}],[\"用go编写的lua\",{\"1\":{\"49\":1}}],[\"用go编写的推荐算法库\",{\"1\":{\"61\":1}}],[\"用go编写的深度神经网络库\",{\"1\":{\"61\":1}}],[\"用go编写的json\",{\"1\":{\"60\":1}}],[\"用go编写的javascript解释器\",{\"1\":{\"49\":1}}],[\"用go编写的图像大小调整服务器\",{\"1\":{\"58\":1}}],[\"用go编写的存储和图像处理服务器\",{\"1\":{\"58\":1}}],[\"用go编写的高度可定制的表达语言\",{\"1\":{\"49\":1}}],[\"用go编写的smtp服务器\",{\"1\":{\"48\":1}}],[\"用于记录函数的映射\",{\"1\":{\"620\":1}}],[\"用于记录该依赖已知的版本号\",{\"1\":{\"379\":1}}],[\"用于比较是否相等的函数eq函数\",{\"1\":{\"620\":1}}],[\"用于获取操作系统的用户信息\",{\"1\":{\"508\":1}}],[\"用于监听操作系统的信号\",{\"1\":{\"508\":1}}],[\"用于格式化输出测试失败的日志信息\",{\"1\":{\"390\":1}}],[\"用于删除项目模块依赖缓存\",{\"1\":{\"375\":1}}],[\"用于计数过程中总共创建了多少个对象\",{\"1\":{\"354\":1}}],[\"用于对象池在申请不到对象时初始化一个对象\",{\"1\":{\"354\":1}}],[\"用于判断操作是否已经执行\",{\"1\":{\"353\":1}}],[\"用于表示测试完毕\",{\"1\":{\"390\":1}}],[\"用于表示上下关闭的原因\",{\"1\":{\"343\":1}}],[\"用于表示数据是否读取成功\",{\"1\":{\"334\":1}}],[\"用于返回其内部对于原error的引用\",{\"1\":{\"311\":1}}],[\"用于输出错误信息\",{\"1\":{\"308\":1}}],[\"用于存放死的指针地址\",{\"1\":{\"116\":1}}],[\"用于包命名\",{\"1\":{\"97\":1}}],[\"用于声明一个函数\",{\"1\":{\"91\":1}}],[\"用于自动化部署\",{\"1\":{\"85\":1}}],[\"用于更快地构建tcp服务器的go库\",{\"1\":{\"64\":1}}],[\"用于快速开发云和裸机\",{\"1\":{\"64\":1}}],[\"用于快速编写tcp应用程序的go软件包\",{\"1\":{\"64\":1}}],[\"用于检索多个网络设备的配置\",{\"1\":{\"64\":1}}],[\"用于执行操作系统命令\",{\"1\":{\"508\":1}}],[\"用于执行snmp操作的本机go库\",{\"1\":{\"64\":1}}],[\"用于执行unicode标准附件\",{\"1\":{\"63\":1}}],[\"用于发送和接收以太网帧的跨平台go软件包\",{\"1\":{\"64\":1}}],[\"用于发送电子邮件\",{\"1\":{\"48\":1}}],[\"用于基于n\",{\"1\":{\"63\":1}}],[\"用于文本处理的库\",{\"1\":{\"63\":1}}],[\"用于word2vec嵌入的阅读器和实用程序功能\",{\"1\":{\"63\":1}}],[\"用于简化在go程序中读取microsoft\",{\"1\":{\"62\":1}}],[\"用于编写xlsx\",{\"1\":{\"62\":1}}],[\"用于创建和处理office\",{\"1\":{\"62\":1}}],[\"用于创建json对象的小型实用程序\",{\"1\":{\"60\":1}}],[\"用于增强拓扑神经演化\",{\"1\":{\"61\":1}}],[\"用于pmml的go\",{\"1\":{\"61\":1}}],[\"用于portaudio音频i\",{\"1\":{\"45\":1}}],[\"用于纯go中的机器学习\",{\"1\":{\"61\":1}}],[\"用于json文档的任意转换的api\",{\"1\":{\"60\":1}}],[\"用于将操作系统中缓存的io写入落实到磁盘上\",{\"1\":{\"325\":1}}],[\"用于将自定义结构编组为hal兼容的json响应\",{\"1\":{\"60\":1}}],[\"用于将错误列表表示为单个错误\",{\"1\":{\"50\":1}}],[\"用于物联网的轻量级流处理引擎\",{\"1\":{\"59\":1}}],[\"用于跟踪连接的设备\",{\"1\":{\"59\":1}}],[\"用于svg生成的go语言库\",{\"1\":{\"58\":1}}],[\"用于lsb隐写术的go工具\",{\"1\":{\"58\":1}}],[\"用于lsb隐写术的pure\",{\"1\":{\"58\":1}}],[\"用于mpo\",{\"1\":{\"58\":1}}],[\"用于图像处理\",{\"1\":{\"58\":1}}],[\"用于图像大小调整的快速\",{\"1\":{\"58\":1}}],[\"用于生成有趣头像的库和cmd工具\",{\"1\":{\"58\":1}}],[\"用于生成类似html的文本输出格式\",{\"1\":{\"43\":1}}],[\"用于opencv的绑定\",{\"1\":{\"58\":1}}],[\"用于cairo图形库的绑定\",{\"1\":{\"58\":1}}],[\"用于collada文件格式\",{\"1\":{\"53\":1}}],[\"用于通知取消的原因\",{\"1\":{\"346\":1}}],[\"用于通知计算机上的任何\",{\"1\":{\"57\":1}}],[\"用于通过tcp\",{\"1\":{\"64\":1}}],[\"用于通过geoserver\",{\"1\":{\"54\":1}}],[\"用于现代桌面ui开发的可嵌入html\",{\"1\":{\"57\":1}}],[\"用于管理文件下载的软件包\",{\"1\":{\"64\":1}}],[\"用于管理闭包和回调的执行\",{\"1\":{\"56\":1}}],[\"用于管理和使用goroutines的工具\",{\"1\":{\"39\":1}}],[\"用于go编程语言的stemmer软件包\",{\"1\":{\"63\":1}}],[\"用于go语言编写的黑盒函数的贝叶斯优化框架\",{\"1\":{\"61\":1}}],[\"用于golang的cyclicbarrier\",{\"1\":{\"56\":1}}],[\"用于golang的高性能goroutine池\",{\"1\":{\"56\":1}}],[\"用于go的通用机器学习库\",{\"1\":{\"61\":1}}],[\"用于go的高性能\",{\"1\":{\"60\":1}}],[\"用于go的面向性能的2d\",{\"1\":{\"53\":1}}],[\"用于go的字节码编译脚本语言\",{\"1\":{\"49\":1}}],[\"用于go的强大而灵活的电子邮件库\",{\"1\":{\"48\":1}}],[\"用于go的快速\",{\"1\":{\"45\":1}}],[\"用于go的libsamplerate绑定\",{\"1\":{\"45\":1}}],[\"用于go的libsox绑定\",{\"1\":{\"45\":1}}],[\"用于go的libmediainfo绑定\",{\"1\":{\"45\":1}}],[\"用于读取器\",{\"1\":{\"64\":1}}],[\"用于读取\",{\"1\":{\"54\":1}}],[\"用于货币时间价值\",{\"1\":{\"52\":1}}],[\"用于从文件\",{\"1\":{\"51\":1}}],[\"用于确定错误的负责任的源代码\",{\"1\":{\"50\":1}}],[\"用于使用udp多播的跨平台本地对等发现\",{\"1\":{\"64\":1}}],[\"用于使用url从各种来源下载文件或目录\",{\"1\":{\"64\":1}}],[\"用于使用libpcap绑定进行数据包处理\",{\"1\":{\"64\":1}}],[\"用于使用mailgun\",{\"1\":{\"48\":1}}],[\"用于使用tendermint共识和区块链协议将以任何编程语言编写的状态机转换为拜占庭容错复制状态机\",{\"1\":{\"47\":1}}],[\"用于客户端和服务器的imap库\",{\"1\":{\"48\":1}}],[\"用于签名和验证电子邮件\",{\"1\":{\"48\":1}}],[\"用于构建\",{\"1\":{\"85\":1}}],[\"用于构建ssh服务器的高级api\",{\"1\":{\"64\":1}}],[\"用于构建rest\",{\"1\":{\"47\":1}}],[\"用于构建gui应用程序的库\",{\"1\":{\"39\":1}}],[\"用于微服务\",{\"1\":{\"47\":1}}],[\"用于在命令行进行美观的输出\",{\"1\":{\"254\":1}}],[\"用于在主机操作系统的任务栏中放置一个图标\",{\"1\":{\"57\":1}}],[\"用于在通知区域中放置图标和菜单\",{\"1\":{\"57\":1}}],[\"用于在http服务之间进行无主p2p自动发现和rpc的库\",{\"1\":{\"47\":1}}],[\"用于在服务中启用异步依赖项运行状况检查的库\",{\"1\":{\"47\":1}}],[\"用于在go中添加支持以交互和监视celery工作者\",{\"1\":{\"47\":1}}],[\"用于在空间填充曲线\",{\"1\":{\"46\":1}}],[\"用于解析类似json的日志的工具\",{\"1\":{\"46\":1}}],[\"用于信息检索的多字符串模式匹配算法\",{\"1\":{\"46\":1}}],[\"用于btoa工具和adobe\",{\"1\":{\"43\":1}}],[\"用于处理格式化输入输出的包\",{\"1\":{\"508\":1}}],[\"用于处理离散概率分布的实用程序和其他可用于执行nlp工作的工具\",{\"1\":{\"63\":1}}],[\"用于处理本地化文本的软件包和一个随附工具\",{\"1\":{\"63\":1}}],[\"用于处理常见的http\",{\"1\":{\"60\":1}}],[\"用于处理连续无界流的概率数据结构\",{\"1\":{\"46\":1}}],[\"用于处理标准midi文件\",{\"1\":{\"45\":1}}],[\"用于处理视频的库\",{\"1\":{\"39\":1}}],[\"用于处理json的库\",{\"1\":{\"39\":1}}],[\"用于处理图像的库\",{\"1\":{\"39\":1}}],[\"映射表其中之一\",{\"1\":{\"271\":1}}],[\"映射表数据结构实现通常有两种\",{\"1\":{\"177\":1}}],[\"映射表\",{\"1\":{\"120\":1,\"121\":1,\"153\":1,\"196\":1,\"298\":1}}],[\"映射\",{\"1\":{\"46\":1}}],[\"值的类型约束为v\",{\"1\":{\"257\":1}}],[\"值是否相等\",{\"1\":{\"213\":2}}],[\"值接收者和指针接收者也是同样的道理\",{\"1\":{\"206\":1}}],[\"值接收者和指针接收者\",{\"1\":{\"205\":1}}],[\"值接收者\",{\"0\":{\"205\":1}}],[\"值得一提的是\",{\"1\":{\"182\":1,\"198\":1}}],[\"值\",{\"0\":{\"276\":1},\"1\":{\"162\":3}}],[\"值为整型的映射表\",{\"1\":{\"120\":1}}],[\"值就是\",{\"1\":{\"99\":1}}],[\"值就是什么\",{\"1\":{\"99\":1}}],[\"值对的地图\",{\"1\":{\"46\":1}}],[\"值存储\",{\"1\":{\"46\":1}}],[\"实际操作\",{\"1\":{\"406\":1}}],[\"实际上该类型并不属于unsafe包\",{\"1\":{\"638\":1,\"639\":1}}],[\"实际上并没有这个语法限制\",{\"1\":{\"617\":1}}],[\"实际上执行的是vcs命令\",{\"1\":{\"362\":1}}],[\"实际上是同一个引用\",{\"1\":{\"351\":1}}],[\"实际声明的构造函数签名如下\",{\"1\":{\"188\":1}}],[\"实线代表着直接调用\",{\"1\":{\"246\":1}}],[\"实例化\",{\"0\":{\"187\":1}}],[\"实施rfc\",{\"1\":{\"64\":1}}],[\"实施压缩位集的软件包\",{\"1\":{\"46\":1}}],[\"实验性ftp服务器框架\",{\"1\":{\"64\":1}}],[\"实时和rpc\",{\"1\":{\"47\":1}}],[\"实现与基本数据类型的字符串表示形式之间的转换\",{\"1\":{\"582\":1}}],[\"实现的方法都是返回零值\",{\"1\":{\"344\":1}}],[\"实现一个接口不需要implements关键字显式的去指定要实现哪一个接口\",{\"1\":{\"212\":1}}],[\"实现\",{\"0\":{\"212\":1}}],[\"实现stringer接口即可\",{\"1\":{\"132\":1}}],[\"实现位集的go包\",{\"1\":{\"46\":1}}],[\"实现对tar压缩文档的访问\",{\"1\":{\"43\":1}}],[\"实现了基本的方法\",{\"1\":{\"537\":1}}],[\"实现了支持以utf\",{\"1\":{\"43\":1}}],[\"实现了utf\",{\"1\":{\"43\":1}}],[\"实现了用于黑箱测试的实用函数\",{\"1\":{\"43\":1}}],[\"实现了以与目标操作系统定义文件路径相兼容的方式处理文件名路径\",{\"1\":{\"43\":1}}],[\"实现了fastcgi协议\",{\"1\":{\"43\":1}}],[\"实现了fips\",{\"1\":{\"43\":4}}],[\"实现了伪随机数生成器\",{\"1\":{\"43\":1}}],[\"实现了多精度的算术运算\",{\"1\":{\"43\":1}}],[\"实现了glenn\",{\"1\":{\"43\":1}}],[\"实现了64位的循环冗余校验或crc\",{\"1\":{\"43\":1}}],[\"实现了32位的循环冗余校验或crc\",{\"1\":{\"43\":1}}],[\"实现了pem\",{\"1\":{\"43\":1}}],[\"实现了pkcs\",{\"1\":{\"43\":1}}],[\"实现了定义于rfc\",{\"1\":{\"43\":3}}],[\"实现了十六进制的编码和解码\",{\"1\":{\"43\":1}}],[\"实现了在http\",{\"1\":{\"43\":1}}],[\"实现了在rfc\",{\"1\":{\"43\":1}}],[\"实现了在无符号整数值和字节串之间的转化\",{\"1\":{\"43\":1}}],[\"实现了在基本数据类型和字符串之间的转换\",{\"1\":{\"43\":1}}],[\"实现了解析der编码的asn\",{\"1\":{\"43\":1}}],[\"实现了adler\",{\"1\":{\"43\":1}}],[\"实现了ascii85数据编码\",{\"1\":{\"43\":1}}],[\"实现了aes加密\",{\"1\":{\"43\":1}}],[\"实现了reader和writer标准接口\",{\"1\":{\"43\":1}}],[\"实现了rc4加密\",{\"1\":{\"43\":1}}],[\"实现了rfc\",{\"1\":{\"43\":7}}],[\"实现了键控哈希消息身份验证码\",{\"1\":{\"43\":1}}],[\"实现了素数域上几个标准的椭圆曲线\",{\"1\":{\"43\":1}}],[\"实现了数据加密标准\",{\"1\":{\"43\":1}}],[\"实现了标准的密码块模式\",{\"1\":{\"43\":1}}],[\"实现了对邮件消息的解析\",{\"1\":{\"43\":1}}],[\"实现了对ast\",{\"1\":{\"43\":1}}],[\"实现了对pe\",{\"1\":{\"43\":1}}],[\"实现了对mach\",{\"1\":{\"43\":1}}],[\"实现了对elf对象文件的访问\",{\"1\":{\"43\":1}}],[\"实现了对循环链表的操作\",{\"1\":{\"43\":1}}],[\"实现了对斜线分割的文件名路径的操作\",{\"1\":{\"43\":1}}],[\"实现了\",{\"1\":{\"43\":1}}],[\"实现了bzip2解压缩\",{\"1\":{\"43\":1}}],[\"实现了操作字符串的简单函数\",{\"1\":{\"43\":1}}],[\"实现了操作错误的函数\",{\"1\":{\"43\":1}}],[\"实现了运行时反射\",{\"1\":{\"43\":1}}],[\"实现了部分的mime规范\",{\"1\":{\"43\":1}}],[\"实现了一些实用的i\",{\"1\":{\"43\":1}}],[\"实现了一些有用的加密函数\",{\"1\":{\"43\":1}}],[\"实现了一个写筛选器\",{\"1\":{\"43\":1}}],[\"实现了一个png图像解码器和编码器\",{\"1\":{\"43\":1}}],[\"实现了一个jpeg图像解码器和编码器\",{\"1\":{\"43\":1}}],[\"实现了一个gif图像解码器\",{\"1\":{\"43\":1}}],[\"实现了一个go源代码文本的扫描器\",{\"1\":{\"43\":1}}],[\"实现了一个go源文件解析器\",{\"1\":{\"43\":1}}],[\"实现了一个基本的颜色库\",{\"1\":{\"43\":1}}],[\"实现了一个基本的二维图像库\",{\"1\":{\"43\":1}}],[\"实现了一个简单的可理解xml名字空间的xml\",{\"1\":{\"43\":1}}],[\"实现了一个简单的正则表达式库\",{\"1\":{\"43\":1}}],[\"实现了一个加密安全的伪随机数生成器\",{\"1\":{\"43\":1}}],[\"实现了一个双链表\",{\"1\":{\"43\":1}}],[\"实现了一个html5兼容的分词器和解析器\",{\"1\":{\"43\":1}}],[\"实现了一系列非平台相关的io相关接口和实现\",{\"1\":{\"40\":1}}],[\"实现了格式化输入输出\",{\"1\":{\"43\":1}}],[\"实现了命令行标记解析\",{\"1\":{\"43\":1}}],[\"实现格式化的输入输出操作\",{\"1\":{\"40\":1}}],[\"实现电子邮件创建和发送的库和工具\",{\"1\":{\"39\":1}}],[\"围棋utp微传输协议的实现\",{\"1\":{\"64\":1}}],[\"围棋实现了高性能\",{\"1\":{\"46\":1}}],[\"围绕sql提供了一个通用的接口\",{\"1\":{\"43\":1}}],[\"树\",{\"1\":{\"46\":1}}],[\"集合操作\",{\"0\":{\"474\":1}}],[\"集合\",{\"0\":{\"471\":1},\"1\":{\"46\":1}}],[\"并使用define定义嵌入的内容\",{\"1\":{\"627\":1}}],[\"并使用cgo进行调用\",{\"1\":{\"231\":1}}],[\"并通过\",{\"1\":{\"619\":1}}],[\"并根据映射函数修改字符串\",{\"1\":{\"605\":1}}],[\"并提供多种语言的\",{\"1\":{\"441\":1}}],[\"并提示如下错误\",{\"1\":{\"221\":1}}],[\"并轻松缩放规模\",{\"1\":{\"402\":1}}],[\"并向go\",{\"1\":{\"379\":1}}],[\"并为你的特定版本打上符合标准的tag\",{\"1\":{\"362\":1}}],[\"并在后续的更新中不断完善\",{\"1\":{\"361\":1}}],[\"并返回删除后的结果\",{\"1\":{\"600\":1}}],[\"并返回结果\",{\"1\":{\"408\":1}}],[\"并返回其原有的值\",{\"1\":{\"355\":1}}],[\"并返回一个对应类型的指针\",{\"1\":{\"194\":1}}],[\"并赋值给count\",{\"1\":{\"348\":1}}],[\"并将结果映射到结构体中\",{\"1\":{\"435\":1}}],[\"并将值赋值给传入的err\",{\"1\":{\"312\":1}}],[\"并将其转换为了c指针后传递给c函数\",{\"1\":{\"222\":1}}],[\"并获取返回值\",{\"1\":{\"290\":1}}],[\"并集\",{\"1\":{\"259\":2}}],[\"并注册到了默认路由中\",{\"1\":{\"243\":1}}],[\"并对其修改的例子\",{\"1\":{\"229\":1}}],[\"并指明了起重机应该有起重和吊货的功能\",{\"1\":{\"212\":1}}],[\"并不知道该在什么时候关闭管道\",{\"1\":{\"339\":1}}],[\"并不会导致阻塞\",{\"1\":{\"340\":1}}],[\"并不会像例子中那样直观\",{\"1\":{\"337\":1}}],[\"并不会对方法外的值造成任何影响\",{\"1\":{\"205\":1}}],[\"并不想读取该文件\",{\"1\":{\"319\":1}}],[\"并不影响建筑进度\",{\"1\":{\"212\":1}}],[\"并不是mongodb教程\",{\"1\":{\"418\":1}}],[\"并不是说分读锁和写锁就有两个锁\",{\"1\":{\"350\":1}}],[\"并不是创建了一个新的类型\",{\"1\":{\"303\":1}}],[\"并不是animal的实现\",{\"1\":{\"206\":1}}],[\"并不是指向头部元素的指针\",{\"1\":{\"157\":1}}],[\"并没有具体的实现\",{\"1\":{\"211\":1}}],[\"并没有被修改成2\",{\"1\":{\"205\":1}}],[\"并没有必要的理由去这样做\",{\"1\":{\"192\":1}}],[\"并作为参数传递了fmt\",{\"1\":{\"204\":1}}],[\"并非从左到右计算\",{\"1\":{\"127\":1}}],[\"并且也要在作用域内才能使用\",{\"1\":{\"619\":1}}],[\"并且可以简单表达清单\",{\"1\":{\"513\":1}}],[\"并且使用js作为脚本语言\",{\"1\":{\"418\":1}}],[\"并且使用了time\",{\"1\":{\"348\":1}}],[\"并且分别输出到old\",{\"1\":{\"395\":1}}],[\"并且auth模块最后仍然要修改go\",{\"1\":{\"382\":1}}],[\"并且该修改可能会被误提交到远程仓库中\",{\"1\":{\"381\":1}}],[\"并且模块c的1\",{\"1\":{\"377\":1}}],[\"并且启用了go\",{\"1\":{\"363\":1}}],[\"并且需要注意的是\",{\"1\":{\"360\":1}}],[\"并且前后存储的值类型应当一致\",{\"1\":{\"360\":1}}],[\"并且返回旧值\",{\"1\":{\"358\":1}}],[\"并且这1000个实例化后的对象在使用完毕后都需要由gc来释放内存\",{\"1\":{\"354\":1}}],[\"并且sync\",{\"1\":{\"354\":1}}],[\"并且son被作为了函数返回值返回出去\",{\"1\":{\"236\":1}}],[\"并且将数据成功添加\",{\"1\":{\"353\":1}}],[\"并且第四个case是一个超时管道\",{\"1\":{\"340\":1}}],[\"并且第二个返回值仍然为true\",{\"1\":{\"339\":1}}],[\"并且加上一些其他的逻辑\",{\"1\":{\"340\":1}}],[\"并且ok为false\",{\"1\":{\"339\":1}}],[\"并且协程的执行顺序也是不确定的\",{\"1\":{\"331\":1}}],[\"并且执行当前函数的善后工作\",{\"1\":{\"315\":1}}],[\"并且上游函数的defer语句同样会执行\",{\"1\":{\"315\":1}}],[\"并且在整个程序的生命周期都不会再改变\",{\"1\":{\"299\":1}}],[\"并且在访问map的时候其实有两个返回值\",{\"1\":{\"179\":1}}],[\"并且比较器也必须使用泛型\",{\"1\":{\"263\":1}}],[\"并且go的泛型约束不允许存在带方法的接口\",{\"1\":{\"263\":1}}],[\"并且goroutine的栈空间是会动态调整的\",{\"1\":{\"229\":1}}],[\"并且动手敲了代码\",{\"1\":{\"248\":1}}],[\"并且还得通过宏告诉cgo去哪里寻找库文件\",{\"1\":{\"231\":1}}],[\"并且还给出了如下的额外定义\",{\"1\":{\"208\":1}}],[\"并且其参数和返回值都得是cgo支持的类型\",{\"1\":{\"219\":1}}],[\"并且t的类型集是接口i类型集的一个子集\",{\"1\":{\"208\":1}}],[\"并且是接口i类型集中的一个元素\",{\"1\":{\"208\":1}}],[\"并且对指针加一运算后\",{\"1\":{\"195\":1}}],[\"并且指针指向对应类型的零值\",{\"1\":{\"194\":1}}],[\"并且不需要改变构造函数的函数签名\",{\"1\":{\"188\":1}}],[\"并且不属于任何类型\",{\"1\":{\"122\":1}}],[\"并且常量的类型可以省略\",{\"1\":{\"130\":1}}],[\"并且nil\",{\"1\":{\"122\":1}}],[\"并且规定了只能位于操作数的后方\",{\"1\":{\"98\":1}}],[\"并且要尽量简短\",{\"1\":{\"92\":1}}],[\"并且由于其编译后的二进制文件小且独立\",{\"1\":{\"78\":1}}],[\"并且有丰富的标准库使得编写跨平台的应用变得简单\",{\"1\":{\"72\":1}}],[\"并记录延迟直方图和其他有用的统计数据并对其进行图形化\",{\"1\":{\"64\":1}}],[\"并支持utf\",{\"1\":{\"63\":1}}],[\"并用nlp填充您的结构\",{\"1\":{\"63\":1}}],[\"并行go框架\",{\"1\":{\"61\":1}}],[\"并行运行功能\",{\"1\":{\"56\":1}}],[\"并发操作包\",{\"1\":{\"508\":1}}],[\"并发安全\",{\"1\":{\"354\":1}}],[\"并发友好的特性\",{\"1\":{\"89\":1}}],[\"并发\",{\"0\":{\"330\":1,\"651\":1},\"1\":{\"84\":1}}],[\"并发性支持\",{\"1\":{\"67\":1}}],[\"并发控制机制的软件交易锁\",{\"1\":{\"56\":1}}],[\"并发读取算法\",{\"1\":{\"51\":1}}],[\"并发fifo队列\",{\"1\":{\"46\":1}}],[\"并可防止代码注入\",{\"1\":{\"43\":1}}],[\"指的是位数\",{\"1\":{\"590\":1}}],[\"指的是精度\",{\"1\":{\"590\":1}}],[\"指的是格式化类型\",{\"1\":{\"590\":1}}],[\"指的是在cgo中c调用go\",{\"1\":{\"219\":1}}],[\"指要转换的浮点数\",{\"1\":{\"590\":1}}],[\"指令\",{\"0\":{\"384\":1}}],[\"指定了使用的cpu核数列表\",{\"1\":{\"394\":1}}],[\"指定上述的统计文件的输出目录\",{\"1\":{\"388\":1}}],[\"指定编译后的二进制文件名称\",{\"1\":{\"388\":1}}],[\"指定替换的模块\",{\"1\":{\"384\":1}}],[\"指定使用的模块\",{\"1\":{\"384\":1}}],[\"指定go版本\",{\"1\":{\"384\":1}}],[\"指定哪些模块参与编译\",{\"1\":{\"382\":1}}],[\"指定子协程的数量\",{\"1\":{\"341\":1}}],[\"指向同一个元素或指向的元素完全相等\",{\"1\":{\"298\":1}}],[\"指向指针的值\",{\"1\":{\"266\":1}}],[\"指向值的指针\",{\"1\":{\"266\":3}}],[\"指针也可以理解为是一个容器\",{\"1\":{\"271\":1}}],[\"指针可能就成了c中常见的悬挂指针\",{\"1\":{\"229\":1}}],[\"指针存储的地址是否相等\",{\"1\":{\"213\":1}}],[\"指针存储的是变量num的地址\",{\"1\":{\"194\":1}}],[\"指针接收者\",{\"0\":{\"206\":1}}],[\"指针\",{\"0\":{\"190\":1,\"229\":1,\"279\":1},\"1\":{\"120\":1,\"121\":1,\"128\":1,\"140\":1,\"162\":1,\"213\":1,\"298\":1,\"643\":1}}],[\"指针缓存\",{\"1\":{\"46\":1}}],[\"指标缓存等的完整go缓存库\",{\"1\":{\"46\":1}}],[\"高于0\",{\"1\":{\"395\":1}}],[\"高精度整数在向低精度整数转换时会抛弃高位保留低位\",{\"1\":{\"304\":1}}],[\"高速kv数据库\",{\"1\":{\"253\":1}}],[\"高级回显服务器和web\",{\"1\":{\"64\":1}}],[\"高级json到go结构转换\",{\"1\":{\"60\":1}}],[\"高效的并发模型\",{\"1\":{\"83\":1}}],[\"高效的并发支持\",{\"0\":{\"70\":1}}],[\"高效\",{\"1\":{\"58\":1,\"89\":1}}],[\"高性能的应用\",{\"1\":{\"88\":1}}],[\"高性能的基于golang游戏服务器架构\",{\"1\":{\"53\":1}}],[\"高性能和准确的货币计算包\",{\"1\":{\"52\":1}}],[\"高性能和线程安全的数据结构的集合\",{\"1\":{\"46\":1}}],[\"高性能中间件\",{\"1\":{\"47\":1}}],[\"高度优化的双端队列\",{\"1\":{\"46\":1}}],[\"高并发直接替换bufio\",{\"1\":{\"46\":1}}],[\"是模板引擎的模板参数\",{\"1\":{\"615\":1}}],[\"是调用f的handler\",{\"1\":{\"537\":1}}],[\"是以上几种数据格式中最为古老的一种\",{\"1\":{\"510\":1}}],[\"是用于存储数据的一种格式\",{\"1\":{\"510\":1}}],[\"是对标准sql库的增强\",{\"1\":{\"431\":1}}],[\"是因为它总是乐观的假设共享数据不会被修改\",{\"1\":{\"359\":1}}],[\"是因为emptyctx的实例必须要有不同的内存地址\",{\"1\":{\"344\":1}}],[\"是因为cgo从中做了类型转换\",{\"1\":{\"218\":1}}],[\"是go在1\",{\"1\":{\"381\":1}}],[\"是go提供的一种并发控制的解决方案\",{\"1\":{\"342\":1}}],[\"是go中实现的计数布隆过滤器的很好替代\",{\"1\":{\"46\":1}}],[\"是否不相等\",{\"1\":{\"620\":1}}],[\"是否相等\",{\"1\":{\"620\":1}}],[\"是否找到子串\",{\"1\":{\"600\":1}}],[\"是否有序\",{\"0\":{\"581\":1}}],[\"是否遵守只取决于开发者\",{\"1\":{\"389\":1}}],[\"是否实现该方法\",{\"1\":{\"312\":1}}],[\"是否为嵌套字段\",{\"1\":{\"286\":1}}],[\"是空接口类型\",{\"1\":{\"305\":1}}],[\"是后续自定义类型的基础\",{\"1\":{\"299\":1}}],[\"是比较安全的\",{\"1\":{\"229\":1}}],[\"是\",{\"1\":{\"213\":7}}],[\"是值拷贝的\",{\"1\":{\"206\":1}}],[\"是在意料之外的\",{\"1\":{\"204\":1}}],[\"是引用类型\",{\"1\":{\"162\":1}}],[\"是相对于当前分组的起始行号\",{\"1\":{\"131\":1}}],[\"是静态类型的\",{\"1\":{\"89\":1}}],[\"是动态类型\",{\"1\":{\"88\":1}}],[\"是解释型语言\",{\"1\":{\"88\":1}}],[\"是编译型语言\",{\"1\":{\"88\":1}}],[\"是云计算的\",{\"1\":{\"79\":1}}],[\"是构建微服务架构的理想选择\",{\"1\":{\"78\":1}}],[\"是跨平台的\",{\"1\":{\"72\":1,\"83\":1}}],[\"是强类型语言\",{\"1\":{\"71\":1}}],[\"是一种并发条件下无锁化并发控制方式\",{\"1\":{\"359\":1}}],[\"是一种通讯机制\",{\"1\":{\"351\":1}}],[\"是一种io多路复用的解决方案\",{\"1\":{\"340\":1}}],[\"是一种轻量级的线程\",{\"1\":{\"331\":1}}],[\"是一种复合类型\",{\"1\":{\"185\":1}}],[\"是一个引用\",{\"1\":{\"643\":1}}],[\"是一个开源的使用\",{\"1\":{\"441\":1}}],[\"是一个分布式\",{\"1\":{\"402\":1}}],[\"是一个符合规范的go\",{\"1\":{\"362\":1}}],[\"是一个临时的并发安全对象池\",{\"1\":{\"354\":1}}],[\"是一个程序性能分析的利器\",{\"1\":{\"240\":1}}],[\"是一个语句\",{\"1\":{\"91\":1}}],[\"是一个相当简单的跨平台游戏库\",{\"1\":{\"53\":1}}],[\"是一门静态类型\",{\"1\":{\"67\":1}}],[\"是由\",{\"1\":{\"67\":1}}],[\"是库\",{\"1\":{\"63\":1}}],[\"是开发者使用最为频繁的函数\",{\"1\":{\"40\":1}}],[\"但不会去更新uinptr所保存的值\",{\"1\":{\"643\":1}}],[\"但不运行\",{\"1\":{\"388\":1}}],[\"但由于在op参数前后添加了\",{\"1\":{\"617\":1}}],[\"但由于类型未知\",{\"1\":{\"262\":1}}],[\"但可以通过函数调用的方式来实现\",{\"1\":{\"617\":1}}],[\"但可能导致运行时错误\",{\"1\":{\"88\":1}}],[\"但可能导致代码冗长\",{\"1\":{\"84\":1}}],[\"但随着时代的更替\",{\"1\":{\"510\":1}}],[\"但结果是乱码\",{\"1\":{\"396\":1}}],[\"但建议还是不要使用特殊字符\",{\"1\":{\"364\":1}}],[\"但也不是原子操作\",{\"1\":{\"356\":1}}],[\"但也有不同\",{\"1\":{\"196\":1}}],[\"但它只适用于处理小字符串的情况\",{\"1\":{\"614\":1}}],[\"但它并不是锁\",{\"1\":{\"351\":1}}],[\"但它提供了更多可用的方法\",{\"1\":{\"350\":1}}],[\"但a协程并不知道这件事\",{\"1\":{\"348\":1}}],[\"但事实上要学会go\",{\"1\":{\"374\":1}}],[\"但事实上recover\",{\"1\":{\"316\":1}}],[\"但事实并非如此\",{\"1\":{\"348\":1}}],[\"但主协程依旧在等待\",{\"1\":{\"341\":1}}],[\"但go是第一个能够将协程和并发支持的相当简洁和优雅的语言\",{\"1\":{\"331\":1}}],[\"但go官方也不建议在c中长期引用go的内存\",{\"1\":{\"229\":1}}],[\"但同时带来的弊端也很明显\",{\"1\":{\"265\":1}}],[\"但内置的可排序类型只有数字和字符串\",{\"1\":{\"263\":1}}],[\"但堆就不一样了\",{\"1\":{\"263\":1}}],[\"但自从诞生以来\",{\"1\":{\"255\":1}}],[\"但有一定的风险\",{\"1\":{\"222\":1}}],[\"但c语言类型可以由多个关键字组成\",{\"1\":{\"220\":1}}],[\"但c语言不允许有多返回值\",{\"1\":{\"217\":1}}],[\"但number的方法集确实是person\",{\"1\":{\"212\":1}}],[\"但fn1\",{\"1\":{\"204\":1}}],[\"但过程也许不对\",{\"1\":{\"203\":1}}],[\"但变量e和n的生命周期并没有结束\",{\"1\":{\"201\":1}}],[\"但一定会提高开发人员的血压和心智负担\",{\"1\":{\"192\":1}}],[\"但除了更加方便以外与第一种方式没有任何的区别\",{\"1\":{\"189\":1}}],[\"但本质上没有任何变化\",{\"1\":{\"189\":1}}],[\"但依旧有返回值\",{\"1\":{\"179\":1}}],[\"但如果想要测试多组数据时\",{\"1\":{\"393\":1}}],[\"但如果使用了\",{\"1\":{\"381\":1}}],[\"但如果是一个大点的项目\",{\"1\":{\"236\":1}}],[\"但如果是一个指针\",{\"1\":{\"206\":1}}],[\"但如果只是一些简单的任务\",{\"1\":{\"233\":1}}],[\"但如果包含非ascii字符结果就不同了\",{\"1\":{\"177\":1}}],[\"但如果对应性能有更高要求\",{\"1\":{\"176\":1}}],[\"但其实是有问题的\",{\"1\":{\"396\":1}}],[\"但其实内部实现都差不多\",{\"1\":{\"175\":1}}],[\"但其引用依旧是同一个\",{\"1\":{\"338\":1}}],[\"但其变量类型是由编译器自行推断的\",{\"1\":{\"300\":1}}],[\"但其性能仍然非常出色\",{\"1\":{\"80\":1}}],[\"但功能有着不小的区别\",{\"1\":{\"156\":1}}],[\"但我们可以通过给自定义类型添加方法来返回其字符串表现形式\",{\"1\":{\"132\":1}}],[\"但实际上它会将a\",{\"1\":{\"127\":1}}],[\"但没有人会去说它这一点\",{\"1\":{\"307\":1}}],[\"但没有使用它\",{\"1\":{\"125\":1}}],[\"但没有依赖项\",{\"1\":{\"45\":1}}],[\"但并不保证用于创建对象的new函数就一定是并发安全的\",{\"1\":{\"354\":1}}],[\"但并不等同\",{\"1\":{\"122\":1}}],[\"但并发编程相对复杂\",{\"1\":{\"89\":1}}],[\"但是uintptr只是一个整数值\",{\"1\":{\"643\":1}}],[\"但是针对html\",{\"1\":{\"628\":1}}],[\"但是每一次都要自定义一个结构体将会十分的繁琐\",{\"1\":{\"537\":1}}],[\"但是前者失败后还会继续执行\",{\"1\":{\"390\":1}}],[\"但是输出结果太简介了\",{\"1\":{\"387\":1}}],[\"但是由于go\",{\"1\":{\"379\":1}}],[\"但是由于grow函数引用了它们\",{\"1\":{\"201\":1}}],[\"但是存储依赖的文件夹是分大小写的\",{\"1\":{\"378\":1}}],[\"但是有一个官方的代理仓库\",{\"1\":{\"370\":1}}],[\"但是有一种情况除外\",{\"1\":{\"125\":1}}],[\"但是它不能存储nil\",{\"1\":{\"360\":1}}],[\"但是它被son的mom字段所引用了\",{\"1\":{\"236\":1}}],[\"但是如果有多个协程访问的话就可能会出现问题了\",{\"1\":{\"353\":1}}],[\"但是会阻塞写协程\",{\"1\":{\"350\":1}}],[\"但是会受到父块中的影响\",{\"1\":{\"129\":1}}],[\"但是为了保险起见\",{\"1\":{\"347\":1}}],[\"但是保险起见\",{\"1\":{\"346\":1}}],[\"但是提供了对应的函数来创建上下文\",{\"1\":{\"344\":1}}],[\"但是死循环+select会导致主协程永久阻塞\",{\"1\":{\"340\":1}}],[\"但是对于上面的操作而言\",{\"1\":{\"359\":1}}],[\"但是对于管道而言\",{\"1\":{\"339\":1}}],[\"但是对于接口类型的话\",{\"1\":{\"260\":1}}],[\"但是顺序还是乱的\",{\"1\":{\"331\":1}}],[\"但是其实这个例子执行过后在大部分情况下什么都不会输出\",{\"1\":{\"331\":1}}],[\"但是调用者本身不负责处理错误\",{\"1\":{\"311\":1}}],[\"但是int类型无法代表interface\",{\"1\":{\"305\":1}}],[\"但是int类型无法被string和bool类型代表\",{\"1\":{\"304\":1}}],[\"但是num2并没有\",{\"1\":{\"304\":1}}],[\"但是不断的循环对于cpu而言依旧是一个不小的开销\",{\"1\":{\"359\":1}}],[\"但是不会输出任何的错误信息\",{\"1\":{\"316\":1}}],[\"但是不会造成任何影响\",{\"1\":{\"205\":1}}],[\"但是不建议使用\",{\"1\":{\"302\":1}}],[\"但是又采用了下划线\",{\"1\":{\"262\":1}}],[\"但是这并不利于人为观察\",{\"1\":{\"519\":1}}],[\"但是这毫无意义\",{\"1\":{\"259\":1}}],[\"但是这样写会显得十分复杂\",{\"1\":{\"256\":1}}],[\"但是receiver可以拥有泛型形参\",{\"1\":{\"258\":1}}],[\"但是sum函数的逻辑都是一模一样的\",{\"1\":{\"256\":1}}],[\"但是反过来\",{\"1\":{\"229\":1}}],[\"但是反过来的话\",{\"1\":{\"206\":1}}],[\"但是导出的go函数返回值不能带指针\",{\"1\":{\"219\":1}}],[\"但是和接口一起使用后\",{\"1\":{\"206\":1}}],[\"但是我们可以调整字段\",{\"1\":{\"192\":1}}],[\"但是在编译时却不会有任何的报错\",{\"1\":{\"191\":1}}],[\"但是在后续赋值时\",{\"1\":{\"125\":1}}],[\"但是go依旧有着oop的影子\",{\"1\":{\"185\":1}}],[\"但是go1\",{\"1\":{\"183\":1}}],[\"但是map的键正是无序且不能重复的\",{\"1\":{\"184\":1}}],[\"但是可以使用已有的泛型类型\",{\"1\":{\"258\":1}}],[\"但是可以通过遍历访问到\",{\"1\":{\"182\":1}}],[\"但是可以覆盖\",{\"1\":{\"172\":1}}],[\"但是官方认为没有必要去修改\",{\"1\":{\"180\":1}}],[\"但是也存在一个特殊情况\",{\"1\":{\"180\":1}}],[\"但是无法存放元素\",{\"1\":{\"178\":1}}],[\"但是实际求得的长度却比英文字符串长\",{\"1\":{\"174\":1}}],[\"但是字节切片是可以修改的\",{\"1\":{\"173\":1}}],[\"但是拓展表达式只有切片能够使用\",{\"1\":{\"169\":1}}],[\"但是遇到换行停止扫描\",{\"1\":{\"143\":1}}],[\"但是专用于存放指针运算\",{\"1\":{\"116\":1}}],[\"但是仅允许在前缀符号之后和数字之间使用\",{\"1\":{\"100\":1}}],[\"但必须加上花括号\",{\"1\":{\"111\":1}}],[\"但在这400毫秒内\",{\"1\":{\"348\":1}}],[\"但在c与go之间切换也会不小的造成性能损失\",{\"1\":{\"233\":1}}],[\"但在go中不行\",{\"1\":{\"111\":1}}],[\"但在性能上可能不如\",{\"1\":{\"88\":1}}],[\"但又不需要用到包中的类型\",{\"1\":{\"94\":1}}],[\"但对于包外而言并不是这样\",{\"1\":{\"93\":1}}],[\"但某些特定领域的库可能不如\",{\"1\":{\"88\":1}}],[\"但这种同步读写的方式是非常危险的\",{\"1\":{\"336\":1}}],[\"但这样会引发另一个问题\",{\"1\":{\"206\":1}}],[\"但这可能对习惯传统\",{\"1\":{\"84\":1}}],[\"但这个特性相对较新\",{\"1\":{\"84\":1}}],[\"但使用较少的内存\",{\"1\":{\"46\":1}}],[\"但需要仔细考虑以便正确应用它们\",{\"1\":{\"43\":1}}],[\"迷你音频库\",{\"1\":{\"45\":1}}],[\"稳定的id3解析和编写库\",{\"1\":{\"45\":1}}],[\"8编码的字符串\",{\"1\":{\"594\":1}}],[\"8编码的文本的函数和常数\",{\"1\":{\"43\":1}}],[\"88999\",{\"1\":{\"592\":1}}],[\"8a2e\",{\"1\":{\"569\":1}}],[\"85a3\",{\"1\":{\"569\":1}}],[\"8512000\",{\"1\":{\"407\":2}}],[\"8ms\",{\"1\":{\"444\":1}}],[\"89\",{\"1\":{\"592\":1}}],[\"895571\",{\"1\":{\"396\":1}}],[\"894\",{\"1\":{\"395\":2}}],[\"894723200\",{\"1\":{\"395\":1}}],[\"8439803\",{\"1\":{\"396\":1}}],[\"84m\",{\"1\":{\"395\":1}}],[\"841\",{\"1\":{\"395\":1}}],[\"8µ\",{\"1\":{\"395\":1}}],[\"825794\",{\"1\":{\"395\":1}}],[\"826中所述\",{\"1\":{\"64\":1}}],[\"87\",{\"1\":{\"184\":1}}],[\"8c\",{\"1\":{\"177\":1}}],[\"817909650\",{\"1\":{\"395\":1}}],[\"81\",{\"1\":{\"152\":1,\"184\":1}}],[\"8080\",{\"1\":{\"243\":3,\"245\":1,\"246\":4,\"247\":1,\"372\":2,\"535\":1,\"536\":1,\"537\":2,\"538\":1,\"570\":1,\"571\":1}}],[\"80\",{\"1\":{\"148\":3}}],[\"802\",{\"1\":{\"64\":2}}],[\"8\",{\"1\":{\"116\":2,\"119\":1,\"131\":1,\"140\":1,\"143\":2,\"152\":12,\"154\":1,\"155\":6,\"163\":1,\"164\":4,\"165\":3,\"166\":6,\"167\":2,\"169\":5,\"178\":1,\"195\":1,\"201\":1,\"222\":1,\"225\":1,\"272\":2,\"294\":1,\"331\":2,\"336\":2,\"339\":1,\"341\":1,\"349\":1,\"355\":2,\"372\":2,\"378\":2,\"379\":13,\"394\":5,\"395\":28,\"396\":4,\"404\":1,\"407\":1,\"408\":1,\"531\":1,\"558\":1,\"560\":1,\"561\":1,\"577\":1,\"579\":1,\"592\":1,\"640\":1,\"641\":1,\"642\":2,\"643\":2,\"644\":2}}],[\"83i\",{\"1\":{\"102\":1}}],[\"8p\",{\"1\":{\"101\":1}}],[\"8和原始文本\",{\"1\":{\"63\":1}}],[\"8文本提供了一个扫描器和分词器\",{\"1\":{\"43\":1}}],[\"该类型与uintptr结合使用\",{\"1\":{\"643\":1}}],[\"该类型也仅有这一个方法\",{\"1\":{\"270\":1}}],[\"该工具便是为了解决性能分析问题而生\",{\"1\":{\"395\":1}}],[\"该工具使用起来十分方便\",{\"1\":{\"385\":1}}],[\"该包可能不具有移植性\",{\"1\":{\"637\":1}}],[\"该包提供的操作可以直接跳过go的类型系统从而读写内存\",{\"1\":{\"637\":1}}],[\"该包通常是为了存储用于测试的辅助数据\",{\"1\":{\"386\":1}}],[\"该包装程序捕获了调用它的文件\",{\"1\":{\"50\":1}}],[\"该版本的go\",{\"1\":{\"379\":1}}],[\"该目录下一定有一个list文件\",{\"1\":{\"379\":1}}],[\"该目录根据域名来划分不同网站的依赖包\",{\"1\":{\"379\":1}}],[\"该关键字仅在主模块中才生效\",{\"1\":{\"378\":1}}],[\"该例开启了3个写协程\",{\"1\":{\"350\":1}}],[\"该例输出的结果为\",{\"1\":{\"140\":1}}],[\"该上下文的任何子级也会随之取消\",{\"1\":{\"346\":1}}],[\"该通道就会被关闭\",{\"1\":{\"343\":1}}],[\"该管道仅仅起到通知作用\",{\"1\":{\"343\":1}}],[\"该方法签名如下\",{\"1\":{\"392\":1}}],[\"该方法返回对应的键值\",{\"1\":{\"343\":1}}],[\"该方法返回一个error\",{\"1\":{\"343\":1}}],[\"该方法具有两个返回值\",{\"1\":{\"343\":1}}],[\"该方法的返回值是字符串\",{\"1\":{\"308\":1}}],[\"该结构体只对外暴露三个方法\",{\"1\":{\"341\":1}}],[\"该结构体中最大的是int64占用8个字节\",{\"1\":{\"192\":1}}],[\"该case则会被忽略\",{\"1\":{\"340\":1}}],[\"该接口下只有一个方法error\",{\"1\":{\"308\":1}}],[\"该函数接收一个切片\",{\"1\":{\"645\":1}}],[\"该函数用于表示结构体内字段偏移量\",{\"1\":{\"641\":1}}],[\"该函数会在测试用例结束时执行\",{\"1\":{\"390\":1}}],[\"该函数会将采集到的数据写入到指定文件中\",{\"1\":{\"242\":1}}],[\"该函数中展现了deadlinecontext的基本使用方法\",{\"1\":{\"389\":1}}],[\"该函数配合select使用可以非常简单的实现超时机制\",{\"1\":{\"340\":1}}],[\"该函数签名如下\",{\"1\":{\"333\":1}}],[\"该函数对于文件夹也是同样的效果\",{\"1\":{\"323\":1}}],[\"该函数对于每一种基础类型都做了处理\",{\"1\":{\"298\":1}}],[\"该函数默认会将参数输出到标准输出中\",{\"1\":{\"138\":1}}],[\"该字符串的内存是由go进行管理的\",{\"1\":{\"222\":1}}],[\"该指令会考虑到nan的情况\",{\"1\":{\"180\":1}}],[\"该特性于go1\",{\"1\":{\"169\":1}}],[\"该格式化工具没有任何的格式化参数可以传递\",{\"1\":{\"107\":1}}],[\"该转义仅在字符串内有效\",{\"1\":{\"104\":1}}],[\"该转义仅在字符内有效\",{\"1\":{\"104\":1}}],[\"该数据的格式正是pprof可视化工具需要的\",{\"1\":{\"43\":1}}],[\"该模式可包装进低级的块加密实现中\",{\"1\":{\"43\":1}}],[\"只输入12小时制的时间\",{\"1\":{\"631\":1}}],[\"只输出日期\",{\"1\":{\"631\":1}}],[\"只会给测试函数传入语料库中的数据\",{\"1\":{\"396\":1}}],[\"只会用到os包下的两个函数\",{\"1\":{\"324\":1}}],[\"只运行regexp匹配的测试用例\",{\"1\":{\"388\":1}}],[\"只编译测试文件\",{\"1\":{\"388\":1}}],[\"只对外暴露了一个do方法\",{\"1\":{\"353\":1}}],[\"只对一个数字使用时\",{\"1\":{\"98\":1}}],[\"只写\",{\"1\":{\"319\":1}}],[\"只读设置\",{\"1\":{\"444\":1}}],[\"只读管道也是一样的道理\",{\"1\":{\"338\":1}}],[\"只读\",{\"1\":{\"319\":1}}],[\"只存在显式的类型转换\",{\"1\":{\"304\":1}}],[\"只有一种情况例外\",{\"1\":{\"618\":1}}],[\"只有一个函数\",{\"1\":{\"365\":1}}],[\"只有一个协程能够对其写入数据\",{\"1\":{\"334\":1}}],[\"只有三个指令\",{\"1\":{\"384\":1}}],[\"只有在真正引用了外部依赖后\",{\"1\":{\"379\":1}}],[\"只有当缓冲区容量满了才会阻塞的等待协程来读取管道中的数据\",{\"1\":{\"336\":1}}],[\"只有两者都为nil时才是完全相等\",{\"1\":{\"298\":1}}],[\"只有切片才能使用拓展表达式\",{\"1\":{\"169\":1}}],[\"只需开启一个新的协程就可以去处理\",{\"1\":{\"574\":1}}],[\"只需执行如下命令\",{\"1\":{\"246\":1}}],[\"只需要换一个函数\",{\"1\":{\"519\":1}}],[\"只需要做到以下三点\",{\"1\":{\"362\":1}}],[\"只需要将初始化操作传入do方法即可\",{\"1\":{\"353\":1}}],[\"只需要提供文件路径即可\",{\"1\":{\"320\":1}}],[\"只需要完成对应的操作就足够\",{\"1\":{\"256\":1}}],[\"只需要执行如下命令\",{\"1\":{\"236\":1}}],[\"只需要传入不同的options函数即可\",{\"1\":{\"188\":1}}],[\"只需要一个clear就可以清空\",{\"1\":{\"183\":1}}],[\"只需要一个字节就能表示\",{\"1\":{\"177\":1}}],[\"只需要稍微修改一下就能解决该问题\",{\"1\":{\"169\":1}}],[\"只需要数行代码\",{\"1\":{\"40\":1}}],[\"只根据crane类型来存放起重机\",{\"1\":{\"212\":1}}],[\"只根据接口的规范来使用功能\",{\"1\":{\"212\":1}}],[\"只要指针是有效的\",{\"1\":{\"643\":1}}],[\"只要没有报错就说明下载成功\",{\"1\":{\"372\":1}}],[\"只要实现了该接口都可以称之为上下文例如著名web框架gin中的gin\",{\"1\":{\"342\":1}}],[\"只要任一协程发生panic\",{\"1\":{\"313\":1}}],[\"只要有interface\",{\"1\":{\"265\":1}}],[\"只要有数组名和下标\",{\"1\":{\"159\":1}}],[\"只要是带有类型集的接口\",{\"1\":{\"260\":1}}],[\"只要是带有方法集的接口\",{\"1\":{\"260\":1}}],[\"只要是实现了一个接口的全部方法\",{\"1\":{\"212\":1}}],[\"只要掌握了泛型\",{\"1\":{\"214\":1}}],[\"只要能够起重和吊货就行\",{\"1\":{\"212\":1}}],[\"只要包含类型集的接口就是通用接口\",{\"1\":{\"208\":1}}],[\"只包含方法集的接口就是基本接口\",{\"1\":{\"208\":1}}],[\"只不过因为字符串转字节切片需求比较频繁\",{\"1\":{\"647\":1}}],[\"只不过go\",{\"1\":{\"384\":1}}],[\"只不过在go中需要显示的指明\",{\"1\":{\"204\":1}}],[\"只不过相对不太常用\",{\"1\":{\"43\":1}}],[\"只是先前版本的基础只是增加了新的功能\",{\"1\":{\"374\":1}}],[\"只是函数签名略有区别\",{\"1\":{\"289\":1}}],[\"只是调用了其它函数\",{\"1\":{\"245\":1}}],[\"只是为了方便开发者使用\",{\"1\":{\"222\":1}}],[\"只是给出了一个规范\",{\"1\":{\"212\":1}}],[\"只是多了一小段\",{\"1\":{\"204\":1}}],[\"只是大多数时候都是anscii字符\",{\"1\":{\"174\":1}}],[\"只是对于切片而言\",{\"1\":{\"162\":1}}],[\"只是一个实现某种性能的小项目\",{\"1\":{\"64\":1}}],[\"只能对管道发送数据\",{\"1\":{\"337\":1,\"338\":1}}],[\"只能阻塞等待\",{\"1\":{\"336\":1}}],[\"只能添加\",{\"1\":{\"319\":1}}],[\"只能说是几乎没有\",{\"1\":{\"307\":1}}],[\"只能自己手写\",{\"1\":{\"233\":1}}],[\"只能以字母和下划线开头\",{\"1\":{\"97\":1}}],[\"只能由字母\",{\"1\":{\"97\":1}}],[\"解析时间\",{\"0\":{\"632\":1}}],[\"解析模板\",{\"1\":{\"615\":1}}],[\"解析成功后再通过\",{\"1\":{\"615\":1}}],[\"解析\",{\"0\":{\"526\":1}}],[\"解析效率\",{\"1\":{\"509\":1}}],[\"解析url并实现查询转义\",{\"1\":{\"43\":1}}],[\"解压过后的依赖组织形式如下所示\",{\"1\":{\"376\":1}}],[\"解压工具\",{\"0\":{\"7\":1}}],[\"解释项目哪些地方用到了依赖\",{\"1\":{\"375\":1}}],[\"解释为\",{\"1\":{\"205\":1}}],[\"解写锁\",{\"1\":{\"350\":1}}],[\"解读锁\",{\"1\":{\"350\":1}}],[\"解锁也只需要unlock\",{\"1\":{\"348\":1}}],[\"解锁\",{\"1\":{\"336\":2,\"349\":2,\"353\":1}}],[\"解锁操作超时的信号量模式实现\",{\"1\":{\"56\":1}}],[\"解包后会返回当前错误链所包裹的错误\",{\"1\":{\"312\":1}}],[\"解决办法有两种\",{\"1\":{\"206\":1}}],[\"解引用符则有两个用途\",{\"1\":{\"194\":1}}],[\"解组到\",{\"1\":{\"46\":1}}],[\"解码器\",{\"1\":{\"45\":1,\"54\":1}}],[\"5e\",{\"1\":{\"567\":1}}],[\"52\",{\"1\":{\"544\":2}}],[\"528z\",{\"1\":{\"407\":1}}],[\"5701\",{\"1\":{\"411\":2,\"412\":1,\"413\":2}}],[\"5µ\",{\"1\":{\"395\":2}}],[\"552113\",{\"1\":{\"394\":1}}],[\"550333\",{\"1\":{\"394\":1}}],[\"5500\",{\"1\":{\"200\":1}}],[\"556fd59b42f6\",{\"1\":{\"373\":1}}],[\"5c51ce4\",{\"1\":{\"368\":2}}],[\"51i\",{\"1\":{\"592\":1}}],[\"5132580\",{\"1\":{\"396\":1}}],[\"51\",{\"1\":{\"392\":1}}],[\"512ms\",{\"1\":{\"444\":1}}],[\"512\",{\"1\":{\"304\":1,\"320\":1}}],[\"51805\",{\"1\":{\"247\":1}}],[\"50+6305039478318694p\",{\"1\":{\"592\":1}}],[\"5087fa2\",{\"1\":{\"368\":2}}],[\"500\",{\"1\":{\"350\":1,\"351\":1}}],[\"5000\",{\"1\":{\"200\":1,\"348\":2}}],[\"50\",{\"1\":{\"284\":2,\"395\":1}}],[\"509证书\",{\"1\":{\"43\":1}}],[\"509编码的键值和证书\",{\"1\":{\"43\":1}}],[\"59\",{\"1\":{\"184\":1}}],[\"5696803\",{\"1\":{\"633\":1}}],[\"5650644266346967p\",{\"1\":{\"590\":1}}],[\"56\",{\"1\":{\"152\":1,\"184\":1,\"395\":1}}],[\"541\",{\"1\":{\"395\":1}}],[\"543\",{\"1\":{\"395\":1}}],[\"548\",{\"1\":{\"395\":1}}],[\"54\",{\"1\":{\"152\":1}}],[\"539s\",{\"1\":{\"396\":1}}],[\"53\",{\"1\":{\"395\":3}}],[\"5389\",{\"1\":{\"64\":2}}],[\"5321中的简单邮件传输协议\",{\"1\":{\"43\":1}}],[\"5\",{\"0\":{\"73\":1,\"81\":1,\"87\":1,\"88\":1,\"89\":1},\"1\":{\"49\":3,\"98\":1,\"101\":2,\"120\":1,\"131\":1,\"140\":1,\"143\":2,\"152\":11,\"155\":2,\"158\":11,\"160\":18,\"163\":1,\"164\":4,\"165\":3,\"166\":6,\"167\":2,\"168\":5,\"169\":4,\"194\":1,\"195\":3,\"201\":1,\"202\":3,\"203\":1,\"204\":1,\"225\":6,\"237\":2,\"239\":5,\"245\":1,\"294\":1,\"321\":2,\"331\":3,\"336\":5,\"339\":2,\"341\":1,\"349\":1,\"354\":1,\"355\":2,\"364\":6,\"368\":3,\"372\":4,\"378\":6,\"379\":1,\"393\":2,\"408\":1,\"444\":2,\"553\":1,\"554\":1,\"555\":2,\"576\":2,\"577\":4,\"579\":4,\"592\":1,\"643\":1,\"644\":1}}],[\"2b\",{\"1\":{\"567\":1}}],[\"2ms\",{\"1\":{\"395\":1}}],[\"2mi\",{\"1\":{\"395\":2}}],[\"2m\",{\"1\":{\"395\":2}}],[\"2中的2代表了使用的cpu核数\",{\"1\":{\"394\":1}}],[\"2中所定义的sha384和sha512哈希算法\",{\"1\":{\"43\":1}}],[\"2中所定义的sha224和sha256哈希算法\",{\"1\":{\"43\":1}}],[\"297796\",{\"1\":{\"396\":2}}],[\"299\",{\"1\":{\"395\":1}}],[\"299637800\",{\"1\":{\"395\":1}}],[\"292320625\",{\"1\":{\"395\":1}}],[\"2925\",{\"1\":{\"395\":1}}],[\"291517150\",{\"1\":{\"395\":1}}],[\"2961\",{\"1\":{\"395\":1}}],[\"298974625\",{\"1\":{\"395\":1}}],[\"290535650\",{\"1\":{\"395\":1}}],[\"29\",{\"1\":{\"394\":6,\"395\":36,\"634\":3}}],[\"29中所述的unicode文本分段的go库\",{\"1\":{\"63\":1}}],[\"2+incompatible\",{\"1\":{\"378\":1}}],[\"266\",{\"1\":{\"396\":2}}],[\"265\",{\"1\":{\"396\":1}}],[\"264\",{\"1\":{\"396\":1}}],[\"263\",{\"1\":{\"396\":1}}],[\"2612\",{\"1\":{\"395\":1}}],[\"267\",{\"1\":{\"312\":1,\"396\":2}}],[\"26\",{\"1\":{\"245\":1,\"395\":1,\"408\":1,\"415\":1,\"552\":1}}],[\"2^9=512\",{\"1\":{\"201\":1}}],[\"2^8=256\",{\"1\":{\"201\":1}}],[\"2^7=128\",{\"1\":{\"201\":1}}],[\"2^6=64\",{\"1\":{\"201\":1}}],[\"2^5=32\",{\"1\":{\"201\":1}}],[\"2^4=16\",{\"1\":{\"201\":1}}],[\"2^3=8\",{\"1\":{\"201\":1}}],[\"2^2=4\",{\"1\":{\"201\":1}}],[\"2^1=2\",{\"1\":{\"201\":1}}],[\"2^0=1\",{\"1\":{\"201\":1}}],[\"2^\",{\"1\":{\"201\":1}}],[\"2版本引用了模块c的1\",{\"1\":{\"377\":2}}],[\"2版本\",{\"1\":{\"377\":2}}],[\"2版本和模块b的1\",{\"1\":{\"377\":1}}],[\"2版本添加\",{\"1\":{\"169\":1}}],[\"2版兼容\",{\"1\":{\"63\":1}}],[\"286\",{\"1\":{\"395\":1}}],[\"286723000\",{\"1\":{\"395\":1}}],[\"281901975\",{\"1\":{\"395\":1}}],[\"285074900\",{\"1\":{\"395\":1}}],[\"2848\",{\"1\":{\"395\":1}}],[\"28\",{\"1\":{\"152\":1,\"200\":1,\"245\":1,\"372\":2,\"378\":1}}],[\"27201964951406896425242246173749149171560804184009624861664038\",{\"1\":{\"545\":1}}],[\"2726\",{\"1\":{\"395\":1}}],[\"27017\",{\"1\":{\"421\":1}}],[\"27s\",{\"1\":{\"396\":1}}],[\"2714\",{\"1\":{\"395\":1}}],[\"276487000\",{\"1\":{\"395\":1}}],[\"278500125\",{\"1\":{\"394\":1}}],[\"277771375\",{\"1\":{\"394\":1}}],[\"27pm\",{\"1\":{\"245\":1}}],[\"27\",{\"1\":{\"152\":1,\"245\":2,\"368\":1,\"558\":1,\"560\":1}}],[\"2748i\",{\"1\":{\"102\":1}}],[\"2d\",{\"1\":{\"152\":1}}],[\"2<<7\",{\"1\":{\"140\":9}}],[\"234\",{\"1\":{\"619\":1}}],[\"2371609442247427\",{\"1\":{\"564\":1}}],[\"2389\",{\"1\":{\"555\":2}}],[\"23t04\",{\"1\":{\"407\":1}}],[\"233336849z\",{\"1\":{\"404\":1}}],[\"231\",{\"1\":{\"177\":1}}],[\"23\",{\"1\":{\"140\":1,\"245\":1,\"368\":3,\"396\":1,\"544\":2,\"576\":1,\"577\":1,\"579\":1}}],[\"21s\",{\"1\":{\"396\":1}}],[\"219\",{\"1\":{\"396\":5}}],[\"217\",{\"1\":{\"396\":2}}],[\"2174\",{\"1\":{\"394\":1}}],[\"2164\",{\"1\":{\"395\":1}}],[\"21更新了clear函数\",{\"1\":{\"183\":1}}],[\"21之前\",{\"1\":{\"183\":1}}],[\"21新增了clear内置函数\",{\"1\":{\"170\":1}}],[\"21\",{\"1\":{\"140\":1,\"152\":1,\"174\":1,\"177\":3,\"201\":1,\"245\":1,\"312\":2,\"368\":3,\"394\":1,\"633\":1,\"634\":4,\"635\":2}}],[\"21版本以上的开发者\",{\"1\":{\"575\":1}}],[\"21版本\",{\"1\":{\"128\":1}}],[\"22false\",{\"1\":{\"593\":1}}],[\"2222\",{\"1\":{\"593\":1}}],[\"22k\",{\"1\":{\"395\":2}}],[\"2263\",{\"1\":{\"395\":1}}],[\"2235\",{\"1\":{\"395\":1}}],[\"228\",{\"1\":{\"177\":1}}],[\"22\",{\"1\":{\"128\":1,\"140\":4,\"178\":1,\"245\":1,\"368\":2,\"373\":1,\"382\":1,\"384\":1,\"415\":1,\"434\":1,\"634\":1}}],[\"2i\",{\"1\":{\"102\":1,\"640\":1}}],[\"259\",{\"1\":{\"396\":1}}],[\"257\",{\"1\":{\"396\":1}}],[\"251\",{\"1\":{\"396\":1}}],[\"255\",{\"1\":{\"225\":1,\"434\":2}}],[\"256\",{\"1\":{\"163\":1,\"396\":1}}],[\"25倍\",{\"1\":{\"163\":1}}],[\"25i\",{\"1\":{\"102\":2}}],[\"25\",{\"1\":{\"101\":2,\"127\":2,\"130\":1,\"131\":2,\"152\":1,\"184\":1,\"188\":1,\"200\":1,\"245\":1,\"390\":3,\"408\":1,\"633\":2,\"634\":3,\"635\":2}}],[\"24小时格式化输出\",{\"1\":{\"631\":1}}],[\"24s\",{\"1\":{\"396\":1}}],[\"2448\",{\"1\":{\"394\":1}}],[\"246859\",{\"1\":{\"362\":1,\"364\":5,\"365\":2,\"366\":1,\"367\":3,\"368\":1,\"369\":5,\"376\":2,\"381\":2,\"382\":3,\"384\":1}}],[\"240\",{\"1\":{\"358\":1}}],[\"24\",{\"1\":{\"100\":5,\"140\":1,\"152\":2,\"241\":1,\"245\":1,\"272\":1,\"286\":1,\"521\":1,\"568\":1,\"640\":2,\"641\":1,\"642\":1}}],[\"20版本以后它就已经被废弃了\",{\"1\":{\"645\":1}}],[\"201\",{\"1\":{\"411\":1}}],[\"20180228061459\",{\"1\":{\"372\":2,\"378\":1}}],[\"2012\",{\"1\":{\"256\":1,\"632\":2}}],[\"2006\",{\"1\":{\"631\":2,\"632\":1}}],[\"2006年1月2日下午15点04分\",{\"1\":{\"631\":1}}],[\"2001\",{\"1\":{\"569\":1}}],[\"200\",{\"1\":{\"346\":4,\"347\":1,\"404\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"412\":1,\"413\":1,\"414\":1}}],[\"20051\",{\"1\":{\"140\":1}}],[\"20050\",{\"1\":{\"140\":1}}],[\"2020\",{\"1\":{\"570\":1,\"571\":1}}],[\"2023\",{\"1\":{\"633\":1,\"634\":3,\"635\":2}}],[\"20230224173230\",{\"1\":{\"373\":1}}],[\"20230829180723\",{\"1\":{\"373\":1}}],[\"20231101134539\",{\"1\":{\"373\":1}}],[\"20231231155935\",{\"1\":{\"373\":1}}],[\"20210923205945\",{\"1\":{\"372\":2,\"378\":1}}],[\"20221115062448\",{\"1\":{\"372\":2,\"378\":2}}],[\"2022\",{\"1\":{\"256\":1,\"629\":1,\"631\":2}}],[\"2024\",{\"1\":{\"245\":1,\"247\":3,\"404\":1,\"407\":1}}],[\"20+6\",{\"1\":{\"147\":1}}],[\"2048\",{\"1\":{\"101\":1,\"620\":2}}],[\"2046中定义的mime多个部分的解析\",{\"1\":{\"43\":1}}],[\"20\",{\"1\":{\"93\":1,\"100\":1,\"140\":1,\"147\":1,\"152\":3,\"177\":3,\"219\":1,\"315\":1,\"347\":1,\"361\":1,\"372\":1,\"374\":2,\"378\":2,\"395\":1,\"396\":1,\"426\":1,\"429\":1,\"434\":1,\"562\":1,\"563\":1,\"564\":1,\"613\":2,\"634\":1}}],[\"2\",{\"0\":{\"70\":1,\"77\":1,\"78\":2,\"79\":1,\"80\":1,\"81\":1,\"84\":1,\"88\":1},\"1\":{\"47\":2,\"49\":2,\"58\":1,\"63\":2,\"65\":1,\"98\":3,\"100\":2,\"101\":5,\"102\":2,\"110\":2,\"125\":3,\"127\":1,\"128\":4,\"129\":4,\"130\":1,\"131\":4,\"140\":1,\"143\":2,\"147\":3,\"149\":2,\"150\":1,\"152\":13,\"154\":3,\"155\":2,\"158\":4,\"160\":14,\"162\":1,\"163\":2,\"164\":4,\"165\":3,\"166\":6,\"167\":2,\"169\":5,\"170\":2,\"172\":1,\"178\":1,\"179\":3,\"180\":2,\"181\":3,\"182\":2,\"183\":2,\"194\":2,\"195\":3,\"200\":1,\"201\":4,\"202\":4,\"203\":1,\"204\":9,\"205\":3,\"206\":7,\"213\":3,\"217\":1,\"218\":1,\"219\":1,\"225\":7,\"231\":1,\"232\":1,\"233\":3,\"236\":9,\"237\":1,\"242\":1,\"256\":1,\"257\":1,\"259\":2,\"283\":1,\"286\":1,\"294\":1,\"302\":1,\"303\":1,\"304\":1,\"306\":1,\"315\":8,\"331\":2,\"336\":5,\"339\":2,\"340\":4,\"341\":3,\"345\":11,\"348\":3,\"349\":1,\"350\":1,\"351\":1,\"355\":2,\"368\":1,\"372\":8,\"373\":4,\"377\":3,\"378\":8,\"393\":1,\"394\":7,\"395\":44,\"396\":6,\"406\":2,\"407\":1,\"408\":1,\"413\":1,\"414\":1,\"449\":1,\"450\":2,\"475\":1,\"478\":1,\"480\":1,\"482\":3,\"483\":1,\"484\":2,\"521\":1,\"545\":2,\"546\":2,\"547\":1,\"549\":1,\"550\":1,\"552\":2,\"553\":2,\"554\":1,\"556\":2,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":2,\"564\":1,\"568\":1,\"569\":1,\"576\":1,\"577\":1,\"579\":1,\"580\":1,\"581\":1,\"589\":2,\"592\":4,\"593\":1,\"599\":2,\"608\":2,\"617\":6,\"620\":9,\"621\":1,\"624\":3,\"625\":2,\"635\":1,\"643\":3,\"644\":2,\"645\":2,\"646\":4}}],[\"2的rpc\",{\"1\":{\"47\":1}}],[\"6s\",{\"1\":{\"396\":1}}],[\"6983438\",{\"1\":{\"629\":1}}],[\"693147180559945309417232121458176568075500134360255254120680009\",{\"1\":{\"545\":1}}],[\"697s\",{\"1\":{\"396\":1}}],[\"690\",{\"1\":{\"43\":1}}],[\"6m\",{\"1\":{\"395\":1}}],[\"6f\",{\"1\":{\"177\":4}}],[\"6c\",{\"1\":{\"177\":7}}],[\"684\",{\"1\":{\"395\":1}}],[\"684023150\",{\"1\":{\"395\":1}}],[\"685030600\",{\"1\":{\"395\":1}}],[\"68\",{\"1\":{\"177\":3}}],[\"600078100\",{\"1\":{\"395\":1}}],[\"6000\",{\"1\":{\"200\":1}}],[\"60\",{\"1\":{\"148\":3,\"630\":2}}],[\"671535\",{\"1\":{\"395\":1}}],[\"679774450\",{\"1\":{\"394\":1}}],[\"67\",{\"1\":{\"140\":1}}],[\"67428e\",{\"1\":{\"101\":1,\"102\":1}}],[\"662993\",{\"1\":{\"394\":1}}],[\"665460800\",{\"1\":{\"394\":1}}],[\"66\",{\"1\":{\"140\":1,\"576\":1,\"577\":2,\"579\":2}}],[\"65533\",{\"1\":{\"396\":1}}],[\"65m\",{\"1\":{\"395\":1}}],[\"656195700\",{\"1\":{\"395\":1}}],[\"659047300\",{\"1\":{\"395\":1}}],[\"65\",{\"1\":{\"140\":1,\"177\":3}}],[\"6305039478318694p\",{\"1\":{\"592\":1}}],[\"6379\",{\"1\":{\"443\":1,\"445\":1,\"617\":2}}],[\"634380250\",{\"1\":{\"395\":1}}],[\"63\",{\"1\":{\"140\":1,\"152\":1,\"543\":2,\"630\":1}}],[\"6248486\",{\"1\":{\"396\":1}}],[\"62\",{\"1\":{\"140\":1}}],[\"61803398874989484820458683436563811772030917980576286213544862\",{\"1\":{\"545\":1}}],[\"61\",{\"1\":{\"140\":1}}],[\"61626364656667\",{\"1\":{\"140\":1}}],[\"64872127070012814684865078781416357165377610071014801157507931\",{\"1\":{\"545\":1}}],[\"64c610d5aec2618d6ca0b516\",{\"1\":{\"426\":1}}],[\"64c610d5aec2618d6ca0b515\",{\"1\":{\"426\":1}}],[\"64c60fa01e2548d9e4de6cf4\",{\"1\":{\"426\":1}}],[\"64<<10\",{\"1\":{\"354\":1}}],[\"64位实数和虚数\",{\"1\":{\"118\":1}}],[\"64位浮点数切片\",{\"1\":{\"120\":1}}],[\"64位浮点数\",{\"1\":{\"117\":1}}],[\"64\",{\"1\":{\"116\":2,\"140\":1,\"152\":1,\"177\":1,\"300\":3,\"307\":1,\"358\":2,\"543\":1,\"589\":2,\"590\":6,\"593\":1}}],[\"64校验和\",{\"1\":{\"43\":1}}],[\"6\",{\"0\":{\"74\":1},\"1\":{\"101\":1,\"102\":1,\"131\":2,\"132\":1,\"140\":1,\"143\":2,\"152\":12,\"154\":1,\"155\":2,\"163\":1,\"164\":4,\"165\":4,\"166\":6,\"169\":7,\"195\":1,\"225\":6,\"236\":1,\"237\":1,\"294\":1,\"331\":3,\"336\":2,\"339\":2,\"341\":1,\"349\":1,\"355\":2,\"372\":2,\"373\":1,\"378\":2,\"395\":4,\"590\":6,\"592\":1,\"604\":1,\"617\":2,\"643\":1,\"644\":1}}],[\"的所有字符\",{\"1\":{\"605\":1}}],[\"的副本\",{\"1\":{\"605\":1}}],[\"的\",{\"1\":{\"509\":1}}],[\"的核心\",{\"1\":{\"402\":1}}],[\"的耗时\",{\"1\":{\"395\":1}}],[\"的格式\",{\"1\":{\"374\":1,\"590\":4}}],[\"的基础之上增加了超时机制\",{\"1\":{\"347\":1}}],[\"的参数是nil\",{\"1\":{\"316\":1}}],[\"的使用有许多隐含的陷阱\",{\"1\":{\"316\":1}}],[\"的执行速度可能会快于子协程的执行速度\",{\"1\":{\"315\":1}}],[\"的定义可以前往参考手册\",{\"1\":{\"304\":1}}],[\"的类型别名\",{\"1\":{\"303\":1}}],[\"的别名\",{\"1\":{\"267\":1}}],[\"的时间内判断最大或最小值\",{\"1\":{\"263\":1}}],[\"的时候\",{\"1\":{\"163\":1}}],[\"的超集\",{\"1\":{\"212\":1}}],[\"的值\",{\"1\":{\"99\":1}}],[\"的静态类型系统提供了更强的类型安全\",{\"1\":{\"88\":1}}],[\"的并发模型非常简洁而高效\",{\"1\":{\"89\":1}}],[\"的并发模型是其最强大的特性之一\",{\"1\":{\"70\":1}}],[\"的并发支持比\",{\"1\":{\"87\":1}}],[\"的生态相对较新\",{\"1\":{\"88\":1}}],[\"的生态系统非常活跃\",{\"1\":{\"85\":1}}],[\"的生态和社区\",{\"0\":{\"85\":1}}],[\"的标准库主要专注于网络编程\",{\"1\":{\"84\":1}}],[\"的编译速度极快\",{\"1\":{\"83\":1}}],[\"的特点\",{\"0\":{\"68\":1}}],[\"的高性能网络功能的框架\",{\"1\":{\"64\":1}}],[\"的库\",{\"1\":{\"64\":1}}],[\"的go端口\",{\"1\":{\"63\":1}}],[\"的go的一组可插拔\",{\"1\":{\"51\":1}}],[\"的自然语言处理库\",{\"1\":{\"63\":1}}],[\"的接口\",{\"1\":{\"61\":1}}],[\"的即插即用\",{\"1\":{\"61\":1}}],[\"的tool\",{\"1\":{\"58\":1}}],[\"的常量\",{\"1\":{\"43\":1}}],[\"的打印\",{\"1\":{\"43\":1}}],[\"中间的text模板就不会生成\",{\"1\":{\"622\":1}}],[\"中\",{\"1\":{\"509\":4}}],[\"中进行创建\",{\"1\":{\"365\":1}}],[\"中的defer语句一个都没有执行\",{\"1\":{\"315\":1}}],[\"中许多繁琐的代码\",{\"1\":{\"89\":1}}],[\"中文汉字\",{\"1\":{\"174\":1}}],[\"中文\",{\"1\":{\"63\":1}}],[\"中提取源代码文档\",{\"1\":{\"43\":1}}],[\"中设置\",{\"1\":{\"0\":1,\"2\":1}}],[\"抽象语法树\",{\"1\":{\"43\":2}}],[\"从连接中读取数据\",{\"1\":{\"574\":1}}],[\"从高到低排列\",{\"1\":{\"481\":1}}],[\"从低到高排列\",{\"1\":{\"481\":1}}],[\"从源集合移动指定元素刀目标集合\",{\"1\":{\"476\":1}}],[\"从源代码中的nil可以看出它仅仅只是一个变量\",{\"1\":{\"122\":1}}],[\"从测试结果中就可以很明显的看出有一个阻塞等待的过程\",{\"1\":{\"392\":1}}],[\"从测试日志中可以看出testsum用例尽管失败了还是输出了test\",{\"1\":{\"390\":1}}],[\"从输出结果中可以看到\",{\"1\":{\"353\":1}}],[\"从结果中可以看出benchstat将其分为了三组\",{\"1\":{\"395\":1}}],[\"从结果中可以看到\",{\"1\":{\"351\":1}}],[\"从结果可以看出全部测试都已经通过\",{\"1\":{\"389\":1}}],[\"从结果可以看出所有的测试用例都通过了\",{\"1\":{\"387\":1}}],[\"从结果可以看到\",{\"1\":{\"233\":1}}],[\"从始至终都只有一个锁\",{\"1\":{\"350\":1}}],[\"从而不用创建结构体\",{\"1\":{\"537\":1}}],[\"从而修改了数据\",{\"1\":{\"348\":1}}],[\"从而避免造成更加严重的后果\",{\"1\":{\"313\":1}}],[\"从原文件中读取数据\",{\"1\":{\"322\":2}}],[\"从指定位置开始写\",{\"1\":{\"321\":1}}],[\"从左往右读\",{\"1\":{\"301\":1}}],[\"从左往右看是cum的占用百分比\",{\"1\":{\"246\":1}}],[\"从上往下看是调用链\",{\"1\":{\"246\":1}}],[\"从理论上来说\",{\"1\":{\"192\":1}}],[\"从中间指定下标i位置开始删除n个元素\",{\"1\":{\"165\":1}}],[\"从中间下标i插入元素\",{\"1\":{\"164\":1}}],[\"从尾部删除n个元素\",{\"1\":{\"165\":1}}],[\"从尾部插入元素\",{\"1\":{\"164\":1}}],[\"从头部删除n个元素\",{\"1\":{\"165\":1}}],[\"从头部插入元素\",{\"1\":{\"164\":1}}],[\"从某种程度上来说\",{\"1\":{\"110\":1}}],[\"从字符串中提取值\",{\"1\":{\"63\":1}}],[\"从字符串创建漂亮的生成图像图案\",{\"1\":{\"58\":1}}],[\"从示例json自动生成go\",{\"1\":{\"60\":1}}],[\"从python到go\",{\"1\":{\"58\":1}}],[\"从go到javascript的编译器\",{\"1\":{\"55\":1}}],[\"从json\",{\"1\":{\"46\":1}}],[\"从一个go\",{\"1\":{\"43\":1}}],[\"从文本中提取链接\",{\"1\":{\"41\":1}}],[\"接下来我们要做的就是这件事\",{\"1\":{\"632\":1}}],[\"接下来直接运行根据上次模糊测试失败的用例\",{\"1\":{\"396\":1}}],[\"接下来执行测试命令看看结果\",{\"1\":{\"389\":1}}],[\"接下来运行auth模块中的代码\",{\"1\":{\"382\":1}}],[\"接下来看看下载一个依赖时\",{\"1\":{\"379\":1}}],[\"接下来看一个并发使用map的例子\",{\"1\":{\"355\":1}}],[\"接下来安装一个第三方依赖试试\",{\"1\":{\"371\":1}}],[\"接下来继续编写一个命令行程序用于输出hello\",{\"1\":{\"365\":1}}],[\"接下来使用cas改造一下\",{\"1\":{\"359\":1}}],[\"接下来使用gcc来制作动态链接库\",{\"1\":{\"231\":1}}],[\"接下来都会一一介绍\",{\"1\":{\"308\":1}}],[\"接下来将会讲解这三种情况\",{\"1\":{\"259\":1}}],[\"接下来会用go描述上述情形\",{\"1\":{\"212\":1}}],[\"接下来逐个讲解\",{\"1\":{\"206\":1}}],[\"接下来创建选项函数\",{\"1\":{\"188\":1}}],[\"接收一个字节类型指针\",{\"1\":{\"648\":1}}],[\"接收的第一个参数是类型\",{\"1\":{\"196\":1}}],[\"接收参数是类型\",{\"1\":{\"196\":1}}],[\"接收两个参数\",{\"1\":{\"178\":1}}],[\"接收类型\",{\"1\":{\"140\":1}}],[\"接收者也不例外\",{\"1\":{\"206\":1}}],[\"接收者也分两种类型\",{\"1\":{\"205\":1}}],[\"接收者就类似于其他语言中的this或self\",{\"1\":{\"204\":1}}],[\"接收者\",{\"1\":{\"43\":1}}],[\"接口的具体类型完全相等时\",{\"1\":{\"298\":1}}],[\"接口的定义变为了类型集\",{\"1\":{\"259\":1}}],[\"接口类型如下\",{\"1\":{\"346\":1}}],[\"接口类型\",{\"1\":{\"266\":1}}],[\"接口类型signedint是一个类型集\",{\"1\":{\"259\":1}}],[\"接口本质上是结构体\",{\"1\":{\"266\":1}}],[\"接口定义为\",{\"1\":{\"208\":1}}],[\"接口实现的定义为\",{\"1\":{\"208\":2}}],[\"接口是一个非常重要的概念\",{\"1\":{\"207\":1}}],[\"接口\",{\"0\":{\"207\":1,\"266\":1},\"1\":{\"120\":1,\"121\":1,\"129\":1,\"213\":1,\"298\":1}}],[\"接口为unix风格\",{\"1\":{\"40\":1}}],[\"以字节为单位返回变量x的大小\",{\"1\":{\"640\":1}}],[\"以空格为分隔符\",{\"1\":{\"620\":1}}],[\"以json格式输出测试日志\",{\"1\":{\"388\":1}}],[\"以表示输出结果是上一次的缓存\",{\"1\":{\"387\":1}}],[\"以便输出不同的样式\",{\"1\":{\"590\":1}}],[\"以便在全局可以执行该二进制文件\",{\"1\":{\"373\":1}}],[\"以便更轻松地处理和取消goroutine\",{\"1\":{\"56\":1}}],[\"以同步io的方式打开文件\",{\"1\":{\"319\":1}}],[\"以读写的模式打开文件\",{\"1\":{\"319\":1}}],[\"以只写的方式打开副本文件\",{\"1\":{\"322\":2}}],[\"以只写的模式打开文件\",{\"1\":{\"319\":1}}],[\"以只读的方式打开原文件\",{\"1\":{\"322\":2}}],[\"以只读的模式打开文件\",{\"1\":{\"319\":1}}],[\"以获得更详细的错误细节\",{\"1\":{\"312\":1}}],[\"以满足不同的错误需求\",{\"1\":{\"310\":1}}],[\"以string为例\",{\"1\":{\"292\":1}}],[\"以指针为例子\",{\"1\":{\"278\":1}}],[\"以下为对比表格\",{\"1\":{\"509\":1}}],[\"以下几种情况还会导致panic\",{\"1\":{\"337\":1}}],[\"以下几种情况使用不当会导致管道阻塞\",{\"1\":{\"337\":1}}],[\"以下示例中\",{\"1\":{\"260\":1}}],[\"以下两种写法都是错误的\",{\"1\":{\"260\":1}}],[\"以下两种写法都将无法通过编译\",{\"1\":{\"258\":1}}],[\"以下写法是错误的\",{\"1\":{\"258\":1}}],[\"以减少扩容次数\",{\"1\":{\"178\":1}}],[\"以上就是模块开发的一个基本流程\",{\"1\":{\"368\":1}}],[\"以上就是一个简单的语法介绍\",{\"1\":{\"91\":1}}],[\"以上三种开启协程的方式都是可以的\",{\"1\":{\"331\":1}}],[\"以上两种拼接方式性能都很差\",{\"1\":{\"176\":1}}],[\"以上几种方式都会给nums分配一片固定大小的内存\",{\"1\":{\"158\":1}}],[\"以供参考\",{\"1\":{\"114\":1}}],[\"以前的yanff\",{\"1\":{\"64\":1}}],[\"以前的rijndael\",{\"1\":{\"43\":1}}],[\"以防万一\",{\"1\":{\"56\":1}}],[\"以了解电子游戏编程\",{\"1\":{\"53\":1}}],[\"以多线程模式运行的嵌入式帐户嵌入式事务数据库\",{\"1\":{\"52\":1}}],[\"以及其长度偏移量\",{\"1\":{\"648\":1}}],[\"以及其他一些快速调试功能\",{\"1\":{\"50\":1}}],[\"以及长度偏移量\",{\"1\":{\"646\":1}}],[\"以及channel\",{\"1\":{\"624\":1}}],[\"以及总体的耗时\",{\"1\":{\"387\":1}}],[\"以及io包下的readall函数\",{\"1\":{\"320\":1}}],[\"以及泛型解决了哪种问题有了一个大概的了解\",{\"1\":{\"256\":1}}],[\"以及所有定义的类型\",{\"1\":{\"92\":1,\"93\":1}}],[\"以及对固定尺寸值的读和写\",{\"1\":{\"43\":1}}],[\"以收集唯一的字段和事件\",{\"1\":{\"46\":1}}],[\"以pprof可视化工具需要的格式写运行时性能测试数据\",{\"1\":{\"43\":1}}],[\"4d\",{\"1\":{\"567\":1}}],[\"4133b2p+20\",{\"1\":{\"590\":1}}],[\"41421356237309504880168872420969807856967187537694807317667974\",{\"1\":{\"545\":1}}],[\"4128202\",{\"1\":{\"395\":2}}],[\"4128204\",{\"1\":{\"395\":3}}],[\"4128201\",{\"1\":{\"395\":2}}],[\"4128203\",{\"1\":{\"395\":2}}],[\"4128187\",{\"1\":{\"395\":2}}],[\"4128189\",{\"1\":{\"395\":3}}],[\"4128185\",{\"1\":{\"394\":2}}],[\"4128198\",{\"1\":{\"395\":1}}],[\"4128190\",{\"1\":{\"395\":1}}],[\"4128191\",{\"1\":{\"395\":2}}],[\"4128194\",{\"1\":{\"395\":1}}],[\"4128192\",{\"1\":{\"395\":1}}],[\"4128196\",{\"1\":{\"394\":1}}],[\"4128199\",{\"1\":{\"394\":1}}],[\"4128176\",{\"1\":{\"394\":2,\"395\":10}}],[\"419651\",{\"1\":{\"395\":1}}],[\"4429256\",{\"1\":{\"634\":1}}],[\"44\",{\"1\":{\"396\":1,\"631\":1}}],[\"444s\",{\"1\":{\"392\":1}}],[\"449s\",{\"1\":{\"392\":1}}],[\"448s\",{\"1\":{\"389\":1}}],[\"4和d1\",{\"1\":{\"377\":1}}],[\"4版本都同时引用了模块d的1\",{\"1\":{\"377\":1}}],[\"4版本\",{\"1\":{\"377\":1}}],[\"43\",{\"1\":{\"368\":1}}],[\"4346所定义的tls\",{\"1\":{\"43\":1}}],[\"4726ab1d7f62\",{\"1\":{\"373\":1}}],[\"47\",{\"1\":{\"184\":1,\"396\":2,\"631\":1}}],[\"4e16\",{\"1\":{\"177\":1}}],[\"48\",{\"1\":{\"152\":1,\"396\":2,\"421\":1,\"443\":1,\"445\":1,\"631\":2}}],[\"423\",{\"1\":{\"395\":1}}],[\"423899\",{\"1\":{\"395\":1}}],[\"4285\",{\"1\":{\"395\":1}}],[\"422275\",{\"1\":{\"395\":1}}],[\"422s\",{\"1\":{\"387\":1}}],[\"42\",{\"1\":{\"152\":1}}],[\"4501592\",{\"1\":{\"634\":1}}],[\"450s\",{\"1\":{\"392\":1}}],[\"4512075\",{\"1\":{\"634\":1}}],[\"456789\",{\"1\":{\"584\":2}}],[\"454452\",{\"1\":{\"395\":1}}],[\"452255\",{\"1\":{\"395\":1}}],[\"457s\",{\"1\":{\"387\":1}}],[\"45\",{\"1\":{\"152\":1,\"396\":1,\"544\":1}}],[\"49mb\",{\"1\":{\"245\":11}}],[\"49\",{\"1\":{\"127\":1,\"152\":1,\"233\":1,\"392\":1}}],[\"404\",{\"1\":{\"657\":1}}],[\"4040067344\",{\"1\":{\"395\":1}}],[\"4040068784\",{\"1\":{\"394\":1}}],[\"4040095664\",{\"1\":{\"395\":1}}],[\"4040090768\",{\"1\":{\"395\":1}}],[\"4040090528\",{\"1\":{\"395\":1}}],[\"4040085248\",{\"1\":{\"395\":1}}],[\"4040089808\",{\"1\":{\"395\":1}}],[\"4040086784\",{\"1\":{\"395\":1}}],[\"4040080064\",{\"1\":{\"394\":1}}],[\"4040078000\",{\"1\":{\"395\":1}}],[\"4040078288\",{\"1\":{\"395\":1}}],[\"4040079488\",{\"1\":{\"395\":1}}],[\"4040076656\",{\"1\":{\"395\":1}}],[\"4040070032\",{\"1\":{\"395\":1}}],[\"4040070224\",{\"1\":{\"395\":1}}],[\"4040070800\",{\"1\":{\"395\":1}}],[\"4040071856\",{\"1\":{\"395\":1}}],[\"4040075408\",{\"1\":{\"395\":1}}],[\"4040077184\",{\"1\":{\"395\":1}}],[\"4040077520\",{\"1\":{\"395\":1}}],[\"4040077568\",{\"1\":{\"395\":1}}],[\"4040077424\",{\"1\":{\"395\":1}}],[\"4040077760\",{\"1\":{\"394\":1}}],[\"4040073104\",{\"1\":{\"394\":1}}],[\"4040056952\",{\"1\":{\"395\":1}}],[\"4040056784\",{\"1\":{\"395\":1}}],[\"4040056736\",{\"1\":{\"394\":1}}],[\"4040056592\",{\"1\":{\"394\":1,\"395\":8}}],[\"4096\",{\"1\":{\"574\":1}}],[\"4090817\",{\"1\":{\"396\":1}}],[\"40808206181339196\",{\"1\":{\"563\":1}}],[\"401298464324817070923729583289916131280e\",{\"1\":{\"544\":1}}],[\"40282346638528859811704183484516925440e+38\",{\"1\":{\"544\":1}}],[\"40\",{\"1\":{\"101\":3,\"152\":1,\"184\":1,\"247\":3,\"286\":1,\"396\":1}}],[\"4\",{\"0\":{\"72\":1,\"80\":1},\"1\":{\"65\":1,\"98\":1,\"100\":2,\"131\":4,\"140\":1,\"143\":2,\"152\":12,\"155\":2,\"158\":2,\"160\":10,\"163\":2,\"164\":4,\"165\":3,\"166\":6,\"167\":2,\"169\":12,\"170\":2,\"172\":1,\"178\":1,\"195\":2,\"202\":2,\"203\":1,\"204\":5,\"225\":6,\"227\":2,\"237\":11,\"238\":5,\"266\":1,\"286\":2,\"294\":1,\"331\":4,\"336\":2,\"339\":2,\"341\":1,\"348\":2,\"349\":1,\"353\":3,\"355\":2,\"364\":2,\"378\":4,\"393\":2,\"394\":7,\"395\":39,\"407\":1,\"408\":1,\"454\":1,\"544\":1,\"559\":1,\"640\":1,\"642\":2,\"643\":1,\"644\":1,\"645\":2,\"646\":2}}],[\"46\",{\"1\":{\"392\":2,\"396\":1}}],[\"464s\",{\"1\":{\"391\":1}}],[\"4648中所定义的base64编码\",{\"1\":{\"43\":1}}],[\"4648中所定义的base32编码\",{\"1\":{\"43\":1}}],[\"4623113902481840538\",{\"1\":{\"643\":1}}],[\"462s\",{\"1\":{\"390\":1}}],[\"4627中的json对象的编码和解码\",{\"1\":{\"43\":1}}],[\"468s\",{\"1\":{\"390\":1}}],[\"文本\",{\"1\":{\"509\":3}}],[\"文本如下\",{\"1\":{\"408\":1}}],[\"文本diff实现\",{\"1\":{\"41\":1}}],[\"文中代码演示的环境是win10\",{\"1\":{\"215\":1}}],[\"文档地址\",{\"1\":{\"419\":1}}],[\"文档生成\",{\"1\":{\"74\":1}}],[\"文档\",{\"0\":{\"367\":1,\"410\":1},\"1\":{\"62\":1}}],[\"文件路径在跨平台方面也会是一个大问题\",{\"1\":{\"381\":1}}],[\"文件io等\",{\"1\":{\"340\":1}}],[\"文件夹的许多操作都与文件操作类似\",{\"1\":{\"326\":1}}],[\"文件夹\",{\"0\":{\"326\":1}}],[\"文件特别大的时候不建议这么做\",{\"1\":{\"322\":1}}],[\"文件复制成功\",{\"1\":{\"322\":1}}],[\"文件读取异常\",{\"1\":{\"320\":1}}],[\"文件读取成功\",{\"1\":{\"319\":1}}],[\"文件打开成功\",{\"1\":{\"319\":2,\"320\":4,\"321\":2}}],[\"文件必须不存在\",{\"1\":{\"319\":1}}],[\"文件访问异常\",{\"1\":{\"319\":2,\"320\":2,\"321\":2}}],[\"文件不存在\",{\"1\":{\"319\":3}}],[\"文件系统的抽象层\",{\"1\":{\"318\":1}}],[\"文件描述符\",{\"0\":{\"134\":1}}],[\"文件的内容如下\",{\"1\":{\"396\":1}}],[\"文件的查找路径默认为项目go\",{\"1\":{\"319\":1}}],[\"文件的模块\",{\"1\":{\"51\":1}}],[\"文件的访问\",{\"1\":{\"43\":1}}],[\"文件操作库\",{\"1\":{\"51\":1}}],[\"文件传输系统\",{\"1\":{\"51\":1}}],[\"文件\",{\"0\":{\"51\":1,\"318\":1},\"1\":{\"43\":1,\"51\":1,\"62\":2,\"378\":1}}],[\"同slice函数\",{\"1\":{\"648\":1}}],[\"同slicedata函数\",{\"1\":{\"647\":1}}],[\"同sql包的使用方式\",{\"1\":{\"43\":1}}],[\"同步工作区的模块依赖\",{\"1\":{\"383\":1}}],[\"同步原语的阻塞跟踪\",{\"1\":{\"243\":1}}],[\"同理\",{\"1\":{\"378\":1}}],[\"同一个机器上的所有go\",{\"1\":{\"376\":1}}],[\"同命令top\",{\"1\":{\"246\":1}}],[\"同样都是官方写的\",{\"1\":{\"312\":1}}],[\"同样会下载一个文件\",{\"1\":{\"243\":1}}],[\"同样的还有t\",{\"1\":{\"390\":1}}],[\"同样的os包也为此提供了方便函数\",{\"1\":{\"319\":1}}],[\"同样的也无法取地址\",{\"1\":{\"643\":1}}],[\"同样的也无法在类型约束中并入\",{\"1\":{\"260\":1}}],[\"同样的也可以修改数组元素\",{\"1\":{\"159\":1}}],[\"同样的\",{\"1\":{\"208\":1,\"212\":1,\"260\":1,\"307\":1,\"336\":1,\"634\":1}}],[\"同样可以\",{\"1\":{\"206\":1}}],[\"同样是二维的数组和切片\",{\"1\":{\"168\":1}}],[\"同时mongo还提供了findoneandupdate和findoneandreplace来获取文档和更新文档\",{\"1\":{\"427\":1}}],[\"同时模块a的1\",{\"1\":{\"377\":1}}],[\"同时监测多个元素是否可用\",{\"1\":{\"340\":1}}],[\"同时panic也可以被恢复来保证程序继续运行\",{\"1\":{\"313\":1}}],[\"同时出现两个会更加进行细节的输出\",{\"1\":{\"236\":1}}],[\"同时修改头文件sum\",{\"1\":{\"219\":1}}],[\"同时需要确保环境变量cgo\",{\"1\":{\"216\":1}}],[\"同时接口也分为了两类\",{\"1\":{\"208\":1}}],[\"同时为了更好的gc和安全考虑\",{\"1\":{\"193\":1}}],[\"同时也会发现目录下多了一个名为go\",{\"1\":{\"372\":1}}],[\"同时也只有一个协程能够读取管道中的数据\",{\"1\":{\"334\":1}}],[\"同时也必须声明管道的存储类型\",{\"1\":{\"332\":1}}],[\"同时也可以用于并发控制\",{\"1\":{\"332\":1}}],[\"同时也抛弃了构造方法\",{\"1\":{\"185\":1}}],[\"同时也是一个换源框架\",{\"1\":{\"11\":1}}],[\"同时if语句也可以包含一些简单的语句\",{\"1\":{\"147\":1}}],[\"同时去除了许多不必要的复杂性\",{\"1\":{\"67\":1}}],[\"部分实现了rfc\",{\"1\":{\"43\":1}}],[\"其类型为\",{\"1\":{\"643\":1}}],[\"其类型都是\",{\"1\":{\"134\":1}}],[\"其含有非常多的时间操作的方法\",{\"1\":{\"629\":1}}],[\"其返回的数据类型是time结构体\",{\"1\":{\"629\":1}}],[\"其返回值是一个空结构体类型的只读管道\",{\"1\":{\"343\":1}}],[\"其返回值是一个只读的管道\",{\"1\":{\"340\":1}}],[\"其目的是为了复用某一个模板而用的\",{\"1\":{\"627\":1}}],[\"其作用域仅限于with语句内\",{\"1\":{\"622\":1}}],[\"其结果为\",{\"1\":{\"620\":1,\"621\":1}}],[\"其语法如下\",{\"1\":{\"618\":1}}],[\"其分隔次数由n决定\",{\"1\":{\"608\":2}}],[\"其支持的类型有\",{\"1\":{\"524\":1}}],[\"其相较于xml更轻便的大小\",{\"1\":{\"516\":1}}],[\"其下有很多子包\",{\"1\":{\"508\":2}}],[\"其后跟想要生成的参数\",{\"1\":{\"396\":1}}],[\"其后的参数也可以跟多个目录\",{\"1\":{\"387\":1}}],[\"其内容非常容易理解\",{\"1\":{\"382\":1}}],[\"其内部有如下一段代码\",{\"1\":{\"611\":1}}],[\"其内部并不会进行排序操作\",{\"1\":{\"581\":1}}],[\"其内部是使用了适配器类型handlerfunc\",{\"1\":{\"537\":1}}],[\"其内部只包含一对键值对\",{\"1\":{\"345\":1}}],[\"其内部的实现是计数器+信号量\",{\"1\":{\"341\":1}}],[\"其内部实现也很简单\",{\"1\":{\"312\":1}}],[\"其内部结构是不一样的\",{\"1\":{\"168\":1}}],[\"其它两个复用其内容并嵌入自定义的新内容\",{\"1\":{\"628\":1}}],[\"其它两个基本上等同于go\",{\"1\":{\"384\":1}}],[\"其它开发者便可以通过模块名来引入代码或安装命令行工具\",{\"1\":{\"368\":1}}],[\"其它人就可以通过模块名来下载你所编写的库\",{\"1\":{\"362\":1}}],[\"其提供了以下几种类型以供进行原子操作\",{\"1\":{\"357\":1}}],[\"其原理就是锁+原子操作\",{\"1\":{\"353\":1}}],[\"其本身只实现了value方法\",{\"1\":{\"345\":1}}],[\"其本质上是无符号整型uint\",{\"1\":{\"270\":1}}],[\"其上手难度相对较小\",{\"1\":{\"330\":1}}],[\"其默认的值就是该类型的零值\",{\"1\":{\"262\":1}}],[\"其默认的遍历单位类型就是一个rune\",{\"1\":{\"177\":1}}],[\"其优点是可控\",{\"1\":{\"242\":1}}],[\"其功能等同于go中的类型别名\",{\"1\":{\"220\":1}}],[\"其次才是值的比较\",{\"1\":{\"213\":1}}],[\"其底层类型为\",{\"1\":{\"204\":1}}],[\"其指向的元素为数组第二个元素\",{\"1\":{\"195\":1}}],[\"其实可以使用t\",{\"1\":{\"390\":1}}],[\"其实sync\",{\"1\":{\"353\":1}}],[\"其实现了sync\",{\"1\":{\"349\":1}}],[\"其实现是由底层的汇编指令ucomisd完成\",{\"1\":{\"180\":1}}],[\"其实go在其他领域也有不少的应用\",{\"1\":{\"254\":1}}],[\"其实接口内部可以看成是一个由\",{\"1\":{\"213\":1}}],[\"其实等价于\",{\"1\":{\"204\":1}}],[\"其实还是需要解引用\",{\"1\":{\"190\":1}}],[\"其实并不是字面量的长度\",{\"1\":{\"174\":1}}],[\"其一维和二维的长度早已固定\",{\"1\":{\"168\":1}}],[\"其值为nil\",{\"1\":{\"332\":1}}],[\"其值必须是可设置的\",{\"1\":{\"268\":1}}],[\"其值默认就是前一个的值\",{\"1\":{\"130\":1}}],[\"其值只能来源于\",{\"1\":{\"129\":1}}],[\"其他情况都表示的是保留小数到后几位\",{\"1\":{\"590\":1}}],[\"其他\",{\"0\":{\"527\":1}}],[\"其他关系数据库操作起来都是大差不大差的\",{\"1\":{\"432\":1}}],[\"其他常用的还有t\",{\"1\":{\"390\":1}}],[\"其他常量标识符\",{\"1\":{\"129\":1}}],[\"其他版本的同一个依赖照样可以正常访问\",{\"1\":{\"378\":1}}],[\"其他的使用起来都大差不差\",{\"1\":{\"409\":1}}],[\"其他的类型的使用也是十分类似的\",{\"1\":{\"358\":1}}],[\"其他的逻辑\",{\"1\":{\"314\":1}}],[\"其他协程进行读操作时会阻塞\",{\"1\":{\"350\":1}}],[\"其他协程进行读操作时不会阻塞\",{\"1\":{\"350\":1}}],[\"其他协程进行写操作时会阻塞\",{\"1\":{\"350\":2}}],[\"其他协程想要访问就必须要先获得锁\",{\"1\":{\"349\":1}}],[\"其他子协程也就自然退出了\",{\"1\":{\"331\":1}}],[\"其他优秀的开源工具分类\",{\"0\":{\"44\":1}}],[\"其中也包括官方提供的标准库\",{\"1\":{\"637\":1}}],[\"其中一些概念的解释如下\",{\"1\":{\"396\":1}}],[\"其中geomoean为平均值\",{\"1\":{\"395\":1}}],[\"其中淡蓝色的表示go\",{\"1\":{\"377\":1}}],[\"其中的direct表示代理下载失败后绕过代理缓存直接访问源代码仓库\",{\"1\":{\"370\":1}}],[\"其中的fmt\",{\"1\":{\"40\":1}}],[\"其中pointer原子类型支持泛型\",{\"1\":{\"357\":1}}],[\"其中newpointer函数和free方法的实现如下\",{\"1\":{\"354\":1}}],[\"其中tryrlock与trylock两个尝试加锁的操作是非阻塞式的\",{\"1\":{\"350\":1}}],[\"其中就包括指针运算\",{\"1\":{\"195\":1}}],[\"其中有5个字节是无用的\",{\"1\":{\"192\":1}}],[\"其中所有客户端都可以无缝同步\",{\"1\":{\"47\":1}}],[\"其中包含golang的到期时间\",{\"1\":{\"46\":1}}],[\"其定义见itu\",{\"1\":{\"43\":1}}],[\"其定义见bruce\",{\"1\":{\"43\":1}}],[\"3c\",{\"1\":{\"567\":1}}],[\"3s\",{\"1\":{\"396\":1}}],[\"3和1\",{\"1\":{\"377\":1}}],[\"3版本\",{\"1\":{\"377\":1}}],[\"31564e+06\",{\"1\":{\"590\":1}}],[\"315643e+06\",{\"1\":{\"590\":1}}],[\"31\",{\"1\":{\"543\":1}}],[\"310\",{\"1\":{\"395\":1}}],[\"31016791\",{\"1\":{\"319\":3}}],[\"3174中所定义的sha1哈希算法\",{\"1\":{\"43\":1}}],[\"39f4de51ef7d\",{\"1\":{\"373\":1}}],[\"39\",{\"1\":{\"298\":1}}],[\"38905609893065\",{\"1\":{\"557\":1}}],[\"387s\",{\"1\":{\"395\":1}}],[\"3870\",{\"1\":{\"395\":1}}],[\"3875中的cgi\",{\"1\":{\"43\":1}}],[\"386412\",{\"1\":{\"395\":1}}],[\"381s\",{\"1\":{\"394\":1}}],[\"38\",{\"1\":{\"245\":1,\"396\":1}}],[\"348056\",{\"1\":{\"396\":1}}],[\"3489和rfc\",{\"1\":{\"64\":1}}],[\"346408\",{\"1\":{\"396\":1}}],[\"3439\",{\"1\":{\"395\":1}}],[\"3432624\",{\"1\":{\"225\":1}}],[\"3432608\",{\"1\":{\"225\":1}}],[\"3432592\",{\"1\":{\"225\":1}}],[\"3432576\",{\"1\":{\"225\":1}}],[\"3432544\",{\"1\":{\"225\":1}}],[\"3432824\",{\"1\":{\"225\":1}}],[\"344530\",{\"1\":{\"394\":1}}],[\"3428\",{\"1\":{\"394\":1}}],[\"34\",{\"1\":{\"201\":1,\"404\":1}}],[\"3333333333333335\",{\"1\":{\"589\":1}}],[\"3333333333333333333\",{\"1\":{\"589\":1}}],[\"3333\",{\"1\":{\"552\":1}}],[\"3326\",{\"1\":{\"514\":2}}],[\"3306\",{\"1\":{\"433\":1,\"435\":1,\"513\":1,\"515\":1}}],[\"335167\",{\"1\":{\"396\":1}}],[\"335358\",{\"1\":{\"395\":1}}],[\"339\",{\"1\":{\"395\":1}}],[\"339596\",{\"1\":{\"395\":1}}],[\"338957\",{\"1\":{\"395\":1}}],[\"3376\",{\"1\":{\"395\":1}}],[\"33\",{\"1\":{\"177\":3,\"178\":1,\"395\":1}}],[\"3315中所述\",{\"1\":{\"64\":1}}],[\"358059\",{\"1\":{\"396\":1}}],[\"35k\",{\"1\":{\"395\":1}}],[\"356465275\",{\"1\":{\"395\":1}}],[\"351858\",{\"1\":{\"394\":1}}],[\"3579\",{\"1\":{\"394\":1}}],[\"35\",{\"1\":{\"152\":1,\"236\":1,\"407\":1,\"413\":2,\"434\":1,\"635\":1}}],[\"30258509299404568401799145468436420760110148862877297603332790\",{\"1\":{\"545\":1}}],[\"3087837\",{\"1\":{\"396\":1}}],[\"30s\",{\"1\":{\"396\":5}}],[\"30ghz\",{\"1\":{\"394\":1,\"395\":3}}],[\"30000000000000004\",{\"1\":{\"304\":1}}],[\"30028\",{\"1\":{\"177\":1}}],[\"30\",{\"1\":{\"152\":1,\"188\":1,\"200\":1,\"391\":1,\"392\":1,\"393\":1,\"396\":2,\"408\":1,\"426\":1,\"429\":1}}],[\"373305\",{\"1\":{\"396\":1}}],[\"372185\",{\"1\":{\"396\":1}}],[\"37\",{\"1\":{\"131\":1,\"396\":1,\"635\":1}}],[\"377\",{\"1\":{\"103\":1}}],[\"361408\",{\"1\":{\"396\":1}}],[\"367225\",{\"1\":{\"396\":1}}],[\"363120\",{\"1\":{\"396\":1}}],[\"3603459389\",{\"1\":{\"319\":3}}],[\"360entsecgroup\",{\"1\":{\"41\":1}}],[\"36\",{\"1\":{\"127\":2,\"152\":2,\"635\":2}}],[\"324\",{\"1\":{\"544\":1}}],[\"326301\",{\"1\":{\"395\":1}}],[\"3266862\",{\"1\":{\"245\":1}}],[\"32768\",{\"1\":{\"238\":4}}],[\"32位实数和虚数\",{\"1\":{\"118\":1}}],[\"32位浮点数\",{\"1\":{\"117\":1}}],[\"32\",{\"1\":{\"116\":2,\"152\":1,\"177\":3,\"263\":1,\"319\":1,\"347\":1,\"392\":2,\"393\":1,\"396\":1,\"543\":2,\"590\":1,\"605\":2}}],[\"32校验和\",{\"1\":{\"43\":2}}],[\"3以太网ii帧和ieee\",{\"1\":{\"64\":1}}],[\"3+进行计算机视觉的go软件包\",{\"1\":{\"58\":1}}],[\"3\",{\"0\":{\"71\":1,\"79\":1,\"83\":1,\"84\":1,\"89\":1},\"1\":{\"58\":1,\"61\":1,\"65\":1,\"98\":1,\"110\":1,\"129\":2,\"131\":5,\"140\":1,\"143\":2,\"152\":11,\"154\":3,\"155\":2,\"158\":4,\"160\":16,\"162\":1,\"163\":1,\"164\":4,\"165\":2,\"166\":6,\"167\":2,\"169\":11,\"170\":2,\"174\":1,\"178\":1,\"179\":4,\"180\":1,\"181\":3,\"182\":2,\"195\":2,\"201\":1,\"202\":3,\"203\":1,\"204\":9,\"218\":1,\"224\":1,\"225\":6,\"229\":3,\"231\":1,\"232\":1,\"237\":1,\"245\":1,\"256\":1,\"257\":1,\"286\":1,\"294\":1,\"303\":1,\"312\":2,\"315\":4,\"331\":4,\"336\":4,\"339\":2,\"340\":2,\"341\":1,\"346\":1,\"347\":1,\"348\":5,\"349\":1,\"350\":3,\"351\":11,\"355\":2,\"368\":1,\"373\":1,\"378\":4,\"379\":5,\"393\":1,\"395\":12,\"406\":2,\"407\":1,\"408\":1,\"411\":1,\"413\":1,\"414\":2,\"444\":1,\"449\":1,\"521\":2,\"544\":1,\"545\":1,\"554\":1,\"558\":3,\"560\":1,\"561\":1,\"576\":1,\"577\":1,\"579\":1,\"580\":1,\"581\":1,\"599\":1,\"617\":5,\"620\":2,\"624\":2,\"634\":1,\"643\":5,\"644\":2,\"645\":2,\"646\":2}}],[\"3d照片的解码器和转换工具\",{\"1\":{\"58\":1}}],[\"3d数学软件包\",{\"1\":{\"53\":1}}],[\"3d游戏引擎\",{\"1\":{\"53\":1}}],[\"3所定义的椭圆曲线数据签名算法\",{\"1\":{\"43\":1}}],[\"3所定义的数据签名算法\",{\"1\":{\"43\":1}}],[\"1+1=\",{\"1\":{\"621\":1}}],[\"1+2j\",{\"1\":{\"591\":2}}],[\"1+2=3\",{\"1\":{\"217\":1}}],[\"1+2i\",{\"1\":{\"213\":1,\"591\":2}}],[\"1+2+3\",{\"1\":{\"130\":1}}],[\"1a\",{\"1\":{\"567\":1}}],[\"1a77947f34deddb41af25e6f0ddb8e830159c179\",{\"1\":{\"404\":1}}],[\"1a未加密哈希函数\",{\"1\":{\"43\":1}}],[\"1ns等\",{\"1\":{\"388\":1}}],[\"1ms\",{\"1\":{\"388\":1}}],[\"1f422d1\",{\"1\":{\"368\":2}}],[\"1fffp\",{\"1\":{\"101\":1}}],[\"1<<64\",{\"1\":{\"543\":1}}],[\"1<<63\",{\"1\":{\"543\":1,\"630\":1}}],[\"1<<16\",{\"1\":{\"543\":1}}],[\"1<<15\",{\"1\":{\"238\":1,\"543\":1}}],[\"1<<8\",{\"1\":{\"543\":1}}],[\"1<<intsize\",{\"1\":{\"543\":1}}],[\"1<<7\",{\"1\":{\"543\":1}}],[\"1<<\",{\"1\":{\"543\":1}}],[\"1<<32\",{\"1\":{\"543\":1}}],[\"1<<31\",{\"1\":{\"543\":1}}],[\"1<<3\",{\"1\":{\"140\":1}}],[\"1e2\",{\"1\":{\"140\":4}}],[\"1e6i\",{\"1\":{\"102\":1}}],[\"1e6\",{\"1\":{\"101\":1}}],[\"19+90i\",{\"1\":{\"592\":1}}],[\"192\",{\"1\":{\"404\":1,\"421\":1,\"443\":1,\"445\":1,\"568\":1,\"569\":1}}],[\"1985543\",{\"1\":{\"396\":1}}],[\"19990\",{\"1\":{\"177\":1}}],[\"19\",{\"1\":{\"140\":1,\"187\":2,\"395\":2,\"408\":1,\"518\":1,\"519\":2}}],[\"1958\",{\"1\":{\"394\":1}}],[\"1950中所定义的zlib格式压缩数据的读和写\",{\"1\":{\"43\":1}}],[\"1951中所定义的gzip格式压缩文件的读和写\",{\"1\":{\"43\":1}}],[\"1951中所定义的deflate压缩数据格式\",{\"1\":{\"43\":1}}],[\"1727066104528\",{\"1\":{\"407\":1}}],[\"1744\",{\"1\":{\"395\":1}}],[\"17及以前\",{\"1\":{\"208\":1}}],[\"17\",{\"1\":{\"140\":1,\"247\":3,\"363\":1,\"368\":3,\"372\":2,\"378\":1,\"404\":1,\"580\":1,\"581\":1,\"629\":1,\"631\":2}}],[\"1315643\",{\"1\":{\"590\":2}}],[\"134\",{\"1\":{\"443\":1,\"445\":1}}],[\"138\",{\"1\":{\"421\":1}}],[\"1388\",{\"1\":{\"395\":1}}],[\"132\",{\"1\":{\"404\":1}}],[\"1321中所定义的md5哈希算法\",{\"1\":{\"43\":1}}],[\"13s\",{\"1\":{\"396\":1}}],[\"1398\",{\"1\":{\"395\":1}}],[\"1332\",{\"1\":{\"395\":1}}],[\"1353\",{\"1\":{\"395\":1}}],[\"13版本时go团队推出了链式错误\",{\"1\":{\"308\":1}}],[\"13\",{\"1\":{\"131\":2,\"140\":1,\"201\":1,\"236\":8,\"239\":4,\"312\":1,\"373\":1}}],[\"1i\",{\"1\":{\"102\":3}}],[\"126\",{\"1\":{\"544\":1}}],[\"1202\",{\"1\":{\"518\":1,\"519\":2}}],[\"120230\",{\"1\":{\"436\":1,\"437\":1,\"438\":1}}],[\"120\",{\"1\":{\"511\":1,\"512\":1,\"517\":2,\"520\":2,\"531\":1}}],[\"1203622300\",{\"1\":{\"395\":1}}],[\"121\",{\"1\":{\"521\":1}}],[\"12132\",{\"1\":{\"434\":1,\"435\":1}}],[\"1211017600\",{\"1\":{\"394\":1}}],[\"12s\",{\"1\":{\"396\":1}}],[\"127\",{\"1\":{\"243\":1,\"245\":1,\"246\":3,\"247\":2,\"433\":1,\"435\":1,\"513\":1,\"515\":1}}],[\"1280\",{\"1\":{\"395\":1}}],[\"128\",{\"1\":{\"221\":1,\"358\":2,\"591\":2,\"592\":3}}],[\"12\",{\"1\":{\"128\":1,\"140\":1,\"152\":2,\"246\":1,\"350\":1,\"351\":1,\"372\":2,\"378\":1,\"411\":2,\"412\":1,\"423\":1,\"425\":2,\"436\":1,\"521\":3,\"549\":1,\"592\":1,\"632\":2,\"643\":3}}],[\"1234\",{\"1\":{\"574\":2}}],[\"12345\",{\"1\":{\"457\":1}}],[\"123456\",{\"1\":{\"421\":1,\"433\":1,\"443\":1,\"445\":1,\"513\":1,\"514\":2,\"515\":1,\"534\":1}}],[\"12345e+5i\",{\"1\":{\"102\":1}}],[\"12345e+5\",{\"1\":{\"101\":1}}],[\"123\",{\"1\":{\"188\":1,\"335\":2,\"336\":1,\"395\":2}}],[\"123i\",{\"1\":{\"102\":1}}],[\"1249847412109375\",{\"1\":{\"101\":1}}],[\"16162\",{\"1\":{\"434\":1}}],[\"168\",{\"1\":{\"404\":1,\"421\":1,\"443\":1,\"445\":1,\"569\":1}}],[\"1688\",{\"1\":{\"394\":1}}],[\"16s\",{\"1\":{\"396\":1}}],[\"1635\",{\"1\":{\"395\":1}}],[\"1663\",{\"1\":{\"395\":1}}],[\"1650\",{\"1\":{\"312\":1}}],[\"164\",{\"1\":{\"287\":1}}],[\"16\",{\"1\":{\"101\":1,\"116\":2,\"130\":1,\"140\":1,\"152\":2,\"174\":1,\"272\":2,\"286\":1,\"347\":1,\"368\":1,\"390\":1,\"392\":2,\"396\":1,\"521\":1,\"599\":1,\"640\":2,\"641\":2,\"642\":1,\"643\":2,\"644\":1}}],[\"16序列的的编码和解码\",{\"1\":{\"43\":1}}],[\"153\",{\"1\":{\"404\":1}}],[\"1538\",{\"1\":{\"395\":1}}],[\"15s\",{\"1\":{\"396\":2}}],[\"151\",{\"1\":{\"395\":1}}],[\"1526\",{\"1\":{\"395\":1}}],[\"1592\",{\"1\":{\"395\":1}}],[\"1556\",{\"1\":{\"395\":1}}],[\"1507\",{\"1\":{\"395\":1}}],[\"150\",{\"1\":{\"177\":1}}],[\"15e+0\",{\"1\":{\"101\":1}}],[\"15\",{\"1\":{\"101\":2,\"140\":1,\"152\":1,\"236\":2,\"245\":2,\"247\":6,\"372\":2,\"378\":1,\"391\":1,\"392\":1,\"396\":1,\"404\":1,\"408\":1,\"525\":2,\"528\":5,\"543\":1,\"580\":1,\"581\":1,\"631\":2}}],[\"1188983000\",{\"1\":{\"395\":1}}],[\"11800h\",{\"1\":{\"394\":1,\"395\":3}}],[\"1158000\",{\"1\":{\"395\":1}}],[\"1153796000\",{\"1\":{\"394\":1}}],[\"11th\",{\"1\":{\"394\":1,\"395\":3}}],[\"110\",{\"1\":{\"390\":5}}],[\"11官方终于推出了go\",{\"1\":{\"361\":1}}],[\"1123\",{\"1\":{\"395\":2}}],[\"1123163300\",{\"1\":{\"395\":1}}],[\"112\",{\"1\":{\"358\":2}}],[\"117\",{\"1\":{\"245\":10}}],[\"114154\",{\"1\":{\"360\":1}}],[\"114514\",{\"1\":{\"256\":1,\"277\":1,\"278\":2,\"280\":2,\"334\":1}}],[\"114\",{\"1\":{\"177\":1,\"585\":2}}],[\"119\",{\"1\":{\"177\":1,\"521\":1}}],[\"111\",{\"1\":{\"177\":4,\"390\":5,\"391\":1,\"392\":1,\"576\":1,\"590\":2}}],[\"1162108\",{\"1\":{\"395\":1}}],[\"116\",{\"1\":{\"172\":1}}],[\"11i\",{\"1\":{\"102\":1}}],[\"11\",{\"1\":{\"101\":1,\"140\":1,\"224\":1,\"229\":1,\"237\":8,\"280\":2,\"368\":2,\"372\":2,\"373\":2,\"378\":1,\"404\":1,\"577\":1,\"579\":1,\"593\":1,\"611\":1,\"613\":1,\"629\":1,\"631\":2,\"641\":1,\"642\":1}}],[\"10>2\",{\"1\":{\"617\":1}}],[\"10+12\",{\"1\":{\"592\":1}}],[\"106\",{\"1\":{\"408\":1}}],[\"1068\",{\"1\":{\"395\":1}}],[\"1068682\",{\"1\":{\"395\":1}}],[\"105\",{\"1\":{\"408\":1}}],[\"10569473\",{\"1\":{\"396\":2}}],[\"1056570\",{\"1\":{\"395\":1}}],[\"1097800\",{\"1\":{\"395\":1}}],[\"1098\",{\"1\":{\"395\":1}}],[\"10345\",{\"1\":{\"395\":1}}],[\"10355\",{\"1\":{\"395\":1}}],[\"10352\",{\"1\":{\"395\":1}}],[\"10313\",{\"1\":{\"395\":1}}],[\"10297\",{\"1\":{\"395\":1}}],[\"1022\",{\"1\":{\"544\":1}}],[\"10222\",{\"1\":{\"395\":1}}],[\"10225\",{\"1\":{\"395\":1}}],[\"10237\",{\"1\":{\"395\":1}}],[\"10208\",{\"1\":{\"395\":1}}],[\"10213\",{\"1\":{\"395\":1}}],[\"10217\",{\"1\":{\"395\":2}}],[\"10216\",{\"1\":{\"395\":1}}],[\"10219\",{\"1\":{\"394\":1}}],[\"10243\",{\"1\":{\"394\":1}}],[\"1024\",{\"1\":{\"142\":1,\"163\":2,\"227\":2,\"257\":2,\"273\":1,\"279\":1,\"297\":2,\"620\":4}}],[\"10个协程执行10个+1操作\",{\"1\":{\"348\":1}}],[\"10个斐波那契数\",{\"1\":{\"201\":1}}],[\"1080713900\",{\"1\":{\"395\":1}}],[\"108\",{\"1\":{\"177\":7}}],[\"10139\",{\"1\":{\"395\":1}}],[\"10141\",{\"1\":{\"395\":1}}],[\"10147\",{\"1\":{\"395\":1}}],[\"10111\",{\"1\":{\"395\":1}}],[\"10158\",{\"1\":{\"395\":1}}],[\"10195\",{\"1\":{\"395\":1}}],[\"10171\",{\"1\":{\"394\":1}}],[\"10126\",{\"1\":{\"394\":1}}],[\"101\",{\"1\":{\"177\":3,\"390\":14,\"391\":2,\"392\":32,\"393\":3,\"593\":1}}],[\"1045291300\",{\"1\":{\"395\":1}}],[\"1042\",{\"1\":{\"395\":1}}],[\"10406\",{\"1\":{\"395\":1}}],[\"104\",{\"1\":{\"177\":3,\"408\":1,\"521\":1}}],[\"1006019\",{\"1\":{\"395\":1}}],[\"100644\",{\"1\":{\"368\":5}}],[\"100倍左右\",{\"1\":{\"355\":1}}],[\"10002\",{\"1\":{\"395\":1}}],[\"10001\",{\"1\":{\"395\":1}}],[\"100000\",{\"1\":{\"266\":1}}],[\"10000\",{\"1\":{\"188\":1,\"394\":1}}],[\"1000\",{\"1\":{\"152\":1,\"233\":1,\"331\":1,\"349\":2,\"350\":3,\"351\":3,\"354\":2,\"630\":3}}],[\"100+3\",{\"1\":{\"147\":1}}],[\"100k\",{\"1\":{\"100\":1}}],[\"100\",{\"1\":{\"100\":1,\"128\":1,\"130\":1,\"147\":3,\"148\":4,\"152\":2,\"164\":2,\"177\":1,\"184\":1,\"185\":1,\"196\":1,\"239\":2,\"245\":11,\"259\":1,\"270\":1,\"298\":2,\"345\":1,\"355\":2,\"364\":3,\"368\":4,\"393\":1,\"394\":2,\"556\":1,\"561\":1,\"640\":1}}],[\"10k\",{\"1\":{\"100\":1}}],[\"10\",{\"1\":{\"100\":1,\"111\":2,\"140\":1,\"143\":3,\"152\":1,\"153\":3,\"154\":4,\"155\":4,\"164\":4,\"165\":3,\"178\":1,\"180\":3,\"181\":1,\"182\":1,\"184\":2,\"185\":4,\"195\":1,\"196\":3,\"201\":2,\"202\":1,\"219\":4,\"225\":1,\"229\":2,\"237\":1,\"238\":5,\"239\":5,\"241\":1,\"242\":2,\"245\":1,\"246\":2,\"263\":3,\"294\":3,\"295\":1,\"331\":6,\"336\":2,\"339\":5,\"341\":2,\"348\":2,\"349\":4,\"353\":2,\"355\":5,\"372\":2,\"378\":1,\"390\":14,\"391\":2,\"392\":32,\"393\":2,\"395\":4,\"408\":1,\"415\":2,\"426\":1,\"427\":2,\"428\":1,\"444\":1,\"521\":1,\"549\":2,\"556\":1,\"561\":1,\"574\":1,\"593\":2,\"606\":2,\"617\":1,\"629\":1,\"631\":2,\"632\":2}}],[\"1q\",{\"1\":{\"64\":1}}],[\"1兼容\",{\"1\":{\"63\":1}}],[\"141593\",{\"1\":{\"590\":1}}],[\"14159261234567891011\",{\"1\":{\"590\":1}}],[\"14159265358979323846264338327950288419716939937510582097494459\",{\"1\":{\"545\":1}}],[\"1415926\",{\"1\":{\"256\":1,\"599\":1,\"617\":2}}],[\"145114\",{\"1\":{\"589\":2}}],[\"14k\",{\"1\":{\"395\":1}}],[\"1422773729\",{\"1\":{\"225\":1}}],[\"140\",{\"1\":{\"177\":1}}],[\"149\",{\"1\":{\"177\":1}}],[\"14\",{\"1\":{\"61\":1,\"140\":1,\"152\":1,\"224\":1,\"236\":3,\"239\":9,\"372\":2,\"378\":1,\"390\":3,\"407\":1,\"408\":1,\"423\":1,\"425\":1,\"617\":1,\"624\":2}}],[\"1和fnv\",{\"1\":{\"43\":1}}],[\"1数据结构\",{\"1\":{\"43\":1}}],[\"1解析和序列化的共享的\",{\"1\":{\"43\":1}}],[\"1协议\",{\"1\":{\"43\":1}}],[\"1\",{\"0\":{\"69\":2,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"77\":1,\"83\":1,\"87\":1},\"1\":{\"43\":2,\"49\":1,\"64\":2,\"84\":2,\"98\":2,\"101\":3,\"102\":1,\"106\":1,\"110\":1,\"125\":9,\"127\":14,\"128\":7,\"129\":5,\"130\":7,\"131\":6,\"140\":13,\"143\":2,\"147\":4,\"149\":7,\"150\":1,\"151\":2,\"152\":15,\"154\":3,\"155\":2,\"158\":6,\"159\":1,\"160\":11,\"162\":1,\"163\":1,\"164\":6,\"165\":3,\"166\":6,\"167\":2,\"169\":11,\"170\":2,\"178\":2,\"179\":4,\"180\":2,\"181\":3,\"182\":2,\"183\":2,\"185\":1,\"195\":4,\"200\":3,\"201\":5,\"202\":4,\"203\":1,\"204\":8,\"205\":2,\"206\":10,\"213\":9,\"217\":2,\"218\":1,\"220\":1,\"221\":2,\"223\":8,\"224\":1,\"225\":10,\"226\":1,\"228\":1,\"229\":2,\"231\":1,\"232\":1,\"233\":2,\"241\":1,\"242\":1,\"243\":1,\"245\":1,\"246\":4,\"247\":2,\"256\":2,\"257\":4,\"258\":1,\"259\":3,\"260\":1,\"262\":2,\"263\":10,\"272\":1,\"283\":1,\"286\":1,\"289\":2,\"290\":1,\"294\":1,\"295\":2,\"300\":4,\"302\":1,\"303\":1,\"304\":3,\"305\":2,\"309\":2,\"315\":9,\"317\":1,\"322\":3,\"327\":1,\"331\":3,\"333\":1,\"334\":1,\"336\":9,\"337\":10,\"338\":2,\"339\":2,\"340\":6,\"341\":8,\"345\":3,\"346\":1,\"347\":1,\"348\":2,\"349\":2,\"350\":5,\"351\":2,\"353\":2,\"354\":1,\"355\":3,\"356\":1,\"363\":1,\"368\":8,\"372\":17,\"373\":3,\"374\":2,\"376\":2,\"378\":12,\"381\":1,\"382\":2,\"384\":1,\"389\":1,\"394\":2,\"395\":6,\"396\":10,\"404\":1,\"408\":1,\"411\":7,\"412\":5,\"413\":7,\"414\":4,\"415\":2,\"425\":4,\"427\":2,\"429\":1,\"433\":1,\"434\":1,\"435\":1,\"444\":6,\"458\":1,\"465\":1,\"469\":2,\"470\":2,\"473\":1,\"480\":1,\"481\":2,\"482\":4,\"484\":2,\"513\":1,\"515\":1,\"521\":3,\"539\":1,\"541\":1,\"543\":17,\"544\":6,\"545\":7,\"546\":1,\"547\":2,\"548\":2,\"549\":2,\"551\":4,\"552\":2,\"555\":2,\"556\":1,\"561\":2,\"563\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"574\":1,\"576\":1,\"577\":2,\"579\":2,\"580\":1,\"581\":1,\"586\":2,\"589\":2,\"590\":4,\"592\":3,\"593\":2,\"597\":4,\"599\":1,\"604\":2,\"605\":1,\"607\":4,\"617\":5,\"619\":3,\"620\":11,\"621\":3,\"622\":2,\"624\":2,\"625\":3,\"630\":3,\"637\":1,\"640\":4,\"643\":3,\"644\":1,\"645\":2,\"646\":1}}],[\"18s\",{\"1\":{\"396\":1}}],[\"18推出的一个新功能\",{\"1\":{\"396\":1}}],[\"1818\",{\"1\":{\"395\":1}}],[\"18引入的关于多模块管理的一个新的解决方案\",{\"1\":{\"381\":1}}],[\"18刚推出泛型的时候确实导致编译更慢了\",{\"1\":{\"264\":1}}],[\"18以后\",{\"1\":{\"259\":1}}],[\"18版本加入了对泛型的支持\",{\"1\":{\"255\":1}}],[\"18版本更新之后\",{\"1\":{\"163\":1}}],[\"18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的\",{\"1\":{\"163\":1}}],[\"18最大的变化就是加入了泛型\",{\"1\":{\"208\":1}}],[\"18时\",{\"1\":{\"208\":1}}],[\"184s\",{\"1\":{\"396\":1}}],[\"184\",{\"1\":{\"177\":1}}],[\"18\",{\"1\":{\"49\":1,\"84\":2,\"140\":1,\"152\":2,\"184\":1,\"189\":2,\"190\":1,\"226\":2,\"263\":1,\"284\":1,\"298\":2,\"372\":2,\"378\":1,\"396\":6,\"408\":1,\"415\":1,\"423\":1,\"424\":1,\"425\":1,\"511\":1,\"512\":1,\"517\":2,\"520\":2,\"531\":1,\"580\":1,\"581\":1,\"592\":1,\"626\":2,\"627\":2,\"628\":3,\"629\":1,\"643\":2}}],[\"180\",{\"1\":{\"43\":2}}],[\"186\",{\"1\":{\"43\":2}}],[\"1中所定义的rsa加密\",{\"1\":{\"43\":1}}],[\"zh\",{\"1\":{\"623\":4}}],[\"zscore\",{\"1\":{\"482\":1}}],[\"zcount\",{\"1\":{\"482\":1}}],[\"zremrangebyscore\",{\"1\":{\"484\":1}}],[\"zremrangebyrank\",{\"1\":{\"484\":1}}],[\"zrem\",{\"1\":{\"484\":1}}],[\"zrevrank\",{\"1\":{\"481\":1}}],[\"zrangeby\",{\"1\":{\"482\":1}}],[\"zrangebyscore\",{\"1\":{\"482\":1}}],[\"zrange\",{\"1\":{\"482\":1}}],[\"zrank\",{\"1\":{\"481\":1}}],[\"zadd\",{\"1\":{\"480\":1}}],[\"z并不一定真实存在\",{\"1\":{\"378\":1}}],[\"zero实现原理\",{\"0\":{\"506\":1}}],[\"zero使用\",{\"0\":{\"504\":1}}],[\"zero\",{\"1\":{\"249\":1,\"611\":2}}],[\"zeromq\",{\"1\":{\"47\":1}}],[\"z\",{\"1\":{\"95\":1,\"378\":1,\"480\":2,\"483\":1}}],[\"zlib\",{\"1\":{\"43\":1}}],[\"zincr\",{\"1\":{\"483\":1}}],[\"zinx\",{\"1\":{\"251\":1}}],[\"ziv\",{\"1\":{\"43\":1}}],[\"zip压缩归档的包\",{\"1\":{\"508\":1}}],[\"ziphash\",{\"1\":{\"376\":1,\"379\":3}}],[\"zip\",{\"1\":{\"43\":1,\"51\":1,\"376\":1,\"379\":3,\"508\":1}}],[\"zookeeper\",{\"1\":{\"41\":1}}],[\"zookeeper客户端\",{\"1\":{\"41\":1}}],[\"如需深究\",{\"1\":{\"564\":1}}],[\"如chan<\",{\"1\":{\"338\":1}}],[\"如<\",{\"1\":{\"338\":1}}],[\"如此一来输出的顺序将会无法确定\",{\"1\":{\"392\":1}}],[\"如此一来实现了读协程与写协程互斥\",{\"1\":{\"350\":1}}],[\"如此一来\",{\"1\":{\"243\":1,\"336\":1,\"337\":1,\"349\":1,\"368\":1}}],[\"如此一来就占用的内存就变为了16字节\",{\"1\":{\"192\":1}}],[\"如数组\",{\"1\":{\"153\":1}}],[\"如结构体\",{\"1\":{\"129\":1}}],[\"如下方式可以通过uintptr获得一个指针\",{\"1\":{\"643\":1}}],[\"如下方的例子\",{\"1\":{\"390\":1}}],[\"如下图所示\",{\"1\":{\"369\":1}}],[\"如下面的例子\",{\"1\":{\"353\":1}}],[\"如下例\",{\"1\":{\"260\":1,\"335\":1,\"339\":1,\"376\":1}}],[\"如下的代码将会无法通过编译\",{\"1\":{\"258\":1}}],[\"如下的代码将无法通过编译\",{\"1\":{\"258\":1}}],[\"如下所图\",{\"1\":{\"243\":1}}],[\"如下所示\",{\"1\":{\"197\":1,\"200\":1,\"203\":1,\"219\":1,\"242\":1,\"243\":2,\"259\":1,\"270\":2,\"317\":1,\"381\":1,\"406\":1,\"615\":1,\"617\":2,\"620\":1}}],[\"如下是正确示例\",{\"1\":{\"158\":1}}],[\"如下\",{\"1\":{\"98\":1,\"142\":1,\"177\":2,\"186\":1,\"213\":1,\"218\":1,\"220\":1,\"256\":4,\"262\":1,\"263\":1,\"266\":1,\"287\":1,\"303\":1,\"340\":1,\"347\":1,\"348\":1,\"350\":1,\"353\":1,\"354\":1,\"390\":1,\"391\":1,\"392\":1,\"396\":1,\"427\":1,\"622\":1,\"645\":1}}],[\"如果管道操作返回的值为空\",{\"1\":{\"622\":1}}],[\"如果值为空的话\",{\"1\":{\"622\":1}}],[\"如果值为nan\",{\"1\":{\"181\":1}}],[\"如果为负数会导致panic\",{\"1\":{\"606\":1}}],[\"如果为空的话则使用默认的处理器\",{\"1\":{\"535\":1}}],[\"如果映射返回负值\",{\"1\":{\"605\":1}}],[\"如果a>b\",{\"1\":{\"597\":1}}],[\"如果auth模块想要使用user模块中的代码只有两种办法\",{\"1\":{\"382\":1}}],[\"如果f是具有适当签名的函数\",{\"1\":{\"537\":1}}],[\"如果结构体有json标签的话\",{\"1\":{\"520\":1}}],[\"如果设置为true\",{\"1\":{\"444\":1}}],[\"如果如果过程出错了\",{\"1\":{\"439\":1}}],[\"如果传入一个空字符串\",{\"1\":{\"596\":1}}],[\"如果传入的是非utf8字符串\",{\"1\":{\"396\":1}}],[\"如果传递的是一个整型\",{\"1\":{\"206\":1}}],[\"如果将其以字节为单位反转后肯定是乱码\",{\"1\":{\"396\":1}}],[\"如果将set的参数换成c\",{\"1\":{\"221\":1}}],[\"如果单次测试执行时间超过了时间间隔d\",{\"1\":{\"388\":1}}],[\"如果单纯的在结构体中混用值接收者和指针接收者的话无伤大雅\",{\"1\":{\"206\":1}}],[\"如果加上了\",{\"1\":{\"387\":1}}],[\"如果想根据测试类型再划分的更细一些也可以将测试类型为作为文件前缀\",{\"1\":{\"386\":1}}],[\"如果想要处理空的情况\",{\"1\":{\"622\":1}}],[\"如果想要自定义结构体排序的话\",{\"1\":{\"580\":1}}],[\"如果想要对结构体进行序列化与反序列化\",{\"1\":{\"509\":1}}],[\"如果想要对一个文件写入数据\",{\"1\":{\"321\":1}}],[\"如果想要禁用缓存\",{\"1\":{\"387\":1}}],[\"如果想要在错误链中找到对应的值或类型\",{\"1\":{\"312\":1}}],[\"如果想要获取方法的参数和返回值细节\",{\"1\":{\"289\":1}}],[\"如果想要进行反射操作\",{\"1\":{\"267\":1}}],[\"如果想要了解更多关于泛型的一些设计理念和细节\",{\"1\":{\"264\":1}}],[\"如果想要了解更多关于泛型的实际案例\",{\"1\":{\"264\":1}}],[\"如果想要关闭这个检查\",{\"1\":{\"219\":1}}],[\"如果想要更详细的介绍\",{\"1\":{\"215\":1}}],[\"如果想要清空切片\",{\"1\":{\"170\":1}}],[\"如果想要交换两个变量的值\",{\"1\":{\"127\":1}}],[\"如果符合在下载模块校验时不会走checksum的公共数据库\",{\"1\":{\"380\":1}}],[\"如果符合规则在下载模块时不会走goproxy\",{\"1\":{\"380\":1}}],[\"如果模块名符合规则表示该模块为私有模块\",{\"1\":{\"380\":1}}],[\"如果哈希值不一致\",{\"1\":{\"379\":1}}],[\"如果一致的话\",{\"1\":{\"379\":1}}],[\"如果一个类型的底层类型属于该类型集\",{\"1\":{\"259\":1}}],[\"如果一个接口包含多个非空类型集\",{\"1\":{\"259\":1}}],[\"如果一个问题需要根据不同类型做出不同的逻辑\",{\"1\":{\"258\":1}}],[\"如果一个本该分配到栈上的变量被分配到了堆上\",{\"1\":{\"235\":1}}],[\"如果本地计算出的哈希值与查询得到的结果不一致\",{\"1\":{\"379\":1}}],[\"如果替换模块具有\",{\"1\":{\"378\":1}}],[\"如果同时有require引用了相同版本的依赖\",{\"1\":{\"378\":1}}],[\"如果原有项目引用了老版本\",{\"1\":{\"378\":1}}],[\"如果版本升级到了v2\",{\"1\":{\"378\":1}}],[\"如果未开启\",{\"1\":{\"363\":1}}],[\"如果内存值与期望值相同\",{\"1\":{\"359\":1}}],[\"如果出现了其他情况\",{\"1\":{\"356\":1}}],[\"如果出现类型不匹配的情况时\",{\"1\":{\"300\":1}}],[\"如果该key已存在\",{\"1\":{\"355\":1}}],[\"如果用了不释放那么对象池的使用将毫无意义\",{\"1\":{\"354\":1}}],[\"如果只有一个协程使用肯定是没有任何问题的\",{\"1\":{\"353\":1}}],[\"如果这些数据结构太过庞大\",{\"1\":{\"353\":1}}],[\"如果这样做的话\",{\"1\":{\"225\":1}}],[\"如果小于3就会一直阻塞等待\",{\"1\":{\"351\":1}}],[\"如果直接传入读写互斥锁会导致写协程重复解锁的问题\",{\"1\":{\"351\":1}}],[\"如果直到子协程退出都没有恢复panic\",{\"1\":{\"315\":1}}],[\"如果获得了写锁\",{\"1\":{\"350\":1}}],[\"如果获得了读锁\",{\"1\":{\"350\":1}}],[\"如果创建了但从来不取消\",{\"1\":{\"347\":1}}],[\"如果创建了一个cancelctx\",{\"1\":{\"346\":1}}],[\"如果所有的父级都没有实现canceler\",{\"1\":{\"346\":1}}],[\"如果所有case都不可用\",{\"1\":{\"340\":1}}],[\"如果父级实现了canceler\",{\"1\":{\"346\":1}}],[\"如果key不存在\",{\"1\":{\"343\":1}}],[\"如果关闭过后\",{\"1\":{\"343\":1}}],[\"如果其父目录不存在\",{\"1\":{\"321\":1}}],[\"如果文件不存在则创建文件\",{\"1\":{\"319\":1}}],[\"如果没有\",{\"1\":{\"396\":1}}],[\"如果没有设置则一直为false\",{\"1\":{\"343\":1}}],[\"如果没有缓冲区则会导致死锁\",{\"1\":{\"334\":1}}],[\"如果没有waitgroup来阻塞父协程的话\",{\"1\":{\"315\":1}}],[\"如果没能按照正确的格式书写结构体\",{\"1\":{\"191\":1}}],[\"如果使用互斥锁\",{\"1\":{\"350\":1}}],[\"如果使用if\",{\"1\":{\"312\":1}}],[\"如果使用闭包而不是延迟调用\",{\"1\":{\"204\":1}}],[\"如果错误为nil的话那么就是打开成功\",{\"1\":{\"307\":1}}],[\"如果打开失败函数将会返回一个错误\",{\"1\":{\"307\":1}}],[\"如果返回reflect\",{\"1\":{\"287\":1}}],[\"如果返回的内存被引用了\",{\"1\":{\"219\":1}}],[\"如果开发一个数学工具包\",{\"1\":{\"256\":1}}],[\"如果开启了cgo\",{\"1\":{\"226\":1}}],[\"如果是用于展示在前端的html文件\",{\"1\":{\"628\":1}}],[\"如果是多维切片\",{\"1\":{\"617\":1}}],[\"如果是子测试中使用将会panic\",{\"1\":{\"391\":1}}],[\"如果是reflect\",{\"1\":{\"279\":1}}],[\"如果是自动采集\",{\"1\":{\"247\":1}}],[\"如果是手动采集的数据\",{\"1\":{\"247\":1}}],[\"如果是一个切片\",{\"1\":{\"206\":1}}],[\"如果数据是由web采集的话\",{\"1\":{\"245\":1,\"246\":1}}],[\"如果别人用了你的库\",{\"1\":{\"233\":1}}],[\"如果不使用slicedata\",{\"1\":{\"645\":1}}],[\"如果不懂什么是内存对齐\",{\"1\":{\"642\":1}}],[\"如果不遵循此规则的模块被称为不规范模块\",{\"1\":{\"378\":1}}],[\"如果不成功的话就不断循环\",{\"1\":{\"359\":1}}],[\"如果不采用对象池的话1000个协程将会创建1000个对象\",{\"1\":{\"354\":1}}],[\"如果不采用对象池\",{\"1\":{\"354\":1}}],[\"如果不将其捕获的话\",{\"1\":{\"313\":1}}],[\"如果不存在\",{\"1\":{\"288\":2}}],[\"如果不去手动释放\",{\"1\":{\"229\":1}}],[\"如果不导入的话就无法使用go导出的函数\",{\"1\":{\"219\":1}}],[\"如果c结构体的某些成员包含bit\",{\"1\":{\"226\":1}}],[\"如果c代码非常多\",{\"1\":{\"217\":1}}],[\"如果有多组数据狠起来就不是很直观\",{\"1\":{\"393\":1}}],[\"如果有几十万个协程或者说创建该对象的成本十分的高昂\",{\"1\":{\"354\":1}}],[\"如果有的话也建议通过网络通信来代替\",{\"1\":{\"219\":1}}],[\"如果有包名重复了\",{\"1\":{\"94\":1}}],[\"如果尝试对不可比较的类型进行比较\",{\"1\":{\"213\":1}}],[\"如果底层的类型是不可比较的\",{\"1\":{\"213\":1}}],[\"如果类型不匹配的话则为false\",{\"1\":{\"213\":1}}],[\"如果类型实现了string接口也会调用string方法来获取其字符串表现形式\",{\"1\":{\"138\":1}}],[\"如果t实现了一个接口\",{\"1\":{\"208\":1}}],[\"如果对其添加元素的话\",{\"1\":{\"206\":1}}],[\"如果签名不一样那就是两个完全不同的函数\",{\"1\":{\"197\":1}}],[\"如果参数只有简单几个\",{\"1\":{\"188\":1}}],[\"如果实例化过程比较复杂\",{\"1\":{\"187\":1}}],[\"如果冲突会触发fatal\",{\"1\":{\"185\":1}}],[\"如果要在c和go之间传递指针\",{\"1\":{\"229\":1}}],[\"如果要导出go函数\",{\"1\":{\"219\":1}}],[\"如果要转换的字符串或字节切片很大\",{\"1\":{\"173\":1}}],[\"如果要对转换后的切片进行修改\",{\"1\":{\"160\":1}}],[\"如果事先就知道了要存放数据的长度\",{\"1\":{\"157\":1}}],[\"如果你打算修改数据\",{\"1\":{\"648\":1}}],[\"如果你是1\",{\"1\":{\"575\":1}}],[\"如果你是es8\",{\"1\":{\"403\":1}}],[\"如果你使用的redis版本号为7\",{\"1\":{\"442\":1}}],[\"如果你使用的redis版本号为6\",{\"1\":{\"442\":1}}],[\"如果你不会请先自行学习\",{\"1\":{\"431\":1}}],[\"如果你没有mongo基础\",{\"1\":{\"418\":1}}],[\"如果你对elasticsearch并不了解\",{\"1\":{\"402\":1}}],[\"如果你对逃逸分析的细节感兴趣\",{\"1\":{\"236\":1}}],[\"如果你能接受go的错误处理\",{\"1\":{\"307\":1}}],[\"如果你想使用orm\",{\"1\":{\"431\":1}}],[\"如果你想要进行微服务开发\",{\"1\":{\"249\":1}}],[\"如果你想要在网页中下载数据文件\",{\"1\":{\"243\":1}}],[\"如果你想以多种方式实例化结构体\",{\"1\":{\"187\":1}}],[\"如果你觉得在传递切片或map时会复制大量的内存\",{\"1\":{\"198\":1}}],[\"如果你真的将语法篇和进阶篇都仔细阅读完了\",{\"1\":{\"248\":1}}],[\"如果你真的想通过此种方法来节省内存\",{\"1\":{\"192\":1}}],[\"如果你真的这么做了\",{\"1\":{\"108\":1}}],[\"如果你学过c系语言\",{\"1\":{\"140\":1}}],[\"如果仅仅只是声明而不指定值\",{\"1\":{\"130\":1}}],[\"如果需要\",{\"1\":{\"64\":1}}],[\"如内存管理\",{\"1\":{\"67\":1}}],[\"如https\",{\"1\":{\"64\":1}}],[\"如rfc\",{\"1\":{\"64\":2}}],[\"如\",{\"1\":{\"56\":1,\"77\":1,\"79\":1,\"85\":1,\"89\":1}}],[\"如互斥锁\",{\"1\":{\"43\":1}}],[\"如控制goroutine的函数\",{\"1\":{\"43\":1}}],[\"如服务器中的运算计数器\",{\"1\":{\"43\":1}}],[\"为测试执行gomaxprocs\",{\"1\":{\"388\":1}}],[\"为\",{\"1\":{\"370\":1}}],[\"为完全相等\",{\"1\":{\"298\":1}}],[\"为此\",{\"1\":{\"519\":1}}],[\"为此就需要用到锁\",{\"1\":{\"348\":1}}],[\"为此就需要使用工具来进行逃逸分析\",{\"1\":{\"236\":1}}],[\"为此可以使用c中的errno\",{\"1\":{\"217\":1}}],[\"为其分配内存空间\",{\"1\":{\"222\":1}}],[\"为了保险都会加一句defer\",{\"1\":{\"439\":1}}],[\"为了解决这类问题\",{\"1\":{\"381\":1}}],[\"为了解决这个问题\",{\"1\":{\"361\":1}}],[\"为了并发安全肯定需要做出一定的牺牲\",{\"1\":{\"355\":1}}],[\"为了让对象池中的缓冲区大小大致相同以便更好的弹性控制缓冲区大小\",{\"1\":{\"354\":1}}],[\"为了更好的维护性\",{\"1\":{\"309\":1}}],[\"为了方便起见\",{\"1\":{\"213\":1}}],[\"为了能够匹配上接收者的类型\",{\"1\":{\"205\":1}}],[\"为了便于阅读\",{\"1\":{\"100\":1}}],[\"为什么不在语言层面支持枚举是笔者非常不能理解的一件事\",{\"1\":{\"132\":1}}],[\"为什么a+b的结果还是1\",{\"1\":{\"127\":1}}],[\"为go设计的跨平台本机gui\",{\"1\":{\"57\":1}}],[\"为go加载open\",{\"1\":{\"51\":1}}],[\"为您提供sync\",{\"1\":{\"56\":1}}],[\"为taglib绑定\",{\"1\":{\"45\":1}}],[\"为template构建解析树\",{\"1\":{\"43\":1}}],[\"为音乐应用程序基于序列转到本地音频混合器\",{\"1\":{\"45\":1}}],[\"为utf\",{\"1\":{\"43\":1}}],[\"为rpc包实现了一个json\",{\"1\":{\"43\":1}}],[\"为复数提供了基本的常量和数学函数\",{\"1\":{\"43\":1}}],[\"为操作系统功能实现了一个平台无关的接口\",{\"1\":{\"43\":1}}],[\"为公共变量提供了一个标准的接口\",{\"1\":{\"43\":1}}],[\"收集了常见的加密常数\",{\"1\":{\"43\":1}}],[\"见识过mysql性能瓶颈之后你会想要选择的一款数据库\",{\"1\":{\"42\":1}}],[\"比\",{\"1\":{\"87\":1}}],[\"比较巧妙\",{\"1\":{\"603\":1}}],[\"比较字符串\",{\"0\":{\"597\":1}}],[\"比较方法\",{\"1\":{\"575\":1,\"580\":1}}],[\"比较器由调用者提供\",{\"1\":{\"263\":1}}],[\"比较\",{\"0\":{\"87\":1,\"88\":1,\"89\":1,\"128\":1}}],[\"比较全能\",{\"1\":{\"42\":1}}],[\"比传统线程更加轻量\",{\"1\":{\"70\":1}}],[\"比net\",{\"1\":{\"64\":1}}],[\"比基于通道的信号量实现更快\",{\"1\":{\"56\":1}}],[\"比如数组和结构体\",{\"1\":{\"643\":1}}],[\"比如数字字符串\",{\"1\":{\"617\":1}}],[\"比如template\",{\"1\":{\"628\":1}}],[\"比如pongo2\",{\"1\":{\"614\":1}}],[\"比如pdf\",{\"1\":{\"245\":1}}],[\"比如在直接挂到后端的静态html页面就需要用到模板引擎\",{\"1\":{\"614\":1}}],[\"比如sha1\",{\"1\":{\"508\":1}}],[\"比如string\",{\"1\":{\"178\":1}}],[\"比如json\",{\"1\":{\"508\":1}}],[\"比如你可以不用任何外部依赖\",{\"1\":{\"508\":1}}],[\"比如通过ping\",{\"1\":{\"404\":1}}],[\"比如增删改查之类的\",{\"1\":{\"402\":1}}],[\"比如将上述t\",{\"1\":{\"391\":1}}],[\"比如将person修改为下面这种\",{\"1\":{\"226\":1}}],[\"比如想要执行test包下所有的测试用例\",{\"1\":{\"387\":1}}],[\"比如hello库就有一个专属的文档页面\",{\"1\":{\"369\":1}}],[\"比如因cas引起aba问题\",{\"1\":{\"359\":1}}],[\"比如整型类型都会提供add方法来实现原子加减操作\",{\"1\":{\"358\":1}}],[\"比如上述的例子输出可能如下\",{\"1\":{\"354\":1}}],[\"比如协程a和b同时调用了add方法\",{\"1\":{\"353\":1}}],[\"比如再开几个子协程破坏了不变量\",{\"1\":{\"348\":1}}],[\"比如5分钟后\",{\"1\":{\"347\":1}}],[\"比如指定一个具体时间2023\",{\"1\":{\"347\":1}}],[\"比如webrtc\",{\"1\":{\"254\":1}}],[\"比如docker\",{\"1\":{\"254\":1}}],[\"比如gzip\",{\"1\":{\"508\":1}}],[\"比如github\",{\"1\":{\"378\":1}}],[\"比如git\",{\"1\":{\"362\":1}}],[\"比如gin\",{\"1\":{\"243\":1}}],[\"比如gotest\",{\"1\":{\"233\":1}}],[\"比如之前提到过的\",{\"1\":{\"193\":1}}],[\"比如os\",{\"1\":{\"126\":1}}],[\"比如\",{\"1\":{\"125\":2,\"130\":1,\"140\":1,\"220\":2,\"432\":1,\"619\":1,\"624\":1,\"625\":1}}],[\"比如下面这个代码\",{\"1\":{\"206\":1}}],[\"比如下面这个例子\",{\"1\":{\"94\":1,\"204\":1}}],[\"比如下面的例子\",{\"1\":{\"173\":1,\"307\":1,\"625\":1}}],[\"比如下面的代码只是声明了变量\",{\"1\":{\"125\":1}}],[\"比如下面的一个例子\",{\"1\":{\"93\":1}}],[\"比如从一个对象序列化为json字符串\",{\"1\":{\"40\":1}}],[\"比如读写文件\",{\"1\":{\"40\":1}}],[\"比如提供了对os中系统相关的io功能的封装\",{\"1\":{\"40\":1}}],[\"项目\",{\"1\":{\"42\":1}}],[\"项目主页配置\",{\"1\":{\"0\":1}}],[\"项目主页\",{\"0\":{\"0\":1}}],[\"u754c\",{\"1\":{\"588\":1}}],[\"u4e16\",{\"1\":{\"588\":1}}],[\"u转义\",{\"1\":{\"588\":1}}],[\"udp大体上的写法也都是类似的\",{\"1\":{\"574\":1}}],[\"udp4\",{\"1\":{\"571\":1}}],[\"udp4addr\",{\"1\":{\"571\":2}}],[\"udpaddr\",{\"1\":{\"571\":1}}],[\"udp6addr\",{\"1\":{\"571\":2}}],[\"udp6\",{\"1\":{\"571\":2}}],[\"udp地址支持udp4\",{\"1\":{\"571\":1}}],[\"udp地址\",{\"0\":{\"571\":1}}],[\"udp协议\",{\"1\":{\"565\":1}}],[\"udp域名解析和unix域套接字\",{\"1\":{\"43\":1}}],[\"uk\",{\"1\":{\"426\":1,\"427\":1,\"429\":3}}],[\"uoy\",{\"1\":{\"396\":1}}],[\"u=\",{\"1\":{\"379\":1}}],[\"uber\",{\"1\":{\"379\":1}}],[\"ugorji\",{\"1\":{\"372\":2,\"378\":1}}],[\"uptrace\",{\"1\":{\"441\":1}}],[\"upsertedid\",{\"1\":{\"427\":1}}],[\"upsertedcount\",{\"1\":{\"427\":1}}],[\"upres\",{\"1\":{\"427\":6}}],[\"updatemany\",{\"1\":{\"427\":1}}],[\"updateone\",{\"1\":{\"427\":2}}],[\"updated\",{\"1\":{\"413\":1}}],[\"update\",{\"1\":{\"368\":3,\"413\":5,\"437\":5,\"439\":1}}],[\"up\",{\"1\":{\"263\":2,\"368\":1}}],[\"ulonglong\",{\"1\":{\"223\":2}}],[\"ulong\",{\"1\":{\"223\":1}}],[\"uchar\",{\"1\":{\"223\":1}}],[\"us\",{\"1\":{\"580\":1,\"581\":1}}],[\"usa\",{\"1\":{\"423\":1,\"424\":3,\"425\":1,\"426\":1,\"511\":1,\"512\":1,\"517\":2,\"518\":1,\"519\":2,\"520\":2,\"531\":1,\"622\":2,\"627\":2,\"628\":3}}],[\"usage\",{\"1\":{\"373\":1,\"528\":1}}],[\"ushort\",{\"1\":{\"223\":2}}],[\"using\",{\"1\":{\"222\":2,\"368\":1,\"372\":3,\"434\":1}}],[\"use\",{\"1\":{\"206\":1,\"300\":1,\"373\":1,\"378\":1,\"382\":1,\"383\":1,\"384\":2,\"423\":1,\"611\":2}}],[\"used\",{\"1\":{\"125\":1}}],[\"userid\",{\"1\":{\"435\":1,\"510\":1,\"511\":1,\"512\":2,\"516\":1,\"517\":2,\"518\":1,\"519\":1,\"520\":1,\"531\":1,\"580\":4,\"581\":3}}],[\"users\",{\"1\":{\"423\":1,\"424\":2,\"425\":10,\"426\":6,\"427\":5,\"428\":2,\"429\":4}}],[\"user模块内容如下\",{\"1\":{\"382\":1}}],[\"username\",{\"1\":{\"382\":2,\"404\":1,\"435\":1,\"510\":1,\"511\":1,\"512\":2,\"513\":3,\"514\":2,\"516\":1,\"517\":2,\"518\":1,\"519\":1,\"520\":1,\"531\":1,\"580\":4,\"581\":3}}],[\"user\",{\"1\":{\"43\":1,\"95\":1,\"247\":3,\"382\":16,\"384\":1,\"406\":2,\"407\":3,\"408\":1,\"409\":1,\"411\":2,\"412\":2,\"413\":2,\"414\":2,\"415\":1,\"423\":1,\"424\":6,\"425\":6,\"426\":5,\"427\":8,\"428\":2,\"429\":2,\"434\":2,\"435\":2,\"436\":1,\"437\":1,\"438\":1,\"508\":1}}],[\"unmarshal\",{\"1\":{\"510\":1,\"512\":1,\"513\":1,\"515\":1,\"516\":1,\"520\":1,\"521\":1}}],[\"unordered\",{\"1\":{\"389\":1}}],[\"unlock\",{\"1\":{\"348\":3,\"349\":2,\"350\":2,\"351\":2,\"353\":1,\"359\":1}}],[\"unexpected\",{\"1\":{\"312\":1}}],[\"unwrap\",{\"1\":{\"311\":1,\"312\":5}}],[\"unknown\",{\"1\":{\"228\":1,\"373\":1}}],[\"undefined\",{\"1\":{\"226\":1,\"372\":1}}],[\"untyped\",{\"1\":{\"221\":1,\"300\":3}}],[\"unsignedint\",{\"1\":{\"259\":4}}],[\"unsigned\",{\"1\":{\"220\":3,\"221\":1,\"223\":9}}],[\"unsafe也还是被大量的项目使用\",{\"1\":{\"637\":1}}],[\"unsafe标准库是官方提供的一个可以进行低级编程的库\",{\"1\":{\"637\":1}}],[\"unsafeaddr\",{\"1\":{\"279\":7}}],[\"unsafepointer时\",{\"1\":{\"279\":2}}],[\"unsafepointer\",{\"1\":{\"270\":2,\"279\":8,\"287\":1}}],[\"unsafe了解细节\",{\"1\":{\"195\":1}}],[\"unsafe\",{\"0\":{\"637\":1},\"1\":{\"173\":4,\"193\":1,\"222\":12,\"225\":9,\"227\":1,\"229\":4,\"266\":5,\"267\":1,\"270\":1,\"279\":6,\"508\":1,\"611\":1,\"637\":2,\"640\":7,\"641\":5,\"642\":6,\"643\":21,\"644\":3,\"645\":7,\"646\":2,\"647\":4,\"648\":2}}],[\"unit\",{\"1\":{\"390\":1}}],[\"unity等客户端库\",{\"1\":{\"53\":1}}],[\"uniseg\",{\"1\":{\"373\":1}}],[\"universal\",{\"1\":{\"372\":2,\"378\":1}}],[\"unix时间格式的\",{\"1\":{\"629\":1}}],[\"unixsec\",{\"1\":{\"629\":1}}],[\"unixaddr\",{\"1\":{\"572\":3}}],[\"unixpacket\",{\"1\":{\"572\":1}}],[\"unixgram\",{\"1\":{\"572\":1}}],[\"unix地址支持unix\",{\"1\":{\"572\":1}}],[\"unix地址\",{\"0\":{\"572\":1}}],[\"unix\",{\"1\":{\"319\":3,\"444\":1,\"572\":1}}],[\"union\",{\"1\":{\"227\":4}}],[\"unioffice\",{\"1\":{\"62\":1}}],[\"unidecode\",{\"1\":{\"63\":1}}],[\"unicode字符集操作包\",{\"1\":{\"508\":1}}],[\"unicode字符集的范围位于0x0000\",{\"1\":{\"177\":1}}],[\"unicode文本的ascii音译\",{\"1\":{\"63\":1}}],[\"unicode编码相关的基础函数\",{\"1\":{\"43\":1}}],[\"unicode\",{\"0\":{\"636\":1},\"1\":{\"43\":3,\"396\":1,\"508\":1,\"609\":4}}],[\"uvwxyz\",{\"1\":{\"171\":2}}],[\"u\",{\"1\":{\"140\":2,\"227\":6,\"274\":1,\"275\":1,\"312\":2,\"319\":1,\"372\":1,\"629\":4}}],[\"u00ff\",{\"1\":{\"105\":1}}],[\"u00008a9e\",{\"1\":{\"105\":1}}],[\"u00101234\",{\"1\":{\"103\":1}}],[\"u65e5本\",{\"1\":{\"105\":1}}],[\"u+0022\",{\"1\":{\"104\":1}}],[\"u+0027\",{\"1\":{\"104\":1}}],[\"u+005c\",{\"1\":{\"104\":1}}],[\"u+000b\",{\"1\":{\"104\":1}}],[\"u+0009\",{\"1\":{\"104\":1}}],[\"u+000d\",{\"1\":{\"104\":1}}],[\"u+000a\",{\"1\":{\"104\":1}}],[\"u+000c\",{\"1\":{\"104\":1}}],[\"u+0008\",{\"1\":{\"104\":1}}],[\"u+0007\",{\"1\":{\"104\":1}}],[\"u12e4\",{\"1\":{\"103\":1}}],[\"uintptr保存的是地址\",{\"1\":{\"643\":1}}],[\"uintptr可以转换为unsafe\",{\"1\":{\"643\":1}}],[\"uintptr\",{\"1\":{\"116\":1,\"134\":3,\"267\":1,\"270\":3,\"272\":1,\"279\":3,\"286\":1,\"357\":1,\"640\":1,\"641\":1,\"642\":1,\"643\":7,\"644\":4}}],[\"uint\",{\"1\":{\"116\":1,\"223\":2,\"259\":5,\"270\":4,\"397\":1,\"524\":1}}],[\"uint64\",{\"1\":{\"116\":1,\"128\":3,\"223\":4,\"259\":5,\"270\":3,\"357\":1,\"358\":1,\"397\":1,\"524\":1,\"643\":6}}],[\"uint32\",{\"1\":{\"116\":1,\"223\":5,\"259\":5,\"266\":1,\"270\":3,\"353\":1,\"357\":1,\"397\":1}}],[\"uint16\",{\"1\":{\"116\":1,\"223\":4,\"259\":5,\"270\":3,\"397\":1}}],[\"uint8\",{\"1\":{\"116\":1,\"119\":1,\"132\":1,\"223\":4,\"227\":1,\"259\":5,\"270\":3,\"397\":1}}],[\"ui的mac\",{\"1\":{\"57\":1}}],[\"ui\",{\"1\":{\"57\":1,\"64\":1}}],[\"utilization\",{\"1\":{\"247\":1}}],[\"utils\",{\"1\":{\"41\":1}}],[\"utp\",{\"1\":{\"64\":1}}],[\"utf\",{\"1\":{\"396\":4}}],[\"utf8mb4\",{\"1\":{\"434\":9}}],[\"utf8\",{\"1\":{\"43\":1,\"177\":1,\"396\":6}}],[\"utf16\",{\"1\":{\"43\":1}}],[\"urn\",{\"1\":{\"372\":2,\"378\":1}}],[\"urlquery\",{\"1\":{\"620\":2}}],[\"url是不分大小写的\",{\"1\":{\"378\":1}}],[\"url替换掉文件名即可\",{\"1\":{\"245\":1,\"246\":1}}],[\"url\",{\"1\":{\"43\":1,\"513\":3,\"514\":2,\"538\":3,\"620\":1}}],[\"urfave\",{\"1\":{\"41\":1}}],[\"uuid\",{\"1\":{\"41\":1,\"404\":1,\"407\":1}}],[\"uuidhttps\",{\"1\":{\"41\":1}}],[\"uuid相关\",{\"1\":{\"41\":1}}],[\"客户端发送数据\",{\"1\":{\"574\":1}}],[\"客户端代码\",{\"1\":{\"574\":1}}],[\"客户端\",{\"0\":{\"532\":1},\"1\":{\"41\":1,\"64\":1}}],[\"生成文件后\",{\"1\":{\"521\":1}}],[\"生成\",{\"1\":{\"41\":1}}],[\"驼峰转换\",{\"1\":{\"41\":1}}],[\"深度拷贝\",{\"1\":{\"41\":1}}],[\"更大的区别在于垃圾回收的处理\",{\"1\":{\"643\":1}}],[\"更像是一种工程上的约定俗成\",{\"1\":{\"389\":1}}],[\"更适合处理这些基础的数据类型\",{\"1\":{\"357\":1}}],[\"更新数据\",{\"1\":{\"437\":1}}],[\"更新文档\",{\"0\":{\"427\":1}}],[\"更新文档内容\",{\"1\":{\"413\":1}}],[\"更新\",{\"0\":{\"413\":1,\"437\":1}}],[\"更新完成后再解锁\",{\"1\":{\"349\":1}}],[\"更新您现有的microsoft\",{\"1\":{\"62\":1}}],[\"更推荐这种写法\",{\"1\":{\"257\":1}}],[\"更换起重机b\",{\"1\":{\"212\":1}}],[\"更换为变量名\",{\"1\":{\"41\":1}}],[\"更多的是使用短变量\",{\"1\":{\"194\":1}}],[\"更多细节前往参考手册\",{\"1\":{\"162\":1}}],[\"更多细节可以前往参考手册\",{\"1\":{\"114\":1}}],[\"更加简洁和高效\",{\"1\":{\"87\":1}}],[\"更易学易用\",{\"1\":{\"87\":1}}],[\"更高效的反射api\",{\"1\":{\"41\":1}}],[\"将unsafe\",{\"1\":{\"643\":2}}],[\"将一个字符串时间按照一定格式转换为go中的时间结构体\",{\"1\":{\"632\":1}}],[\"将两个模板关联以后\",{\"1\":{\"627\":1}}],[\"将英文字符串转换成大写字符串\",{\"1\":{\"609\":1}}],[\"将英文字符串英文小写字符串\",{\"1\":{\"609\":1}}],[\"将a与b按照字典顺序进行字符串比较\",{\"1\":{\"597\":1}}],[\"将json字符串反序列化为go对象\",{\"1\":{\"516\":1}}],[\"将json转换为go结构\",{\"1\":{\"60\":1}}],[\"将go对象序列化为json字符串\",{\"1\":{\"516\":1}}],[\"将go源代码解析成抽象语法树的包\",{\"1\":{\"508\":1}}],[\"将给定集合的并集保存在结果集里\",{\"1\":{\"474\":1}}],[\"将给定集合的交集保存在结果集里\",{\"1\":{\"474\":1}}],[\"将给定集合的差集保存在结果集里\",{\"1\":{\"474\":1}}],[\"将年龄为10的人地址更新为cn\",{\"1\":{\"427\":1}}],[\"将名为lili人更名为mark\",{\"1\":{\"427\":1}}],[\"将字符串转换为\",{\"1\":{\"396\":1}}],[\"将字符串转换成字节切片以后\",{\"1\":{\"173\":1}}],[\"将不会生成随机的测试数据\",{\"1\":{\"396\":1}}],[\"将测试用例标记为可并行运行\",{\"1\":{\"392\":1}}],[\"将预期结果修改为错误的结果\",{\"1\":{\"390\":1}}],[\"将执行追踪情况写入文件\",{\"1\":{\"388\":1}}],[\"将依赖按照vendor格式进行复制\",{\"1\":{\"383\":1}}],[\"将其取名为hello\",{\"1\":{\"364\":1}}],[\"将其编组进\",{\"1\":{\"46\":1}}],[\"将暂时用不到的对象放入池中\",{\"1\":{\"354\":1}}],[\"将上面的读写互斥锁的例子稍微修改下即可\",{\"1\":{\"351\":1}}],[\"将上面的代码稍微修改下\",{\"1\":{\"289\":1}}],[\"将双向管道传给某个协程或函数并且不希望它读取\",{\"1\":{\"338\":1}}],[\"将创建失败并会返回错误\",{\"1\":{\"321\":1}}],[\"将已写入的数据归入切片\",{\"1\":{\"320\":1}}],[\"将文件读进传入的字节切片\",{\"1\":{\"320\":1}}],[\"将文本转换为句子列表\",{\"1\":{\"63\":1}}],[\"将数据应用到模板中\",{\"1\":{\"615\":1}}],[\"将数据添加到文件末尾\",{\"1\":{\"319\":1}}],[\"将数组作为参数传递给函数时\",{\"1\":{\"157\":1}}],[\"将x转换为类型\",{\"1\":{\"304\":2}}],[\"将p转换为类型\",{\"1\":{\"304\":1}}],[\"将泛型引入项目后\",{\"1\":{\"256\":1}}],[\"将web\",{\"1\":{\"246\":1}}],[\"将此前收集到的数据文件作为参数\",{\"1\":{\"245\":1}}],[\"将cutset匹配的子串删除\",{\"1\":{\"610\":2}}],[\"将cutset任意匹配的子串删除\",{\"1\":{\"610\":3}}],[\"将c转换为类型\",{\"1\":{\"304\":1}}],[\"将c的数组作为go切片的底层数组的例子如下\",{\"1\":{\"225\":1}}],[\"将c代码转换为go代码\",{\"1\":{\"55\":1}}],[\"将导致指针越界\",{\"1\":{\"219\":1}}],[\"将无法支持交叉编译\",{\"1\":{\"216\":1}}],[\"将性能敏感的任务交给c去完成\",{\"1\":{\"215\":1}}],[\"将长度修改为10\",{\"1\":{\"166\":1}}],[\"将会分配一个新的内存给复制的副本\",{\"1\":{\"596\":1}}],[\"将会引发panic\",{\"1\":{\"341\":1}}],[\"将会阻塞等待\",{\"1\":{\"340\":1}}],[\"将会永远阻塞下去\",{\"1\":{\"336\":1}}],[\"将会是false\",{\"1\":{\"312\":1}}],[\"将会到处都充斥着if\",{\"1\":{\"307\":1}}],[\"将会留到并发那一节再做介绍\",{\"1\":{\"146\":1}}],[\"将会无法通过编译\",{\"1\":{\"130\":1,\"338\":1}}],[\"将图像转换为ascii\",{\"1\":{\"58\":1}}],[\"将矢量图形转换为pdf\",{\"1\":{\"58\":1}}],[\"将fortran\",{\"1\":{\"55\":1}}],[\"将加密的电子邮件发送到用go编写的区块链地址\",{\"1\":{\"48\":1}}],[\"将dynamodb用作原子计数器的库\",{\"1\":{\"47\":1}}],[\"将正则表达式解析为语法树\",{\"1\":{\"43\":1}}],[\"将\",{\"1\":{\"41\":1,\"54\":1,\"643\":1}}],[\"将node版本下载到nvm的目录下面\",{\"1\":{\"10\":1}}],[\"彩色输出\",{\"1\":{\"41\":1}}],[\"本文使用的是github\",{\"1\":{\"442\":1}}],[\"本文仅仅讲解如何使用go语言驱动来操作redis数据库\",{\"1\":{\"441\":1}}],[\"本文只是简单讲解如何利用go进行sql操作\",{\"1\":{\"431\":1}}],[\"本文主要介绍使用在go中使用官方的mongo驱动操作mongodb数据库\",{\"1\":{\"418\":1}}],[\"本文用es8来进行演示\",{\"1\":{\"403\":1}}],[\"本文会讲解如何用go来进行对elastisearch的一些基本操作\",{\"1\":{\"402\":1}}],[\"本文会讲解如何通过go语言来进行基本的文件处理\",{\"1\":{\"318\":1}}],[\"本地依赖和go\",{\"1\":{\"379\":1}}],[\"本地存储\",{\"1\":{\"41\":1}}],[\"本质上也是对openfile的封装\",{\"1\":{\"321\":1}}],[\"本来应该是将其分配到栈上\",{\"1\":{\"236\":1}}],[\"本篇不会对实现原理做过多的讲解\",{\"1\":{\"177\":1}}],[\"本节不会讲解\",{\"1\":{\"146\":1}}],[\"本站的第一个入门的案例就是输出一个字符串\",{\"1\":{\"133\":1}}],[\"本机\",{\"1\":{\"45\":1}}],[\"本机go\",{\"1\":{\"45\":1}}],[\"本包提供了对json的基本支持\",{\"1\":{\"40\":1}}],[\"本包提供了对操作系统功能的非平台相关访问接口\",{\"1\":{\"40\":1}}],[\"可见模板引擎的使用其实相当简单\",{\"1\":{\"615\":1}}],[\"可见性\",{\"0\":{\"93\":1}}],[\"可提供的配置项总共有四个\",{\"1\":{\"532\":1}}],[\"可用于网络传输\",{\"1\":{\"510\":1}}],[\"可选持久性的键值对\",{\"1\":{\"441\":1}}],[\"可基于内存\",{\"1\":{\"441\":1}}],[\"可看go官方对于上面四种测试类型的解释\",{\"1\":{\"385\":1}}],[\"可读性\",{\"1\":{\"307\":1}}],[\"可读和写由逗号分割的数值\",{\"1\":{\"43\":1}}],[\"可接收的底层参数类型必须是指针\",{\"1\":{\"271\":1}}],[\"可比较\",{\"1\":{\"213\":1}}],[\"可能是一个结构体\",{\"1\":{\"390\":1}}],[\"可能是项目直接引用的依赖引用了该依赖\",{\"1\":{\"378\":1}}],[\"可能的目录结构如下\",{\"1\":{\"379\":1}}],[\"可能会返回nil\",{\"1\":{\"343\":1}}],[\"可能会发生关闭一个已经关闭了的管道\",{\"1\":{\"337\":1}}],[\"可能会无法判别错误的类别或者误判\",{\"1\":{\"311\":1}}],[\"可能子协程还没开始运行\",{\"1\":{\"331\":1}}],[\"可能很多人认为是下面这种输出\",{\"1\":{\"204\":1}}],[\"可能还不被所有开发者广泛接受和使用\",{\"1\":{\"84\":1}}],[\"可更轻松地构建im服务器\",{\"1\":{\"64\":1}}],[\"可扩展的结构化数据序列化机制\",{\"1\":{\"521\":1}}],[\"可扩展的游戏服务器框架\",{\"1\":{\"53\":1}}],[\"可扩展的游戏服务器引擎\",{\"1\":{\"53\":1}}],[\"可扩展且自以为是的文件系统功能\",{\"1\":{\"51\":1}}],[\"可在opengl上使用\",{\"1\":{\"53\":1}}],[\"可插入\",{\"1\":{\"57\":1}}],[\"可插入任何现成的记录器\",{\"1\":{\"50\":1}}],[\"可插拔的microservice工具箱和分布式系统平台\",{\"1\":{\"47\":1}}],[\"可插拔传输\",{\"1\":{\"47\":1}}],[\"可破解的软件包\",{\"1\":{\"50\":1}}],[\"可嵌入的ngaro\",{\"1\":{\"49\":1}}],[\"可嵌入的脚本编程语言\",{\"1\":{\"49\":1}}],[\"可以仅通过一个指针\",{\"1\":{\"643\":1}}],[\"可以进行数学运算\",{\"1\":{\"643\":1}}],[\"可以创建一个新的定时器\",{\"1\":{\"634\":1}}],[\"可以创建一个新的计时器\",{\"1\":{\"633\":1}}],[\"可以实现类似vue插槽的效果\",{\"1\":{\"627\":1}}],[\"可以在参数前后加上\",{\"1\":{\"617\":1}}],[\"可以在标准库cmd\",{\"1\":{\"215\":1,\"236\":1}}],[\"可以不用设置\",{\"1\":{\"444\":1}}],[\"可以不需要重复声明类型\",{\"1\":{\"186\":1}}],[\"可以去了解gorm\",{\"1\":{\"431\":1}}],[\"可以从结果中看到测试全部通过了\",{\"1\":{\"396\":1}}],[\"可以为日后的维护省去不少的麻烦\",{\"1\":{\"386\":1}}],[\"可以让你马上使用user模块的新修改而无需进行等待\",{\"1\":{\"382\":1}}],[\"可以让编译器自动推断长度\",{\"1\":{\"158\":1}}],[\"可以发现又出错了\",{\"1\":{\"396\":1}}],[\"可以发现有一些依赖包的版本并不是语义化的版本号\",{\"1\":{\"378\":1}}],[\"可以发现相较于之前多了很多东西\",{\"1\":{\"372\":1}}],[\"可以加上参数\",{\"1\":{\"387\":1}}],[\"可以加上\",{\"1\":{\"372\":1}}],[\"可以存储任意类型的值\",{\"1\":{\"360\":1}}],[\"可以存在多个\",{\"1\":{\"124\":1,\"130\":1}}],[\"可以复用对象减少实例化的频率\",{\"1\":{\"354\":1}}],[\"可以考虑采用懒加载的方式\",{\"1\":{\"353\":1}}],[\"可以做出如下修改\",{\"1\":{\"341\":1}}],[\"可以配合for循环使用\",{\"1\":{\"340\":1}}],[\"可以遍历读取缓冲管道中的数据\",{\"1\":{\"339\":1}}],[\"可以使当前协程暂停一段时间\",{\"1\":{\"331\":1}}],[\"可以使用当前goroutine处于挂起状态一定的时间\",{\"1\":{\"635\":1}}],[\"可以使用with\",{\"1\":{\"622\":1}}],[\"可以使用t\",{\"1\":{\"392\":1}}],[\"可以使用模块路径和版本替换又或者是其他平台指定的文件路径\",{\"1\":{\"378\":1}}],[\"可以使用os\",{\"1\":{\"319\":1}}],[\"可以使用any来替代interace\",{\"1\":{\"213\":1}}],[\"可以使用strings\",{\"1\":{\"176\":1}}],[\"可以使用赋值运算符直接进行交换\",{\"1\":{\"127\":1}}],[\"可以使用官方提供的语法糖\",{\"1\":{\"125\":1}}],[\"可以使用\",{\"1\":{\"124\":1,\"617\":1}}],[\"可以及时的处理并且保证程序继续运行\",{\"1\":{\"316\":1}}],[\"可以递归进行查找匹配\",{\"1\":{\"312\":1}}],[\"可以很轻易的写出一个主协程等待子协程执行完毕的例子\",{\"1\":{\"336\":1}}],[\"可以很轻易的自定义error\",{\"1\":{\"310\":1}}],[\"可以很快的理解它的内存占用也是24个字节\",{\"1\":{\"192\":1}}],[\"可以得到一个格式化参数的error\",{\"1\":{\"309\":1}}],[\"可以一层一层往回找到\",{\"1\":{\"307\":1}}],[\"可以绕过go的类型系统\",{\"1\":{\"306\":1}}],[\"可以声明一个自定义名称的新类型\",{\"1\":{\"302\":1}}],[\"可以达到同样的效果\",{\"1\":{\"272\":1}}],[\"可以判断类型为any的数据结构所存储的元素类型\",{\"1\":{\"271\":1}}],[\"可以知晓空接口存储的值究竟是什么基础类型\",{\"1\":{\"270\":1}}],[\"可以前往\",{\"1\":{\"642\":1}}],[\"可以前往type\",{\"1\":{\"264\":1}}],[\"可以前往strings\",{\"1\":{\"177\":1}}],[\"可以查看其它命令\",{\"1\":{\"245\":1}}],[\"可以设为1\",{\"1\":{\"219\":1}}],[\"可以如下设置\",{\"1\":{\"219\":1}}],[\"可以自行阅读源码\",{\"1\":{\"564\":1}}],[\"可以自定义\",{\"1\":{\"242\":1}}],[\"可以自己去了解\",{\"1\":{\"217\":1}}],[\"可以自动格式化代码\",{\"1\":{\"74\":1}}],[\"可以保存所有实现了crane接口的值\",{\"1\":{\"212\":1}}],[\"可以观察到接口的实现是隐式的\",{\"1\":{\"212\":1}}],[\"可以随意替换\",{\"1\":{\"212\":1}}],[\"可以与绝世起重机无缝衔接\",{\"1\":{\"212\":1}}],[\"可以称类型t实现了接口i\",{\"1\":{\"208\":1}}],[\"可以正常运行\",{\"1\":{\"206\":1}}],[\"可以简单理解为是上面两个的具体实现\",{\"1\":{\"508\":1}}],[\"可以简单理解为是指向底层数组的指针\",{\"1\":{\"162\":1}}],[\"可以简单的看成一个形参\",{\"1\":{\"205\":1}}],[\"可以猜猜输出是什么\",{\"1\":{\"204\":1}}],[\"可以非常简单的实现一个求费波那契数列的函数\",{\"1\":{\"201\":1}}],[\"可以省略掉重复的类型声明\",{\"1\":{\"199\":1}}],[\"可以省略掉var关键字和后置类型\",{\"1\":{\"125\":1}}],[\"可以只需要声明一次类型\",{\"1\":{\"198\":1}}],[\"可以只写一次类型\",{\"1\":{\"124\":1}}],[\"可以将当前函数标记为帮助函数\",{\"1\":{\"391\":1}}],[\"可以将文件名作为参数\",{\"1\":{\"247\":1}}],[\"可以将query参数debug=1去掉\",{\"1\":{\"243\":1}}],[\"可以将map作为set来进行使用\",{\"1\":{\"193\":1}}],[\"可以将类似于related\",{\"1\":{\"62\":1}}],[\"可以看出这是该依赖的一个文档页面\",{\"1\":{\"372\":1}}],[\"可以看出数组的地址与数字第一个元素的地址一致\",{\"1\":{\"195\":1}}],[\"可以看看这个泛型数据结构库246859\",{\"1\":{\"264\":1}}],[\"可以看看这两个库\",{\"1\":{\"192\":1}}],[\"可以看到在with语句内部\",{\"1\":{\"622\":1}}],[\"可以看到在第六次遍历的时候读取的是零值\",{\"1\":{\"339\":1}}],[\"可以看到其输出形式跟直接使用fmt\",{\"1\":{\"617\":1}}],[\"可以看到请求体是需要自己手动序列化的\",{\"1\":{\"409\":1}}],[\"可以看到这一次通过了测试\",{\"1\":{\"396\":1}}],[\"可以看到这一次并没有通过\",{\"1\":{\"396\":1}}],[\"可以看到old执行耗时为894\",{\"1\":{\"395\":1}}],[\"可以看到仓库的url是https\",{\"1\":{\"364\":1}}],[\"可以看到rlocker也只是把读写互斥锁的读锁操作封装了一下\",{\"1\":{\"351\":1}}],[\"可以看到创建一个条件变量前提就是需要创建一个锁\",{\"1\":{\"351\":1}}],[\"可以看到最终结果为4\",{\"1\":{\"348\":1}}],[\"可以看到仅仅只是返回了emptyctx指针\",{\"1\":{\"344\":1}}],[\"可以看到上面的代码发生了死锁\",{\"1\":{\"339\":1}}],[\"可以看到负责写的协程刚开始就一口气发送了5个数据\",{\"1\":{\"336\":1}}],[\"可以看到所有的数字都完整输出了\",{\"1\":{\"331\":1}}],[\"可以看到demo\",{\"1\":{\"315\":1}}],[\"可以看到它们都是被var定义的变量\",{\"1\":{\"309\":1}}],[\"可以看到它的错误类型是syscall\",{\"1\":{\"217\":1}}],[\"可以看到第一个参数是main\",{\"1\":{\"289\":1}}],[\"可以看到两个函数的参数类型都是any\",{\"1\":{\"267\":1}}],[\"可以看到返回值是\",{\"1\":{\"262\":1}}],[\"可以看到结果并不是有序的\",{\"1\":{\"182\":1}}],[\"可以看到明明是向s2添加元素\",{\"1\":{\"169\":1}}],[\"可以看到\",{\"1\":{\"168\":1}}],[\"可以看到长度与容量并不一致\",{\"1\":{\"163\":1}}],[\"可以看到切片与数组在外貌上的区别\",{\"1\":{\"162\":1}}],[\"可以看到iota的值本质上就是iota所在行相对于当前const分组的第一行的差值\",{\"1\":{\"131\":1}}],[\"可以减少其内存占用\",{\"1\":{\"192\":1}}],[\"可以显式组合\",{\"1\":{\"189\":1}}],[\"可以更为灵活的实例化结构体\",{\"1\":{\"188\":1}}],[\"可以更轻松地创建json对象\",{\"1\":{\"60\":1}}],[\"可以\",{\"1\":{\"170\":1,\"219\":1}}],[\"可以有效减少后续扩容的内存消耗\",{\"1\":{\"162\":1}}],[\"可以是goto\",{\"1\":{\"150\":1}}],[\"可以通过如下方式来访问对应下标的值\",{\"1\":{\"617\":1}}],[\"可以通过字段名来访问其值\",{\"1\":{\"617\":1}}],[\"可以通过脚本来完成组合操作\",{\"1\":{\"418\":1}}],[\"可以通过\",{\"1\":{\"380\":1}}],[\"可以通过method\",{\"1\":{\"289\":1}}],[\"可以通过编译但是毫无意义\",{\"1\":{\"260\":1}}],[\"可以通过编译\",{\"1\":{\"259\":1,\"260\":1,\"302\":1}}],[\"可以通过强制类型转换将其他数字也转换成该类型\",{\"1\":{\"132\":1}}],[\"可以通过花括号建立一个代码块\",{\"1\":{\"129\":1}}],[\"可以按照下面这样写\",{\"1\":{\"126\":1}}],[\"可以转换为\",{\"1\":{\"119\":1}}],[\"可以表达unicode字符\",{\"1\":{\"119\":1}}],[\"可以表达anscii字符\",{\"1\":{\"119\":1}}],[\"可以评估表达式的引擎\",{\"1\":{\"49\":1}}],[\"可以被编组\",{\"1\":{\"46\":1}}],[\"可生成干净的响应式html电子邮件\",{\"1\":{\"48\":1}}],[\"可实现高负载\",{\"1\":{\"47\":1}}],[\"可空转到类型\",{\"1\":{\"46\":1}}],[\"可对数据结构的内容进行有效且安全的验证\",{\"1\":{\"46\":1}}],[\"可加载\",{\"1\":{\"46\":1}}],[\"可链接\",{\"1\":{\"46\":1}}],[\"可运行外部命令\",{\"1\":{\"43\":1}}],[\"可解析x\",{\"1\":{\"43\":1}}],[\"可取消的goroutine\",{\"1\":{\"41\":1}}],[\"可配置的html标签过滤\",{\"1\":{\"41\":1}}],[\"可做到任意切换想要的版本\",{\"1\":{\"10\":1}}],[\"wyh\",{\"1\":{\"521\":2,\"580\":1,\"581\":1}}],[\"wyh246859\",{\"1\":{\"435\":1}}],[\"wg\",{\"1\":{\"341\":3,\"574\":4}}],[\"wgs84\",{\"1\":{\"54\":1}}],[\"w格式动词\",{\"1\":{\"311\":1}}],[\"wr\",{\"1\":{\"615\":1,\"625\":1}}],[\"writing\",{\"1\":{\"368\":1}}],[\"written\",{\"1\":{\"322\":3,\"396\":2}}],[\"writetimeout\",{\"1\":{\"444\":1,\"536\":1}}],[\"writeto\",{\"1\":{\"242\":1}}],[\"writefile\",{\"1\":{\"321\":3,\"322\":1}}],[\"writefile与io\",{\"1\":{\"321\":1}}],[\"writeat\",{\"1\":{\"321\":1}}],[\"writes\",{\"1\":{\"185\":1,\"355\":1}}],[\"writestring\",{\"1\":{\"136\":1,\"139\":1,\"176\":2,\"321\":6,\"365\":2,\"394\":1,\"611\":2}}],[\"write\",{\"1\":{\"142\":1,\"321\":1,\"325\":1,\"337\":2,\"338\":2,\"340\":1,\"350\":2,\"351\":2,\"354\":1,\"574\":1}}],[\"writerto\",{\"1\":{\"613\":1}}],[\"writer等\",{\"1\":{\"508\":1}}],[\"writer\",{\"1\":{\"43\":1,\"46\":2,\"139\":6,\"198\":2,\"239\":2,\"321\":1,\"322\":1,\"354\":1,\"537\":1,\"538\":2,\"541\":2,\"615\":1,\"617\":3,\"625\":4}}],[\"wronly|os\",{\"1\":{\"322\":2}}],[\"wronly或o\",{\"1\":{\"321\":1}}],[\"wronly\",{\"1\":{\"319\":2}}],[\"wrap2\",{\"1\":{\"312\":4}}],[\"wrappederr\",{\"1\":{\"354\":1}}],[\"wrapperror同样实现了error接口\",{\"1\":{\"311\":1}}],[\"wrapp\",{\"1\":{\"312\":2}}],[\"wrap1\",{\"1\":{\"312\":4}}],[\"wraperrs\",{\"1\":{\"354\":1}}],[\"wraperr\",{\"1\":{\"311\":1}}],[\"wraperror\",{\"1\":{\"311\":3}}],[\"w\",{\"1\":{\"177\":4,\"216\":1,\"239\":2,\"242\":6,\"311\":1,\"312\":2,\"321\":1,\"354\":2,\"363\":1,\"370\":1,\"376\":1,\"541\":1}}],[\"where\",{\"1\":{\"435\":1,\"437\":1,\"438\":1}}],[\"when\",{\"1\":{\"63\":1}}],[\"while\",{\"1\":{\"396\":1}}],[\"why\",{\"1\":{\"375\":1}}],[\"whatlanggo\",{\"1\":{\"63\":1}}],[\"world\",{\"1\":{\"105\":1,\"130\":1,\"136\":1,\"137\":2,\"138\":1,\"139\":2,\"140\":4,\"153\":1,\"173\":1,\"177\":1,\"257\":2,\"269\":1,\"273\":1,\"276\":2,\"292\":2,\"320\":3,\"321\":14,\"331\":3,\"355\":5,\"360\":1,\"365\":2,\"396\":4,\"443\":1,\"600\":14,\"611\":2,\"615\":2,\"617\":10,\"623\":2,\"647\":1,\"648\":1}}],[\"word\",{\"1\":{\"62\":1,\"266\":2}}],[\"work如下所示\",{\"1\":{\"384\":1}}],[\"work中的的replace指令会作用于所有的模块\",{\"1\":{\"384\":1}}],[\"work中添加一个新模块\",{\"1\":{\"383\":1}}],[\"work仅用于演示\",{\"1\":{\"382\":1}}],[\"work也不应该提交到vcs中\",{\"1\":{\"382\":1}}],[\"work文件的内容很简单\",{\"1\":{\"384\":1}}],[\"work文件仅用在开发过程中\",{\"1\":{\"382\":1}}],[\"work文件\",{\"1\":{\"382\":1}}],[\"workspace\",{\"1\":{\"245\":1,\"312\":4,\"381\":1,\"528\":5}}],[\"work\",{\"1\":{\"212\":4,\"381\":2,\"382\":5,\"383\":2,\"389\":1}}],[\"workers\",{\"1\":{\"396\":1}}],[\"workerpool\",{\"1\":{\"56\":1}}],[\"worker\",{\"1\":{\"56\":1}}],[\"workpool\",{\"1\":{\"41\":2}}],[\"warning\",{\"1\":{\"372\":3}}],[\"water\",{\"1\":{\"64\":1}}],[\"waterfall等等\",{\"1\":{\"56\":1}}],[\"walk会递归遍历整个文件夹\",{\"1\":{\"329\":1}}],[\"walk\",{\"1\":{\"57\":1,\"210\":1,\"212\":5,\"329\":1}}],[\"wait方法等待子协程结束\",{\"1\":{\"341\":1}}],[\"wait\",{\"1\":{\"185\":1,\"315\":1,\"341\":15,\"345\":1,\"346\":2,\"347\":5,\"348\":5,\"349\":5,\"350\":8,\"351\":11,\"353\":5,\"354\":5,\"355\":10,\"574\":1}}],[\"waitgroup的值不应该被复制\",{\"1\":{\"341\":1}}],[\"waitgroup通常适用于可动态调整协程数量的时候\",{\"1\":{\"341\":1}}],[\"waitgroup替代了原先的time\",{\"1\":{\"341\":1}}],[\"waitgroup使用起来十分简单\",{\"1\":{\"341\":1}}],[\"waitgroup即等待执行\",{\"1\":{\"341\":1}}],[\"waitgroup是sync包下提供的一个结构体\",{\"1\":{\"341\":1}}],[\"waitgroup可以动态的控制一组指定数量的协程\",{\"1\":{\"331\":1}}],[\"waitgroup类似的队列组可访问性\",{\"1\":{\"56\":1}}],[\"waitgroup与错误处理和并发控制类似\",{\"1\":{\"56\":1}}],[\"waitgroup\",{\"0\":{\"341\":1},\"1\":{\"56\":1,\"315\":5,\"331\":1,\"341\":8,\"345\":5,\"346\":12,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":2,\"574\":1}}],[\"wails\",{\"1\":{\"57\":1}}],[\"waveform\",{\"1\":{\"45\":1}}],[\"wire\",{\"1\":{\"404\":1}}],[\"will\",{\"1\":{\"389\":1}}],[\"willf\",{\"1\":{\"46\":1}}],[\"with会检查管道操作返回的值\",{\"1\":{\"622\":1}}],[\"withindex\",{\"1\":{\"408\":1}}],[\"withbody\",{\"1\":{\"406\":1,\"408\":1,\"415\":2}}],[\"withhuman\",{\"1\":{\"404\":2,\"407\":1,\"408\":1}}],[\"withpretty\",{\"1\":{\"404\":1,\"407\":1,\"408\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":3}}],[\"withtimeout其实与withdealine非常相似\",{\"1\":{\"347\":1}}],[\"withtimeout\",{\"1\":{\"347\":2}}],[\"withdeadline\",{\"1\":{\"347\":3,\"389\":1}}],[\"withcancel\",{\"1\":{\"346\":5}}],[\"withcancel源代码中所示\",{\"1\":{\"346\":1}}],[\"withvalue\",{\"1\":{\"345\":1}}],[\"with\",{\"0\":{\"622\":1},\"1\":{\"208\":1,\"222\":2,\"245\":2,\"266\":1,\"372\":1,\"373\":1,\"389\":1,\"396\":1,\"622\":4,\"625\":6}}],[\"withsalary\",{\"1\":{\"188\":2}}],[\"withaddress\",{\"1\":{\"188\":2}}],[\"withage\",{\"1\":{\"188\":3}}],[\"withname\",{\"1\":{\"188\":3}}],[\"width=24\",{\"1\":{\"237\":1}}],[\"width\",{\"1\":{\"177\":2,\"186\":1}}],[\"winter\",{\"1\":{\"132\":3}}],[\"winrm\",{\"1\":{\"64\":1}}],[\"windows用户建议提前安装好mingw\",{\"1\":{\"215\":1}}],[\"windows正在开发中\",{\"1\":{\"57\":1}}],[\"windows\",{\"1\":{\"41\":1,\"43\":1,\"57\":3,\"72\":1,\"394\":1,\"395\":3}}],[\"we\",{\"1\":{\"372\":1}}],[\"were\",{\"1\":{\"245\":1}}],[\"werr\",{\"1\":{\"50\":1}}],[\"web开发是go语言中一个很常见的应用场景\",{\"1\":{\"249\":1}}],[\"web开发\",{\"0\":{\"249\":1}}],[\"web\",{\"0\":{\"77\":1},\"1\":{\"77\":2},\"2\":{\"495\":1}}],[\"webvtt\",{\"1\":{\"65\":1}}],[\"webview\",{\"1\":{\"57\":1}}],[\"webrtc\",{\"1\":{\"64\":2}}],[\"webcolors库的端口\",{\"1\":{\"58\":1}}],[\"webcolors\",{\"1\":{\"58\":1}}],[\"websockets和love构建的高性能\",{\"1\":{\"47\":1}}],[\"websocket\",{\"1\":{\"41\":2}}],[\"welch编码格式的压缩的数据格式\",{\"1\":{\"43\":1}}],[\"搜索api就跟平时http\",{\"1\":{\"415\":1}}],[\"搜索\",{\"0\":{\"415\":1},\"1\":{\"41\":1}}],[\"搜索es\",{\"1\":{\"41\":1}}],[\"分隔字符串\",{\"0\":{\"608\":1}}],[\"分割字符串\",{\"0\":{\"602\":1}}],[\"分钟\",{\"1\":{\"444\":2}}],[\"分两次执行基准测试\",{\"1\":{\"395\":1}}],[\"分析\",{\"0\":{\"244\":1,\"408\":1}}],[\"分析导致创建新os线程原因\",{\"1\":{\"243\":1}}],[\"分析结果\",{\"1\":{\"240\":1}}],[\"分别如下\",{\"1\":{\"268\":1}}],[\"分别有reflect\",{\"1\":{\"267\":1}}],[\"分别用c和go编写了一个两数求和的函数\",{\"1\":{\"233\":1}}],[\"分别是耗时\",{\"1\":{\"395\":1}}],[\"分别是auth\",{\"1\":{\"382\":1}}],[\"分别是withdeadline和withtimeout\",{\"1\":{\"347\":1}}],[\"分别是os\",{\"1\":{\"321\":1}}],[\"分别是os包下的readfile函数\",{\"1\":{\"320\":1}}],[\"分别是reflect\",{\"1\":{\"267\":1}}],[\"分别是类型与初始容量\",{\"1\":{\"178\":1}}],[\"分别是\",{\"1\":{\"134\":1,\"342\":1,\"643\":1}}],[\"分配内存\",{\"1\":{\"229\":1}}],[\"分配新的底层数组\",{\"1\":{\"169\":1}}],[\"分为普通字符串和原生字符串\",{\"1\":{\"171\":1}}],[\"分发和运行容器化应用\",{\"1\":{\"85\":1}}],[\"分布式sql数据库\",{\"1\":{\"253\":1}}],[\"分布式键值数据库\",{\"1\":{\"253\":1}}],[\"分布式可插拔rpc服务框架\",{\"1\":{\"47\":1}}],[\"分布式\",{\"1\":{\"47\":1,\"441\":1}}],[\"分布式系统\",{\"0\":{\"47\":1},\"1\":{\"39\":1}}],[\"分词\",{\"1\":{\"41\":1}}],[\"illegal\",{\"1\":{\"611\":2}}],[\"iş\",{\"1\":{\"609\":2}}],[\"i̇ş\",{\"1\":{\"609\":2}}],[\"i7\",{\"1\":{\"394\":1,\"395\":3}}],[\"i736aousyt75hyzlojw9eryxcy6ean6h4bzxu064p\",{\"1\":{\"379\":1}}],[\"i<<1\",{\"1\":{\"263\":2}}],[\"i>>1\",{\"1\":{\"263\":2}}],[\"iris\",{\"1\":{\"249\":1}}],[\"iris等等\",{\"1\":{\"243\":1}}],[\"i指的是搜索头文件的相对路径\",{\"1\":{\"231\":1}}],[\"itoa\",{\"1\":{\"585\":2}}],[\"ityp\",{\"1\":{\"266\":1}}],[\"itab\",{\"1\":{\"266\":2}}],[\"it\",{\"1\":{\"222\":4,\"389\":4}}],[\"its\",{\"1\":{\"208\":1,\"389\":3}}],[\"iterator\",{\"1\":{\"372\":2,\"378\":1}}],[\"iterable\",{\"1\":{\"153\":1}}],[\"iter\",{\"1\":{\"46\":1}}],[\"i就是接收者\",{\"1\":{\"204\":1}}],[\"issorted\",{\"1\":{\"581\":1}}],[\"isinf\",{\"1\":{\"551\":2}}],[\"isnan\",{\"1\":{\"550\":1}}],[\"isnotexist\",{\"1\":{\"319\":2}}],[\"isatty\",{\"1\":{\"372\":2,\"378\":1}}],[\"isregular\",{\"1\":{\"329\":2}}],[\"isdir\",{\"1\":{\"329\":1}}],[\"is函数的作用是判断错误链中是否包含指定的错误\",{\"1\":{\"312\":1}}],[\"isexported\",{\"1\":{\"286\":2,\"289\":2}}],[\"is\",{\"1\":{\"172\":6,\"173\":2,\"174\":2,\"175\":2,\"176\":8,\"208\":4,\"222\":15,\"244\":1,\"247\":1,\"266\":2,\"312\":4,\"320\":1,\"372\":2,\"382\":1,\"389\":1,\"390\":14,\"391\":2,\"392\":2,\"393\":2,\"396\":1,\"408\":3,\"574\":1,\"599\":2,\"607\":8,\"608\":8,\"609\":4,\"610\":10,\"612\":2,\"615\":2,\"618\":2}}],[\"i=2\",{\"1\":{\"165\":1}}],[\"i=3\",{\"1\":{\"164\":1}}],[\"i=0\",{\"1\":{\"111\":1}}],[\"i+n\",{\"1\":{\"165\":1}}],[\"i+1\",{\"1\":{\"152\":1,\"164\":2,\"396\":3,\"645\":2,\"647\":1}}],[\"i++\",{\"1\":{\"111\":2,\"152\":2,\"154\":2,\"155\":2,\"167\":1,\"168\":1,\"177\":3,\"184\":1,\"185\":3,\"201\":2,\"225\":2,\"233\":1,\"241\":1,\"245\":1,\"246\":2,\"286\":1,\"289\":4,\"294\":1,\"321\":2,\"331\":4,\"336\":2,\"339\":4,\"340\":2,\"341\":1,\"348\":1,\"349\":1,\"350\":2,\"351\":2,\"353\":1,\"354\":1,\"355\":4,\"394\":4,\"634\":1}}],[\"ieee\",{\"1\":{\"117\":3}}],[\"ietf\",{\"1\":{\"64\":1}}],[\"i\",{\"1\":{\"102\":1,\"111\":5,\"143\":2,\"152\":12,\"153\":6,\"154\":8,\"155\":8,\"165\":1,\"167\":3,\"168\":3,\"177\":17,\"184\":2,\"185\":6,\"201\":6,\"203\":2,\"204\":7,\"205\":2,\"206\":8,\"212\":2,\"225\":8,\"231\":1,\"232\":1,\"233\":2,\"241\":2,\"245\":2,\"246\":4,\"263\":14,\"267\":2,\"281\":1,\"286\":4,\"289\":12,\"294\":4,\"309\":4,\"321\":4,\"331\":14,\"336\":6,\"339\":11,\"340\":6,\"341\":3,\"348\":2,\"349\":2,\"350\":10,\"351\":11,\"353\":10,\"354\":2,\"355\":10,\"394\":8,\"396\":15,\"415\":1,\"467\":1,\"574\":2,\"575\":2,\"580\":5,\"585\":2,\"617\":2,\"634\":2,\"645\":6,\"647\":3}}],[\"iface对应的是nonemptyinterface\",{\"1\":{\"266\":1}}],[\"iface\",{\"1\":{\"266\":1}}],[\"if\",{\"0\":{\"147\":1,\"148\":1},\"1\":{\"97\":1,\"145\":1,\"147\":6,\"148\":16,\"151\":1,\"152\":1,\"154\":2,\"155\":2,\"179\":1,\"180\":1,\"188\":1,\"199\":1,\"200\":2,\"201\":2,\"217\":2,\"222\":2,\"242\":3,\"256\":1,\"262\":3,\"263\":7,\"281\":1,\"283\":1,\"286\":1,\"287\":2,\"288\":1,\"290\":1,\"305\":1,\"307\":4,\"309\":1,\"312\":4,\"314\":1,\"316\":3,\"317\":1,\"319\":5,\"320\":8,\"321\":5,\"322\":8,\"323\":1,\"324\":2,\"325\":3,\"327\":3,\"328\":1,\"329\":10,\"345\":1,\"346\":1,\"353\":6,\"354\":1,\"356\":1,\"359\":1,\"365\":3,\"382\":5,\"390\":8,\"391\":2,\"392\":2,\"393\":2,\"396\":7,\"404\":2,\"406\":2,\"407\":2,\"408\":2,\"409\":2,\"411\":2,\"412\":2,\"413\":2,\"414\":2,\"415\":6,\"421\":1,\"424\":1,\"425\":4,\"426\":2,\"427\":4,\"428\":2,\"429\":2,\"434\":1,\"435\":3,\"436\":2,\"437\":2,\"438\":2,\"439\":1,\"443\":2,\"511\":1,\"512\":1,\"514\":1,\"515\":2,\"517\":1,\"519\":1,\"520\":1,\"521\":2,\"530\":1,\"531\":1,\"567\":1,\"568\":1,\"569\":2,\"570\":2,\"571\":2,\"572\":1,\"573\":2,\"574\":6,\"605\":1,\"611\":2,\"613\":1,\"615\":2,\"617\":5,\"619\":1,\"621\":1,\"623\":4,\"624\":3,\"625\":2,\"626\":6,\"628\":2,\"632\":2}}],[\"icu\",{\"1\":{\"63\":1}}],[\"i18n\",{\"1\":{\"63\":1}}],[\"im\",{\"1\":{\"250\":1}}],[\"im通讯\",{\"0\":{\"250\":1}}],[\"implements\",{\"0\":{\"274\":1},\"1\":{\"274\":3}}],[\"implement\",{\"1\":{\"206\":1,\"208\":2,\"537\":1}}],[\"importer\",{\"1\":{\"508\":1}}],[\"import是导入关键字\",{\"1\":{\"91\":1}}],[\"import\",{\"1\":{\"91\":1,\"94\":7,\"96\":1,\"97\":1,\"128\":1,\"133\":1,\"136\":1,\"138\":1,\"170\":1,\"216\":1,\"217\":3,\"218\":2,\"219\":2,\"220\":1,\"221\":2,\"222\":8,\"223\":1,\"224\":1,\"225\":4,\"226\":2,\"227\":2,\"228\":2,\"229\":4,\"231\":2,\"232\":2,\"233\":2,\"239\":1,\"242\":3,\"243\":3,\"312\":1,\"365\":3,\"367\":2,\"372\":1,\"382\":2,\"387\":2,\"389\":2,\"390\":4,\"391\":1,\"392\":1,\"394\":2,\"396\":1,\"421\":1,\"443\":1,\"521\":1,\"523\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":2,\"574\":2,\"583\":1,\"595\":1,\"615\":1,\"628\":1}}],[\"img\",{\"1\":{\"58\":1}}],[\"imghdr模块确定go文件中包含的图像类型\",{\"1\":{\"58\":1}}],[\"imaging\",{\"1\":{\"58\":1}}],[\"imaginary\",{\"1\":{\"58\":1}}],[\"imagick\",{\"1\":{\"58\":1}}],[\"image2ascii\",{\"1\":{\"58\":1}}],[\"image\",{\"1\":{\"43\":2,\"508\":1}}],[\"imap\",{\"1\":{\"48\":1}}],[\"id>\",{\"1\":{\"511\":1,\"512\":1}}],[\"idlecheckfrequency\",{\"1\":{\"444\":1}}],[\"idletimeout\",{\"1\":{\"444\":1,\"536\":1}}],[\"idxlo\",{\"1\":{\"319\":1}}],[\"idxhi\",{\"1\":{\"319\":1}}],[\"id\",{\"1\":{\"257\":7,\"258\":3,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"435\":2,\"436\":2,\"437\":1,\"438\":1,\"510\":1,\"518\":2,\"519\":1,\"520\":1}}],[\"id类型\",{\"1\":{\"46\":1}}],[\"id3v2\",{\"1\":{\"45\":1}}],[\"inlocation\",{\"1\":{\"632\":2}}],[\"inline\",{\"1\":{\"245\":1}}],[\"inf\",{\"1\":{\"551\":1}}],[\"inf检测\",{\"0\":{\"551\":1}}],[\"inforesp\",{\"1\":{\"404\":2}}],[\"information\",{\"1\":{\"373\":1}}],[\"info\",{\"1\":{\"329\":6,\"376\":1,\"379\":3,\"404\":2,\"626\":2,\"627\":2,\"628\":3}}],[\"ini的改进\",{\"1\":{\"509\":1}}],[\"initial\",{\"1\":{\"368\":1}}],[\"init命令初始化模块\",{\"1\":{\"364\":1}}],[\"initdatabase\",{\"1\":{\"314\":2}}],[\"init\",{\"1\":{\"130\":1,\"152\":1,\"243\":1,\"354\":1,\"364\":1,\"365\":1,\"368\":3,\"375\":1,\"383\":1,\"435\":1}}],[\"innodb\",{\"1\":{\"434\":1}}],[\"input\",{\"1\":{\"396\":5}}],[\"indent\",{\"1\":{\"510\":1,\"519\":1}}],[\"indexrune\",{\"1\":{\"604\":2}}],[\"indexany\",{\"1\":{\"604\":2}}],[\"index为可迭代数据结构的索引\",{\"1\":{\"153\":1}}],[\"index\",{\"1\":{\"43\":1,\"153\":3,\"167\":2,\"204\":4,\"243\":1,\"245\":1,\"286\":2,\"289\":3,\"294\":1,\"404\":1,\"406\":1,\"407\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"537\":3,\"538\":2,\"604\":2,\"617\":2,\"619\":2,\"620\":3}}],[\"india\",{\"1\":{\"580\":1,\"581\":1}}],[\"indicesdelete\",{\"1\":{\"409\":2}}],[\"indicesvalidatequery\",{\"1\":{\"405\":1}}],[\"indicesclose\",{\"1\":{\"405\":1}}],[\"indicesclone\",{\"1\":{\"405\":1}}],[\"indicesclearcache\",{\"1\":{\"405\":1}}],[\"indicesanalyze\",{\"1\":{\"405\":1}}],[\"indicesaddblock\",{\"1\":{\"405\":1}}],[\"indices\",{\"1\":{\"405\":3,\"406\":1,\"407\":1,\"408\":1,\"409\":1}}],[\"indices结构体中\",{\"1\":{\"405\":1}}],[\"indirect注释的表示该依赖没有被当前项目直接引用\",{\"1\":{\"378\":1}}],[\"indirect\",{\"1\":{\"372\":23,\"378\":25}}],[\"insert\",{\"1\":{\"434\":2,\"436\":5,\"439\":1}}],[\"insertedids\",{\"1\":{\"426\":1}}],[\"insertedid\",{\"1\":{\"426\":1}}],[\"insertone和db\",{\"1\":{\"426\":1}}],[\"insertone\",{\"1\":{\"426\":1}}],[\"insertmany\",{\"1\":{\"423\":1,\"426\":2}}],[\"insertions\",{\"1\":{\"368\":6}}],[\"instance\",{\"1\":{\"372\":1}}],[\"install命令会将第三方依赖下载到本地并编译成二进制文件\",{\"1\":{\"373\":1}}],[\"install\",{\"1\":{\"367\":3,\"369\":1,\"373\":1,\"395\":1}}],[\"instead\",{\"1\":{\"332\":1,\"378\":1}}],[\"incr\",{\"1\":{\"458\":1}}],[\"inconsistently\",{\"1\":{\"360\":1}}],[\"include<complex\",{\"1\":{\"221\":1}}],[\"include\",{\"1\":{\"69\":1,\"216\":1,\"217\":4,\"218\":2,\"219\":11,\"220\":1,\"221\":1,\"222\":10,\"223\":1,\"224\":1,\"225\":4,\"226\":2,\"227\":2,\"228\":2,\"229\":4,\"231\":3,\"232\":1,\"233\":1,\"407\":1}}],[\"inuse\",{\"1\":{\"245\":1,\"246\":2}}],[\"invalid\",{\"1\":{\"128\":1,\"195\":1,\"270\":3,\"300\":1,\"302\":1,\"309\":1,\"338\":1,\"396\":3,\"591\":1,\"643\":1}}],[\"intvar\",{\"1\":{\"525\":1,\"528\":1}}],[\"intval\",{\"1\":{\"305\":2}}],[\"introduction\",{\"1\":{\"418\":1}}],[\"intall安装命令行程序\",{\"1\":{\"369\":1}}],[\"into\",{\"1\":{\"360\":2,\"364\":1,\"434\":2,\"436\":1}}],[\"intch\",{\"1\":{\"333\":3,\"334\":5,\"337\":20}}],[\"int类型\",{\"1\":{\"303\":1}}],[\"intsize\",{\"1\":{\"543\":3}}],[\"ints\",{\"1\":{\"258\":1,\"334\":1,\"337\":4,\"576\":3,\"584\":2,\"640\":2}}],[\"intslice就是接收者的类型\",{\"1\":{\"204\":1}}],[\"intslice\",{\"1\":{\"204\":12}}],[\"int就是类型实参\",{\"1\":{\"256\":1}}],[\"int指针\",{\"1\":{\"196\":1}}],[\"int即代表该变量的类型是一个int类型的指针\",{\"1\":{\"194\":1}}],[\"intn\",{\"1\":{\"184\":1,\"331\":1,\"348\":2,\"349\":2,\"350\":4,\"351\":4,\"415\":2}}],[\"intnum\",{\"1\":{\"124\":1}}],[\"int是不可比较的\",{\"1\":{\"178\":1}}],[\"int是可比较的\",{\"1\":{\"178\":1}}],[\"int这种方式声明的切片\",{\"1\":{\"162\":1}}],[\"int=1\",{\"1\":{\"140\":2}}],[\"int64占8个字节\",{\"1\":{\"192\":1}}],[\"int64\",{\"1\":{\"116\":1,\"128\":4,\"192\":3,\"223\":4,\"233\":3,\"257\":2,\"258\":2,\"259\":7,\"260\":2,\"270\":3,\"294\":1,\"302\":3,\"320\":1,\"321\":1,\"322\":2,\"354\":1,\"357\":1,\"358\":1,\"359\":4,\"397\":1,\"524\":1,\"629\":2,\"643\":1}}],[\"int32能够表示31位整数\",{\"1\":{\"304\":1}}],[\"int32占4个字节\",{\"1\":{\"192\":1}}],[\"int32\",{\"1\":{\"116\":1,\"119\":1,\"140\":1,\"192\":2,\"217\":5,\"219\":15,\"223\":5,\"225\":7,\"226\":3,\"227\":3,\"229\":5,\"231\":7,\"232\":2,\"233\":7,\"256\":1,\"257\":2,\"258\":2,\"259\":7,\"260\":2,\"270\":3,\"304\":2,\"357\":1,\"397\":1,\"521\":1,\"629\":1,\"642\":1,\"643\":2}}],[\"int16占2字节\",{\"1\":{\"192\":1}}],[\"int16\",{\"1\":{\"116\":1,\"192\":1,\"223\":4,\"259\":7,\"260\":2,\"270\":3,\"397\":1}}],[\"int8只能表示7位整数\",{\"1\":{\"304\":1}}],[\"int8占一个字节\",{\"1\":{\"192\":1}}],[\"int8\",{\"1\":{\"116\":1,\"192\":5,\"223\":4,\"259\":8,\"260\":4,\"270\":3,\"304\":2,\"397\":1}}],[\"int\",{\"1\":{\"111\":1,\"116\":1,\"120\":4,\"124\":4,\"125\":2,\"127\":2,\"140\":1,\"143\":5,\"144\":1,\"149\":1,\"158\":12,\"160\":6,\"162\":4,\"163\":1,\"164\":3,\"165\":1,\"166\":2,\"167\":2,\"168\":4,\"169\":3,\"170\":2,\"176\":4,\"178\":5,\"179\":3,\"180\":2,\"181\":1,\"182\":1,\"183\":2,\"184\":1,\"185\":2,\"186\":2,\"187\":2,\"188\":2,\"189\":2,\"191\":1,\"194\":6,\"195\":5,\"196\":5,\"197\":11,\"198\":2,\"199\":8,\"200\":6,\"201\":6,\"202\":2,\"204\":15,\"205\":2,\"206\":13,\"210\":1,\"212\":5,\"213\":3,\"217\":4,\"218\":8,\"220\":1,\"221\":1,\"222\":4,\"223\":10,\"225\":1,\"231\":1,\"233\":1,\"238\":5,\"239\":5,\"241\":4,\"245\":1,\"246\":4,\"256\":7,\"257\":18,\"258\":13,\"259\":12,\"260\":10,\"262\":1,\"263\":7,\"270\":4,\"271\":2,\"273\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":2,\"283\":4,\"285\":2,\"286\":5,\"289\":1,\"293\":2,\"294\":2,\"295\":2,\"296\":2,\"297\":2,\"298\":2,\"300\":3,\"301\":17,\"302\":2,\"303\":9,\"304\":6,\"305\":2,\"306\":3,\"309\":2,\"313\":1,\"314\":1,\"319\":9,\"320\":2,\"321\":4,\"327\":1,\"331\":4,\"332\":1,\"333\":2,\"334\":1,\"335\":2,\"336\":3,\"337\":9,\"338\":3,\"339\":3,\"340\":16,\"341\":1,\"344\":1,\"348\":1,\"349\":1,\"350\":2,\"351\":2,\"353\":11,\"354\":1,\"355\":4,\"359\":2,\"382\":1,\"393\":1,\"397\":1,\"424\":1,\"425\":2,\"435\":1,\"444\":4,\"510\":1,\"513\":1,\"516\":1,\"518\":1,\"524\":1,\"525\":2,\"527\":2,\"528\":2,\"541\":3,\"575\":3,\"576\":1,\"580\":4,\"584\":1,\"585\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"597\":1,\"599\":1,\"604\":5,\"606\":1,\"607\":1,\"608\":2,\"617\":1,\"638\":1,\"639\":1,\"640\":5,\"641\":1,\"643\":3,\"644\":3,\"645\":5,\"646\":1}}],[\"intel\",{\"1\":{\"394\":1,\"395\":3}}],[\"integertype代表的是任意整数类型\",{\"1\":{\"639\":1}}],[\"integertype\",{\"0\":{\"639\":1},\"1\":{\"196\":1,\"639\":1,\"644\":1,\"646\":1,\"648\":1}}],[\"integer\",{\"1\":{\"101\":1,\"259\":6,\"260\":5}}],[\"interesting\",{\"1\":{\"396\":12}}],[\"interval\",{\"1\":{\"395\":3}}],[\"interactive\",{\"1\":{\"245\":1}}],[\"interfaces\",{\"1\":{\"613\":1}}],[\"interfaces即通用接口\",{\"1\":{\"259\":1}}],[\"interface下的三个方法len\",{\"1\":{\"575\":1}}],[\"interface\",{\"1\":{\"97\":1,\"120\":1,\"198\":1,\"206\":1,\"208\":11,\"210\":1,\"212\":3,\"213\":8,\"257\":1,\"259\":15,\"260\":10,\"266\":2,\"267\":1,\"270\":4,\"271\":1,\"272\":1,\"273\":1,\"274\":2,\"275\":2,\"278\":1,\"279\":1,\"280\":2,\"281\":2,\"284\":1,\"286\":2,\"287\":2,\"290\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"305\":1,\"306\":1,\"308\":1,\"312\":1,\"343\":1,\"346\":1,\"349\":1,\"390\":1,\"422\":3,\"460\":1,\"513\":2,\"575\":2}}],[\"interface接口的实现\",{\"1\":{\"51\":1}}],[\"interface接口的任何类型的堆操作\",{\"1\":{\"43\":1}}],[\"internal\",{\"1\":{\"95\":1,\"236\":1}}],[\"internet消息格式和邮件消息的流库\",{\"1\":{\"48\":1}}],[\"in\",{\"1\":{\"95\":5,\"177\":1,\"178\":1,\"206\":1,\"208\":1,\"222\":2,\"245\":4,\"264\":1,\"283\":1,\"284\":1,\"289\":1,\"300\":1,\"313\":1,\"372\":4,\"373\":2,\"378\":1,\"379\":1,\"389\":1,\"513\":2}}],[\"ip6\",{\"1\":{\"569\":1}}],[\"ip4\",{\"1\":{\"569\":1}}],[\"ipv6addr\",{\"1\":{\"569\":2}}],[\"ipv6\",{\"1\":{\"569\":1}}],[\"ipv4net\",{\"1\":{\"568\":2}}],[\"ipv4addr\",{\"1\":{\"568\":2,\"569\":2}}],[\"ip地址支持解析ipv4\",{\"1\":{\"569\":1}}],[\"ip地址\",{\"0\":{\"569\":1},\"1\":{\"565\":1}}],[\"iptr++\",{\"1\":{\"229\":1}}],[\"iptr\",{\"1\":{\"229\":1}}],[\"iptc等\",{\"1\":{\"51\":1}}],[\"ipnet\",{\"1\":{\"64\":1,\"568\":1}}],[\"ipaddr\",{\"1\":{\"569\":1}}],[\"ipaddr启发而使用ip地址\",{\"1\":{\"64\":1}}],[\"ipaddress和ruby\",{\"1\":{\"64\":1}}],[\"iplib\",{\"1\":{\"64\":1}}],[\"ip\",{\"1\":{\"43\":1,\"64\":1,\"568\":1}}],[\"ipdb\",{\"1\":{\"41\":1}}],[\"ipipdotnet\",{\"1\":{\"41\":1}}],[\"ivpusic\",{\"1\":{\"41\":1}}],[\"io库\",{\"1\":{\"318\":1}}],[\"io进行实验\",{\"1\":{\"59\":1}}],[\"ios\",{\"1\":{\"57\":1}}],[\"iota来实现枚举\",{\"1\":{\"132\":1}}],[\"iota<<2\",{\"1\":{\"131\":2}}],[\"iota是递增的\",{\"1\":{\"131\":1}}],[\"iota是一个内置的常量标识符\",{\"1\":{\"131\":1}}],[\"iota\",{\"0\":{\"131\":1},\"1\":{\"129\":1,\"131\":6,\"132\":1,\"270\":1,\"541\":1}}],[\"iot是用于实现google\",{\"1\":{\"59\":1}}],[\"iot\",{\"1\":{\"59\":2}}],[\"iot设备库套件\",{\"1\":{\"59\":1}}],[\"iot和云本机系统的轻量级高性能消息传递系统\",{\"1\":{\"47\":1}}],[\"iotest\",{\"1\":{\"43\":1}}],[\"ioutil\",{\"1\":{\"43\":1}}],[\"io\",{\"1\":{\"40\":1,\"41\":1,\"43\":2,\"47\":1,\"198\":1,\"307\":1,\"320\":3,\"321\":2,\"322\":3,\"329\":1,\"354\":1,\"370\":1,\"379\":6,\"508\":2,\"530\":1,\"541\":2,\"574\":2,\"613\":7,\"615\":1,\"617\":1,\"625\":2}}],[\"dd这类\",{\"1\":{\"631\":1}}],[\"ddd\",{\"1\":{\"590\":1}}],[\"dddd\",{\"1\":{\"590\":1}}],[\"dddde±dd\",{\"1\":{\"590\":2}}],[\"ddddp±ddd\",{\"1\":{\"590\":3}}],[\"db\",{\"1\":{\"404\":1,\"423\":1,\"424\":1,\"425\":2,\"427\":1,\"433\":2,\"435\":6,\"436\":1,\"437\":1,\"438\":1,\"439\":3,\"443\":1,\"444\":1,\"445\":1},\"2\":{\"430\":1,\"440\":1,\"487\":1}}],[\"db的excel读取为表格\",{\"1\":{\"62\":1}}],[\"d97214ce235bfcf5\",{\"1\":{\"396\":1}}],[\"d856c981b6266ba2便是输出的语料文件路径\",{\"1\":{\"396\":1}}],[\"d856c981b6266ba2\",{\"1\":{\"396\":7}}],[\"d为时间间隔\",{\"1\":{\"388\":1}}],[\"dmitri\",{\"1\":{\"379\":1}}],[\"dlrow\",{\"1\":{\"396\":1}}],[\"dlv\",{\"1\":{\"373\":7}}],[\"dll\",{\"1\":{\"231\":3}}],[\"dump\",{\"1\":{\"373\":1}}],[\"duration\",{\"1\":{\"331\":1,\"338\":1,\"347\":2,\"348\":2,\"349\":2,\"350\":4,\"351\":4,\"444\":9,\"524\":1,\"629\":2,\"630\":4,\"633\":1,\"634\":1,\"635\":1}}],[\"duktape\",{\"1\":{\"49\":1}}],[\"d个格式化参数的的错误\",{\"1\":{\"309\":1}}],[\"dgraph\",{\"1\":{\"253\":1}}],[\"d+\",{\"1\":{\"217\":1}}],[\"d=\",{\"1\":{\"201\":1,\"217\":1}}],[\"d将不会被返回\",{\"1\":{\"199\":1}}],[\"dsn就是数据库的连接地址\",{\"1\":{\"433\":1}}],[\"dsl\",{\"1\":{\"406\":2,\"408\":2,\"415\":4}}],[\"dst\",{\"1\":{\"175\":6,\"322\":1,\"329\":2}}],[\"dsa\",{\"1\":{\"43\":1}}],[\"d\",{\"1\":{\"111\":1,\"130\":1,\"140\":2,\"143\":3,\"144\":3,\"148\":1,\"152\":2,\"177\":4,\"179\":4,\"181\":3,\"182\":2,\"192\":1,\"199\":4,\"201\":1,\"206\":2,\"217\":1,\"218\":1,\"219\":2,\"223\":6,\"225\":1,\"229\":2,\"233\":2,\"245\":1,\"258\":2,\"312\":4,\"315\":6,\"319\":2,\"338\":1,\"347\":1,\"388\":1,\"389\":2,\"390\":24,\"391\":6,\"392\":6,\"393\":4,\"415\":1,\"422\":3,\"424\":1,\"425\":2,\"427\":10,\"428\":2,\"429\":4,\"460\":2,\"467\":1,\"472\":1,\"528\":5,\"590\":2,\"602\":4,\"629\":2,\"633\":1,\"634\":1,\"635\":1}}],[\"dns解析\",{\"1\":{\"565\":1}}],[\"dns\",{\"0\":{\"573\":1},\"1\":{\"64\":1}}],[\"dhcp6\",{\"1\":{\"64\":1}}],[\"dht实施\",{\"1\":{\"47\":1}}],[\"dht\",{\"1\":{\"47\":1}}],[\"dkim库\",{\"1\":{\"48\":1}}],[\"dkim\",{\"1\":{\"48\":1}}],[\"dynamic\",{\"1\":{\"434\":1}}],[\"dynamodb支持的分布式锁定实现\",{\"1\":{\"47\":1}}],[\"dynamolock\",{\"1\":{\"47\":1}}],[\"dynatomic\",{\"1\":{\"47\":1}}],[\"doog\",{\"1\":{\"396\":1}}],[\"doother\",{\"1\":{\"348\":2}}],[\"don\",{\"1\":{\"372\":1}}],[\"done通道将会关闭\",{\"1\":{\"346\":1}}],[\"done永远会返回nil\",{\"1\":{\"345\":1}}],[\"done方法表示当前协程已经执行完毕\",{\"1\":{\"341\":1}}],[\"done\",{\"1\":{\"185\":1,\"315\":1,\"341\":5,\"343\":3,\"344\":1,\"345\":2,\"346\":10,\"347\":2,\"348\":1,\"349\":1,\"350\":4,\"351\":4,\"353\":5,\"354\":1,\"355\":2,\"364\":4,\"368\":5,\"389\":1,\"574\":1}}],[\"doprintf\",{\"1\":{\"354\":1}}],[\"doslow\",{\"1\":{\"353\":2}}],[\"dosomthing函数显然不知道doother函数可能会对数据做点什么\",{\"1\":{\"348\":1}}],[\"dosomething\",{\"1\":{\"213\":2,\"348\":2}}],[\"download目录下存放着依赖的原始文件\",{\"1\":{\"376\":1}}],[\"download\",{\"1\":{\"375\":1,\"376\":1,\"379\":2}}],[\"downloading\",{\"1\":{\"369\":1,\"373\":14}}],[\"down\",{\"1\":{\"263\":2}}],[\"do2\",{\"1\":{\"246\":1}}],[\"do1\",{\"1\":{\"246\":1}}],[\"dog指针依然可以正常赋值给animal\",{\"1\":{\"206\":1}}],[\"dog\",{\"1\":{\"206\":13}}],[\"do\",{\"1\":{\"202\":4,\"212\":1,\"219\":5,\"233\":2,\"237\":2,\"241\":1,\"242\":3,\"243\":1,\"245\":4,\"259\":11,\"260\":4,\"312\":3,\"332\":1,\"333\":1,\"345\":2,\"348\":1,\"353\":3,\"389\":1,\"533\":1,\"534\":1}}],[\"does\",{\"1\":{\"206\":1,\"217\":1,\"237\":2,\"239\":1,\"309\":2}}],[\"doe\",{\"1\":{\"188\":1}}],[\"double\",{\"1\":{\"224\":4,\"260\":2,\"406\":2,\"407\":1}}],[\"doublejump\",{\"1\":{\"47\":1}}],[\"douceur\",{\"1\":{\"48\":1}}],[\"dot\",{\"1\":{\"47\":1,\"245\":2}}],[\"documentation\",{\"1\":{\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1}}],[\"docs\",{\"1\":{\"368\":6}}],[\"docx\",{\"1\":{\"62\":1}}],[\"doc\",{\"1\":{\"43\":1,\"215\":1,\"388\":2,\"411\":2,\"413\":4,\"415\":2}}],[\"docker\",{\"0\":{\"20\":1,\"496\":1},\"1\":{\"79\":1,\"85\":1,\"404\":2},\"2\":{\"497\":1}}],[\"drop\",{\"1\":{\"434\":1}}],[\"driven\",{\"1\":{\"393\":2}}],[\"drivername\",{\"1\":{\"433\":1}}],[\"driver接口的类型都支持\",{\"1\":{\"432\":1}}],[\"driver\",{\"1\":{\"43\":1,\"94\":1,\"419\":4,\"420\":1,\"421\":3,\"422\":2,\"423\":2,\"426\":2,\"427\":2,\"428\":2,\"429\":2,\"432\":4}}],[\"drmaa\",{\"1\":{\"47\":1}}],[\"draft\",{\"1\":{\"64\":1}}],[\"dragonboat\",{\"1\":{\"47\":1}}],[\"draw\",{\"1\":{\"43\":1}}],[\"dwarf\",{\"1\":{\"43\":1}}],[\"dial\",{\"1\":{\"574\":1}}],[\"dialtimeout\",{\"1\":{\"444\":1}}],[\"dialer\",{\"1\":{\"444\":2}}],[\"dirpath\",{\"1\":{\"329\":4}}],[\"dirs\",{\"1\":{\"327\":2}}],[\"dir\",{\"1\":{\"327\":5,\"329\":1}}],[\"direntry\",{\"1\":{\"327\":2}}],[\"director\",{\"1\":{\"538\":3}}],[\"directory\",{\"1\":{\"219\":1,\"373\":1,\"388\":1}}],[\"direct\",{\"1\":{\"370\":1}}],[\"directmedia\",{\"1\":{\"53\":1}}],[\"dic\",{\"1\":{\"279\":3,\"313\":2}}],[\"dict\",{\"1\":{\"46\":2,\"619\":1}}],[\"disconnect\",{\"1\":{\"421\":1}}],[\"discards\",{\"1\":{\"331\":1}}],[\"dismatch\",{\"1\":{\"256\":1}}],[\"disassemble\",{\"1\":{\"246\":1}}],[\"disasm\",{\"1\":{\"245\":1}}],[\"div\",{\"1\":{\"199\":1}}],[\"different\",{\"1\":{\"245\":1}}],[\"diff实用程序\",{\"1\":{\"60\":1}}],[\"difflib\",{\"1\":{\"41\":1}}],[\"digota\",{\"1\":{\"47\":1}}],[\"digital\",{\"1\":{\"43\":2}}],[\"dereference\",{\"1\":{\"643\":1}}],[\"derekparker\",{\"1\":{\"373\":1}}],[\"debian12\",{\"1\":{\"404\":1}}],[\"debugging\",{\"1\":{\"373\":3}}],[\"debug\",{\"1\":{\"43\":2,\"243\":6,\"245\":1,\"246\":3,\"247\":1,\"372\":6,\"373\":4}}],[\"deprecated\",{\"1\":{\"378\":1}}],[\"deprecation\",{\"1\":{\"378\":1}}],[\"details\",{\"1\":{\"372\":1}}],[\"demo\",{\"1\":{\"315\":5}}],[\"denied\",{\"1\":{\"309\":1}}],[\"del\",{\"1\":{\"448\":1}}],[\"deletion\",{\"1\":{\"368\":1}}],[\"deletemany\",{\"1\":{\"428\":1}}],[\"deleteone\",{\"1\":{\"428\":1}}],[\"deletedcount\",{\"1\":{\"428\":2}}],[\"deleted\",{\"1\":{\"414\":1}}],[\"deletedoc\",{\"1\":{\"414\":3}}],[\"delete\",{\"1\":{\"181\":3,\"183\":1,\"355\":1,\"409\":1,\"414\":1,\"438\":5,\"439\":1}}],[\"deltas\",{\"1\":{\"368\":1}}],[\"delta\",{\"1\":{\"341\":1,\"364\":2,\"368\":3}}],[\"delve\",{\"1\":{\"254\":1,\"373\":5}}],[\"deadlock\",{\"1\":{\"339\":1,\"341\":1}}],[\"deadline是截止时间\",{\"1\":{\"343\":1}}],[\"deadline\",{\"1\":{\"309\":1,\"343\":5,\"344\":2,\"347\":3,\"389\":2}}],[\"dead\",{\"1\":{\"228\":6}}],[\"deathowl\",{\"1\":{\"41\":1}}],[\"define\",{\"1\":{\"625\":8,\"627\":1,\"628\":2}}],[\"defined\",{\"1\":{\"247\":3}}],[\"defines\",{\"1\":{\"208\":1,\"259\":1}}],[\"defer中嵌套的panic\",{\"1\":{\"315\":1}}],[\"defer中也可以嵌套panic\",{\"1\":{\"315\":1}}],[\"defer关键字可以使得一个函数延迟一段时间调用\",{\"1\":{\"202\":1}}],[\"defer\",{\"1\":{\"97\":1,\"139\":2,\"202\":5,\"203\":1,\"204\":6,\"307\":1,\"315\":26,\"316\":3,\"319\":1,\"322\":4,\"325\":1,\"327\":1,\"329\":2,\"334\":1,\"335\":2,\"336\":3,\"337\":4,\"340\":5,\"345\":1,\"346\":6,\"347\":2,\"353\":2,\"389\":1,\"421\":1,\"435\":1,\"439\":1,\"446\":1,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"574\":3,\"633\":1,\"634\":1}}],[\"defaultservemux是的默认实例\",{\"1\":{\"537\":1}}],[\"default分支可以省略\",{\"1\":{\"340\":1}}],[\"default\",{\"1\":{\"97\":1,\"149\":3,\"228\":1,\"245\":1,\"340\":1,\"345\":1,\"346\":4,\"347\":1,\"372\":2,\"404\":1,\"434\":3,\"528\":3,\"627\":1}}],[\"device\",{\"1\":{\"217\":1}}],[\"devices\",{\"1\":{\"59\":1}}],[\"dev\",{\"1\":{\"134\":3,\"372\":1,\"441\":1}}],[\"devops\",{\"0\":{\"79\":1}}],[\"deepequal\",{\"1\":{\"298\":5}}],[\"deepequal是反射包下提供的一个用于判断两个变量是否完全相等的函数\",{\"1\":{\"298\":1}}],[\"deep\",{\"1\":{\"61\":1}}],[\"deepcopy\",{\"1\":{\"41\":1}}],[\"decr\",{\"1\":{\"458\":1}}],[\"decode\",{\"1\":{\"424\":1,\"427\":1}}],[\"decoderuneinstring\",{\"1\":{\"177\":1}}],[\"declared\",{\"1\":{\"125\":1}}],[\"decent\",{\"1\":{\"51\":1}}],[\"decimal\",{\"1\":{\"41\":1,\"52\":1}}],[\"deque\",{\"1\":{\"46\":2}}],[\"desbytes\",{\"1\":{\"175\":3}}],[\"destfile\",{\"1\":{\"329\":3}}],[\"destpath\",{\"1\":{\"329\":4}}],[\"dest\",{\"1\":{\"166\":4}}],[\"des\",{\"1\":{\"43\":2}}],[\"date\",{\"1\":{\"404\":1,\"407\":2}}],[\"datas\",{\"1\":{\"617\":8,\"619\":2,\"625\":2}}],[\"datasourcename\",{\"1\":{\"433\":1}}],[\"datastructures\",{\"1\":{\"46\":1}}],[\"database\",{\"1\":{\"43\":1,\"424\":1,\"425\":2,\"426\":2,\"427\":4,\"428\":2,\"429\":1,\"508\":2,\"513\":3,\"514\":2}}],[\"data\",{\"1\":{\"43\":1,\"222\":2,\"227\":3,\"244\":1,\"264\":1,\"266\":2,\"321\":1,\"322\":2,\"348\":4,\"349\":4,\"365\":3,\"393\":7,\"396\":4,\"407\":1,\"416\":1,\"510\":1,\"516\":1,\"521\":4,\"574\":2,\"615\":3,\"617\":32,\"619\":2,\"625\":15,\"628\":3}}],[\"dap\",{\"1\":{\"373\":3}}],[\"dangerop\",{\"1\":{\"315\":8,\"316\":6,\"317\":2}}],[\"darkroom\",{\"1\":{\"58\":1}}],[\"dag执行\",{\"1\":{\"47\":1}}],[\"davecgh\",{\"1\":{\"41\":1}}],[\"dai0522\",{\"1\":{\"41\":1}}],[\"v+1\",{\"1\":{\"620\":1}}],[\"v9\",{\"1\":{\"442\":1}}],[\"v8\",{\"1\":{\"403\":1,\"442\":1}}],[\"v7\",{\"1\":{\"403\":1}}],[\"vs\",{\"1\":{\"395\":4}}],[\"v4\",{\"1\":{\"378\":1}}],[\"v4l\",{\"1\":{\"65\":1}}],[\"vendor\",{\"1\":{\"383\":1}}],[\"verify\",{\"1\":{\"375\":1,\"382\":3}}],[\"version\",{\"1\":{\"373\":2,\"404\":4,\"407\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1}}],[\"vet\",{\"1\":{\"366\":1}}],[\"v3\",{\"1\":{\"372\":4,\"378\":2}}],[\"v0\",{\"1\":{\"372\":26,\"373\":9,\"378\":14}}],[\"v10\",{\"1\":{\"372\":4,\"378\":2}}],[\"v1\",{\"1\":{\"368\":5,\"369\":2,\"372\":15,\"373\":3,\"376\":6,\"378\":26,\"379\":14,\"381\":1,\"384\":1,\"396\":1}}],[\"v也会被输出\",{\"1\":{\"314\":1}}],[\"vtype\",{\"1\":{\"271\":3}}],[\"vue\",{\"1\":{\"249\":1}}],[\"via\",{\"1\":{\"373\":1}}],[\"viewer\",{\"1\":{\"247\":3}}],[\"visualize\",{\"1\":{\"245\":2}}],[\"visualization\",{\"1\":{\"244\":1}}],[\"viper\",{\"1\":{\"41\":2}}],[\"v\",{\"1\":{\"104\":1,\"140\":4,\"160\":4,\"206\":6,\"221\":1,\"257\":2,\"277\":1,\"278\":1,\"279\":4,\"280\":1,\"281\":3,\"284\":1,\"314\":1,\"360\":1,\"366\":1,\"373\":3,\"374\":1,\"376\":1,\"379\":1,\"382\":1,\"387\":3,\"388\":1,\"389\":1,\"390\":3,\"391\":1,\"392\":3,\"394\":1,\"395\":2,\"396\":5,\"510\":3,\"516\":2,\"519\":1,\"600\":1,\"620\":1}}],[\"vlan标签的封送处理\",{\"1\":{\"64\":1}}],[\"validatequery\",{\"1\":{\"405\":1}}],[\"validator\",{\"1\":{\"372\":2,\"378\":1}}],[\"valid\",{\"1\":{\"396\":1}}],[\"validstring\",{\"1\":{\"396\":5}}],[\"val2\",{\"1\":{\"191\":1}}],[\"val1\",{\"1\":{\"191\":1}}],[\"val\",{\"1\":{\"167\":2,\"179\":2,\"182\":4,\"204\":2,\"205\":2,\"206\":2,\"213\":1,\"221\":2,\"345\":2,\"354\":3,\"358\":1,\"360\":7,\"449\":2,\"456\":1,\"457\":1,\"458\":2,\"460\":3,\"617\":1,\"620\":4}}],[\"value结构体\",{\"1\":{\"360\":1}}],[\"value结构体类型来表示go中的值\",{\"1\":{\"267\":1}}],[\"value类型支持存储任何类型\",{\"1\":{\"357\":1}}],[\"value类型的话\",{\"1\":{\"279\":1}}],[\"valuectx多用于在多级协程中传递一些数据\",{\"1\":{\"345\":1}}],[\"valuectx实现比较简单\",{\"1\":{\"345\":1}}],[\"valuectx\",{\"0\":{\"345\":1},\"1\":{\"342\":1,\"345\":2}}],[\"value代表着反射接口的值\",{\"1\":{\"276\":1}}],[\"valueof函数\",{\"1\":{\"267\":1}}],[\"valueof\",{\"1\":{\"256\":2,\"267\":1,\"268\":1,\"276\":2,\"277\":1,\"278\":1,\"279\":2,\"280\":1,\"281\":1,\"284\":3,\"287\":2,\"290\":2,\"295\":2,\"297\":1}}],[\"values\",{\"1\":{\"245\":1,\"307\":1,\"434\":2}}],[\"valuetype\",{\"1\":{\"178\":1}}],[\"value则是对应索引下的值\",{\"1\":{\"153\":1}}],[\"value\",{\"0\":{\"360\":1},\"1\":{\"121\":1,\"153\":3,\"172\":1,\"206\":1,\"208\":2,\"237\":1,\"245\":1,\"266\":2,\"267\":2,\"276\":1,\"277\":1,\"278\":2,\"279\":6,\"280\":2,\"281\":1,\"284\":6,\"287\":3,\"288\":1,\"289\":1,\"290\":2,\"292\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":6,\"300\":1,\"331\":1,\"343\":3,\"344\":1,\"345\":3,\"354\":2,\"355\":9,\"357\":1,\"360\":7,\"372\":1,\"422\":1,\"436\":1,\"441\":1,\"611\":2}}],[\"value存储\",{\"1\":{\"41\":1}}],[\"varchar\",{\"1\":{\"434\":3}}],[\"variable\",{\"1\":{\"208\":2,\"338\":1,\"372\":1,\"619\":1}}],[\"varis\",{\"1\":{\"61\":1}}],[\"var\",{\"1\":{\"97\":1,\"112\":1,\"122\":1,\"124\":6,\"125\":6,\"128\":4,\"134\":1,\"142\":1,\"143\":1,\"144\":1,\"148\":2,\"158\":8,\"162\":1,\"168\":1,\"175\":2,\"178\":1,\"194\":2,\"197\":1,\"204\":5,\"206\":2,\"211\":1,\"212\":1,\"213\":3,\"222\":1,\"225\":1,\"226\":1,\"227\":2,\"229\":1,\"233\":1,\"241\":1,\"246\":1,\"257\":1,\"258\":1,\"262\":1,\"270\":2,\"271\":2,\"281\":1,\"300\":1,\"302\":2,\"303\":2,\"304\":4,\"305\":2,\"306\":1,\"307\":1,\"309\":1,\"312\":2,\"313\":1,\"315\":1,\"329\":2,\"332\":1,\"336\":2,\"337\":3,\"340\":1,\"341\":4,\"344\":1,\"345\":1,\"346\":2,\"347\":1,\"348\":2,\"349\":3,\"350\":3,\"351\":4,\"353\":2,\"354\":3,\"355\":4,\"358\":2,\"359\":3,\"360\":2,\"365\":1,\"394\":2,\"415\":1,\"424\":1,\"425\":2,\"427\":1,\"429\":1,\"435\":3,\"512\":1,\"515\":1,\"525\":3,\"528\":3,\"574\":1,\"628\":1,\"640\":5}}],[\"vat\",{\"1\":{\"52\":1}}],[\"vfs\",{\"1\":{\"51\":1}}],[\"vm实现\",{\"1\":{\"49\":1}}],[\"vm和编译器\",{\"1\":{\"49\":1}}],[\"vm到纯go的端口\",{\"1\":{\"49\":1}}],[\"vol\",{\"1\":{\"319\":1}}],[\"void\",{\"1\":{\"217\":1,\"219\":3,\"220\":1,\"221\":1,\"222\":5,\"223\":8,\"224\":2,\"225\":1,\"229\":1}}],[\"vorbis解码器\",{\"1\":{\"45\":1}}],[\"vorbis\",{\"1\":{\"45\":1}}],[\"vo所创建的fnv\",{\"1\":{\"43\":1}}],[\"v2\",{\"1\":{\"41\":1,\"372\":8,\"373\":4,\"378\":6}}],[\"lmsgprefix\",{\"1\":{\"541\":2}}],[\"lmicroseconds\",{\"1\":{\"541\":2}}],[\"lt\",{\"1\":{\"612\":3,\"620\":2}}],[\"ltime\",{\"1\":{\"541\":3}}],[\"ltrim\",{\"1\":{\"470\":2}}],[\"lrem\",{\"1\":{\"470\":1}}],[\"lrange\",{\"1\":{\"469\":1}}],[\"lru\",{\"1\":{\"41\":2,\"373\":1}}],[\"lpop\",{\"1\":{\"469\":1}}],[\"lpush\",{\"1\":{\"467\":1}}],[\"lutc\",{\"1\":{\"541\":1}}],[\"lucene\",{\"1\":{\"404\":1}}],[\"lukechampine\",{\"1\":{\"379\":1}}],[\"lua\",{\"1\":{\"49\":4}}],[\"lua绑定库\",{\"1\":{\"49\":1}}],[\"lua的\",{\"1\":{\"49\":1}}],[\"lstdflags\",{\"1\":{\"541\":1}}],[\"lshortfile\",{\"1\":{\"541\":2}}],[\"lset\",{\"1\":{\"467\":1}}],[\"lsonindex\",{\"1\":{\"263\":10}}],[\"ls\",{\"1\":{\"231\":1,\"372\":1,\"376\":2,\"379\":2,\"382\":1}}],[\"lsit\",{\"1\":{\"43\":1}}],[\"l指的是库文件的名称\",{\"1\":{\"231\":1}}],[\"l指的是库搜索路径\",{\"1\":{\"231\":1}}],[\"l$\",{\"1\":{\"231\":1,\"232\":1}}],[\"lf\",{\"1\":{\"224\":1}}],[\"ldate\",{\"1\":{\"541\":3}}],[\"ldflags\",{\"1\":{\"231\":1,\"232\":1}}],[\"ld\",{\"1\":{\"223\":2}}],[\"l\",{\"1\":{\"158\":2,\"177\":7,\"225\":5,\"236\":3,\"237\":1,\"238\":1,\"239\":2,\"319\":2,\"340\":3,\"351\":1,\"368\":1,\"540\":2,\"541\":2}}],[\"llongfile\",{\"1\":{\"541\":1}}],[\"llen\",{\"1\":{\"468\":1}}],[\"llibsum\",{\"1\":{\"231\":1,\"232\":1}}],[\"llb\",{\"1\":{\"64\":1}}],[\"llgo\",{\"1\":{\"55\":1}}],[\"lhttp\",{\"1\":{\"64\":1}}],[\"ln10\",{\"1\":{\"545\":2}}],[\"ln2\",{\"1\":{\"545\":2}}],[\"ln\",{\"1\":{\"58\":1}}],[\"latest后缀\",{\"1\":{\"372\":1}}],[\"latest\",{\"1\":{\"367\":2,\"369\":2,\"372\":1,\"373\":1}}],[\"lastindexany\",{\"1\":{\"604\":2}}],[\"lastindex\",{\"1\":{\"604\":2}}],[\"lastinsertid\",{\"1\":{\"436\":1}}],[\"lastwritetime\",{\"1\":{\"319\":1}}],[\"lastaccesstime\",{\"1\":{\"319\":1}}],[\"large\",{\"1\":{\"238\":1}}],[\"label\",{\"0\":{\"150\":1}}],[\"layer的\",{\"1\":{\"53\":1}}],[\"landon\",{\"1\":{\"43\":1}}],[\"language\",{\"1\":{\"185\":1,\"187\":1,\"191\":2,\"215\":1,\"510\":1,\"608\":8}}],[\"lang中的模式识别包\",{\"1\":{\"61\":1}}],[\"lang\",{\"1\":{\"41\":1,\"623\":3}}],[\"location\",{\"1\":{\"629\":1,\"632\":2}}],[\"localhost\",{\"1\":{\"514\":2,\"535\":1}}],[\"locales\",{\"1\":{\"372\":2,\"378\":1}}],[\"loc\",{\"1\":{\"629\":1}}],[\"locker等\",{\"1\":{\"352\":1}}],[\"locker\",{\"1\":{\"349\":1,\"351\":2}}],[\"locker接口\",{\"1\":{\"349\":1}}],[\"lock\",{\"1\":{\"47\":1,\"336\":5,\"348\":3,\"349\":5,\"350\":2,\"351\":2,\"353\":1,\"359\":4,\"376\":1,\"379\":3}}],[\"loadlocation\",{\"1\":{\"632\":1}}],[\"loadint64\",{\"1\":{\"358\":1,\"359\":1}}],[\"loadanddelete\",{\"1\":{\"355\":2}}],[\"loaded的值取决于key是否存在\",{\"1\":{\"355\":1}}],[\"loaded\",{\"1\":{\"355\":2}}],[\"loaded为true\",{\"1\":{\"355\":1}}],[\"loadorstore\",{\"1\":{\"355\":2}}],[\"load\",{\"1\":{\"354\":1,\"355\":2,\"358\":2,\"360\":2}}],[\"loaduint32\",{\"1\":{\"353\":1}}],[\"loop\",{\"1\":{\"340\":2,\"624\":3}}],[\"looklook\",{\"1\":{\"249\":1}}],[\"lookupmx\",{\"1\":{\"573\":1}}],[\"lookuphost\",{\"1\":{\"573\":1}}],[\"lookup支持的参数如下面代码所示\",{\"1\":{\"242\":1}}],[\"lookup\",{\"1\":{\"242\":1,\"288\":2}}],[\"longstringlongstringlongstringlongstringlongstringlongstringlongstringlongstring\",{\"1\":{\"394\":1}}],[\"longstring\",{\"1\":{\"394\":7}}],[\"longer\",{\"1\":{\"389\":1}}],[\"longlong\",{\"1\":{\"223\":2}}],[\"long\",{\"1\":{\"223\":11,\"406\":2,\"407\":1}}],[\"lowdatetime\",{\"1\":{\"319\":3}}],[\"low与high依旧是原来的含义不变\",{\"1\":{\"169\":1}}],[\"low\",{\"1\":{\"169\":3}}],[\"log10e\",{\"1\":{\"545\":1}}],[\"log2e\",{\"1\":{\"545\":1}}],[\"logf\",{\"1\":{\"390\":1,\"396\":2}}],[\"logging\",{\"1\":{\"373\":1}}],[\"logger\",{\"1\":{\"372\":1,\"540\":2,\"541\":3}}],[\"loglog\",{\"1\":{\"46\":1}}],[\"log草图\",{\"1\":{\"46\":1}}],[\"log\",{\"0\":{\"539\":1},\"1\":{\"43\":2,\"46\":1,\"198\":1,\"242\":6,\"368\":1,\"373\":1,\"390\":5,\"391\":1,\"392\":5,\"421\":2,\"424\":1,\"425\":4,\"426\":2,\"427\":4,\"428\":2,\"429\":3,\"443\":2,\"508\":1,\"539\":3,\"540\":3,\"541\":8,\"556\":4,\"568\":2,\"613\":1}}],[\"logrus\",{\"1\":{\"41\":1}}],[\"le\",{\"1\":{\"620\":2}}],[\"level\",{\"1\":{\"395\":3}}],[\"levenshtein距离和相似性度量标准\",{\"1\":{\"46\":1}}],[\"levenshtein\",{\"1\":{\"46\":2}}],[\"leodido\",{\"1\":{\"372\":2,\"378\":1}}],[\"length是一个变量\",{\"1\":{\"158\":1}}],[\"length\",{\"1\":{\"158\":5,\"222\":2}}],[\"len\",{\"1\":{\"130\":1,\"159\":1,\"163\":1,\"165\":1,\"167\":1,\"168\":1,\"173\":1,\"174\":2,\"175\":1,\"177\":4,\"179\":1,\"204\":3,\"222\":2,\"225\":3,\"262\":1,\"263\":1,\"294\":1,\"314\":1,\"317\":1,\"320\":4,\"336\":1,\"353\":3,\"396\":6,\"521\":3,\"575\":1,\"580\":2,\"611\":1,\"620\":2,\"644\":3,\"645\":2,\"646\":2,\"647\":1,\"648\":2}}],[\"less\",{\"1\":{\"128\":1,\"263\":1,\"575\":2,\"580\":1}}],[\"leaf\",{\"1\":{\"53\":1,\"252\":1}}],[\"lempel\",{\"1\":{\"43\":1}}],[\"limit\",{\"1\":{\"425\":1}}],[\"license\",{\"1\":{\"376\":1,\"382\":1}}],[\"literal\",{\"1\":{\"236\":1,\"237\":1,\"239\":1}}],[\"lili\",{\"1\":{\"189\":2,\"236\":1,\"257\":1,\"263\":3,\"426\":1,\"427\":2,\"429\":1}}],[\"lihua\",{\"1\":{\"140\":3}}],[\"lindex\",{\"1\":{\"469\":1}}],[\"linsertafter\",{\"1\":{\"467\":1}}],[\"linsertbefore\",{\"1\":{\"467\":1}}],[\"liner\",{\"1\":{\"373\":1}}],[\"line\",{\"1\":{\"145\":9,\"387\":1,\"390\":3,\"391\":1}}],[\"linkio\",{\"1\":{\"64\":1}}],[\"linux桌面应用程序\",{\"1\":{\"57\":1}}],[\"linux\",{\"1\":{\"57\":3,\"72\":1}}],[\"linux采用了elf格式\",{\"1\":{\"43\":1}}],[\"library\",{\"1\":{\"312\":2}}],[\"libsum\",{\"1\":{\"231\":2,\"232\":1}}],[\"libsvm的golang版本衍生作品\",{\"1\":{\"61\":1}}],[\"libsvm\",{\"1\":{\"61\":1}}],[\"lib\",{\"1\":{\"231\":4,\"232\":2}}],[\"libvlc\",{\"1\":{\"65\":2}}],[\"libgosubs\",{\"1\":{\"65\":1}}],[\"libpcap的包装器\",{\"1\":{\"64\":1}}],[\"libtextcat\",{\"1\":{\"63\":2}}],[\"libxlsxwriter的golang绑定\",{\"1\":{\"62\":1}}],[\"libappindicator3\",{\"1\":{\"57\":1}}],[\"liftbridge\",{\"1\":{\"47\":1}}],[\"listen\",{\"1\":{\"574\":1}}],[\"listener\",{\"1\":{\"574\":3}}],[\"listening\",{\"1\":{\"247\":1,\"372\":1}}],[\"listenandserve\",{\"1\":{\"243\":2,\"535\":1,\"536\":1,\"537\":2,\"538\":1}}],[\"listings\",{\"1\":{\"245\":1}}],[\"list\",{\"1\":{\"11\":1,\"245\":1,\"375\":1,\"376\":1,\"379\":1,\"387\":1,\"388\":1,\"435\":3,\"467\":5,\"468\":1,\"469\":4,\"470\":3,\"508\":1}}],[\"lzw\",{\"1\":{\"43\":1}}],[\"xxx\",{\"1\":{\"526\":2}}],[\"xxim\",{\"1\":{\"250\":1}}],[\"xe4\",{\"1\":{\"396\":9}}],[\"xf0\",{\"1\":{\"396\":2}}],[\"xff\",{\"1\":{\"103\":1,\"105\":1}}],[\"x90\",{\"1\":{\"396\":2}}],[\"x91\",{\"1\":{\"396\":2}}],[\"x84\",{\"1\":{\"396\":2}}],[\"xprog\",{\"1\":{\"388\":1}}],[\"x07\",{\"1\":{\"103\":1}}],[\"x的绑定\",{\"1\":{\"65\":1}}],[\"xtcp\",{\"1\":{\"64\":1}}],[\"xlsx\",{\"1\":{\"62\":4}}],[\"xmlstr\",{\"1\":{\"512\":2}}],[\"xml序列化\",{\"1\":{\"510\":1}}],[\"xml又名extensible\",{\"1\":{\"510\":1}}],[\"xml之类的\",{\"1\":{\"508\":1}}],[\"xml\",{\"0\":{\"510\":1},\"1\":{\"43\":1,\"509\":1,\"511\":1,\"512\":1}}],[\"x509\",{\"1\":{\"43\":2}}],[\"xurls\",{\"1\":{\"41\":1}}],[\"x\",{\"1\":{\"41\":1,\"43\":1,\"65\":2,\"95\":1,\"106\":1,\"140\":10,\"147\":3,\"177\":3,\"280\":1,\"298\":1,\"304\":2,\"354\":1,\"372\":10,\"373\":2,\"378\":14,\"395\":1,\"396\":1,\"590\":3,\"617\":2,\"640\":1,\"641\":1,\"642\":1,\"643\":1}}],[\"xorm\",{\"1\":{\"41\":2,\"249\":1,\"431\":1}}],[\"b>\",{\"1\":{\"612\":1}}],[\"bc\",{\"1\":{\"604\":1}}],[\"b2\",{\"1\":{\"586\":2}}],[\"btree\",{\"1\":{\"434\":1}}],[\"bsd\",{\"1\":{\"441\":1}}],[\"bson数据的有序表示\",{\"1\":{\"422\":2}}],[\"bson文档的无序表示\",{\"1\":{\"422\":2}}],[\"bson文档的有序表示的基本单位\",{\"1\":{\"422\":2}}],[\"bson文档的有序表示\",{\"1\":{\"422\":2}}],[\"bson\",{\"0\":{\"422\":1},\"1\":{\"422\":1,\"424\":1,\"425\":3,\"427\":10,\"428\":2,\"429\":4}}],[\"bsm\",{\"1\":{\"41\":1}}],[\"b76863e36670\",{\"1\":{\"372\":2,\"378\":1}}],[\"bzr\",{\"1\":{\"362\":1}}],[\"bzip2\",{\"1\":{\"43\":1}}],[\"b协程的执行结果被覆盖了\",{\"1\":{\"348\":1}}],[\"b协程已经完成了访问和计算并成功更新了count的值\",{\"1\":{\"348\":1}}],[\"bkg\",{\"1\":{\"346\":2}}],[\"broadcast\",{\"1\":{\"351\":2}}],[\"browser\",{\"1\":{\"247\":1}}],[\"break关键字会终止最内层的for循环\",{\"1\":{\"154\":1}}],[\"break\",{\"0\":{\"154\":1},\"1\":{\"97\":1,\"145\":1,\"150\":1,\"154\":2,\"263\":2,\"340\":1,\"359\":1,\"574\":1,\"624\":1}}],[\"breaker\",{\"1\":{\"56\":1}}],[\"bye\",{\"1\":{\"387\":3,\"389\":5,\"396\":4}}],[\"by\",{\"1\":{\"222\":2,\"237\":1,\"247\":2,\"332\":2,\"372\":1,\"611\":2}}],[\"bytereader\",{\"1\":{\"613\":1}}],[\"bytedance\",{\"1\":{\"372\":2,\"378\":2,\"379\":4}}],[\"byte来访问类型unsigned\",{\"1\":{\"220\":1}}],[\"byte值\",{\"1\":{\"140\":1}}],[\"byte类型即字节切片\",{\"1\":{\"119\":1}}],[\"byte\",{\"1\":{\"119\":1,\"124\":1,\"140\":3,\"142\":1,\"172\":1,\"173\":2,\"175\":1,\"176\":1,\"198\":1,\"220\":6,\"222\":8,\"239\":1,\"257\":3,\"266\":1,\"307\":1,\"320\":6,\"321\":4,\"325\":1,\"396\":4,\"397\":2,\"415\":2,\"510\":3,\"512\":1,\"513\":2,\"516\":2,\"519\":1,\"520\":1,\"574\":3,\"590\":1,\"592\":1,\"593\":1,\"611\":1,\"613\":1,\"640\":1,\"647\":3,\"648\":2}}],[\"bytescanner\",{\"1\":{\"613\":1}}],[\"bytes\",{\"1\":{\"43\":1,\"173\":7,\"176\":4,\"177\":1,\"320\":6,\"406\":1,\"408\":1,\"411\":1,\"413\":1,\"415\":3,\"508\":1,\"511\":2,\"515\":2,\"517\":2,\"519\":2,\"521\":2,\"531\":1,\"593\":8,\"648\":3}}],[\"b8\",{\"1\":{\"177\":1}}],[\"b1\",{\"1\":{\"173\":2,\"377\":1}}],[\"b1和s1的地址是一样的\",{\"1\":{\"173\":1}}],[\"b++\",{\"1\":{\"147\":2}}],[\"b++这类语句的写法是错误的\",{\"1\":{\"98\":1}}],[\"b\",{\"1\":{\"95\":1,\"104\":1,\"112\":2,\"125\":1,\"127\":19,\"128\":5,\"130\":1,\"140\":4,\"143\":3,\"144\":3,\"147\":5,\"148\":2,\"149\":1,\"150\":2,\"151\":1,\"158\":1,\"178\":1,\"179\":4,\"180\":6,\"181\":6,\"182\":4,\"183\":2,\"192\":3,\"197\":7,\"199\":14,\"200\":3,\"201\":4,\"202\":2,\"204\":19,\"213\":5,\"217\":5,\"218\":3,\"219\":11,\"220\":4,\"231\":3,\"233\":4,\"256\":8,\"258\":7,\"263\":4,\"283\":3,\"298\":2,\"303\":2,\"305\":2,\"315\":4,\"320\":2,\"321\":2,\"340\":5,\"355\":2,\"390\":28,\"391\":6,\"392\":6,\"393\":6,\"394\":19,\"395\":62,\"396\":8,\"415\":4,\"460\":5,\"467\":1,\"472\":1,\"477\":1,\"480\":1,\"483\":1,\"586\":2,\"587\":2,\"590\":2,\"592\":1,\"597\":1,\"598\":1,\"602\":4,\"611\":6,\"612\":2,\"643\":2}}],[\"bac\",{\"1\":{\"598\":1}}],[\"backend\",{\"1\":{\"373\":2}}],[\"background\",{\"1\":{\"344\":3,\"345\":1,\"346\":2,\"347\":1,\"389\":1,\"421\":1}}],[\"background和context\",{\"1\":{\"344\":1}}],[\"ba\",{\"1\":{\"598\":1,\"604\":1}}],[\"baidu\",{\"1\":{\"530\":1}}],[\"badger\",{\"1\":{\"253\":1}}],[\"basic\",{\"1\":{\"208\":1,\"627\":2,\"628\":3}}],[\"basecontext\",{\"1\":{\"536\":1}}],[\"baseline\",{\"1\":{\"396\":6}}],[\"base\",{\"1\":{\"264\":1,\"395\":4}}],[\"base64x\",{\"1\":{\"372\":2,\"378\":3}}],[\"base64\",{\"1\":{\"43\":1}}],[\"base32\",{\"1\":{\"43\":1}}],[\"bazaar\",{\"1\":{\"362\":1}}],[\"baz\",{\"1\":{\"95\":2}}],[\"bar\",{\"1\":{\"95\":2}}],[\"bang\",{\"1\":{\"95\":2}}],[\"bayesian\",{\"1\":{\"61\":1}}],[\"before\",{\"1\":{\"396\":3,\"600\":4,\"629\":1}}],[\"benchstat是一个开源的性能测试分析工具\",{\"1\":{\"395\":1}}],[\"benchstat\",{\"0\":{\"395\":1},\"1\":{\"395\":2}}],[\"benchmarkconcatbuilder\",{\"1\":{\"394\":8,\"395\":32}}],[\"benchmarkconcatdirect\",{\"1\":{\"394\":8,\"395\":32}}],[\"benchmem\",{\"1\":{\"388\":1,\"394\":1,\"395\":2}}],[\"bench\",{\"1\":{\"387\":2,\"388\":1,\"394\":3,\"395\":4}}],[\"bench参数则会运行所有类型的测试\",{\"1\":{\"387\":1}}],[\"benchtime\",{\"1\":{\"387\":1}}],[\"begin\",{\"1\":{\"373\":5,\"439\":2}}],[\"be\",{\"1\":{\"222\":4,\"389\":1}}],[\"betteralign\",{\"1\":{\"192\":1}}],[\"beta偏差校正和tailcut空间减少功能\",{\"1\":{\"46\":1}}],[\"beijing\",{\"1\":{\"140\":3}}],[\"beego\",{\"1\":{\"42\":3,\"77\":1}}],[\"blackfriday\",{\"1\":{\"373\":1}}],[\"block语句可以插槽中的默认内容\",{\"1\":{\"627\":1}}],[\"blocking\",{\"1\":{\"247\":2,\"389\":1}}],[\"blockprofilerate\",{\"1\":{\"388\":1}}],[\"blockprofile\",{\"1\":{\"242\":1,\"388\":1}}],[\"block\",{\"1\":{\"242\":1,\"243\":1,\"388\":1,\"627\":1,\"628\":1}}],[\"bloom过滤器实现\",{\"1\":{\"46\":1}}],[\"bloom\",{\"1\":{\"46\":3}}],[\"bluemonday\",{\"1\":{\"41\":1}}],[\"bluele\",{\"1\":{\"41\":1}}],[\"builtins获取默认的函数映射表\",{\"1\":{\"620\":1}}],[\"builder作为函数参数传递的时候\",{\"1\":{\"611\":1}}],[\"builder的性能要远远高于使用+拼接字符串\",{\"1\":{\"394\":1}}],[\"builder则要好很多\",{\"1\":{\"394\":1}}],[\"builder\",{\"1\":{\"176\":6,\"271\":2,\"394\":1,\"611\":13}}],[\"build\",{\"1\":{\"43\":1,\"212\":3,\"216\":1,\"218\":1,\"231\":1,\"232\":1,\"236\":2,\"237\":1,\"238\":1,\"239\":2,\"404\":5,\"528\":4}}],[\"burnt\",{\"1\":{\"378\":1}}],[\"burntsushi最终会转义为github\",{\"1\":{\"378\":1}}],[\"but\",{\"1\":{\"365\":1}}],[\"buffers\",{\"0\":{\"521\":1},\"1\":{\"509\":1}}],[\"buffer\",{\"1\":{\"296\":1,\"320\":13,\"521\":2,\"613\":3}}],[\"buffer容量\",{\"1\":{\"163\":1}}],[\"buff\",{\"1\":{\"239\":1}}],[\"buffstreams\",{\"1\":{\"64\":1}}],[\"buf\",{\"1\":{\"142\":3,\"222\":5,\"239\":1,\"354\":5,\"574\":3,\"611\":1}}],[\"bufio提供了可缓冲的输出方法\",{\"1\":{\"139\":1}}],[\"bufio可以比较方便地提供readline之类的操作\",{\"1\":{\"40\":1}}],[\"bufio\",{\"0\":{\"139\":1,\"144\":1},\"1\":{\"40\":1,\"43\":1,\"139\":2,\"144\":1,\"145\":2,\"508\":1}}],[\"b站出品必属于精品\",{\"1\":{\"42\":1}}],[\"bibibibibi\",{\"1\":{\"212\":2}}],[\"birthday\",{\"1\":{\"188\":1}}],[\"bimg\",{\"1\":{\"58\":1}}],[\"bild\",{\"1\":{\"58\":1}}],[\"bilibili开源的微服务框架\",{\"1\":{\"42\":1}}],[\"bidimap\",{\"1\":{\"46\":1}}],[\"bitzise\",{\"1\":{\"590\":1}}],[\"bitsize\",{\"1\":{\"589\":2,\"590\":1,\"591\":2,\"592\":2}}],[\"bits\",{\"1\":{\"508\":1}}],[\"bitset\",{\"1\":{\"46\":1}}],[\"bittorrent客户端软件包\",{\"1\":{\"47\":1}}],[\"bittorrent客户端和库\",{\"1\":{\"47\":1}}],[\"bittorrent\",{\"1\":{\"47\":1}}],[\"bit\",{\"1\":{\"46\":1}}],[\"bitly\",{\"1\":{\"41\":1}}],[\"bin>\",{\"1\":{\"528\":4}}],[\"bin\",{\"1\":{\"434\":4,\"528\":1}}],[\"bin或者$gobin目录下\",{\"1\":{\"373\":1}}],[\"binder\",{\"1\":{\"49\":1}}],[\"binpacker\",{\"1\":{\"46\":1}}],[\"binaryheap\",{\"1\":{\"263\":7}}],[\"binary\",{\"1\":{\"43\":1,\"373\":2,\"418\":1}}],[\"bigmemdata\",{\"1\":{\"354\":4}}],[\"bigfile\",{\"1\":{\"51\":1}}],[\"big\",{\"1\":{\"43\":1,\"508\":1}}],[\"bob\",{\"1\":{\"200\":1,\"622\":2}}],[\"body\",{\"1\":{\"153\":1,\"530\":2,\"531\":1,\"533\":1,\"534\":1,\"624\":3,\"625\":5,\"627\":1}}],[\"boot\",{\"1\":{\"212\":4}}],[\"boolvar\",{\"1\":{\"525\":1,\"528\":1}}],[\"bool\",{\"1\":{\"115\":1,\"201\":2,\"258\":1,\"270\":3,\"273\":1,\"274\":1,\"275\":1,\"286\":2,\"288\":1,\"298\":1,\"312\":2,\"343\":2,\"344\":1,\"346\":1,\"350\":2,\"353\":2,\"355\":6,\"357\":1,\"359\":1,\"382\":1,\"390\":1,\"392\":1,\"393\":1,\"397\":1,\"444\":1,\"524\":1,\"525\":2,\"528\":1,\"575\":1,\"580\":1,\"586\":1,\"587\":1,\"598\":3,\"600\":1,\"601\":1,\"602\":2,\"603\":2,\"629\":2}}],[\"boomfilters\",{\"1\":{\"46\":1}}],[\"bom\",{\"1\":{\"41\":1}}],[\"bouk\",{\"1\":{\"41\":1}}],[\"bba\",{\"1\":{\"603\":1}}],[\"bbb\",{\"1\":{\"578\":1}}],[\"bb\",{\"1\":{\"149\":1}}],[\"bbolt\",{\"1\":{\"41\":1}}],[\"bbloom\",{\"1\":{\"41\":1}}],[\"a=b返回0\",{\"1\":{\"597\":1}}],[\"a<b返回\",{\"1\":{\"597\":1}}],[\"a<<1\",{\"1\":{\"147\":2}}],[\"a019774\",{\"1\":{\"545\":1}}],[\"a002392\",{\"1\":{\"545\":1}}],[\"a002162\",{\"1\":{\"545\":1}}],[\"a002161\",{\"1\":{\"545\":1}}],[\"a002193\",{\"1\":{\"545\":1}}],[\"a001622\",{\"1\":{\"545\":1}}],[\"a001113\",{\"1\":{\"545\":1}}],[\"a000796\",{\"1\":{\"545\":1}}],[\"avhhuqv2shgkrp9z7xbdda\",{\"1\":{\"407\":1}}],[\"available\",{\"1\":{\"373\":1}}],[\"abb\",{\"1\":{\"603\":1}}],[\"abbc\",{\"1\":{\"603\":1}}],[\"abijk\",{\"1\":{\"597\":1}}],[\"abe\",{\"1\":{\"597\":5}}],[\"abs\",{\"1\":{\"548\":1}}],[\"abandon\",{\"1\":{\"389\":1}}],[\"about\",{\"1\":{\"373\":5}}],[\"abcabcabcabcabcabcabcabcabcabc\",{\"1\":{\"606\":1}}],[\"abcedf\",{\"1\":{\"598\":2}}],[\"abcedfg\",{\"1\":{\"598\":2}}],[\"abcefg\",{\"1\":{\"457\":1}}],[\"abcefghijklmn\",{\"1\":{\"456\":1}}],[\"abcd\",{\"1\":{\"597\":1}}],[\"abcdefghijk\",{\"1\":{\"605\":5,\"613\":2}}],[\"abcdefghijlmn\",{\"1\":{\"171\":2}}],[\"abcdefghisa\",{\"1\":{\"604\":1}}],[\"abcdefga\",{\"1\":{\"604\":1}}],[\"abcdefg\",{\"1\":{\"140\":1,\"598\":3,\"604\":3}}],[\"abc\",{\"1\":{\"105\":1,\"259\":1,\"597\":1,\"598\":1,\"606\":1}}],[\"a62a605\",{\"1\":{\"368\":2}}],[\"aint64\",{\"1\":{\"358\":10}}],[\"a执行的稍微快一些\",{\"1\":{\"353\":1}}],[\"a协程最初访问到的值已经过时了\",{\"1\":{\"348\":1}}],[\"a协程在计算完毕后\",{\"1\":{\"348\":1}}],[\"a协程访问数据耗费500毫秒\",{\"1\":{\"348\":1}}],[\"am\",{\"1\":{\"631\":1}}],[\"amd64\",{\"1\":{\"312\":1,\"394\":1,\"395\":3}}],[\"amqp\",{\"1\":{\"41\":1}}],[\"aggregate\",{\"1\":{\"429\":3}}],[\"agones\",{\"1\":{\"252\":1}}],[\"age>\",{\"1\":{\"511\":1,\"512\":1}}],[\"age\",{\"1\":{\"124\":1,\"125\":3,\"140\":1,\"185\":1,\"186\":1,\"187\":5,\"188\":6,\"189\":4,\"190\":3,\"191\":2,\"197\":4,\"200\":4,\"226\":6,\"227\":1,\"263\":7,\"285\":2,\"286\":1,\"287\":2,\"293\":2,\"298\":3,\"382\":1,\"406\":2,\"407\":1,\"411\":2,\"412\":1,\"413\":2,\"415\":2,\"423\":3,\"424\":3,\"425\":10,\"426\":3,\"427\":3,\"428\":1,\"429\":1,\"435\":2,\"458\":5,\"510\":2,\"511\":1,\"512\":2,\"516\":1,\"517\":2,\"518\":3,\"519\":2,\"520\":2,\"521\":3,\"525\":5,\"528\":6,\"531\":1,\"580\":6,\"581\":3,\"622\":4,\"626\":3,\"627\":4,\"628\":5,\"640\":1,\"641\":4,\"642\":4,\"643\":2}}],[\"atoi\",{\"1\":{\"584\":2}}],[\"atomic包下已经提供了原子操作相关的api\",{\"1\":{\"357\":1}}],[\"atomic\",{\"1\":{\"43\":1,\"353\":2,\"354\":1,\"357\":8,\"358\":5,\"359\":2,\"360\":5,\"388\":1}}],[\"attach\",{\"1\":{\"373\":2}}],[\"attached\",{\"1\":{\"372\":1}}],[\"atmoic包还提供了compareandswap操作\",{\"1\":{\"359\":1}}],[\"atmoic包下原子操作只有函数签名\",{\"1\":{\"357\":1}}],[\"at\",{\"1\":{\"236\":4,\"237\":3,\"238\":1,\"239\":5,\"245\":1,\"395\":3,\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1}}],[\"a2\",{\"1\":{\"198\":1}}],[\"a139339\",{\"1\":{\"545\":1}}],[\"a1\",{\"1\":{\"198\":1}}],[\"aaa\",{\"1\":{\"578\":1}}],[\"aaaaaaaaaa\",{\"1\":{\"606\":1}}],[\"aaaa\",{\"1\":{\"149\":1}}],[\"aa\",{\"1\":{\"467\":1,\"641\":1,\"642\":1}}],[\"aac比特流解析器\",{\"1\":{\"45\":1}}],[\"autocompletion\",{\"1\":{\"373\":1}}],[\"authorization\",{\"1\":{\"534\":1}}],[\"auth模块依赖于user模块的结构体user\",{\"1\":{\"382\":1}}],[\"auth\",{\"1\":{\"346\":8,\"382\":7,\"384\":1}}],[\"authservice\",{\"1\":{\"346\":2}}],[\"authentication\",{\"1\":{\"43\":1,\"382\":1}}],[\"autumn\",{\"1\":{\"132\":3}}],[\"a+b\",{\"1\":{\"127\":2,\"143\":1,\"144\":1,\"217\":1}}],[\"a++\",{\"1\":{\"98\":1,\"147\":2}}],[\"ajson\",{\"1\":{\"60\":1}}],[\"ajstarks\",{\"1\":{\"41\":1}}],[\"already\",{\"1\":{\"309\":2,\"372\":1}}],[\"alignof\",{\"0\":{\"642\":1},\"1\":{\"642\":4}}],[\"aliases\",{\"1\":{\"407\":1}}],[\"alive\",{\"1\":{\"228\":6,\"389\":1}}],[\"alice\",{\"1\":{\"200\":1}}],[\"allocation\",{\"1\":{\"407\":1}}],[\"allocated\",{\"1\":{\"222\":2}}],[\"alloc\",{\"1\":{\"246\":2}}],[\"allocsprofile\",{\"1\":{\"242\":1}}],[\"allocs\",{\"1\":{\"242\":1,\"243\":1,\"394\":13,\"395\":62}}],[\"all\",{\"1\":{\"56\":1,\"245\":1,\"339\":1,\"341\":1,\"372\":2,\"395\":2,\"415\":1,\"425\":2,\"429\":1}}],[\"algorithms\",{\"1\":{\"46\":1}}],[\"algorithm\",{\"1\":{\"43\":2}}],[\"arbitrarytyp\",{\"1\":{\"645\":1}}],[\"arbitrarytype\",{\"0\":{\"638\":1},\"1\":{\"638\":1,\"640\":1,\"641\":1,\"642\":1,\"643\":2,\"645\":1,\"646\":2}}],[\"arbitrary可以翻译为任意的\",{\"1\":{\"638\":1}}],[\"arbitrary\",{\"1\":{\"389\":1}}],[\"arch\",{\"1\":{\"372\":2,\"373\":1,\"378\":1}}],[\"archive\",{\"1\":{\"43\":1,\"508\":2}}],[\"are\",{\"1\":{\"307\":1,\"339\":1,\"341\":1,\"395\":2}}],[\"areana\",{\"1\":{\"508\":1}}],[\"area\",{\"1\":{\"186\":1}}],[\"arg3\",{\"1\":{\"620\":1}}],[\"arg2\",{\"1\":{\"620\":1}}],[\"arg1\",{\"1\":{\"620\":1}}],[\"argv\",{\"1\":{\"373\":1}}],[\"arg\",{\"1\":{\"297\":2,\"354\":1}}],[\"args\",{\"1\":{\"297\":3,\"396\":1,\"527\":1}}],[\"arguments\",{\"1\":{\"387\":1,\"390\":3,\"391\":1}}],[\"argument\",{\"1\":{\"239\":6,\"309\":1}}],[\"ar\",{\"1\":{\"232\":1}}],[\"arrange\",{\"1\":{\"222\":2}}],[\"array\",{\"1\":{\"160\":4,\"222\":2,\"270\":3}}],[\"arr\",{\"1\":{\"160\":9,\"195\":7,\"225\":5}}],[\"arp\",{\"1\":{\"64\":1}}],[\"artifex\",{\"1\":{\"56\":1}}],[\"a\",{\"1\":{\"53\":1,\"98\":4,\"103\":1,\"104\":1,\"112\":2,\"125\":11,\"127\":13,\"128\":5,\"129\":11,\"130\":1,\"143\":6,\"144\":3,\"147\":3,\"148\":2,\"149\":3,\"150\":2,\"151\":5,\"158\":1,\"172\":7,\"173\":2,\"174\":2,\"175\":2,\"176\":8,\"178\":7,\"179\":4,\"180\":4,\"181\":6,\"182\":4,\"183\":2,\"192\":3,\"197\":6,\"198\":2,\"199\":17,\"200\":3,\"201\":4,\"202\":2,\"204\":19,\"206\":4,\"208\":9,\"213\":5,\"217\":5,\"218\":3,\"219\":11,\"220\":3,\"222\":7,\"231\":3,\"232\":1,\"233\":4,\"237\":7,\"244\":1,\"245\":2,\"256\":8,\"258\":11,\"259\":1,\"263\":4,\"283\":3,\"295\":2,\"298\":2,\"300\":3,\"303\":2,\"305\":2,\"306\":2,\"313\":2,\"315\":8,\"319\":1,\"340\":5,\"354\":2,\"355\":9,\"356\":4,\"367\":1,\"369\":2,\"372\":1,\"373\":7,\"389\":2,\"390\":28,\"391\":6,\"392\":6,\"393\":6,\"395\":2,\"408\":3,\"415\":1,\"422\":3,\"460\":4,\"461\":1,\"462\":1,\"467\":4,\"470\":1,\"472\":1,\"473\":1,\"476\":1,\"477\":1,\"480\":1,\"482\":1,\"484\":1,\"574\":1,\"597\":1,\"598\":2,\"599\":2,\"602\":4,\"604\":1,\"606\":1,\"610\":10,\"618\":2}}],[\"azul3d\",{\"1\":{\"53\":1}}],[\"acknowledged\",{\"1\":{\"406\":2,\"409\":1}}],[\"accept\",{\"1\":{\"574\":1}}],[\"accidentally\",{\"1\":{\"378\":1}}],[\"accounting\",{\"1\":{\"52\":1,\"245\":1}}],[\"actual\",{\"1\":{\"355\":1,\"390\":38,\"391\":8,\"392\":8,\"393\":8}}],[\"activity\",{\"1\":{\"57\":1}}],[\"action\",{\"1\":{\"41\":1}}],[\"after函数\",{\"1\":{\"340\":1}}],[\"after函数的返回值是一个只读通道\",{\"1\":{\"338\":1}}],[\"after\",{\"1\":{\"338\":2,\"340\":3,\"389\":1,\"396\":3,\"600\":4,\"629\":1}}],[\"afs\",{\"1\":{\"51\":1}}],[\"afero\",{\"1\":{\"51\":1}}],[\"adaptor\",{\"1\":{\"373\":1}}],[\"adaptive\",{\"1\":{\"46\":1}}],[\"admin\",{\"1\":{\"249\":2,\"421\":1}}],[\"add将返回使用偏移量len更新后的pointer\",{\"1\":{\"644\":1}}],[\"addsec\",{\"1\":{\"629\":1}}],[\"addparsetree方法进行关联\",{\"1\":{\"626\":1}}],[\"addparsetree\",{\"1\":{\"626\":2}}],[\"addblock\",{\"1\":{\"405\":1}}],[\"additional\",{\"1\":{\"373\":1}}],[\"addint64\",{\"1\":{\"358\":1}}],[\"added\",{\"1\":{\"369\":1,\"372\":24}}],[\"add方法用于指明要等待的协程的数量\",{\"1\":{\"341\":1}}],[\"add和sub函数在每次操作前都会尝试向管道中发送数据\",{\"1\":{\"336\":1}}],[\"addrs\",{\"1\":{\"573\":2}}],[\"addr\",{\"1\":{\"243\":1,\"279\":10,\"287\":1,\"359\":1,\"443\":1,\"444\":2,\"445\":1,\"536\":1,\"611\":4}}],[\"addr=false\",{\"1\":{\"237\":1}}],[\"address指向的地址已经无效了\",{\"1\":{\"643\":1}}],[\"address>\",{\"1\":{\"511\":1,\"512\":1}}],[\"addresses\",{\"1\":{\"404\":1}}],[\"address\",{\"1\":{\"124\":1,\"140\":1,\"187\":4,\"188\":4,\"197\":4,\"236\":1,\"285\":2,\"286\":1,\"287\":2,\"293\":2,\"423\":1,\"424\":5,\"425\":8,\"426\":3,\"427\":5,\"429\":1,\"435\":2,\"510\":2,\"511\":1,\"512\":2,\"516\":1,\"517\":2,\"518\":3,\"519\":2,\"520\":2,\"531\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"580\":4,\"581\":3,\"622\":4,\"627\":4,\"628\":5,\"643\":3}}],[\"add\",{\"0\":{\"644\":1},\"1\":{\"185\":1,\"315\":1,\"336\":1,\"341\":5,\"345\":1,\"346\":2,\"347\":3,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"353\":4,\"354\":2,\"355\":2,\"358\":1,\"359\":2,\"368\":4,\"389\":1,\"396\":4,\"534\":1,\"574\":1,\"620\":2,\"629\":1,\"644\":3,\"645\":2,\"647\":1}}],[\"adler32\",{\"1\":{\"43\":1}}],[\"asia\",{\"1\":{\"632\":1}}],[\"asleep\",{\"1\":{\"339\":1,\"341\":1}}],[\"asm\",{\"1\":{\"312\":1,\"372\":2,\"378\":1}}],[\"as\",{\"1\":{\"206\":1,\"222\":2,\"300\":1,\"312\":3,\"367\":1,\"389\":2}}],[\"associate\",{\"1\":{\"626\":2}}],[\"assembly\",{\"1\":{\"245\":1}}],[\"assign=false\",{\"1\":{\"237\":1}}],[\"assignment\",{\"1\":{\"178\":1,\"206\":1,\"300\":1,\"313\":1}}],[\"assign\",{\"1\":{\"172\":1,\"236\":1,\"237\":1}}],[\"ass\",{\"1\":{\"65\":2}}],[\"async\",{\"1\":{\"56\":1}}],[\"astits\",{\"1\":{\"65\":1}}],[\"astisub\",{\"1\":{\"65\":1}}],[\"astilectron\",{\"1\":{\"57\":1}}],[\"astar\",{\"1\":{\"53\":1}}],[\"ast\",{\"1\":{\"43\":2,\"508\":1}}],[\"asn1\",{\"1\":{\"43\":1}}],[\"ascii85\",{\"1\":{\"43\":1}}],[\"apr\",{\"1\":{\"245\":1}}],[\"appendbool\",{\"1\":{\"593\":1}}],[\"appendfloat\",{\"1\":{\"593\":1}}],[\"appendint\",{\"1\":{\"593\":1}}],[\"append模式打开的文件\",{\"1\":{\"321\":1}}],[\"append模式打开时\",{\"1\":{\"321\":1}}],[\"append|os\",{\"1\":{\"321\":3}}],[\"appendnametopath\",{\"1\":{\"319\":1}}],[\"append函数是有返回值的\",{\"1\":{\"206\":1}}],[\"append\",{\"1\":{\"163\":2,\"164\":4,\"165\":1,\"169\":2,\"173\":1,\"176\":1,\"206\":6,\"225\":1,\"241\":1,\"246\":1,\"262\":1,\"263\":1,\"319\":2,\"320\":1,\"353\":2,\"415\":1}}],[\"application\",{\"1\":{\"531\":1}}],[\"applied\",{\"1\":{\"43\":1}}],[\"applyuri\",{\"1\":{\"421\":1}}],[\"apple\",{\"1\":{\"65\":2}}],[\"appindicator\",{\"1\":{\"57\":1}}],[\"app\",{\"1\":{\"57\":1,\"365\":1}}],[\"api设计更加合理\",{\"1\":{\"575\":1}}],[\"api对开发人员而言十分友好\",{\"1\":{\"508\":1}}],[\"api完全没问题\",{\"1\":{\"416\":1}}],[\"api完全一样\",{\"1\":{\"416\":1}}],[\"api用起来完全一样\",{\"1\":{\"415\":1}}],[\"api最常用的就是搜索api\",{\"1\":{\"415\":1}}],[\"api了解更多信息\",{\"1\":{\"413\":1}}],[\"api还可以支持script实现upsert等之类的操作\",{\"1\":{\"413\":1}}],[\"apis\",{\"1\":{\"405\":1}}],[\"api操作索引\",{\"1\":{\"405\":1}}],[\"api操纵geoserver实例\",{\"1\":{\"54\":1}}],[\"api查看服务状态\",{\"1\":{\"404\":1}}],[\"api测试服务是否可以用\",{\"1\":{\"404\":1}}],[\"api基本上都是选项式函数\",{\"1\":{\"404\":1}}],[\"api绑定\",{\"1\":{\"64\":1}}],[\"api服务器\",{\"1\":{\"61\":1}}],[\"api错误参考进行绑定\",{\"1\":{\"60\":1}}],[\"api\",{\"1\":{\"51\":1,\"58\":1,\"60\":1,\"61\":1,\"77\":1,\"404\":1,\"441\":1}}],[\"api发送邮件\",{\"1\":{\"48\":1}}],[\"api的任何问题\",{\"1\":{\"404\":1}}],[\"api的纯go实现\",{\"1\":{\"64\":1}}],[\"api的绑定\",{\"1\":{\"49\":1}}],[\"api的幼稚go绑定\",{\"1\":{\"49\":1}}],[\"api的轻型smtp客户端\",{\"1\":{\"48\":1}}],[\"api的实时api网关\",{\"1\":{\"47\":1}}],[\"apache\",{\"1\":{\"41\":1}}],[\"aes\",{\"1\":{\"43\":1}}],[\"anonymous\",{\"1\":{\"286\":1}}],[\"annotated\",{\"1\":{\"245\":1}}],[\"analyzer\",{\"1\":{\"408\":2}}],[\"analyze\",{\"1\":{\"245\":1,\"405\":1,\"408\":7}}],[\"analysis\",{\"1\":{\"244\":1,\"247\":1}}],[\"an\",{\"1\":{\"206\":8,\"208\":2,\"259\":1,\"266\":2,\"312\":1,\"372\":1,\"389\":1}}],[\"animal\",{\"1\":{\"206\":5}}],[\"ans\",{\"1\":{\"148\":18,\"199\":2,\"348\":2,\"349\":2}}],[\"ansi\",{\"1\":{\"41\":1,\"441\":1}}],[\"any类型\",{\"1\":{\"360\":1}}],[\"any类型时也可能会发生逃逸\",{\"1\":{\"239\":1}}],[\"any的参数v\",{\"1\":{\"314\":1}}],[\"anything\",{\"1\":{\"213\":21}}],[\"any接口内部没有方法集合\",{\"1\":{\"213\":1}}],[\"any\",{\"1\":{\"143\":3,\"198\":2,\"199\":1,\"208\":3,\"213\":3,\"256\":2,\"259\":1,\"262\":2,\"263\":3,\"267\":2,\"270\":1,\"271\":2,\"281\":1,\"298\":1,\"312\":1,\"314\":1,\"343\":4,\"344\":2,\"345\":3,\"354\":5,\"355\":11,\"360\":1,\"373\":1,\"389\":1,\"396\":2,\"426\":1,\"510\":3,\"516\":2,\"519\":1,\"615\":2,\"617\":11,\"619\":2,\"620\":4,\"622\":2,\"623\":2,\"624\":1,\"625\":9,\"626\":1,\"627\":1,\"628\":1}}],[\"and\",{\"1\":{\"125\":1,\"128\":1,\"177\":1,\"244\":1,\"247\":1,\"300\":1,\"302\":1,\"307\":1,\"372\":2,\"373\":5,\"389\":1,\"444\":1,\"620\":2}}],[\"andrew\",{\"1\":{\"307\":1}}],[\"andreasbriese\",{\"1\":{\"41\":1}}],[\"android\",{\"1\":{\"53\":1,\"57\":1}}],[\"ants\",{\"1\":{\"56\":1}}],[\"anko\",{\"1\":{\"49\":1}}],[\"操作go\",{\"1\":{\"416\":1}}],[\"操作函数签名如下\",{\"1\":{\"359\":1}}],[\"操作完毕后就会解锁\",{\"1\":{\"359\":1}}],[\"操作\",{\"1\":{\"41\":6}}],[\"操作系统用户包\",{\"1\":{\"508\":1}}],[\"操作系统命令包\",{\"1\":{\"508\":1}}],[\"操作系统信号包\",{\"1\":{\"508\":1}}],[\"操作系统进行交互的包\",{\"1\":{\"508\":1}}],[\"操作系统提供的系统调用包\",{\"1\":{\"508\":1}}],[\"操作系统\",{\"1\":{\"11\":1}}],[\"rlocker方法获得\",{\"1\":{\"351\":1}}],[\"rlocker\",{\"1\":{\"351\":7}}],[\"rlock\",{\"1\":{\"350\":2,\"351\":2}}],[\"rw\",{\"1\":{\"350\":11,\"351\":8}}],[\"rwmutex\",{\"1\":{\"331\":1,\"350\":8,\"351\":5}}],[\"rdwr|o\",{\"1\":{\"321\":1}}],[\"rdwr|os\",{\"1\":{\"319\":1,\"320\":2,\"321\":3,\"329\":1}}],[\"rdwr的模式打开\",{\"1\":{\"321\":1}}],[\"rdwr\",{\"1\":{\"319\":2}}],[\"rdonly\",{\"1\":{\"319\":3,\"322\":2}}],[\"russross\",{\"1\":{\"373\":1}}],[\"rust同样也是返回错误值\",{\"1\":{\"307\":1}}],[\"run=fuzzreverse\",{\"1\":{\"396\":3}}],[\"run方法会开启一个新的协程用于运行子测试\",{\"1\":{\"392\":1}}],[\"run参数来指定\",{\"1\":{\"387\":1}}],[\"run直接运行\",{\"1\":{\"369\":1}}],[\"runlock\",{\"1\":{\"350\":2,\"351\":2}}],[\"running\",{\"1\":{\"247\":1,\"372\":1,\"373\":1}}],[\"run\",{\"1\":{\"206\":9,\"366\":2,\"369\":1,\"372\":2,\"382\":1,\"387\":6,\"388\":2,\"389\":3,\"390\":8,\"391\":2,\"392\":23,\"394\":1,\"395\":2,\"396\":15,\"546\":1,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"596\":1,\"597\":1,\"598\":3,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"613\":1}}],[\"runereader\",{\"1\":{\"613\":1}}],[\"runewidth\",{\"1\":{\"373\":1}}],[\"runescanner\",{\"1\":{\"613\":1}}],[\"runes\",{\"1\":{\"177\":4}}],[\"rune再遍历也是一样的道理\",{\"1\":{\"177\":1}}],[\"rune本质上是int32的类型别名\",{\"1\":{\"177\":1}}],[\"rune\",{\"1\":{\"119\":1,\"140\":1,\"177\":1,\"396\":4,\"397\":1,\"598\":1,\"602\":2,\"604\":1,\"605\":8}}],[\"runtime\",{\"0\":{\"649\":1},\"1\":{\"43\":2,\"242\":3,\"245\":1,\"312\":4,\"388\":2,\"508\":1,\"643\":1}}],[\"rresvalue\",{\"1\":{\"284\":2}}],[\"rrestype\",{\"1\":{\"283\":2}}],[\"rpop\",{\"1\":{\"469\":1}}],[\"rpush\",{\"1\":{\"467\":1}}],[\"rparamtype\",{\"1\":{\"283\":2}}],[\"rpc调用和ftp客户端管理文件\",{\"1\":{\"51\":1}}],[\"rpcx\",{\"1\":{\"47\":1}}],[\"rpc\",{\"1\":{\"43\":3,\"47\":2}}],[\"rvalue\",{\"1\":{\"277\":2,\"278\":2,\"280\":2,\"281\":2,\"287\":6,\"290\":3,\"292\":3,\"294\":3,\"295\":3}}],[\"rtype\",{\"1\":{\"266\":3,\"267\":1,\"271\":5,\"283\":6,\"284\":2,\"286\":7,\"288\":2,\"289\":8,\"293\":2}}],[\"rsc\",{\"1\":{\"379\":1}}],[\"rsonindex\",{\"1\":{\"263\":4}}],[\"rsa等\",{\"1\":{\"508\":1}}],[\"rsa\",{\"1\":{\"43\":1}}],[\"rqlite\",{\"1\":{\"253\":1}}],[\"rquad\",{\"1\":{\"46\":1}}],[\"r\",{\"1\":{\"104\":1,\"177\":7,\"320\":1,\"322\":1,\"351\":4,\"394\":1,\"395\":3,\"396\":16,\"598\":1,\"602\":2,\"604\":1,\"605\":7,\"612\":2}}],[\"rfc\",{\"1\":{\"64\":2}}],[\"rgf93\",{\"1\":{\"54\":1}}],[\"round\",{\"1\":{\"555\":2,\"561\":2}}],[\"routing\",{\"1\":{\"407\":1}}],[\"routine\",{\"1\":{\"56\":1,\"245\":1}}],[\"rollback\",{\"1\":{\"439\":3}}],[\"rowsaffected\",{\"1\":{\"437\":1,\"438\":1}}],[\"row\",{\"1\":{\"434\":1}}],[\"root\",{\"1\":{\"312\":2,\"433\":1,\"435\":1,\"513\":1,\"514\":2,\"515\":1}}],[\"rob\",{\"1\":{\"307\":1}}],[\"robotgo\",{\"1\":{\"57\":1}}],[\"rosedb\",{\"1\":{\"253\":1}}],[\"roaring\",{\"1\":{\"46\":1}}],[\"rocketmq\",{\"0\":{\"490\":1},\"1\":{\"41\":1}}],[\"rocketmq操作\",{\"1\":{\"41\":1}}],[\"rcs\",{\"1\":{\"232\":1}}],[\"rc4\",{\"1\":{\"43\":1}}],[\"rcrowley\",{\"1\":{\"41\":2}}],[\"range所支持的pipeline必须是数组\",{\"1\":{\"624\":1}}],[\"range中也会频繁用到\",{\"1\":{\"621\":1}}],[\"range会不断读取管道中的元素\",{\"1\":{\"339\":1}}],[\"range遍历管道时\",{\"1\":{\"339\":1}}],[\"range遍历其他可迭代数据结构时\",{\"1\":{\"339\":1}}],[\"range遍历一个字符串\",{\"1\":{\"153\":1}}],[\"range语句\",{\"1\":{\"339\":1}}],[\"range可以遍历map\",{\"1\":{\"182\":1}}],[\"range可以更加方便的遍历一些可迭代的数据结构\",{\"1\":{\"153\":1}}],[\"range进行遍历时\",{\"1\":{\"177\":1}}],[\"range循环\",{\"1\":{\"167\":1}}],[\"range的实现都有所不同\",{\"1\":{\"153\":1}}],[\"range也可以迭代一个整型值\",{\"1\":{\"153\":1}}],[\"range\",{\"0\":{\"153\":1,\"339\":1},\"1\":{\"97\":1,\"143\":1,\"153\":5,\"167\":1,\"168\":2,\"177\":1,\"182\":2,\"183\":1,\"188\":1,\"201\":1,\"203\":1,\"225\":1,\"241\":1,\"246\":1,\"284\":1,\"290\":1,\"297\":1,\"327\":2,\"339\":2,\"355\":3,\"393\":1,\"396\":2,\"415\":2,\"574\":1,\"617\":4,\"619\":1,\"624\":4,\"625\":1,\"626\":1}}],[\"randomname\",{\"1\":{\"415\":2}}],[\"rand\",{\"1\":{\"43\":2,\"184\":1,\"241\":1,\"246\":1,\"331\":1,\"348\":2,\"349\":2,\"350\":4,\"351\":4,\"415\":3,\"508\":1}}],[\"rawnum\",{\"1\":{\"194\":2}}],[\"raw\",{\"1\":{\"64\":1}}],[\"rake\",{\"1\":{\"63\":2}}],[\"raspberry\",{\"1\":{\"57\":1}}],[\"raylib\",{\"1\":{\"53\":1}}],[\"rain\",{\"1\":{\"47\":1}}],[\"raft\",{\"1\":{\"47\":2}}],[\"radix\",{\"1\":{\"46\":1}}],[\"rabbitmq\",{\"1\":{\"41\":1}}],[\"rivo\",{\"1\":{\"373\":1}}],[\"riface\",{\"1\":{\"274\":3,\"275\":3}}],[\"ristretto或内存支持\",{\"1\":{\"46\":1}}],[\"ringpop\",{\"1\":{\"47\":1}}],[\"ring\",{\"1\":{\"43\":1,\"46\":1,\"508\":1}}],[\"riot\",{\"1\":{\"41\":1}}],[\"request\",{\"1\":{\"533\":2,\"534\":3,\"537\":5,\"538\":8}}],[\"require关键字表示引用了一个外部依赖\",{\"1\":{\"378\":1}}],[\"require\",{\"1\":{\"372\":2,\"378\":6}}],[\"reverse包装再进行排序\",{\"1\":{\"579\":1}}],[\"reverseproxy\",{\"1\":{\"538\":1}}],[\"reverse\",{\"1\":{\"396\":10,\"579\":1}}],[\"reused\",{\"1\":{\"364\":2,\"368\":2}}],[\"reference\",{\"1\":{\"361\":1}}],[\"reflectvalue\",{\"1\":{\"276\":2}}],[\"reflect包同时根据一些特殊的类型提供了不同的更为方便的函数\",{\"1\":{\"291\":1}}],[\"reflect包使用kind枚举出了go中所有的基础类型\",{\"1\":{\"270\":1}}],[\"reflect包提供了两个函数来将go中的类型转换为上述的两种类型以便进行反射操作\",{\"1\":{\"267\":1}}],[\"reflecttype\",{\"1\":{\"269\":2}}],[\"reflect2\",{\"1\":{\"41\":1,\"372\":2,\"378\":1}}],[\"reflect\",{\"1\":{\"41\":1,\"43\":1,\"217\":2,\"221\":2,\"226\":2,\"227\":2,\"256\":4,\"267\":1,\"269\":2,\"270\":1,\"271\":2,\"272\":5,\"273\":4,\"274\":3,\"275\":3,\"276\":2,\"277\":1,\"278\":1,\"279\":2,\"280\":1,\"281\":1,\"283\":1,\"284\":4,\"286\":3,\"287\":5,\"288\":1,\"289\":3,\"290\":6,\"292\":2,\"293\":2,\"294\":2,\"295\":4,\"296\":2,\"297\":6,\"298\":5,\"354\":1,\"508\":1}}],[\"releasemode\",{\"1\":{\"372\":1}}],[\"release\",{\"1\":{\"372\":1}}],[\"release只是符合github规范\",{\"1\":{\"368\":1}}],[\"rel\",{\"1\":{\"329\":3}}],[\"remote\",{\"1\":{\"364\":4,\"368\":1}}],[\"removed\",{\"1\":{\"372\":1}}],[\"removefromparent\",{\"1\":{\"346\":2}}],[\"removeall\",{\"1\":{\"324\":2}}],[\"remove\",{\"1\":{\"324\":2}}],[\"remember\",{\"1\":{\"46\":1}}],[\"rename\",{\"1\":{\"323\":2,\"452\":1}}],[\"repeat\",{\"1\":{\"606\":3}}],[\"replicas\",{\"1\":{\"406\":2,\"407\":1}}],[\"replacer\",{\"1\":{\"612\":1}}],[\"replacer转用于替换字符串\",{\"1\":{\"612\":1}}],[\"replaceall\",{\"1\":{\"607\":2}}],[\"replace的方便函数\",{\"1\":{\"607\":1}}],[\"replaceone\",{\"1\":{\"427\":1}}],[\"replace指令的话会修改go\",{\"1\":{\"381\":1}}],[\"replace将会替换掉指定版本的依赖\",{\"1\":{\"378\":1}}],[\"replace\",{\"1\":{\"378\":3,\"381\":1,\"384\":1,\"607\":5,\"612\":1}}],[\"repalce\",{\"1\":{\"384\":1}}],[\"repo\",{\"1\":{\"370\":1}}],[\"report\",{\"1\":{\"245\":1}}],[\"representabilitsy\",{\"1\":{\"304\":1}}],[\"representability以了解更多细节\",{\"1\":{\"304\":1}}],[\"representability\",{\"1\":{\"304\":1}}],[\"re\",{\"1\":{\"290\":2,\"396\":2}}],[\"readheadertimeout\",{\"1\":{\"536\":1}}],[\"readonly\",{\"1\":{\"444\":1}}],[\"readtimeout\",{\"1\":{\"444\":2,\"536\":1}}],[\"readpref\",{\"1\":{\"421\":2}}],[\"readdir的一层简单封装\",{\"1\":{\"327\":1}}],[\"readdir本质上也只是对\",{\"1\":{\"327\":1}}],[\"readdir函数\",{\"1\":{\"327\":2}}],[\"readdir\",{\"1\":{\"327\":6}}],[\"readfrom\",{\"1\":{\"322\":3}}],[\"readfile而言\",{\"1\":{\"320\":1}}],[\"readfile\",{\"1\":{\"320\":5,\"322\":1,\"515\":1}}],[\"readall\",{\"1\":{\"320\":3,\"530\":1}}],[\"readall而言\",{\"1\":{\"320\":1}}],[\"readat\",{\"1\":{\"320\":1}}],[\"readerat\",{\"1\":{\"613\":1}}],[\"reader实现了io\",{\"1\":{\"613\":1}}],[\"reader类型的实现\",{\"1\":{\"320\":1}}],[\"reader类似\",{\"1\":{\"145\":1}}],[\"reader\",{\"1\":{\"144\":2,\"320\":1,\"322\":2,\"531\":2,\"613\":4}}],[\"reader来进行内容读取\",{\"1\":{\"144\":1}}],[\"read\",{\"0\":{\"142\":1},\"1\":{\"142\":1,\"246\":1,\"320\":2,\"340\":1,\"350\":2,\"351\":2,\"574\":1,\"613\":3}}],[\"readme\",{\"1\":{\"126\":1,\"307\":1,\"319\":8,\"320\":5,\"321\":3,\"322\":6,\"323\":2,\"324\":1,\"368\":8,\"372\":1,\"376\":1,\"382\":1}}],[\"retractions\",{\"1\":{\"378\":1}}],[\"retract指令表示\",{\"1\":{\"378\":1}}],[\"retract\",{\"1\":{\"378\":5}}],[\"retry\",{\"1\":{\"56\":1}}],[\"returns\",{\"1\":{\"365\":1}}],[\"return关键字可以不需要指定返回哪些值\",{\"1\":{\"199\":1}}],[\"return\",{\"1\":{\"97\":1,\"127\":1,\"132\":5,\"149\":1,\"187\":1,\"188\":5,\"197\":5,\"198\":1,\"199\":6,\"200\":4,\"201\":6,\"202\":1,\"204\":4,\"212\":6,\"213\":1,\"217\":3,\"218\":1,\"219\":4,\"221\":1,\"228\":3,\"231\":1,\"233\":3,\"236\":3,\"237\":4,\"239\":1,\"241\":1,\"246\":1,\"256\":4,\"257\":1,\"258\":4,\"259\":3,\"260\":3,\"262\":7,\"263\":8,\"274\":2,\"275\":2,\"283\":2,\"285\":1,\"293\":1,\"297\":1,\"307\":5,\"309\":2,\"310\":2,\"311\":2,\"312\":9,\"319\":1,\"320\":1,\"321\":1,\"322\":6,\"325\":1,\"329\":10,\"344\":6,\"345\":3,\"346\":5,\"347\":2,\"351\":1,\"353\":5,\"354\":4,\"355\":2,\"365\":1,\"382\":5,\"390\":2,\"396\":4,\"415\":1,\"435\":3,\"436\":2,\"437\":2,\"438\":2,\"485\":2,\"511\":1,\"512\":1,\"514\":1,\"515\":2,\"517\":1,\"519\":1,\"520\":1,\"521\":2,\"530\":1,\"580\":2,\"602\":1,\"605\":4,\"615\":1,\"617\":2,\"620\":2,\"625\":2,\"626\":2,\"632\":2,\"643\":2}}],[\"regex\",{\"1\":{\"508\":1}}],[\"regexp\",{\"1\":{\"43\":2,\"388\":5}}],[\"register\",{\"1\":{\"432\":1}}],[\"register注册驱动\",{\"1\":{\"432\":1}}],[\"regions\",{\"1\":{\"247\":2}}],[\"regommend\",{\"1\":{\"61\":1}}],[\"rez\",{\"1\":{\"58\":1}}],[\"resolveunixaddr\",{\"1\":{\"572\":2}}],[\"resolveudpaddr\",{\"1\":{\"571\":3}}],[\"resolvetcpaddr\",{\"1\":{\"570\":3}}],[\"resolveipaddr\",{\"1\":{\"569\":3}}],[\"resolving\",{\"1\":{\"368\":1}}],[\"resp\",{\"1\":{\"406\":2,\"530\":3,\"531\":2,\"533\":2,\"534\":2}}],[\"responsewriter\",{\"1\":{\"537\":5,\"538\":1}}],[\"response\",{\"1\":{\"407\":2,\"408\":2,\"409\":2,\"411\":2,\"412\":2,\"413\":2,\"414\":2,\"415\":6}}],[\"responsibility\",{\"1\":{\"222\":2}}],[\"respond\",{\"1\":{\"60\":1}}],[\"result\",{\"1\":{\"331\":1,\"365\":4,\"367\":2,\"411\":1,\"413\":1,\"414\":1,\"424\":2,\"428\":4,\"436\":2,\"443\":3,\"448\":1}}],[\"results\",{\"1\":{\"297\":2}}],[\"reserved0\",{\"1\":{\"319\":1}}],[\"res\",{\"1\":{\"218\":2,\"221\":3,\"231\":2,\"232\":2,\"262\":6,\"263\":2,\"290\":2,\"394\":4,\"427\":3,\"437\":2,\"438\":2}}],[\"restful\",{\"1\":{\"77\":1,\"402\":1,\"404\":1}}],[\"rest\",{\"1\":{\"54\":1}}],[\"resgate\",{\"1\":{\"47\":1}}],[\"resize\",{\"1\":{\"41\":1,\"58\":1}}],[\"redirection\",{\"1\":{\"373\":1}}],[\"redirect\",{\"1\":{\"373\":1}}],[\"redis命令\",{\"1\":{\"446\":1}}],[\"redis命令和方法名一一对应\",{\"1\":{\"446\":1}}],[\"redis只能查询缓存不能更新\",{\"1\":{\"444\":1}}],[\"redis连接最大的存活时间\",{\"1\":{\"444\":1}}],[\"redis连接池多久会关闭一个空闲连接\",{\"1\":{\"444\":1}}],[\"redis连接池最小空闲连接数\",{\"1\":{\"444\":1}}],[\"redis连接池的最大连接数\",{\"1\":{\"444\":1}}],[\"redis新连接超时时间\",{\"1\":{\"444\":1}}],[\"redis操作失败最大重试次数\",{\"1\":{\"444\":1}}],[\"redis数据库\",{\"1\":{\"444\":1}}],[\"redis密码\",{\"1\":{\"444\":1}}],[\"redis地址\",{\"1\":{\"444\":1}}],[\"redisclient\",{\"1\":{\"443\":3,\"445\":1,\"446\":1,\"448\":2,\"449\":4,\"450\":3,\"451\":2,\"452\":1,\"453\":1,\"454\":1,\"456\":2,\"457\":2,\"458\":5,\"460\":5,\"461\":1,\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"467\":5,\"468\":1,\"469\":4,\"470\":3,\"472\":2,\"473\":4,\"474\":6,\"475\":2,\"476\":1,\"477\":1,\"478\":1,\"480\":1,\"481\":2,\"482\":4,\"483\":1,\"484\":3,\"485\":6,\"486\":3}}],[\"redis即可以当作一个nosql数据库\",{\"1\":{\"441\":1}}],[\"redis等\",{\"1\":{\"46\":1}}],[\"redis\",{\"0\":{\"441\":1},\"1\":{\"41\":3,\"47\":1,\"441\":5,\"442\":6,\"443\":5,\"444\":1,\"445\":2,\"446\":1,\"480\":2,\"482\":1,\"483\":1}}],[\"reduce\",{\"1\":{\"47\":1}}],[\"reduce系统\",{\"1\":{\"47\":1}}],[\"receiving\",{\"1\":{\"364\":1}}],[\"receive\",{\"1\":{\"338\":1}}],[\"receiver\",{\"1\":{\"206\":1}}],[\"records\",{\"1\":{\"434\":1}}],[\"recommend\",{\"1\":{\"372\":1}}],[\"recovery\",{\"1\":{\"372\":1}}],[\"recover\",{\"1\":{\"316\":3}}],[\"recognize\",{\"1\":{\"217\":1}}],[\"rectangle\",{\"1\":{\"186\":1}}],[\"rec\",{\"1\":{\"43\":1}}],[\"recipe\",{\"1\":{\"11\":1}}],[\"地图\",{\"1\":{\"46\":1}}],[\"地址解析\",{\"0\":{\"566\":1}}],[\"地址是否相等\",{\"1\":{\"213\":1}}],[\"地址\",{\"1\":{\"41\":1,\"42\":1,\"422\":1}}],[\"地理相关的位置信息和工具库\",{\"1\":{\"39\":1}}],[\"地理位置\",{\"0\":{\"54\":1},\"1\":{\"39\":1}}],[\"这两个函数实际是math包下的两个函数\",{\"1\":{\"643\":1}}],[\"这两个例子的输出都是相同的\",{\"1\":{\"177\":1}}],[\"这四个特殊操作构成了整个unsafe包的基石\",{\"1\":{\"643\":1}}],[\"这才是本文主要讲解的内容\",{\"1\":{\"615\":1}}],[\"这将会用到http\",{\"1\":{\"532\":1}}],[\"这段聚合操作就是匹配所有address为uk的用户\",{\"1\":{\"429\":1}}],[\"这段代码永远都是先输出1再输出2\",{\"1\":{\"341\":1}}],[\"这段代码的输出依旧是不确定的\",{\"1\":{\"331\":1}}],[\"这段代码的意图很明显\",{\"1\":{\"307\":1}}],[\"这段代码结果是正确的\",{\"1\":{\"203\":1}}],[\"这次的问题是对字符串做了两次反转后不相等\",{\"1\":{\"396\":1}}],[\"这次需要测试的是一个反转字符串的函数\",{\"1\":{\"396\":1}}],[\"这次将样本数修改为5个\",{\"1\":{\"395\":1}}],[\"这次就正常了\",{\"1\":{\"204\":1}}],[\"这下可以很清楚的看到每一个测试用例的执行顺序\",{\"1\":{\"387\":1}}],[\"这台机器上能用的路径可能到另一台机器上就不能用了\",{\"1\":{\"381\":1}}],[\"这单单靠一个go\",{\"1\":{\"379\":1}}],[\"这其实是对应版本的commitid\",{\"1\":{\"378\":1}}],[\"这在go中是行不通的\",{\"1\":{\"348\":1}}],[\"这在传统语言中是无法想象的\",{\"1\":{\"40\":1}}],[\"这可能会导致主协程一直阻塞等待\",{\"1\":{\"341\":1}}],[\"这会十分的繁琐\",{\"1\":{\"512\":1}}],[\"这会消耗很多的系统资源\",{\"1\":{\"350\":1}}],[\"这会覆盖原有的类型\",{\"1\":{\"302\":1}}],[\"这会极大的降低维护人员的心智负担\",{\"1\":{\"107\":1}}],[\"这三个定律便是go反射的核心\",{\"1\":{\"268\":1}}],[\"这必然会导致编译速度变慢\",{\"1\":{\"264\":1}}],[\"这并非多此一举\",{\"1\":{\"262\":1}}],[\"这类问题不关心给出的类型是什么\",{\"1\":{\"256\":1}}],[\"这时\",{\"1\":{\"617\":1}}],[\"这时可以选择再嵌套一层t\",{\"1\":{\"392\":1}}],[\"这时可以加上参数\",{\"1\":{\"387\":1}}],[\"这时候就需要用到读写锁\",{\"1\":{\"350\":1}}],[\"这时候就需要用到了泛型\",{\"1\":{\"256\":1}}],[\"这时应该通过指针来修改其元素值\",{\"1\":{\"280\":1}}],[\"这时名称不再重要\",{\"1\":{\"200\":1}}],[\"这使得我们可以暂时使用一些本地来不及发版的修改\",{\"1\":{\"381\":1}}],[\"这使得我们可以直接一键运行pprof数据采集\",{\"1\":{\"243\":1}}],[\"这使得异步流控制更加直观\",{\"1\":{\"56\":1}}],[\"这里有一些数据\",{\"1\":{\"593\":2}}],[\"这里有两篇go团队关于错误处理的文章\",{\"1\":{\"307\":1}}],[\"这里采用反转两次的方法来进行验证\",{\"1\":{\"396\":1}}],[\"这里以删除gin为例子\",{\"1\":{\"372\":1}}],[\"这里先按下不表\",{\"1\":{\"372\":1}}],[\"这里只需要将它的地址复制下来\",{\"1\":{\"372\":1}}],[\"这里直接选择第一个\",{\"1\":{\"372\":1}}],[\"这里会出现很多搜索结果\",{\"1\":{\"372\":1}}],[\"这里选择七牛云的代理\",{\"1\":{\"370\":1}}],[\"这里开启1000个协程\",{\"1\":{\"354\":1}}],[\"这里传入的是sync\",{\"1\":{\"351\":1}}],[\"这里使用的是sqlx库\",{\"1\":{\"431\":1}}],[\"这里使用了sync\",{\"1\":{\"341\":1}}],[\"这里使用时就不能省略掉类型实参\",{\"1\":{\"257\":1}}],[\"这里总共创建了3个管道\",{\"1\":{\"336\":1}}],[\"这里面主要包含了以下几个部分\",{\"1\":{\"247\":1}}],[\"这里的数据大多数可读性并不高\",{\"1\":{\"243\":1}}],[\"这里的类型内存大小更为清晰明确\",{\"1\":{\"223\":1}}],[\"这里将切片的底层数组的指针传递给了c函数\",{\"1\":{\"225\":1}}],[\"这里将称成为grow函数\",{\"1\":{\"201\":1}}],[\"这适用于简单的场景\",{\"1\":{\"217\":1}}],[\"这就会出现一个问题\",{\"1\":{\"378\":1}}],[\"这就形成了死锁\",{\"1\":{\"341\":1}}],[\"这就是问题所在\",{\"1\":{\"353\":1}}],[\"这就是面向接口编程的好处\",{\"1\":{\"212\":1}}],[\"这就是间接的循环导入\",{\"1\":{\"94\":1}}],[\"这就叫面向接口编程\",{\"1\":{\"212\":1}}],[\"这就叫实现\",{\"1\":{\"212\":1}}],[\"这就叫接口\",{\"1\":{\"212\":1}}],[\"这部分应该是希望它们在函数体执行结束后再执行\",{\"1\":{\"204\":1}}],[\"这也解释了为什么下面看起来很正常的代码会发生死锁\",{\"1\":{\"335\":1}}],[\"这也是通常而言推荐模块名格式\",{\"1\":{\"378\":1}}],[\"这也是为什么不允许被值拷贝的原因\",{\"1\":{\"611\":1}}],[\"这也是为什么上例中对象计数要用到原子值的原因\",{\"1\":{\"354\":1}}],[\"这也是为什么go的并发性能很不错的原因之一\",{\"1\":{\"331\":1}}],[\"这也是为什么需要as函数的原因\",{\"1\":{\"312\":1}}],[\"这也是为什么前面提到了只要有反射就离不开空接口\",{\"1\":{\"267\":1}}],[\"这也是一个空接口\",{\"1\":{\"213\":1}}],[\"这也就导致了例子中的结果\",{\"1\":{\"206\":1}}],[\"这也就导致了第一个例子中的奇怪现象\",{\"1\":{\"204\":1}}],[\"这也造成了每次哈希值都不相同\",{\"1\":{\"180\":1}}],[\"这也代表了编译器是如何看待你的代码的\",{\"1\":{\"110\":1}}],[\"这一过程可以用go\",{\"1\":{\"382\":1}}],[\"这一过程通常不会花费太多时间\",{\"1\":{\"373\":1}}],[\"这一串网址同时也是go项目的模块名称\",{\"1\":{\"378\":1}}],[\"这一点是我们不希望看到的\",{\"1\":{\"381\":1}}],[\"这一点会在后续的管道原理中说明\",{\"1\":{\"338\":1}}],[\"这一点你会在以后的编码中慢慢体会到\",{\"1\":{\"248\":1}}],[\"这一小节会简单的介绍下go的类型系统和基本使用\",{\"1\":{\"299\":1}}],[\"这一堆概念很死板\",{\"1\":{\"208\":1}}],[\"这一段代码将会无法通过编译\",{\"1\":{\"206\":1}}],[\"这一概念\",{\"1\":{\"201\":1}}],[\"这一键值对\",{\"1\":{\"179\":1}}],[\"这一节就来讲一下在go中如何进行输入输出\",{\"1\":{\"133\":1}}],[\"这超出了基础的范围\",{\"1\":{\"177\":1}}],[\"这显然会出现乱码\",{\"1\":{\"177\":1}}],[\"这\",{\"1\":{\"174\":1}}],[\"这么做可以减少cpu访问内存的次数\",{\"1\":{\"192\":1}}],[\"这么做是为了内存安全\",{\"1\":{\"173\":1}}],[\"这么做通常是为了加载包下的init函数\",{\"1\":{\"94\":1}}],[\"这样\",{\"1\":{\"643\":1}}],[\"这样使用就等同于单元测试\",{\"1\":{\"396\":1}}],[\"这样在后续的学习中会更加方便\",{\"1\":{\"386\":1}}],[\"这样就可以避免出现上述问题\",{\"1\":{\"396\":1}}],[\"这样就可能会造成程序错误\",{\"1\":{\"378\":1}}],[\"这样就实现了一个简单的互斥锁\",{\"1\":{\"336\":1}}],[\"这样无锁化的操作虽然不会导致协程阻塞\",{\"1\":{\"359\":1}}],[\"这样确实三个管道都能用上了\",{\"1\":{\"340\":1}}],[\"这样可以使得分析日志时定位更准确\",{\"1\":{\"391\":1}}],[\"这样可以存放任意类型\",{\"1\":{\"263\":1}}],[\"这样可以避免覆盖原切片的后续元素\",{\"1\":{\"170\":1}}],[\"这样做肯定比以前使用interface\",{\"1\":{\"263\":1}}],[\"这样做的好处就是传递的过程不再需要拷贝\",{\"1\":{\"222\":1}}],[\"这样做会更安全\",{\"1\":{\"222\":1}}],[\"这样才能确保程序正常通过编译\",{\"1\":{\"216\":1}}],[\"这样的测试数据看起来就要直观很多\",{\"1\":{\"393\":1}}],[\"这样的代码依旧不能修改内部的值\",{\"1\":{\"205\":1}}],[\"这样的代码连编译都过不了\",{\"1\":{\"108\":1}}],[\"这样的程序将无法通过编译\",{\"1\":{\"195\":1}}],[\"这样一来即便不需要注释也可以知晓这是什么类型的测试\",{\"1\":{\"386\":1}}],[\"这样一来将协程a添加的数据直接覆盖掉了\",{\"1\":{\"353\":1}}],[\"这样一来\",{\"1\":{\"220\":1,\"348\":1}}],[\"这样一来对于不同实例化的需求只需要一个构造函数即可完成\",{\"1\":{\"188\":1}}],[\"这样一来就是一个简单的枚举实现了\",{\"1\":{\"132\":1}}],[\"这样用起来太麻烦了\",{\"1\":{\"142\":1}}],[\"这种格式纯粹是个人觉得看的顺眼\",{\"1\":{\"617\":1}}],[\"这种格式\",{\"1\":{\"617\":1}}],[\"这种嵌套的测试用例一般称为子测试\",{\"1\":{\"392\":1}}],[\"这种优化带来的提升是显而易见的\",{\"1\":{\"354\":1}}],[\"这种复制方式需要先将源文件的全部内容读取到内存中\",{\"1\":{\"322\":1}}],[\"这种判断语句\",{\"1\":{\"307\":1}}],[\"这种情况一般是有特殊用途\",{\"1\":{\"340\":1}}],[\"这种情况panic确实会恢复\",{\"1\":{\"316\":1}}],[\"这种情况下就会占用很大的内存并且给gc带来非常大的压力\",{\"1\":{\"354\":1}}],[\"这种情况下\",{\"1\":{\"303\":1}}],[\"这种情况就没法直接访问了\",{\"1\":{\"220\":1}}],[\"这种情况经常会在遍历字符串时遇到\",{\"1\":{\"177\":1}}],[\"这种方式来直接访问\",{\"1\":{\"220\":1}}],[\"这种我们一般称之为内存泄漏\",{\"1\":{\"203\":1}}],[\"这种理念是否正确见仁见智\",{\"1\":{\"197\":1}}],[\"这种代码是可以通过编译的\",{\"1\":{\"125\":1}}],[\"这种设计虽然避免了程序中断\",{\"1\":{\"84\":1}}],[\"这个管道与chan是两个东西\",{\"1\":{\"621\":1}}],[\"这个例子非常的简单\",{\"1\":{\"574\":1}}],[\"这个redis驱动几乎将所有的操作封装好了\",{\"1\":{\"446\":1}}],[\"这个回滚自然是无效的\",{\"1\":{\"439\":1}}],[\"这个时候就可以使用retract指令\",{\"1\":{\"378\":1}}],[\"这个过程是自动完成的\",{\"1\":{\"369\":1}}],[\"这个过程叫传递\",{\"1\":{\"311\":1}}],[\"这个有很多选择\",{\"1\":{\"364\":1}}],[\"这个包通常命名为test\",{\"1\":{\"386\":1}}],[\"这个包相当于是标准库errors包的加强版\",{\"1\":{\"312\":1}}],[\"这个包对于实现go语言的调试器非常有价值\",{\"1\":{\"43\":1}}],[\"这个类型约束内规定了哪些类型是允许的\",{\"1\":{\"256\":1}}],[\"这个很好理解\",{\"1\":{\"237\":1}}],[\"这个坑还是非常隐晦的\",{\"1\":{\"204\":1}}],[\"这个序号其实就是代码的相对行号\",{\"1\":{\"131\":1}}],[\"这个效果就更为明显\",{\"1\":{\"127\":1}}],[\"这个规则仅适用于函数内的变量\",{\"1\":{\"125\":1}}],[\"这个可见性的规则适用于整个go语言的任何地方\",{\"1\":{\"93\":1}}],[\"这个特性特别适合容器化应用和微服务架构的部署\",{\"1\":{\"75\":1}}],[\"这意味着所有变量的类型在编译时就已经确定\",{\"1\":{\"71\":1}}],[\"这些定义的模板在并不会生成在最终的模板中\",{\"1\":{\"625\":1}}],[\"这些是比较常用的api\",{\"1\":{\"409\":1}}],[\"这些是对net\",{\"1\":{\"43\":1}}],[\"这些内置的基础类型\",{\"1\":{\"299\":1}}],[\"这些数据要看懂还挺不容易的\",{\"1\":{\"247\":1}}],[\"这些函数实际上并不存在\",{\"1\":{\"222\":1}}],[\"这些变量的内存会随着出栈而被回收\",{\"1\":{\"201\":1}}],[\"这些枚举实际上就是数字\",{\"1\":{\"132\":1}}],[\"这些\",{\"1\":{\"70\":1}}],[\"这是自定义函数的途径之一\",{\"1\":{\"620\":1}}],[\"这是为了减少传输过程的空间损耗\",{\"1\":{\"519\":1}}],[\"这是为了避免内存安全问题\",{\"1\":{\"87\":1}}],[\"这是这门语言的核心所在\",{\"1\":{\"330\":1}}],[\"这是\",{\"1\":{\"309\":1}}],[\"这是具名返回值的使用方式\",{\"1\":{\"262\":1}}],[\"这是benchmark所不能满足的\",{\"1\":{\"234\":1}}],[\"这是因为go并没有一个公共的依赖仓库\",{\"1\":{\"378\":1}}],[\"这是因为go会在适当情况下对指针进行解引用\",{\"1\":{\"206\":1}}],[\"这是因为在unicode编码中\",{\"1\":{\"174\":1}}],[\"这是两个不同的类型\",{\"1\":{\"206\":1}}],[\"这是一段输出\",{\"1\":{\"152\":1}}],[\"这是一个手动声明多个变量来创建测试数据的例子\",{\"1\":{\"393\":1}}],[\"这是一个使用互斥锁的例子\",{\"1\":{\"359\":1}}],[\"这是一个管道的声明语句\",{\"1\":{\"332\":1}}],[\"这是一个在循环体中开启协程的例子\",{\"1\":{\"331\":1}}],[\"这是一个原始错误\",{\"1\":{\"311\":1}}],[\"这是一个原生字符串\",{\"1\":{\"171\":1}}],[\"这是一个错误\",{\"1\":{\"309\":1}}],[\"这是一个计算文件哈希值的demo\",{\"1\":{\"307\":1}}],[\"这是一个典型的数值溢出问题\",{\"1\":{\"304\":1}}],[\"这是一个二维map\",{\"1\":{\"303\":1}}],[\"这是一个函数指针\",{\"1\":{\"301\":1}}],[\"这是一个泛型结构体\",{\"1\":{\"257\":1}}],[\"这是一个泛型哈希表\",{\"1\":{\"257\":1}}],[\"这是一个泛型切片形参的例子\",{\"1\":{\"257\":1}}],[\"这是一个泛型切片\",{\"1\":{\"257\":1}}],[\"这是一个功能十分简单的函数\",{\"1\":{\"256\":1}}],[\"这是一个很简单的模板文件使用案例\",{\"1\":{\"628\":1}}],[\"这是一个很简单的readme文档\",{\"1\":{\"367\":1}}],[\"这是一个很简单的示例\",{\"1\":{\"236\":1}}],[\"这是一个很经典的循环案例\",{\"1\":{\"152\":1}}],[\"这是一个非常简单的测试\",{\"1\":{\"233\":1}}],[\"这是一个person接口\",{\"1\":{\"210\":1}}],[\"这是一个自定义排序规则的例子\",{\"1\":{\"200\":1}}],[\"这是一个无序比较双精度浮点数的指令\",{\"1\":{\"180\":1}}],[\"这是一个字符串\",{\"1\":{\"174\":2}}],[\"这是一个普通字符串\",{\"1\":{\"171\":4}}],[\"这是一个变量\",{\"1\":{\"158\":1}}],[\"这是一个双循环\",{\"1\":{\"154\":1}}],[\"这是一个死循环\",{\"1\":{\"152\":1}}],[\"这是一个语句\",{\"1\":{\"96\":1}}],[\"这是一个超级简单的负载均衡器\",{\"1\":{\"64\":1}}],[\"这是一个围棋实施解霸其中中国分词算法\",{\"1\":{\"63\":1}}],[\"这是一个档案主页的案例\",{\"1\":{\"2\":1}}],[\"这是计算斐波那契数列的一小段代码\",{\"1\":{\"127\":1}}],[\"这是启动函数main函数\",{\"1\":{\"96\":1}}],[\"这是直接循环导入\",{\"1\":{\"94\":1}}],[\"这是代理服务器的非常简单但快速的后端\",{\"1\":{\"64\":1}}],[\"这是main包\",{\"1\":{\"96\":1}}],[\"这是martin\",{\"1\":{\"63\":1}}],[\"这是mmseg的go实现\",{\"1\":{\"63\":1}}],[\"这是众所周知的库\",{\"1\":{\"51\":1}}],[\"这是项目主页的案例\",{\"1\":{\"0\":1}}],[\"通用接口就是为了泛型服务的\",{\"1\":{\"214\":1}}],[\"通用接口\",{\"0\":{\"214\":1},\"1\":{\"208\":1}}],[\"通用网关接口\",{\"1\":{\"43\":1}}],[\"通常我们会有一个需求就是\",{\"1\":{\"632\":1}}],[\"通常用于测试程序的内存占用\",{\"1\":{\"394\":1}}],[\"通常用于表述一些不可再细化分割的操作\",{\"1\":{\"356\":1}}],[\"通常用于表示一个常量声明中的无类型整数序数\",{\"1\":{\"131\":1}}],[\"通常是官方所编写的标准库代码示例\",{\"1\":{\"389\":1}}],[\"通常该目录为$gomodcache\",{\"1\":{\"379\":1}}],[\"通常格式为vx\",{\"1\":{\"378\":1}}],[\"通常来说\",{\"1\":{\"339\":1}}],[\"通常关闭操作会放在defer语句里\",{\"1\":{\"319\":1}}],[\"通常在一些危险操作中会出现\",{\"1\":{\"313\":1}}],[\"通常建议小转大\",{\"1\":{\"304\":1}}],[\"通常会使用char\",{\"1\":{\"222\":1}}],[\"通常会用到该包\",{\"1\":{\"40\":1}}],[\"通常不建议使用这种方式\",{\"1\":{\"187\":1}}],[\"通常情况下需要配置以下几个环境配置来进行模块私有处理\",{\"1\":{\"380\":1}}],[\"通常情况下是调用os包下的exit函数退出程序\",{\"1\":{\"317\":1}}],[\"通常情况下\",{\"1\":{\"162\":1,\"177\":1,\"338\":1,\"378\":1,\"379\":1}}],[\"通道用使用起来都是类似的\",{\"1\":{\"271\":1}}],[\"通道分配内存\",{\"1\":{\"196\":1}}],[\"通道\",{\"1\":{\"70\":1,\"120\":1,\"121\":1,\"128\":1,\"153\":1,\"213\":1,\"271\":1}}],[\"通过uintptr转换为unsafe\",{\"1\":{\"643\":1}}],[\"通过unsafe包下提供的操作\",{\"1\":{\"306\":1}}],[\"通过unsafe\",{\"1\":{\"225\":1,\"227\":1}}],[\"通过block语句\",{\"1\":{\"627\":1}}],[\"通过with语句还可以在作用域内改写根对象\",{\"1\":{\"622\":1}}],[\"通过with语句可以控制变量和根对象的作用域\",{\"1\":{\"622\":1}}],[\"通过web和api界面进行电子邮件和smtp测试\",{\"1\":{\"48\":1}}],[\"通过$衔接变量名来访问该变量的值\",{\"1\":{\"619\":1}}],[\"通过$符号来表示这是一个变量\",{\"1\":{\"619\":1}}],[\"通过直接调用http包下的函数就可以发起简单的请求\",{\"1\":{\"530\":1}}],[\"通过直观的数据对比性能正是基准测试的目的所在\",{\"1\":{\"394\":1}}],[\"通过调用flag\",{\"1\":{\"526\":1}}],[\"通过sqlx\",{\"1\":{\"433\":1}}],[\"通过size方法可以获取对应类型所占的字节大小\",{\"1\":{\"272\":1}}],[\"通过以上几种类型\",{\"1\":{\"422\":1}}],[\"通过命令go\",{\"1\":{\"388\":2}}],[\"通过命令行就可以使用\",{\"1\":{\"107\":1}}],[\"通过一行代码就运行起了一个最简单的web服务器\",{\"1\":{\"372\":1}}],[\"通过go\",{\"1\":{\"364\":1,\"369\":2,\"405\":1}}],[\"通过如下命令开启用go\",{\"1\":{\"363\":1}}],[\"通过如下命令来查看是否开启\",{\"1\":{\"363\":1}}],[\"通过rwmutex\",{\"1\":{\"351\":1}}],[\"通过有缓冲管道还可以实现一个简单的互斥锁\",{\"1\":{\"336\":1}}],[\"通过内置函数len可以访问管道缓冲区中数据的个数\",{\"1\":{\"336\":1}}],[\"通过openfile函数可以控制更多细节\",{\"1\":{\"319\":1}}],[\"通过格式化输出\",{\"1\":{\"312\":1}}],[\"通过实现error\",{\"1\":{\"310\":1}}],[\"通过这种写法可以根据不同的case做出不同的逻辑处理\",{\"1\":{\"306\":1}}],[\"通过显式的将myfloat64\",{\"1\":{\"304\":1}}],[\"通过类型声明的类型都是新类型\",{\"1\":{\"302\":1}}],[\"通过time\",{\"1\":{\"633\":1,\"634\":1}}],[\"通过t\",{\"1\":{\"391\":1,\"392\":1}}],[\"通过type关键字声明了一个基础类型为int64名为myint的类型\",{\"1\":{\"302\":1}}],[\"通过tcp和udp发送数据包\",{\"1\":{\"64\":1}}],[\"通过tcp流化协议缓冲区数据变得容易\",{\"1\":{\"64\":1}}],[\"通过索引访问的例子如下\",{\"1\":{\"286\":1}}],[\"通过反射可以构造新的值\",{\"1\":{\"291\":1}}],[\"通过反射可以获取函数的一切信息\",{\"1\":{\"282\":1}}],[\"通过反射值来调用函数\",{\"1\":{\"284\":1}}],[\"通过反射类型来获取函数的一切信息\",{\"1\":{\"283\":1}}],[\"通过反向传播进行训练\",{\"1\":{\"61\":1}}],[\"通过id删除一个指定的文档\",{\"1\":{\"414\":1}}],[\"通过info\",{\"1\":{\"404\":1}}],[\"通过interface\",{\"1\":{\"281\":1}}],[\"通过implements方法可以判断一个类型是否实现了某一接口\",{\"1\":{\"274\":1}}],[\"通过kind方法\",{\"1\":{\"270\":1}}],[\"通过kind\",{\"1\":{\"270\":1}}],[\"通过list命令以源代码的形式查看\",{\"1\":{\"245\":1}}],[\"通过图片我们可以更加清晰的看到整个调用栈的内存情况\",{\"1\":{\"245\":1}}],[\"通过各种各样的测试\",{\"1\":{\"234\":1}}],[\"通过前缀c\",{\"1\":{\"228\":1}}],[\"通过cap可以访问管道缓冲区的大小\",{\"1\":{\"336\":1}}],[\"通过comparable方法可以判断一个类型是否可以被比较\",{\"1\":{\"273\":1}}],[\"通过c\",{\"1\":{\"226\":1}}],[\"通过引入c文件\",{\"1\":{\"218\":1}}],[\"通过导入语句import\",{\"1\":{\"216\":1}}],[\"通过输出可以很清晰的看到父子的层级结构\",{\"1\":{\"392\":1}}],[\"通过输出可以看到\",{\"1\":{\"225\":1}}],[\"通过输出会发现\",{\"1\":{\"213\":1}}],[\"通过输出字符串第一个元素可以看出结果\",{\"1\":{\"174\":1}}],[\"通过对比上面几个例子可以发现这段代码\",{\"1\":{\"204\":1}}],[\"通过结果得知成功导入了模块\",{\"1\":{\"382\":1}}],[\"通过结果可以观察到相同的键值并没有覆盖\",{\"1\":{\"180\":1}}],[\"通过结构体和方法也可以模拟出一个类\",{\"1\":{\"185\":1}}],[\"通过for\",{\"1\":{\"182\":1,\"339\":1}}],[\"通过fallthrough关键字来继续执行相邻的下一个分支\",{\"1\":{\"149\":1}}],[\"通过代码可以观察到\",{\"1\":{\"179\":1}}],[\"通过var\",{\"1\":{\"162\":1}}],[\"通过vies检查增值税号和检查iban银行帐号的模块\",{\"1\":{\"52\":1}}],[\"通过上面几个例子可以发现\",{\"1\":{\"131\":1}}],[\"通过函数来进行两数相加\",{\"1\":{\"127\":1}}],[\"通过不同的前缀可以表达不同进制的浮点数\",{\"1\":{\"101\":1}}],[\"通过名称访问的例子如下\",{\"1\":{\"286\":1}}],[\"通过名称\",{\"1\":{\"94\":1}}],[\"通过名称和id进行用户账户检查\",{\"1\":{\"43\":1}}],[\"通过\",{\"1\":{\"83\":1,\"617\":2}}],[\"通过其http服务器运行时提供性能测试数据\",{\"1\":{\"43\":1}}],[\"通过构建内存索引实现的高速字符串匹配查找算法\",{\"1\":{\"43\":1}}],[\"通过http包\",{\"1\":{\"40\":1}}],[\"hw\",{\"1\":{\"567\":3}}],[\"hscan\",{\"1\":{\"465\":1}}],[\"hset\",{\"1\":{\"460\":1}}],[\"hlen\",{\"1\":{\"464\":1}}],[\"hls的m3u8播放列表的解析器和生成器库\",{\"1\":{\"65\":1}}],[\"hkeys\",{\"1\":{\"463\":1}}],[\"hdel\",{\"1\":{\"461\":1}}],[\"hmget\",{\"1\":{\"460\":1}}],[\"hmset\",{\"1\":{\"460\":1}}],[\"hmac\",{\"1\":{\"43\":2}}],[\"h1\",{\"1\":{\"379\":2}}],[\"hgetall\",{\"1\":{\"460\":1}}],[\"hget\",{\"1\":{\"460\":1}}],[\"hg\",{\"1\":{\"362\":1}}],[\"h头文件\",{\"1\":{\"231\":1}}],[\"h不能在go文件导入\",{\"1\":{\"219\":1}}],[\"h中还定义了其它很多错误代码\",{\"1\":{\"217\":1}}],[\"h>中的整数类型\",{\"1\":{\"223\":1}}],[\"h>的整数类型提供了支持\",{\"1\":{\"223\":1}}],[\"h>\",{\"1\":{\"216\":1,\"217\":4,\"219\":6,\"220\":1,\"221\":2,\"222\":8,\"223\":1,\"224\":1,\"225\":4,\"226\":2,\"227\":2,\"228\":2,\"229\":4,\"231\":2,\"233\":1}}],[\"hour\",{\"1\":{\"630\":1}}],[\"honnef\",{\"1\":{\"379\":1}}],[\"host\",{\"1\":{\"314\":2,\"444\":1,\"538\":1}}],[\"how\",{\"1\":{\"246\":1}}],[\"hoist\",{\"1\":{\"212\":8}}],[\"home\",{\"1\":{\"0\":1,\"2\":1,\"95\":1,\"384\":1}}],[\"h\",{\"1\":{\"177\":3,\"217\":1,\"218\":3,\"219\":8,\"222\":2,\"231\":2,\"232\":1,\"274\":1,\"275\":1,\"528\":1,\"537\":1}}],[\"hugo\",{\"1\":{\"254\":1}}],[\"husk提取算法的golang实现\",{\"1\":{\"63\":1}}],[\"huego\",{\"1\":{\"59\":1}}],[\"hunch\",{\"1\":{\"56\":1}}],[\"hprose\",{\"1\":{\"47\":1}}],[\"hyperloglog实施\",{\"1\":{\"46\":1}}],[\"hyperloglog\",{\"1\":{\"46\":1}}],[\"his\",{\"1\":{\"274\":1,\"275\":1}}],[\"hisstruct\",{\"1\":{\"274\":3,\"275\":3}}],[\"highdatetime\",{\"1\":{\"319\":3}}],[\"high\",{\"1\":{\"169\":2}}],[\"hilbert\",{\"1\":{\"46\":1}}],[\"hide\",{\"1\":{\"46\":1}}],[\"here\",{\"1\":{\"367\":1}}],[\"hertz\",{\"1\":{\"249\":1}}],[\"hermes\",{\"1\":{\"48\":1}}],[\"hellc++\",{\"1\":{\"607\":1}}],[\"hellc\",{\"1\":{\"607\":2}}],[\"helloworld\",{\"1\":{\"185\":2,\"578\":1}}],[\"hello\",{\"1\":{\"91\":2,\"96\":1,\"105\":1,\"106\":1,\"108\":2,\"130\":1,\"133\":1,\"136\":1,\"137\":2,\"138\":1,\"139\":2,\"140\":4,\"153\":1,\"173\":1,\"177\":5,\"216\":2,\"257\":2,\"269\":1,\"273\":1,\"276\":2,\"281\":2,\"290\":2,\"292\":2,\"320\":3,\"321\":14,\"325\":1,\"331\":7,\"341\":4,\"355\":3,\"360\":1,\"362\":2,\"364\":7,\"365\":18,\"366\":3,\"367\":8,\"368\":30,\"369\":10,\"376\":4,\"381\":2,\"384\":2,\"387\":7,\"389\":9,\"396\":4,\"443\":2,\"588\":4,\"596\":3,\"600\":14,\"601\":4,\"607\":5,\"611\":2,\"615\":2,\"617\":10,\"623\":2,\"647\":1,\"648\":1}}],[\"helper\",{\"0\":{\"391\":1},\"1\":{\"391\":3,\"392\":1}}],[\"help\",{\"1\":{\"245\":1,\"373\":7,\"385\":1,\"388\":1}}],[\"height\",{\"1\":{\"186\":1}}],[\"hectane\",{\"1\":{\"48\":1}}],[\"headless\",{\"1\":{\"373\":2}}],[\"head\",{\"1\":{\"368\":2,\"467\":1}}],[\"header\",{\"1\":{\"266\":2,\"534\":1}}],[\"health\",{\"1\":{\"47\":2}}],[\"heapprofile\",{\"1\":{\"242\":3}}],[\"heap\",{\"1\":{\"43\":1,\"222\":2,\"236\":2,\"237\":2,\"238\":3,\"239\":6,\"242\":3,\"243\":1,\"245\":2,\"246\":2,\"263\":52,\"508\":1}}],[\"hexists\",{\"1\":{\"462\":1}}],[\"hexsum\",{\"1\":{\"307\":3}}],[\"hex\",{\"1\":{\"43\":1,\"307\":1}}],[\"hbase\",{\"1\":{\"41\":1}}],[\"html转义\",{\"1\":{\"620\":1}}],[\"html转markdown\",{\"1\":{\"41\":1}}],[\"html模板操作包\",{\"1\":{\"508\":1}}],[\"html渲染器的html\",{\"1\":{\"57\":1}}],[\"html和css创建应用的程序\",{\"1\":{\"57\":1}}],[\"html2text\",{\"1\":{\"41\":1}}],[\"html\",{\"1\":{\"41\":1,\"43\":2,\"57\":1,\"508\":2,\"612\":1,\"620\":2}}],[\"http协议等常见任务的功能\",{\"1\":{\"565\":1}}],[\"http包提供了开箱即用的反向代理功能\",{\"1\":{\"538\":1}}],[\"http包十分的优秀\",{\"1\":{\"529\":1}}],[\"http包中的东西的补充\",{\"1\":{\"43\":1}}],[\"httphandler\",{\"1\":{\"346\":2}}],[\"http接口返回的就是这一种数据\",{\"1\":{\"242\":1}}],[\"httplabs可让您检查http请求并伪造响应\",{\"1\":{\"64\":1}}],[\"httplab\",{\"1\":{\"64\":1}}],[\"http快10倍\",{\"1\":{\"64\":1}}],[\"http客户端实现\",{\"1\":{\"47\":1}}],[\"httputil\",{\"1\":{\"43\":1,\"538\":1}}],[\"httptest\",{\"1\":{\"43\":1}}],[\"https\",{\"1\":{\"41\":57,\"372\":1,\"404\":1,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"538\":1,\"545\":9}}],[\"http\",{\"0\":{\"529\":1},\"1\":{\"40\":1,\"43\":6,\"64\":1,\"77\":1,\"243\":13,\"245\":2,\"246\":7,\"247\":2,\"249\":1,\"372\":1,\"380\":1,\"508\":1,\"530\":1,\"531\":1,\"533\":2,\"534\":2,\"535\":1,\"536\":1,\"537\":8,\"538\":5}}],[\"hardwareaddr\",{\"1\":{\"567\":1}}],[\"happened\",{\"1\":{\"312\":1}}],[\"hassuffix\",{\"1\":{\"603\":2}}],[\"hasprefix\",{\"1\":{\"603\":2}}],[\"has\",{\"1\":{\"206\":1,\"226\":1}}],[\"hashset等\",{\"1\":{\"46\":1}}],[\"hash\",{\"1\":{\"43\":3,\"177\":1,\"266\":1,\"307\":3,\"404\":1}}],[\"hashicorp的raft共识协议的golang实现\",{\"1\":{\"47\":1}}],[\"hashicorp\",{\"1\":{\"41\":1,\"373\":1}}],[\"handling\",{\"1\":{\"307\":1}}],[\"handle\",{\"1\":{\"537\":2}}],[\"handlefunc\",{\"1\":{\"243\":6,\"537\":1,\"538\":1}}],[\"handlerfunc\",{\"1\":{\"537\":1}}],[\"handlerfunc类型是一个适配器\",{\"1\":{\"537\":1}}],[\"handlerfunc函数\",{\"1\":{\"537\":1}}],[\"handlers\",{\"1\":{\"41\":1}}],[\"handler\",{\"1\":{\"41\":1,\"243\":1,\"536\":1}}],[\"hanzi至hanyu拼音转换器\",{\"1\":{\"63\":1}}],[\"eq\",{\"1\":{\"620\":3,\"621\":1,\"623\":2,\"624\":1}}],[\"equalfold\",{\"1\":{\"601\":4}}],[\"equal\",{\"1\":{\"263\":2,\"390\":5,\"391\":1,\"392\":16,\"393\":2,\"395\":2,\"629\":1}}],[\"e的指数\",{\"0\":{\"557\":1}}],[\"es\",{\"1\":{\"415\":1}}],[\"es8+默认使用https连接了\",{\"1\":{\"404\":1}}],[\"escape\",{\"1\":{\"236\":2,\"237\":2,\"239\":1}}],[\"escapes\",{\"1\":{\"236\":1,\"237\":2,\"238\":2,\"239\":4}}],[\"eyb\",{\"1\":{\"396\":1}}],[\"eywa本质上是一个连接管理器\",{\"1\":{\"59\":1}}],[\"eywa\",{\"1\":{\"59\":1}}],[\"edit\",{\"1\":{\"375\":1,\"383\":1}}],[\"edge应用和集成的开源框架\",{\"1\":{\"59\":1}}],[\"ebpf\",{\"1\":{\"373\":1}}],[\"ebiten\",{\"1\":{\"53\":1}}],[\"e0a39a4cb421\",{\"1\":{\"372\":2,\"378\":1}}],[\"e6fbc62\",{\"1\":{\"368\":3}}],[\"eof\",{\"1\":{\"320\":1,\"574\":1}}],[\"eog\",{\"1\":{\"245\":2}}],[\"einval\",{\"1\":{\"217\":1}}],[\"e和n\",{\"1\":{\"201\":1}}],[\"e7\",{\"1\":{\"177\":1}}],[\"e4\",{\"1\":{\"177\":1,\"396\":1}}],[\"e相同\",{\"1\":{\"140\":1}}],[\"e+0i\",{\"1\":{\"102\":1}}],[\"e+0\",{\"1\":{\"101\":1}}],[\"e1\",{\"1\":{\"94\":1}}],[\"e\",{\"1\":{\"94\":2,\"130\":1,\"140\":5,\"148\":1,\"177\":3,\"192\":1,\"201\":3,\"225\":2,\"262\":4,\"263\":2,\"310\":2,\"311\":4,\"315\":1,\"422\":4,\"460\":2,\"467\":1,\"472\":1,\"545\":1,\"590\":5,\"599\":1,\"602\":4}}],[\"ecin\",{\"1\":{\"396\":1}}],[\"echo\",{\"1\":{\"77\":1,\"249\":1}}],[\"ecdsa\",{\"1\":{\"43\":1}}],[\"eval\",{\"1\":{\"485\":1}}],[\"evalsha\",{\"1\":{\"485\":1}}],[\"even\",{\"1\":{\"389\":1}}],[\"event\",{\"1\":{\"247\":1}}],[\"every\",{\"1\":{\"11\":1}}],[\"everywhere\",{\"1\":{\"11\":1}}],[\"evince\",{\"1\":{\"245\":2}}],[\"evoli\",{\"1\":{\"61\":1}}],[\"ethernet\",{\"1\":{\"64\":1}}],[\"ether\",{\"1\":{\"64\":1}}],[\"etrs89\",{\"1\":{\"54\":1}}],[\"etcd中实现的raft协议\",{\"1\":{\"47\":1}}],[\"etcd\",{\"1\":{\"41\":3,\"253\":1,\"379\":1}}],[\"errdeadlineexceeded\",{\"1\":{\"309\":2}}],[\"errclosed\",{\"1\":{\"309\":2}}],[\"errexist\",{\"1\":{\"309\":2}}],[\"errpermission\",{\"1\":{\"309\":2}}],[\"errprintf\",{\"1\":{\"199\":1}}],[\"errinvalid\",{\"1\":{\"309\":2}}],[\"erros\",{\"1\":{\"309\":1}}],[\"errorlog\",{\"1\":{\"536\":1}}],[\"erroring\",{\"1\":{\"354\":1}}],[\"errorf内部使用的是t\",{\"1\":{\"390\":1}}],[\"errorf等同于t\",{\"1\":{\"390\":1}}],[\"errorf函数来进行创建\",{\"1\":{\"311\":1}}],[\"errorf\",{\"1\":{\"309\":1,\"311\":1,\"312\":2,\"390\":3,\"396\":4}}],[\"error在历史上也有过大改\",{\"1\":{\"308\":1}}],[\"error本身是一个预定义的接口\",{\"1\":{\"308\":1}}],[\"error的严重级别不足以停止整个程序的运行\",{\"1\":{\"308\":1}}],[\"error属于是一种正常的流程错误\",{\"1\":{\"308\":1}}],[\"error\",{\"0\":{\"308\":1},\"1\":{\"126\":1,\"143\":3,\"185\":2,\"198\":3,\"199\":1,\"219\":1,\"239\":1,\"256\":1,\"305\":1,\"307\":3,\"308\":2,\"309\":1,\"310\":2,\"311\":3,\"312\":20,\"319\":3,\"320\":5,\"321\":6,\"322\":2,\"323\":1,\"324\":2,\"327\":2,\"328\":2,\"329\":3,\"339\":1,\"341\":1,\"343\":2,\"344\":1,\"346\":1,\"354\":1,\"355\":1,\"365\":1,\"373\":1,\"382\":2,\"396\":1,\"404\":1,\"433\":1,\"439\":3,\"444\":2,\"510\":3,\"513\":2,\"516\":2,\"519\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"584\":1,\"586\":1,\"589\":1,\"591\":1,\"615\":2,\"617\":1,\"620\":1,\"625\":2,\"626\":2,\"628\":3,\"643\":1}}],[\"errorx\",{\"1\":{\"50\":1}}],[\"errors包提供了几个方便函数用于处理错误\",{\"1\":{\"312\":1}}],[\"errorstring结构体\",{\"1\":{\"310\":1}}],[\"errorstring\",{\"1\":{\"310\":3}}],[\"errors\",{\"1\":{\"43\":1,\"50\":4,\"60\":1,\"199\":1,\"256\":1,\"307\":1,\"309\":2,\"311\":1,\"312\":9,\"320\":1,\"382\":3,\"396\":1,\"574\":2}}],[\"errnodeadline\",{\"1\":{\"309\":2}}],[\"errnotexist\",{\"1\":{\"309\":2}}],[\"errno\",{\"1\":{\"217\":4}}],[\"err\",{\"1\":{\"143\":3,\"198\":1,\"217\":4,\"242\":9,\"307\":15,\"309\":2,\"311\":4,\"312\":13,\"316\":9,\"319\":11,\"320\":20,\"321\":17,\"322\":26,\"323\":3,\"324\":6,\"325\":8,\"327\":9,\"328\":3,\"329\":21,\"343\":3,\"344\":1,\"346\":6,\"347\":1,\"354\":2,\"365\":3,\"382\":6,\"389\":1,\"396\":4,\"404\":7,\"406\":6,\"407\":6,\"408\":6,\"409\":6,\"411\":6,\"412\":6,\"413\":6,\"414\":6,\"415\":18,\"421\":3,\"424\":3,\"425\":12,\"426\":6,\"427\":13,\"428\":6,\"429\":6,\"433\":1,\"435\":10,\"436\":8,\"437\":8,\"438\":8,\"439\":3,\"443\":4,\"511\":3,\"512\":3,\"513\":2,\"514\":3,\"515\":6,\"517\":3,\"519\":3,\"520\":3,\"521\":6,\"530\":4,\"531\":3,\"567\":4,\"568\":3,\"569\":6,\"570\":6,\"571\":6,\"572\":3,\"573\":6,\"574\":16,\"584\":2,\"586\":6,\"589\":4,\"613\":3,\"615\":4,\"617\":15,\"619\":3,\"625\":6,\"626\":18,\"628\":6,\"632\":6}}],[\"errlog\",{\"1\":{\"50\":1}}],[\"embed\",{\"1\":{\"628\":3}}],[\"emqx\",{\"0\":{\"488\":1}}],[\"emptyctx通常是用来当作最顶层的上下文\",{\"1\":{\"344\":1}}],[\"emptyctx的底层类型实际上是一个int\",{\"1\":{\"344\":1}}],[\"emptyctx就可以通过context\",{\"1\":{\"344\":1}}],[\"emptyctx就是空的上下文\",{\"1\":{\"344\":1}}],[\"emptyctx\",{\"0\":{\"344\":1},\"1\":{\"342\":1,\"344\":7}}],[\"emptyinterface\",{\"1\":{\"266\":3}}],[\"empty\",{\"1\":{\"193\":2}}],[\"employee\",{\"1\":{\"189\":2,\"628\":2}}],[\"emperror\",{\"1\":{\"50\":1}}],[\"email\",{\"1\":{\"48\":1}}],[\"emitter\",{\"1\":{\"47\":1}}],[\"eff\",{\"1\":{\"437\":2,\"438\":2}}],[\"effective\",{\"1\":{\"168\":1}}],[\"eface\",{\"1\":{\"266\":1,\"270\":3,\"271\":6}}],[\"ef\",{\"1\":{\"46\":1}}],[\"ea0xadu+shlu7x5o3gkhrpq1ikimrsihttpf0ybecua=\",{\"1\":{\"379\":1}}],[\"eaopt\",{\"1\":{\"61\":1}}],[\"easymidi是一个简单可靠的库\",{\"1\":{\"45\":1}}],[\"easymidi\",{\"1\":{\"45\":1}}],[\"eapache\",{\"1\":{\"41\":1}}],[\"en\",{\"1\":{\"623\":3}}],[\"engine\",{\"1\":{\"372\":1,\"434\":1}}],[\"engo是用go语言编写的开源2d游戏引擎\",{\"1\":{\"53\":1}}],[\"engo\",{\"1\":{\"53\":1}}],[\"ent这些库\",{\"1\":{\"431\":1}}],[\"ent\",{\"1\":{\"249\":1}}],[\"entering\",{\"1\":{\"245\":1}}],[\"entry\",{\"1\":{\"178\":1,\"313\":1,\"327\":4,\"396\":1}}],[\"enumerating\",{\"1\":{\"364\":1,\"368\":1}}],[\"enum\",{\"1\":{\"228\":3,\"521\":1}}],[\"enabled=1\",{\"1\":{\"216\":1}}],[\"enabled是否设置为1\",{\"1\":{\"216\":1}}],[\"environment\",{\"1\":{\"372\":1}}],[\"env\",{\"1\":{\"216\":2,\"363\":2,\"370\":1,\"372\":1,\"376\":3}}],[\"end永远也不会输出\",{\"1\":{\"340\":1}}],[\"end\",{\"1\":{\"331\":9,\"340\":1,\"341\":3,\"408\":7,\"622\":4,\"623\":2,\"624\":7,\"625\":14,\"627\":2,\"628\":3,\"635\":2}}],[\"endl\",{\"1\":{\"195\":4}}],[\"endindex\",{\"1\":{\"160\":1}}],[\"enhanced\",{\"1\":{\"43\":1}}],[\"encode\",{\"0\":{\"509\":1},\"1\":{\"307\":1}}],[\"encoding\",{\"1\":{\"40\":1,\"43\":1,\"46\":1,\"508\":1,\"516\":1}}],[\"encryption\",{\"1\":{\"43\":2}}],[\"elapsed\",{\"1\":{\"396\":18}}],[\"elasticsearch提供的go\",{\"1\":{\"404\":1}}],[\"elasticsearch\",{\"0\":{\"402\":1},\"1\":{\"402\":3,\"403\":2,\"404\":2}}],[\"elastic\",{\"1\":{\"41\":1,\"402\":2,\"403\":2,\"404\":1}}],[\"ele\",{\"1\":{\"279\":10,\"280\":4}}],[\"elem\",{\"0\":{\"271\":1,\"278\":1},\"1\":{\"271\":4,\"274\":3,\"275\":3,\"278\":2,\"279\":2,\"280\":1,\"286\":2,\"287\":3,\"288\":1,\"289\":2,\"290\":1,\"292\":2,\"293\":2,\"296\":1,\"297\":1}}],[\"element\",{\"1\":{\"236\":1,\"239\":1}}],[\"elems\",{\"1\":{\"163\":1}}],[\"elems是待添加的元素\",{\"1\":{\"163\":1}}],[\"else的基础上创建更多的判断分支\",{\"1\":{\"148\":1}}],[\"else\",{\"0\":{\"147\":1,\"148\":1},\"1\":{\"97\":1,\"147\":4,\"148\":16,\"151\":1,\"179\":1,\"200\":1,\"201\":1,\"305\":1,\"319\":5,\"320\":5,\"321\":2,\"322\":2,\"323\":1,\"324\":2,\"327\":2,\"328\":1,\"329\":1,\"353\":2,\"443\":1,\"574\":1,\"605\":1,\"611\":1,\"622\":2,\"623\":4,\"624\":1}}],[\"elias\",{\"1\":{\"46\":1}}],[\"elf是一种常见的二进制可执行文件和共享库的文件格式\",{\"1\":{\"43\":1}}],[\"elf\",{\"1\":{\"43\":1}}],[\"elliptic\",{\"1\":{\"43\":2}}],[\"examine\",{\"1\":{\"373\":1}}],[\"examples\",{\"1\":{\"422\":3,\"423\":3,\"426\":3,\"427\":3,\"428\":3,\"429\":3}}],[\"examplesay\",{\"1\":{\"387\":4,\"389\":3}}],[\"examplewithdeadline\",{\"1\":{\"389\":1}}],[\"examplegoodbye\",{\"1\":{\"387\":3,\"389\":3}}],[\"examplehello\",{\"1\":{\"387\":3,\"389\":3}}],[\"example1\",{\"1\":{\"94\":3}}],[\"example\",{\"1\":{\"93\":1,\"94\":7,\"236\":1,\"237\":1,\"238\":1,\"239\":2,\"245\":1,\"254\":1,\"367\":2,\"368\":9,\"376\":1,\"378\":8,\"381\":1,\"382\":2,\"387\":2,\"389\":2}}],[\"exceeded\",{\"1\":{\"347\":1,\"389\":1}}],[\"excel文件的方法\",{\"1\":{\"62\":1}}],[\"excel最新版本使用的xml格式的库\",{\"1\":{\"62\":1}}],[\"excel™\",{\"1\":{\"62\":1}}],[\"excelize\",{\"1\":{\"41\":1,\"62\":1}}],[\"excel\",{\"1\":{\"41\":1,\"62\":3}}],[\"exclude关键字表示了不加载指定版本的依赖\",{\"1\":{\"378\":1}}],[\"exclude\",{\"1\":{\"378\":3}}],[\"excl\",{\"1\":{\"319\":2}}],[\"extern\",{\"1\":{\"219\":1}}],[\"extra\",{\"1\":{\"140\":2}}],[\"exe\",{\"1\":{\"216\":1,\"218\":2,\"231\":2,\"232\":1,\"528\":4}}],[\"exercise\",{\"1\":{\"212\":1}}],[\"exectmpl\",{\"1\":{\"617\":5,\"619\":1,\"625\":2}}],[\"execerr\",{\"1\":{\"615\":2}}],[\"execs\",{\"1\":{\"396\":12}}],[\"executetemplate\",{\"1\":{\"625\":2}}],[\"execute方法将data数据应用于模板中\",{\"1\":{\"615\":1}}],[\"execute\",{\"1\":{\"152\":3,\"373\":1,\"615\":2,\"617\":1,\"626\":1,\"628\":2}}],[\"executable\",{\"1\":{\"43\":1}}],[\"exec\",{\"1\":{\"43\":1,\"373\":1,\"388\":1,\"436\":1,\"437\":1,\"438\":1,\"508\":1}}],[\"exwrite\",{\"1\":{\"198\":1}}],[\"exwriter\",{\"1\":{\"198\":1}}],[\"exists\",{\"1\":{\"309\":1,\"434\":1}}],[\"exist\",{\"1\":{\"179\":2,\"180\":4,\"309\":1,\"443\":1}}],[\"exit\",{\"1\":{\"145\":2,\"317\":1,\"396\":2,\"539\":1}}],[\"exif\",{\"1\":{\"51\":1}}],[\"exiftool的go绑定\",{\"1\":{\"51\":1}}],[\"exiftool\",{\"1\":{\"51\":1}}],[\"expire\",{\"1\":{\"449\":1}}],[\"expired\",{\"1\":{\"389\":1}}],[\"expected\",{\"1\":{\"365\":4,\"390\":38,\"391\":8,\"392\":8,\"393\":5}}],[\"expect+num\",{\"1\":{\"359\":1}}],[\"expect\",{\"1\":{\"359\":2}}],[\"explicit\",{\"1\":{\"222\":2}}],[\"export\",{\"1\":{\"219\":11,\"372\":1}}],[\"exp函数的返回值是一个函数\",{\"1\":{\"201\":1}}],[\"exp\",{\"1\":{\"59\":1,\"201\":2,\"373\":1,\"393\":3,\"557\":1}}],[\"expression3\",{\"1\":{\"148\":1}}],[\"expression2\",{\"1\":{\"148\":1}}],[\"expression1\",{\"1\":{\"148\":1}}],[\"expression必须是一个布尔表达式\",{\"1\":{\"147\":1}}],[\"expression\",{\"1\":{\"147\":2,\"152\":2}}],[\"expr\",{\"1\":{\"49\":1,\"130\":1,\"149\":1}}],[\"expvar\",{\"1\":{\"43\":1}}],[\"ego\",{\"1\":{\"41\":4}}],[\"oeis\",{\"1\":{\"545\":9}}],[\"objectid\",{\"1\":{\"426\":3}}],[\"objects\",{\"1\":{\"246\":2,\"364\":4,\"368\":4}}],[\"ombdisnwtfiuyjnf9xnpbw\",{\"1\":{\"404\":1}}],[\"overslept\",{\"1\":{\"389\":1}}],[\"oversight\",{\"1\":{\"56\":1}}],[\"ok为false\",{\"1\":{\"288\":1}}],[\"ok\",{\"1\":{\"258\":1,\"281\":2,\"286\":2,\"288\":3,\"305\":2,\"312\":2,\"334\":1,\"337\":4,\"339\":2,\"340\":24,\"343\":2,\"344\":1,\"355\":1,\"366\":1,\"382\":3,\"387\":5,\"389\":1,\"390\":1,\"391\":1,\"392\":3,\"394\":1,\"395\":2,\"396\":3,\"404\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"412\":1,\"413\":1,\"414\":1}}],[\"onconnect\",{\"1\":{\"444\":1}}],[\"once的实现相当简单\",{\"1\":{\"353\":1}}],[\"once保证了在并发条件下指定操作只会执行一次\",{\"1\":{\"353\":1}}],[\"once译为一次\",{\"1\":{\"353\":1}}],[\"once要解决的问题\",{\"1\":{\"353\":1}}],[\"once\",{\"0\":{\"353\":1},\"1\":{\"353\":5}}],[\"one\",{\"1\":{\"426\":4}}],[\"oneline\",{\"1\":{\"368\":1}}],[\"only\",{\"1\":{\"338\":1,\"378\":1}}],[\"on\",{\"1\":{\"247\":1,\"372\":1,\"388\":1}}],[\"onnx\",{\"1\":{\"61\":2}}],[\"outputdir\",{\"1\":{\"388\":1}}],[\"output\",{\"1\":{\"245\":2,\"387\":3,\"389\":7}}],[\"outputs\",{\"1\":{\"245\":2}}],[\"out\",{\"1\":{\"155\":2,\"242\":2,\"247\":3,\"283\":1,\"289\":1,\"388\":6,\"513\":2,\"514\":2,\"541\":1,\"617\":8,\"619\":2,\"625\":2}}],[\"outer\",{\"1\":{\"154\":2}}],[\"outboxer是一个实现库模式的go库\",{\"1\":{\"47\":1}}],[\"outboxer\",{\"1\":{\"47\":1}}],[\"o\",{\"1\":{\"140\":4,\"177\":4,\"216\":1,\"218\":1,\"231\":4,\"232\":3,\"245\":1,\"309\":1,\"319\":19,\"320\":4,\"321\":15,\"322\":8,\"329\":3,\"353\":11,\"388\":1,\"607\":3}}],[\"oop\",{\"1\":{\"84\":4}}],[\"ocrserver\",{\"1\":{\"61\":1}}],[\"o与低级别的主板设备接口\",{\"1\":{\"59\":1}}],[\"oak\",{\"1\":{\"53\":1}}],[\"ori\",{\"1\":{\"596\":4}}],[\"original\",{\"1\":{\"312\":3}}],[\"originalerr\",{\"1\":{\"312\":4}}],[\"origin\",{\"1\":{\"252\":1,\"322\":6,\"368\":2}}],[\"oracle\",{\"1\":{\"432\":1,\"514\":2}}],[\"or\",{\"1\":{\"219\":1,\"226\":1,\"263\":2,\"373\":1,\"543\":1,\"620\":2,\"643\":1}}],[\"orderbook\",{\"1\":{\"52\":1}}],[\"org\",{\"1\":{\"41\":2,\"64\":1,\"370\":1,\"372\":12,\"373\":2,\"378\":16,\"379\":6,\"395\":1,\"420\":1,\"421\":3,\"531\":1,\"533\":1,\"534\":1,\"538\":2,\"545\":9}}],[\"official\",{\"1\":{\"419\":2}}],[\"office\",{\"1\":{\"51\":1}}],[\"off\",{\"1\":{\"320\":1,\"321\":1,\"388\":1}}],[\"offsetof\",{\"0\":{\"641\":1},\"1\":{\"641\":3,\"643\":2}}],[\"offset\",{\"1\":{\"286\":2,\"320\":1,\"321\":4,\"322\":2,\"408\":14,\"482\":1,\"643\":1}}],[\"of\",{\"1\":{\"172\":1,\"206\":1,\"208\":6,\"236\":1,\"244\":1,\"245\":2,\"331\":2,\"338\":1,\"360\":2,\"406\":4,\"407\":2,\"434\":1,\"528\":1,\"611\":2}}],[\"ofxgo\",{\"1\":{\"52\":1}}],[\"op表示每一次循环内存分配的次数\",{\"1\":{\"394\":1}}],[\"op表示每一次循环所分配内存的字节大小\",{\"1\":{\"394\":1}}],[\"op代表了每一次循环所消耗的时间\",{\"1\":{\"394\":1}}],[\"op\",{\"1\":{\"233\":4,\"394\":36,\"395\":188,\"617\":2}}],[\"option\",{\"1\":{\"188\":2,\"521\":1}}],[\"options\",{\"1\":{\"11\":1,\"188\":2,\"245\":1,\"421\":2,\"425\":1,\"443\":1,\"444\":2,\"445\":1}}],[\"opqrst\",{\"1\":{\"171\":1}}],[\"operation\",{\"1\":{\"128\":1,\"195\":1,\"300\":1,\"302\":1,\"338\":1}}],[\"operator\",{\"1\":{\"98\":1}}],[\"opentelemetry\",{\"1\":{\"379\":1}}],[\"opencensus\",{\"1\":{\"379\":1}}],[\"opencv\",{\"1\":{\"58\":1}}],[\"openfile\",{\"1\":{\"319\":3,\"320\":2,\"321\":3,\"322\":4,\"329\":1}}],[\"open函数\",{\"1\":{\"433\":1}}],[\"open函数返回值一个文件指针和一个错误\",{\"1\":{\"319\":1}}],[\"open函数有两个返回值\",{\"1\":{\"126\":1}}],[\"opening\",{\"1\":{\"247\":1}}],[\"open\",{\"1\":{\"126\":2,\"250\":1,\"307\":2,\"319\":5,\"327\":1,\"329\":1,\"433\":2,\"435\":2}}],[\"openstreetmap\",{\"1\":{\"54\":1}}],[\"opc\",{\"1\":{\"51\":2}}],[\"ot\",{\"1\":{\"396\":1}}],[\"other\",{\"1\":{\"348\":1}}],[\"otto\",{\"1\":{\"49\":1}}],[\"ot进行分布式同步\",{\"1\":{\"47\":1}}],[\"oto\",{\"1\":{\"45\":1}}],[\"otokaze\",{\"1\":{\"41\":1}}],[\"o库的绑定\",{\"1\":{\"45\":1}}],[\"o连接的对象可导出的方法的访问\",{\"1\":{\"43\":1}}],[\"o函数\",{\"1\":{\"43\":1}}],[\"o对象文件的访问\",{\"1\":{\"43\":1}}],[\"o原语的基本接口\",{\"1\":{\"43\":1}}],[\"olleh\",{\"1\":{\"396\":1}}],[\"oldnew\",{\"1\":{\"612\":1}}],[\"old指要被替换的部分\",{\"1\":{\"607\":1}}],[\"old\",{\"1\":{\"358\":1,\"359\":1,\"395\":5,\"607\":3}}],[\"oldpath\",{\"1\":{\"323\":1}}],[\"oldcap+3\",{\"1\":{\"163\":1}}],[\"oldcap+\",{\"1\":{\"163\":1}}],[\"oldcap\",{\"1\":{\"163\":1}}],[\"olekukonko\",{\"1\":{\"41\":1}}],[\"olivere\",{\"1\":{\"41\":1}}],[\"os包下提供了以下常量以供使用\",{\"1\":{\"319\":1}}],[\"os库\",{\"1\":{\"318\":1}}],[\"osx库\",{\"1\":{\"57\":1}}],[\"osgb36\",{\"1\":{\"54\":1}}],[\"osm\",{\"1\":{\"54\":1}}],[\"os\",{\"1\":{\"40\":1,\"43\":2,\"57\":1,\"126\":1,\"134\":4,\"136\":2,\"139\":2,\"142\":2,\"144\":1,\"145\":1,\"198\":1,\"199\":1,\"242\":6,\"307\":2,\"317\":1,\"319\":7,\"320\":8,\"321\":7,\"322\":11,\"323\":1,\"324\":2,\"325\":2,\"327\":7,\"328\":1,\"329\":6,\"365\":3,\"508\":4,\"515\":1,\"615\":2,\"617\":4,\"619\":1,\"625\":1,\"626\":1,\"628\":3}}],[\"在运行时修改其底层的数据是完全可行的\",{\"1\":{\"647\":1}}],[\"在运行时由eface\",{\"1\":{\"266\":1}}],[\"在运行时由如下的结构体iface来进行表示\",{\"1\":{\"266\":1}}],[\"在需要的时候并不会被回收掉\",{\"1\":{\"643\":1}}],[\"在官方文档的描述中\",{\"1\":{\"643\":1}}],[\"在t2模板中引用t1模板\",{\"1\":{\"627\":1}}],[\"在t1模板中定义插槽\",{\"1\":{\"627\":1}}],[\"在with语句中声明的变量\",{\"1\":{\"622\":1}}],[\"在windows平台就是mingw\",{\"1\":{\"216\":1}}],[\"在模板语法的案例中\",{\"1\":{\"628\":1}}],[\"在模板中也可以声明变量\",{\"1\":{\"619\":1}}],[\"在模糊测试中\",{\"1\":{\"396\":1}}],[\"在例子中之所以会在两边额外加个空格写成\",{\"1\":{\"617\":1}}],[\"在花括号中\",{\"1\":{\"617\":1}}],[\"在花括号内\",{\"1\":{\"617\":1}}],[\"在以后模板引擎的使用中\",{\"1\":{\"615\":1}}],[\"在以前的版本\",{\"1\":{\"382\":1}}],[\"在案例代码中\",{\"1\":{\"615\":1}}],[\"在实际的使用情况中大多数都是将模板放在文件中\",{\"1\":{\"628\":1}}],[\"在实际开发中一般用的是html\",{\"1\":{\"614\":1}}],[\"在实际应用中goto用的很少\",{\"1\":{\"151\":1}}],[\"在平时我们经常会使用fmt\",{\"1\":{\"614\":1}}],[\"在其他语言比如java中\",{\"1\":{\"593\":1}}],[\"在其它语言中的if和for语句通常可以简写\",{\"1\":{\"111\":1}}],[\"在反序列化时需要注意\",{\"1\":{\"520\":1}}],[\"在参考值后面插入值\",{\"1\":{\"467\":1}}],[\"在参考值前面插入值\",{\"1\":{\"467\":1}}],[\"在当前互联网时代中\",{\"1\":{\"509\":1}}],[\"在当前节点实例上\",{\"1\":{\"444\":1}}],[\"在当前目录初始化go\",{\"1\":{\"375\":1}}],[\"在项目中的话一般不会直接使用驱动来进行数据库操作\",{\"1\":{\"431\":1}}],[\"在构造查询条件的时候\",{\"1\":{\"425\":1}}],[\"在建立https连接时\",{\"1\":{\"404\":1}}],[\"在测试中\",{\"1\":{\"396\":1}}],[\"在并发执行测试用例时\",{\"1\":{\"392\":1}}],[\"在记录日志时输出的行号也是帮助函数的调用者的行号\",{\"1\":{\"391\":1}}],[\"在下一轮测试中会继续执行\",{\"1\":{\"390\":1}}],[\"在下载依赖时也可以指定commitid替换语义化版本号\",{\"1\":{\"378\":1}}],[\"在命令行中执行go\",{\"1\":{\"385\":1}}],[\"在命令行中查看数据一般使用top命令\",{\"1\":{\"245\":1}}],[\"在标准库和许多开源框架都能看到测试的身影\",{\"1\":{\"385\":1}}],[\"在日后发布新版本后再将其去掉\",{\"1\":{\"381\":1}}],[\"在require时\",{\"1\":{\"378\":1}}],[\"在reflect包下\",{\"1\":{\"267\":1}}],[\"在module的上一行开头注释deprecated来表示该模块已弃用\",{\"1\":{\"378\":1}}],[\"在引用依赖时由于路径都一致\",{\"1\":{\"378\":1}}],[\"在文件中可以发现绝大多数的依赖地址都带有github等字眼\",{\"1\":{\"378\":1}}],[\"在文件io\",{\"1\":{\"139\":1}}],[\"在$gomodcache\",{\"1\":{\"376\":1}}],[\"在缓存中解压的依赖源文件都是只读的\",{\"1\":{\"376\":1}}],[\"在依赖地址后面加上\",{\"1\":{\"372\":1}}],[\"在里面搜索著名的web框架gin\",{\"1\":{\"372\":1}}],[\"在上述的地面中\",{\"1\":{\"626\":1}}],[\"在上述的单元测试中\",{\"1\":{\"393\":1}}],[\"在上述的例子中第一个子测试未执行完毕第二个子测试是不会执行的\",{\"1\":{\"392\":1}}],[\"在上述类型声明中\",{\"1\":{\"302\":1}}],[\"在上面这些api中\",{\"1\":{\"409\":1}}],[\"在上面的go\",{\"1\":{\"378\":1}}],[\"在上面创建一个新项目\",{\"1\":{\"364\":1}}],[\"在今天几乎所有的go项目都在采用go\",{\"1\":{\"361\":1}}],[\"在撰写本文时\",{\"1\":{\"361\":1}}],[\"在计算机学科中\",{\"1\":{\"356\":1}}],[\"在计算sum函数返回值时\",{\"1\":{\"127\":1}}],[\"在fmt\",{\"1\":{\"354\":1}}],[\"在读数据的时候都会先获得读锁\",{\"1\":{\"350\":1}}],[\"在相关流程结束后\",{\"1\":{\"347\":1}}],[\"在相应的流程结束后就应该调用cancel函数\",{\"1\":{\"346\":1}}],[\"在select的case中对值为nil的管道进行操作的话\",{\"1\":{\"340\":1}}],[\"在某一时刻\",{\"1\":{\"340\":1}}],[\"在某一个时刻\",{\"1\":{\"334\":1,\"336\":1}}],[\"在后续其它模板使用插槽时\",{\"1\":{\"627\":1}}],[\"在后续的with\",{\"1\":{\"621\":1}}],[\"在后续的更新中\",{\"1\":{\"213\":1}}],[\"在后续使用时\",{\"1\":{\"619\":1}}],[\"在后续使用中就不需要再额外的创建对象可以直接复用\",{\"1\":{\"354\":1}}],[\"在后\",{\"1\":{\"338\":1}}],[\"在前\",{\"1\":{\"338\":1}}],[\"在前面的几节已经很多次提到过内置函数new和make\",{\"1\":{\"196\":1}}],[\"在向管道写入数据时必须立刻有其他协程来读取数据\",{\"1\":{\"335\":1}}],[\"在创建模板时从text\",{\"1\":{\"620\":1}}],[\"在创建条件变量时\",{\"1\":{\"351\":1}}],[\"在创建上下文时通过闭包将其包装为返回值以供外界调用\",{\"1\":{\"346\":1}}],[\"在创建其他三种上下文时作为父上下文传入\",{\"1\":{\"344\":1}}],[\"在创建管道时\",{\"1\":{\"333\":1}}],[\"在创建一个文件时\",{\"1\":{\"321\":1}}],[\"在过程中\",{\"1\":{\"329\":1}}],[\"在执行时会行尾添加\",{\"1\":{\"387\":1}}],[\"在执行测试时\",{\"1\":{\"386\":1,\"390\":1}}],[\"在执行完毕前\",{\"1\":{\"356\":1}}],[\"在执行最后一个defer时\",{\"1\":{\"315\":1}}],[\"在执行的过程中每一个表达式的判断是从左到右\",{\"1\":{\"148\":1}}],[\"在本例中\",{\"1\":{\"315\":1}}],[\"在本文开头就已经提到过\",{\"1\":{\"177\":1}}],[\"在这里代表的是任意类型\",{\"1\":{\"638\":1}}],[\"在这期间goroutine将被阻塞\",{\"1\":{\"635\":1}}],[\"在这个项目中\",{\"1\":{\"382\":1}}],[\"在这个过程中\",{\"1\":{\"348\":1}}],[\"在这一小段代码中总共出现了三次if\",{\"1\":{\"307\":1}}],[\"在这种情况下\",{\"1\":{\"173\":1,\"185\":1}}],[\"在数字的类型转换中\",{\"1\":{\"304\":1}}],[\"在数组初始化时\",{\"1\":{\"158\":1}}],[\"在程序的生命周期都不会再发生改变\",{\"1\":{\"300\":1}}],[\"在之前的数据类型的小节中已经简单了介绍过了go中的所有内置的数据类型\",{\"1\":{\"299\":1}}],[\"在pop和peek方法中\",{\"1\":{\"262\":1}}],[\"在泛型结构体中\",{\"1\":{\"257\":1}}],[\"在开始编写测试之前\",{\"1\":{\"386\":1}}],[\"在开始之前确保你的版本足以完全支持go\",{\"1\":{\"363\":1}}],[\"在开始之前先简单的了解一下位于runtime包下的两个接口\",{\"1\":{\"266\":1}}],[\"在开始之前\",{\"1\":{\"256\":1}}],[\"在开发时通常会使用匿名空接口来表示接收任何类型的值\",{\"1\":{\"213\":1}}],[\"在游戏服务器这个领域\",{\"1\":{\"252\":1}}],[\"在得到了采集的数据文件后\",{\"1\":{\"244\":1}}],[\"在写入时传入的数字有以下几个含义\",{\"1\":{\"242\":1}}],[\"在此之前为了数据更加多样化\",{\"1\":{\"246\":1}}],[\"在此之前\",{\"1\":{\"241\":1}}],[\"在此前的内容中\",{\"1\":{\"234\":1}}],[\"在没有协程来读取之前\",{\"1\":{\"336\":1}}],[\"在没有考虑周全之前\",{\"1\":{\"233\":1}}],[\"在没有泛型之前\",{\"1\":{\"128\":1}}],[\"在传递过后实际上是在c内存和go内存中各自保存了一份\",{\"1\":{\"222\":1}}],[\"在传递给c函数之前要将其转换为\",{\"1\":{\"222\":1}}],[\"在传递给c函数时\",{\"1\":{\"222\":1}}],[\"在cas的例子中\",{\"1\":{\"359\":1}}],[\"在c中使用malloc创建一个\",{\"1\":{\"222\":1}}],[\"在c函数调用期间cgo会尽量保证内存安全\",{\"1\":{\"219\":1}}],[\"在默认情况下该环境变量是默认启用的\",{\"1\":{\"216\":1}}],[\"在比较空接口时\",{\"1\":{\"213\":1}}],[\"在调用c函数时可以像go一样用返回值来处理错误\",{\"1\":{\"217\":1}}],[\"在调用方法时会去调用具体类型的具体值\",{\"1\":{\"213\":1}}],[\"在调用一个函数时\",{\"1\":{\"200\":1}}],[\"在接口里\",{\"1\":{\"210\":1}}],[\"在方法中对值接收者修改并不会产生任何影响\",{\"1\":{\"206\":1}}],[\"在原来的代码中\",{\"1\":{\"206\":1}}],[\"在大多数情况下\",{\"1\":{\"206\":1,\"357\":1}}],[\"在通过值类型调用指针接收者的方法时\",{\"1\":{\"206\":1}}],[\"在循环次数很大或次数不确定时\",{\"1\":{\"203\":1}}],[\"在函数返回之前这些defer描述的函数最后都会被逐个执行\",{\"1\":{\"202\":1}}],[\"在函数内部\",{\"1\":{\"129\":1}}],[\"在grow函数内还能直接修改这两个变量\",{\"1\":{\"201\":1}}],[\"在go1\",{\"1\":{\"170\":1,\"183\":1,\"208\":1}}],[\"在golang1\",{\"1\":{\"163\":1}}],[\"在go语言中错误处理以返回值的形式返回\",{\"1\":{\"217\":1}}],[\"在go语言中\",{\"1\":{\"125\":1}}],[\"在go程序中快速\",{\"1\":{\"62\":1}}],[\"在go中大部分的api都是由标准库testing提供\",{\"1\":{\"385\":1}}],[\"在go中的sort包下提供了官方实现的排序方法\",{\"1\":{\"575\":1}}],[\"在go中的select监测的元素就是管道\",{\"1\":{\"340\":1}}],[\"在go中的异常有三种级别\",{\"1\":{\"307\":1}}],[\"在go中的类型声明是后置的\",{\"1\":{\"124\":1}}],[\"在go中通过类型声明\",{\"1\":{\"302\":1}}],[\"在go中类似的写法如下\",{\"1\":{\"301\":1}}],[\"在go中有三个经典的反射定律\",{\"1\":{\"268\":1}}],[\"在go中有一个专门的接口类型用于代表所有可比较类型\",{\"1\":{\"213\":1}}],[\"在go中导入import\",{\"1\":{\"220\":1}}],[\"在go中是不支持指针运算的\",{\"1\":{\"195\":1}}],[\"在go中输出有很多中方法\",{\"1\":{\"135\":1}}],[\"在go中内置的有序类型只有数字和字符串\",{\"1\":{\"128\":1}}],[\"在go中所有的花括号都不应该换行\",{\"1\":{\"108\":1}}],[\"在go中\",{\"1\":{\"92\":1,\"115\":1,\"127\":1,\"146\":1,\"151\":1,\"156\":1,\"170\":1,\"177\":1,\"178\":1,\"189\":1,\"196\":1,\"203\":1,\"235\":1,\"265\":1,\"266\":1,\"302\":1,\"304\":1,\"306\":1,\"331\":1,\"340\":1,\"509\":1,\"516\":1}}],[\"在go中本地解析和解复用mpeg传输流\",{\"1\":{\"65\":1}}],[\"在go中处理字幕\",{\"1\":{\"65\":1}}],[\"在go中定义计算图\",{\"1\":{\"61\":1}}],[\"在go中实现的多层感知器网络\",{\"1\":{\"61\":1}}],[\"在go中实现的bloom过滤器\",{\"1\":{\"46\":1}}],[\"在go中加载gtfs文件\",{\"1\":{\"51\":1}}],[\"在go中计算levenshtein距离的实现\",{\"1\":{\"46\":1}}],[\"在go代码中嵌入其他语言\",{\"1\":{\"39\":1}}],[\"在正常情况下随着exp函数的调用结束\",{\"1\":{\"201\":1}}],[\"在一些情况下我们需要将其序列化成人类能够观察的形式\",{\"1\":{\"519\":1}}],[\"在一些情况下\",{\"1\":{\"392\":1}}],[\"在一些情况中\",{\"1\":{\"311\":1,\"337\":1}}],[\"在一些语言中又被称为lamda表达式\",{\"1\":{\"201\":1}}],[\"在一定程度上保证了性能\",{\"1\":{\"193\":1}}],[\"在编译时\",{\"1\":{\"381\":1}}],[\"在编译后它们会被转换成其它的操作\",{\"1\":{\"222\":1}}],[\"在编译的时候会转换为\",{\"1\":{\"190\":1}}],[\"在编码器\",{\"1\":{\"43\":1}}],[\"在声明结构体字段时\",{\"1\":{\"186\":1}}],[\"在初始化map时应当尽量分配一个合理的容量\",{\"1\":{\"178\":1}}],[\"在使用unsafe包函数时编辑器甚至会提示你类型不匹配\",{\"1\":{\"639\":1}}],[\"在使用完ticker后\",{\"1\":{\"634\":1}}],[\"在使用完timer以后\",{\"1\":{\"633\":1}}],[\"在使用完一个管道后一定要记得关闭该管道\",{\"1\":{\"333\":1}}],[\"在使用模板参数时\",{\"1\":{\"617\":1}}],[\"在使用之前你就要先使用sql\",{\"1\":{\"432\":1}}],[\"在使用install命令时\",{\"1\":{\"373\":1}}],[\"在使用第三方依赖时\",{\"1\":{\"372\":1}}],[\"在使用sync\",{\"1\":{\"354\":1}}],[\"在使用时\",{\"1\":{\"353\":1}}],[\"在使用时需要显式的指定字段p\",{\"1\":{\"189\":1}}],[\"在使用类型转换时\",{\"1\":{\"304\":1}}],[\"在使用网页分析时\",{\"1\":{\"246\":1}}],[\"在使用cgo时\",{\"1\":{\"223\":1}}],[\"在使用for\",{\"1\":{\"177\":1}}],[\"在使用数字时\",{\"1\":{\"140\":1}}],[\"在对s2进行读写时\",{\"1\":{\"169\":1}}],[\"在1\",{\"1\":{\"163\":1,\"259\":1,\"308\":1}}],[\"在输入输出这方面\",{\"1\":{\"145\":1}}],[\"在有大量输入需要读取的时候\",{\"1\":{\"144\":1}}],[\"在\",{\"1\":{\"140\":1,\"394\":1}}],[\"在性能敏感的场景不建议大量使用\",{\"1\":{\"138\":1}}],[\"在os包下有三个外暴露的文件描述符\",{\"1\":{\"134\":1}}],[\"在已经赋值的常量后面的常量可以不用赋值\",{\"1\":{\"130\":1}}],[\"在同一个常量分组中\",{\"1\":{\"130\":1}}],[\"在格式化后\",{\"1\":{\"110\":1}}],[\"在自定义包和函数时命名应当尽量避免与之重复\",{\"1\":{\"91\":1}}],[\"在早期版本中并没有提供泛型功能\",{\"1\":{\"84\":1}}],[\"在内的多种操作系统\",{\"1\":{\"72\":1}}],[\"在纯go中实现quic协议\",{\"1\":{\"64\":1}}],[\"在纯go和simd中调整图像大小\",{\"1\":{\"58\":1}}],[\"在给定的语法情况下使用俄语名称\",{\"1\":{\"63\":1}}],[\"在多个平台上播放声音的低级库\",{\"1\":{\"45\":1}}],[\"在多个goroutine访问共享资源的时候\",{\"1\":{\"40\":1}}],[\"在具备了缓存功能后\",{\"1\":{\"40\":1}}],[\"它通常和slicedata配合起来使用\",{\"1\":{\"646\":1}}],[\"它支持泛型\",{\"1\":{\"575\":1}}],[\"它使用空白符号缩进和大量依赖外观的特色\",{\"1\":{\"513\":1}}],[\"它使用标准输入并输出json\",{\"1\":{\"60\":1}}],[\"它接受两个参数\",{\"1\":{\"433\":1}}],[\"它接受一个可变长personoptions类型的参数\",{\"1\":{\"188\":1}}],[\"它接受一个\",{\"1\":{\"188\":1}}],[\"它更多的是为了展示某一个功能的使用方法\",{\"1\":{\"389\":1}}],[\"它只是暂时让你略过了提交到发版的这一过程\",{\"1\":{\"382\":1}}],[\"它也同样实现了locker接口\",{\"1\":{\"350\":1}}],[\"它没法被取消\",{\"1\":{\"344\":1}}],[\"它没有名称\",{\"1\":{\"200\":1}}],[\"它则是一边读一边写\",{\"1\":{\"322\":1}}],[\"它完完全全是一门面向工程的语言\",{\"1\":{\"248\":1}}],[\"它完全实现了mqtt协议v3\",{\"1\":{\"64\":1}}],[\"它与前者的数据文件互不兼容\",{\"1\":{\"247\":1}}],[\"它需要一定的时间进行采样\",{\"1\":{\"242\":1}}],[\"它会返回该段内存的切片表达形式\",{\"1\":{\"646\":1}}],[\"它会根据版本及模块名缓存开发者下载过的模块\",{\"1\":{\"370\":1}}],[\"它会对程序运行时的数据进行部分采样\",{\"1\":{\"240\":1}}],[\"它会与go的目标文件最终链接成一个可执行文件\",{\"1\":{\"232\":1}}],[\"它会先将数据写入到内存中\",{\"1\":{\"139\":1}}],[\"它在运行时会与可执行文件一起加载到内存中\",{\"1\":{\"231\":1}}],[\"它在io的基础上提供了缓存功能\",{\"1\":{\"40\":1}}],[\"它带有gc\",{\"1\":{\"229\":1}}],[\"它有两种检查级别\",{\"1\":{\"219\":1}}],[\"它包含了有关所有go导出的类型\",{\"1\":{\"219\":1}}],[\"它描述了一组抽象的规范\",{\"1\":{\"207\":1}}],[\"它不一定能在减少内存占用这方面带来实质性的提升\",{\"1\":{\"192\":1}}],[\"它必须是指针\",{\"1\":{\"188\":1}}],[\"它用于存放不知道长度的数据\",{\"1\":{\"161\":1}}],[\"它的内容结构更加简洁\",{\"1\":{\"513\":1}}],[\"它的用途十分广泛\",{\"1\":{\"510\":1}}],[\"它的本质是\",{\"1\":{\"429\":1}}],[\"它的基本数据单位就是文档\",{\"1\":{\"418\":1}}],[\"它的增长趋势总体上而言会持续变缓\",{\"1\":{\"396\":1}}],[\"它的执行结果是\",{\"1\":{\"396\":1}}],[\"它的存在只是为了更加方便的进行本地开发\",{\"1\":{\"382\":1}}],[\"它的作用主要是解决一致性构建问题\",{\"1\":{\"379\":1}}],[\"它的功能同样非常简单\",{\"1\":{\"365\":1}}],[\"它的功能非常简单\",{\"1\":{\"365\":1}}],[\"它的使用与其他的原子类型并无太大的差别\",{\"1\":{\"360\":1}}],[\"它的使用非常简单\",{\"1\":{\"353\":1}}],[\"它的实现也只是稍微封装了一下并调用withdeadline\",{\"1\":{\"347\":1}}],[\"它的出现是可以被接受的\",{\"1\":{\"308\":1}}],[\"它的返回值是c语言中的int而非go中的int\",{\"1\":{\"218\":1}}],[\"它的参数是会被预计算的\",{\"1\":{\"204\":1}}],[\"它的参数支持任意类型\",{\"1\":{\"138\":1}}],[\"它的输出\",{\"1\":{\"622\":1}}],[\"它的输出如下\",{\"1\":{\"622\":1}}],[\"它的输出还是和之前一样\",{\"1\":{\"206\":1}}],[\"它的输出一定是3而不是7\",{\"1\":{\"204\":1}}],[\"它的输出是\",{\"1\":{\"129\":2}}],[\"它的入参依旧是0和1\",{\"1\":{\"127\":1}}],[\"它的顺序是先计算值再赋值\",{\"1\":{\"127\":1}}],[\"它的创建开销极小\",{\"1\":{\"70\":1}}],[\"它们仅仅只是一个代表而已\",{\"1\":{\"639\":1}}],[\"它们都是使用的本地文件系统\",{\"1\":{\"628\":1}}],[\"它们是两个不同的变量\",{\"1\":{\"622\":1}}],[\"它们是这样一个调用链go\",{\"1\":{\"219\":1}}],[\"它们之间不能有其它字符\",{\"1\":{\"618\":1}}],[\"它们分别代表了\",{\"1\":{\"243\":1}}],[\"它们在go中会以字节数组的形式存在\",{\"1\":{\"227\":1}}],[\"它们诞生在exp函数的作用域内\",{\"1\":{\"201\":1}}],[\"它们的实际类型就是你传入的具体类型\",{\"1\":{\"639\":1}}],[\"它们的实际类型如下\",{\"1\":{\"422\":1}}],[\"它们的类型是time\",{\"1\":{\"630\":1}}],[\"它们的返回值就是一个闭包函数\",{\"1\":{\"188\":1}}],[\"它们的参数支持所有的可比较类型\",{\"1\":{\"128\":1}}],[\"它们一般是with开头\",{\"1\":{\"188\":1}}],[\"它们不再具有返回值\",{\"1\":{\"98\":1}}],[\"它们被降级为了语句statement\",{\"1\":{\"98\":1}}],[\"它就是异或运算符\",{\"1\":{\"98\":1}}],[\"它控制可见性的方式非常简单\",{\"1\":{\"93\":1}}],[\"它摒弃了传统编程语言中的一些冗余和复杂性\",{\"1\":{\"69\":1}}],[\"它将现代编程语言中的许多最佳实践\",{\"1\":{\"67\":1}}],[\"它将不支持它的api添加到cors支持中\",{\"1\":{\"64\":1}}],[\"它可以更好的控制子孙协程以及层级更深的协程\",{\"1\":{\"342\":1}}],[\"它可以很灵活的去应对一些问题\",{\"1\":{\"265\":1}}],[\"它可以在o\",{\"1\":{\"263\":1}}],[\"它可以确保数据交换的安全性\",{\"1\":{\"70\":1}}],[\"它可以缓冲消息和热交换连接\",{\"1\":{\"64\":1}}],[\"它可将一个输入的tab分割的列翻译为适当对齐的文本\",{\"1\":{\"43\":1}}],[\"它是用于直接调用通过在execute时期传入的data中的函数\",{\"1\":{\"620\":1}}],[\"它是乐观锁的一种典型实现\",{\"1\":{\"359\":1}}],[\"它是一种在协程间通信的解决方案\",{\"1\":{\"332\":1}}],[\"它是一个变量而不是常量\",{\"1\":{\"307\":1}}],[\"它是一个简单的记录包\",{\"1\":{\"43\":1}}],[\"它是通过错误来体现\",{\"1\":{\"307\":1}}],[\"它是绝对不会自己释放掉的\",{\"1\":{\"229\":1}}],[\"它是中文分词算法\",{\"1\":{\"63\":1}}],[\"它限制了任务执行的并发性\",{\"1\":{\"56\":1}}],[\"它遵循实体组件系统范式\",{\"1\":{\"53\":1}}],[\"它自动构建html输出\",{\"1\":{\"43\":1}}],[\"它提供的api与text\",{\"1\":{\"628\":1}}],[\"它提供了处理网络通信\",{\"1\":{\"565\":1}}],[\"它提供了fmt\",{\"1\":{\"138\":1}}],[\"它提供了用于构建各种机器学习和神经网络算法的原语\",{\"1\":{\"61\":1}}],[\"它提供了基本的同步原语\",{\"1\":{\"40\":1}}],[\"它提供命令行参数的规则定义和传入参数解析的功能\",{\"1\":{\"40\":1}}],[\"它甚至使你能够在不了解c语言的情况下编写出新的换源方法\",{\"1\":{\"11\":1}}],[\"时区\",{\"1\":{\"541\":1}}],[\"时间类型可以格式化输出\",{\"1\":{\"631\":1}}],[\"时间单位\",{\"0\":{\"630\":1}}],[\"时间\",{\"1\":{\"541\":1}}],[\"时间操作的包\",{\"1\":{\"508\":1}}],[\"时间分析器具有可插拔的规则\",{\"1\":{\"63\":1}}],[\"时至今日\",{\"1\":{\"361\":1}}],[\"时序数据库\",{\"1\":{\"253\":2}}],[\"时\",{\"1\":{\"40\":1,\"180\":1}}],[\"自身的地址\",{\"1\":{\"611\":1}}],[\"自带的日志包\",{\"1\":{\"508\":1}}],[\"自带的交叉编译也没法用了\",{\"1\":{\"233\":1}}],[\"自减\",{\"1\":{\"458\":1}}],[\"自增\",{\"1\":{\"458\":1}}],[\"自定义函数的返回值一般有两个\",{\"1\":{\"620\":1}}],[\"自定义排序\",{\"0\":{\"580\":1}}],[\"自定义error\",{\"1\":{\"312\":1}}],[\"自定义错误\",{\"0\":{\"310\":1}}],[\"自定义错误是通过var来声明的\",{\"1\":{\"307\":1}}],[\"自定义协议的tcp\",{\"1\":{\"64\":1}}],[\"自动\",{\"0\":{\"243\":1}}],[\"自动和手动\",{\"1\":{\"241\":1}}],[\"自动测速\",{\"1\":{\"11\":1}}],[\"自然不会有这种特殊待遇了\",{\"1\":{\"643\":1}}],[\"自然所有的case都不可用\",{\"1\":{\"340\":1}}],[\"自然闭包函数也就无法恢复panic\",{\"1\":{\"316\":1}}],[\"自然也就不再需要free\",{\"1\":{\"222\":1}}],[\"自然而然实现animal接口的就是dog指针\",{\"1\":{\"206\":1}}],[\"自然en和ru语言日期\",{\"1\":{\"63\":1}}],[\"自然语言处理\",{\"0\":{\"63\":1},\"1\":{\"39\":1}}],[\"自适应基数树的\",{\"1\":{\"46\":1}}],[\"微秒\",{\"1\":{\"541\":1}}],[\"微调相关性\",{\"1\":{\"402\":1}}],[\"微软办公软件\",{\"1\":{\"39\":1}}],[\"微服务项目我推荐参考该项目进行学习\",{\"1\":{\"249\":1}}],[\"微服务架构\",{\"0\":{\"78\":1}}],[\"微服务架构以及高性能网络应用\",{\"1\":{\"67\":1}}],[\"微服务\",{\"1\":{\"89\":1},\"2\":{\"21\":1,\"24\":1,\"26\":1,\"28\":1,\"30\":1,\"32\":1,\"34\":1}}],[\"机器学习\",{\"0\":{\"61\":1},\"1\":{\"39\":1}}],[\"jmoiron\",{\"1\":{\"432\":1}}],[\"jet\",{\"1\":{\"614\":1}}],[\"jettison\",{\"1\":{\"60\":1}}],[\"jenny\",{\"1\":{\"423\":1,\"425\":1}}],[\"juejin\",{\"1\":{\"512\":1,\"642\":1}}],[\"just\",{\"1\":{\"367\":1}}],[\"jump\",{\"1\":{\"47\":2}}],[\"join\",{\"1\":{\"329\":1}}],[\"john\",{\"1\":{\"188\":1,\"226\":1,\"263\":2,\"426\":1}}],[\"job\",{\"1\":{\"185\":1,\"187\":1,\"189\":2,\"191\":2}}],[\"j++\",{\"1\":{\"152\":1,\"154\":2,\"155\":2}}],[\"j+1\",{\"1\":{\"152\":1}}],[\"j\",{\"1\":{\"152\":9,\"154\":8,\"155\":8,\"309\":3,\"396\":15,\"575\":2,\"580\":5,\"617\":2}}],[\"js做了安全处理\",{\"1\":{\"628\":1}}],[\"js转义\",{\"1\":{\"620\":1}}],[\"js进行快速简单的桌面ui开发\",{\"1\":{\"57\":1}}],[\"js\",{\"1\":{\"57\":1,\"620\":2}}],[\"jsonstr\",{\"1\":{\"520\":2}}],[\"json包下提供对应的函数来进行json的序列化与反序列化\",{\"1\":{\"516\":1}}],[\"json在restful风格的接口通信中经常会用到\",{\"1\":{\"516\":1}}],[\"jsonhal\",{\"1\":{\"60\":1}}],[\"jsongo\",{\"1\":{\"60\":1}}],[\"jsonf\",{\"1\":{\"60\":1}}],[\"jsonapi\",{\"1\":{\"60\":1}}],[\"json2go\",{\"1\":{\"60\":1}}],[\"json查询\",{\"1\":{\"60\":1}}],[\"json响应\",{\"1\":{\"60\":1}}],[\"jsonerror可让我们轻松创建遵循jsonapi规范的json响应错误\",{\"1\":{\"60\":1}}],[\"jsonerror\",{\"1\":{\"60\":1}}],[\"jsonrpc软件包可帮助实现json\",{\"1\":{\"47\":1}}],[\"jsonrpc\",{\"1\":{\"43\":1,\"47\":2}}],[\"json相关\",{\"1\":{\"41\":1}}],[\"json目前广泛用做网络程序中的通信格式\",{\"1\":{\"40\":1}}],[\"json\",{\"0\":{\"516\":1},\"1\":{\"40\":1,\"41\":1,\"43\":1,\"47\":1,\"60\":1,\"288\":2,\"372\":4,\"378\":2,\"388\":1,\"418\":1,\"509\":2,\"517\":1,\"519\":1,\"520\":1,\"531\":4}}],[\"json格式的版本元数据\",{\"1\":{\"379\":1}}],[\"json格式\",{\"0\":{\"60\":1},\"1\":{\"39\":1}}],[\"jpeg\",{\"1\":{\"43\":1}}],[\"jtolds\",{\"1\":{\"41\":1}}],[\"jan\",{\"1\":{\"631\":1}}],[\"jane\",{\"1\":{\"188\":1}}],[\"jar\",{\"1\":{\"532\":1}}],[\"jackmike\",{\"1\":{\"622\":1}}],[\"jack123456\",{\"1\":{\"382\":2}}],[\"jackup\",{\"1\":{\"212\":8}}],[\"jack\",{\"1\":{\"93\":1,\"125\":5,\"130\":2,\"140\":1,\"187\":2,\"189\":2,\"190\":1,\"236\":1,\"257\":1,\"258\":1,\"287\":2,\"298\":6,\"365\":1,\"366\":2,\"367\":1,\"369\":4,\"382\":2,\"384\":1,\"411\":2,\"412\":1,\"413\":2,\"423\":1,\"424\":1,\"425\":1,\"428\":1,\"448\":1,\"449\":1,\"450\":1,\"460\":2,\"511\":1,\"512\":1,\"517\":2,\"518\":1,\"519\":2,\"520\":2,\"531\":1,\"580\":1,\"581\":1,\"609\":4,\"617\":1,\"619\":3,\"622\":3,\"626\":2,\"627\":2,\"628\":3,\"643\":2}}],[\"jazigo是用go语言编写的工具\",{\"1\":{\"64\":1}}],[\"jazigo\",{\"1\":{\"64\":1}}],[\"jaydiff\",{\"1\":{\"60\":1}}],[\"jaytaylor\",{\"1\":{\"41\":1}}],[\"java会自动完成类型转换\",{\"1\":{\"593\":1}}],[\"javascript转译器\",{\"1\":{\"55\":1}}],[\"javascript引擎绑定\",{\"1\":{\"49\":1}}],[\"java\",{\"0\":{\"89\":1},\"1\":{\"55\":1,\"89\":3}}],[\"jaeger\",{\"0\":{\"25\":1}}],[\"jinzhu\",{\"1\":{\"41\":1}}],[\"图像操作的包\",{\"1\":{\"508\":1}}],[\"图像处理过滤器的包装\",{\"1\":{\"58\":1}}],[\"图数据库\",{\"1\":{\"253\":2}}],[\"图画的并不严谨\",{\"1\":{\"229\":1}}],[\"图文电视\",{\"1\":{\"65\":1}}],[\"图片缩放\",{\"1\":{\"41\":1}}],[\"图片\",{\"0\":{\"58\":1},\"1\":{\"39\":1,\"51\":1}}],[\"图形界面\",{\"0\":{\"57\":1},\"1\":{\"39\":1}}],[\"编辑go\",{\"1\":{\"375\":1,\"383\":1}}],[\"编写规范\",{\"0\":{\"386\":1}}],[\"编写完后对源代码格式化并测试\",{\"1\":{\"366\":1}}],[\"编写\",{\"0\":{\"365\":1}}],[\"编写模块\",{\"0\":{\"362\":1}}],[\"编写一个简单的函数来模拟内存和cpu的消耗\",{\"1\":{\"241\":1}}],[\"编写头文件lib\",{\"1\":{\"231\":1}}],[\"编写具体的函数\",{\"1\":{\"218\":1}}],[\"编写和使用openstreetmap数据和api的库\",{\"1\":{\"54\":1}}],[\"编程的开发者来说有一定学习曲线\",{\"1\":{\"84\":1}}],[\"编程语言\",{\"1\":{\"11\":1}}],[\"编译后在命令行启动程序\",{\"1\":{\"528\":1}}],[\"编译后的程序更为高效\",{\"1\":{\"89\":1}}],[\"编译快是因为编译期做的优化少\",{\"1\":{\"264\":1}}],[\"编译\",{\"1\":{\"232\":1}}],[\"编译速度变慢\",{\"1\":{\"233\":1}}],[\"编译速度非常快\",{\"1\":{\"73\":1}}],[\"编译速度快\",{\"0\":{\"73\":1}}],[\"编译型语言\",{\"1\":{\"67\":1,\"89\":1}}],[\"编译器就难受\",{\"1\":{\"264\":1}}],[\"编译器就会告诉你无法访问\",{\"1\":{\"94\":1}}],[\"编译器很明确的告诉了我们变量mom发生了逃逸\",{\"1\":{\"236\":1}}],[\"编译器会提示头文件不存在\",{\"1\":{\"219\":1}}],[\"编译器会告诉你两者之间类型并不相同\",{\"1\":{\"128\":1}}],[\"编译器将会输出如下错误\",{\"1\":{\"206\":1}}],[\"编译器报错\",{\"1\":{\"130\":1}}],[\"编译器无法推断其类型\",{\"1\":{\"125\":1}}],[\"编译器\",{\"0\":{\"55\":1}}],[\"编译器相关\",{\"1\":{\"39\":1}}],[\"编码器\",{\"1\":{\"58\":1}}],[\"金融功能库\",{\"1\":{\"52\":1}}],[\"金融\",{\"0\":{\"52\":1,\"62\":1},\"1\":{\"39\":1}}],[\"电子邮件\",{\"0\":{\"48\":1},\"1\":{\"39\":1}}],[\"音频和音乐\",{\"0\":{\"45\":1},\"1\":{\"39\":1}}],[\"音乐\",{\"0\":{\"6\":1}}],[\"包应该是再熟悉不过的概念了\",{\"1\":{\"374\":1}}],[\"包裹原始错误\",{\"1\":{\"312\":2}}],[\"包名\",{\"1\":{\"286\":1,\"289\":1}}],[\"包为内部包\",{\"1\":{\"95\":1}}],[\"包b又导入了包a\",{\"1\":{\"94\":1}}],[\"包b也导入了包a\",{\"1\":{\"94\":1}}],[\"包c导入了包b\",{\"1\":{\"94\":1}}],[\"包a导入了包c\",{\"1\":{\"94\":1}}],[\"包arp实现arp协议\",{\"1\":{\"64\":1}}],[\"包的命名风格建议都是小写字母\",{\"1\":{\"92\":1}}],[\"包内共享所有变量\",{\"1\":{\"92\":1}}],[\"包其实就是一个文件夹\",{\"1\":{\"92\":1}}],[\"包装crypto\",{\"1\":{\"64\":1}}],[\"包raw允许在设备驱动程序级别为网络接口读取和写入数据\",{\"1\":{\"64\":1}}],[\"包括哈希文件\",{\"1\":{\"376\":1}}],[\"包括已释放\",{\"1\":{\"246\":2}}],[\"包括换行和缩进\",{\"1\":{\"171\":1}}],[\"包括英语和德语词干\",{\"1\":{\"63\":1}}],[\"包括porter\",{\"1\":{\"63\":1}}],[\"包括tcp\",{\"1\":{\"43\":1}}],[\"包含字符串\",{\"0\":{\"598\":1}}],[\"包含\",{\"1\":{\"266\":1}}],[\"包含当程序在运行时调试其自身的功能\",{\"1\":{\"43\":1}}],[\"包含用于对x\",{\"1\":{\"43\":1}}],[\"包含一个低级的操作系统原语的接口\",{\"1\":{\"43\":1}}],[\"包含与go运行时系统交互的操作\",{\"1\":{\"43\":1}}],[\"包\",{\"0\":{\"92\":1},\"1\":{\"39\":1,\"41\":1,\"43\":1,\"45\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"582\":1,\"594\":1}}],[\"k3这种方式访问\",{\"1\":{\"617\":1}}],[\"k2\",{\"1\":{\"617\":1}}],[\"k1\",{\"1\":{\"617\":1}}],[\"k8s\",{\"2\":{\"499\":1}}],[\"k8s等\",{\"1\":{\"254\":1}}],[\"know\",{\"1\":{\"404\":1}}],[\"ket\",{\"1\":{\"443\":1}}],[\"keep\",{\"1\":{\"389\":1}}],[\"key2\",{\"1\":{\"191\":1}}],[\"key不存在\",{\"1\":{\"179\":1}}],[\"keytype\",{\"1\":{\"178\":1}}],[\"keyed\",{\"1\":{\"43\":1}}],[\"key\",{\"1\":{\"41\":1,\"181\":1,\"182\":4,\"271\":2,\"288\":2,\"343\":2,\"344\":1,\"345\":5,\"355\":10,\"422\":1,\"434\":3,\"441\":1,\"619\":1}}],[\"klauspost\",{\"1\":{\"372\":2,\"378\":1}}],[\"kib\",{\"1\":{\"368\":1}}],[\"kindnames\",{\"1\":{\"270\":1}}],[\"kind类型仅仅实现了stringer接口的string\",{\"1\":{\"270\":1}}],[\"kind来表示go中的基础类型\",{\"1\":{\"270\":1}}],[\"kind\",{\"0\":{\"270\":1},\"1\":{\"256\":3,\"267\":2,\"270\":5,\"271\":2,\"283\":2}}],[\"kingpin\",{\"1\":{\"254\":1}}],[\"kitex\",{\"1\":{\"249\":1}}],[\"kit\",{\"1\":{\"47\":1}}],[\"k\",{\"1\":{\"183\":2,\"257\":2,\"617\":2}}],[\"kcptun\",{\"1\":{\"64\":1}}],[\"kcp\",{\"1\":{\"64\":2}}],[\"k模式和k\",{\"1\":{\"61\":1}}],[\"krakend\",{\"1\":{\"47\":1}}],[\"kratos\",{\"1\":{\"42\":3,\"249\":1}}],[\"kak\",{\"1\":{\"429\":1}}],[\"kagome\",{\"1\":{\"63\":1}}],[\"kazaam\",{\"1\":{\"60\":1}}],[\"kademlia\",{\"1\":{\"47\":1}}],[\"kafka\",{\"0\":{\"492\":1},\"1\":{\"41\":1}}],[\"kubernetes\",{\"0\":{\"29\":1,\"498\":1},\"1\":{\"79\":1,\"85\":1}}],[\"kong\",{\"0\":{\"27\":1}}],[\"pm\",{\"1\":{\"631\":1}}],[\"pmezard\",{\"1\":{\"41\":1}}],[\"phi\",{\"1\":{\"545\":1}}],[\"php\",{\"1\":{\"49\":1}}],[\"p为\",{\"1\":{\"395\":1}}],[\"p=1\",{\"1\":{\"395\":6}}],[\"p=0\",{\"1\":{\"395\":13}}],[\"pypi\",{\"1\":{\"370\":1}}],[\"python的pip\",{\"1\":{\"361\":1}}],[\"python\",{\"0\":{\"88\":1},\"1\":{\"49\":1,\"88\":4}}],[\"pb\",{\"1\":{\"242\":1,\"245\":1,\"246\":1}}],[\"pbf\",{\"1\":{\"54\":2}}],[\"p1\",{\"1\":{\"200\":3}}],[\"p10\",{\"1\":{\"101\":1}}],[\"p++\",{\"1\":{\"195\":2}}],[\"p是一个指针\",{\"1\":{\"194\":1}}],[\"p2\",{\"1\":{\"188\":1,\"200\":3}}],[\"please\",{\"1\":{\"372\":1}}],[\"playground\",{\"1\":{\"372\":6,\"378\":3}}],[\"player\",{\"1\":{\"228\":2}}],[\"platform\",{\"1\":{\"249\":1}}],[\"pl\",{\"1\":{\"188\":1}}],[\"p\",{\"1\":{\"140\":2,\"173\":2,\"188\":14,\"189\":4,\"190\":5,\"194\":4,\"195\":6,\"226\":6,\"257\":2,\"285\":1,\"287\":2,\"293\":1,\"304\":3,\"319\":1,\"354\":21,\"521\":4,\"580\":10,\"641\":6,\"642\":7,\"643\":6,\"645\":8}}],[\"pubsubnumsub\",{\"1\":{\"486\":1}}],[\"publish\",{\"1\":{\"486\":1}}],[\"published\",{\"1\":{\"378\":1}}],[\"publicip\",{\"1\":{\"64\":1}}],[\"put\",{\"1\":{\"354\":3}}],[\"puts\",{\"1\":{\"216\":1,\"222\":6}}],[\"push\",{\"1\":{\"262\":2,\"263\":5,\"368\":1}}],[\"pure\",{\"1\":{\"53\":1,\"62\":1,\"64\":1,\"233\":2}}],[\"purl\",{\"1\":{\"49\":1}}],[\"pttl\",{\"1\":{\"451\":1}}],[\"ptr\",{\"1\":{\"222\":4,\"225\":2,\"227\":4,\"229\":4,\"267\":1,\"270\":1,\"644\":3,\"646\":1,\"647\":4,\"648\":1}}],[\"ptrie\",{\"1\":{\"46\":1}}],[\"pt\",{\"1\":{\"58\":1}}],[\"pdfcpu\",{\"1\":{\"51\":1}}],[\"pdf\",{\"1\":{\"51\":2}}],[\"pkg为测试所在的包\",{\"1\":{\"394\":1}}],[\"pkgpath\",{\"1\":{\"267\":1,\"271\":1,\"286\":1,\"289\":1}}],[\"pkg\",{\"1\":{\"50\":1,\"312\":2,\"372\":1,\"376\":1,\"394\":1,\"395\":3}}],[\"pkix\",{\"1\":{\"43\":1}}],[\"pglock\",{\"1\":{\"47\":1}}],[\"pipline\",{\"1\":{\"429\":2}}],[\"pipeline可以根据自己的需求来指定关联模板的根对象\",{\"1\":{\"626\":1}}],[\"pipeline类型\",{\"1\":{\"429\":1}}],[\"pipeline\",{\"1\":{\"46\":1,\"429\":2,\"622\":2,\"623\":2,\"624\":5,\"626\":1}}],[\"pike\",{\"1\":{\"307\":1}}],[\"ping测试连接是否可用\",{\"1\":{\"421\":1}}],[\"ping\",{\"1\":{\"404\":3,\"421\":1}}],[\"pingresp\",{\"1\":{\"404\":2}}],[\"pingcap\",{\"1\":{\"42\":1}}],[\"pinner来固定内存\",{\"1\":{\"229\":1}}],[\"pinyin\",{\"1\":{\"63\":1}}],[\"picfit\",{\"1\":{\"58\":1}}],[\"pi\",{\"1\":{\"57\":1,\"545\":1}}],[\"pixel\",{\"1\":{\"53\":1}}],[\"pitaya\",{\"1\":{\"53\":1,\"252\":1}}],[\"ppfree\",{\"1\":{\"354\":2}}],[\"pp\",{\"1\":{\"354\":3,\"643\":3}}],[\"pprof主要负责分析程序的资源占用\",{\"1\":{\"247\":1}}],[\"pprof支持相当多的格式\",{\"1\":{\"245\":1}}],[\"pprof开源地址\",{\"1\":{\"244\":1}}],[\"pprof包将上面的分析函数包装成了http接口\",{\"1\":{\"243\":1}}],[\"pprof包\",{\"1\":{\"242\":1}}],[\"pprof\",{\"0\":{\"240\":1},\"1\":{\"43\":2,\"233\":1,\"240\":1,\"242\":7,\"243\":10,\"244\":2,\"245\":7,\"246\":7,\"247\":1}}],[\"pptx\",{\"1\":{\"62\":1}}],[\"ppt\",{\"1\":{\"41\":1}}],[\"png\",{\"1\":{\"43\":1,\"245\":3}}],[\"pause\",{\"1\":{\"392\":4}}],[\"pattern\",{\"1\":{\"628\":1}}],[\"patterns\",{\"1\":{\"628\":1}}],[\"patch\",{\"1\":{\"374\":2}}],[\"path\",{\"1\":{\"43\":2,\"307\":2,\"319\":1,\"324\":1,\"328\":1,\"329\":3,\"508\":2,\"538\":1}}],[\"passes\",{\"1\":{\"389\":1}}],[\"password\",{\"1\":{\"382\":5,\"404\":1,\"443\":1,\"444\":1,\"445\":1,\"513\":3,\"514\":2}}],[\"pass\",{\"1\":{\"366\":2,\"387\":6,\"389\":4,\"390\":3,\"391\":3,\"392\":13,\"394\":1,\"395\":2,\"396\":10,\"546\":2,\"547\":2,\"548\":2,\"549\":2,\"550\":2,\"551\":2,\"552\":2,\"553\":2,\"554\":2,\"555\":2,\"556\":2,\"557\":2,\"558\":2,\"559\":2,\"560\":2,\"561\":2,\"562\":2,\"563\":2,\"564\":2,\"584\":2,\"585\":2,\"586\":2,\"587\":2,\"588\":2,\"589\":2,\"590\":2,\"591\":2,\"592\":2,\"593\":2,\"596\":2,\"597\":2,\"598\":6,\"599\":2,\"600\":2,\"601\":2,\"602\":2,\"603\":2,\"604\":2,\"605\":2,\"606\":2,\"607\":4,\"608\":2,\"609\":2,\"610\":2,\"611\":2,\"613\":2}}],[\"passing\",{\"1\":{\"219\":1}}],[\"panic则会抛出panic\",{\"1\":{\"539\":1}}],[\"panic日志\",{\"1\":{\"539\":1,\"540\":1,\"541\":1}}],[\"panicln\",{\"1\":{\"421\":1,\"424\":1,\"425\":4,\"426\":2,\"427\":4,\"428\":2,\"429\":2,\"539\":1,\"540\":1,\"541\":1}}],[\"panicking\",{\"1\":{\"354\":1}}],[\"panic的参数禁止使用nil\",{\"1\":{\"316\":1}}],[\"panic是向上传递而不是向下\",{\"1\":{\"316\":1}}],[\"panic是go是运行时异常的表达形式\",{\"1\":{\"313\":1}}],[\"panic恢复\",{\"1\":{\"316\":4}}],[\"panicb\",{\"1\":{\"315\":6}}],[\"panica\",{\"1\":{\"315\":2}}],[\"panic函数接收一个类型为\",{\"1\":{\"314\":1}}],[\"panic中文译为恐慌\",{\"1\":{\"313\":1}}],[\"panic\",{\"0\":{\"313\":1},\"1\":{\"178\":1,\"307\":1,\"313\":1,\"314\":3,\"315\":16,\"316\":4,\"325\":2,\"346\":1,\"360\":2,\"382\":1,\"404\":2,\"406\":2,\"407\":2,\"408\":2,\"409\":2,\"411\":2,\"412\":2,\"413\":2,\"414\":2,\"415\":6,\"443\":1,\"567\":1,\"569\":2,\"570\":2,\"571\":2,\"572\":1,\"573\":2,\"574\":5,\"611\":1,\"613\":1,\"617\":4,\"619\":1,\"625\":1,\"626\":5,\"628\":2,\"643\":1}}],[\"pack\",{\"1\":{\"364\":1,\"368\":1}}],[\"package便会为其创建一个页面\",{\"1\":{\"369\":1}}],[\"packages\",{\"1\":{\"215\":1,\"371\":1,\"582\":1,\"594\":1,\"614\":1,\"637\":1}}],[\"package关键字声明了是当前go文件属于哪一个包\",{\"1\":{\"91\":1}}],[\"package\",{\"1\":{\"91\":1,\"93\":1,\"94\":6,\"95\":5,\"96\":1,\"97\":1,\"133\":1,\"136\":1,\"137\":1,\"138\":1,\"170\":1,\"216\":1,\"217\":2,\"218\":1,\"219\":2,\"220\":1,\"221\":1,\"222\":4,\"223\":1,\"224\":1,\"225\":2,\"226\":1,\"227\":1,\"228\":1,\"229\":2,\"231\":1,\"232\":1,\"233\":1,\"236\":1,\"237\":1,\"238\":1,\"239\":2,\"242\":3,\"243\":3,\"365\":3,\"367\":1,\"369\":2,\"372\":1,\"373\":2,\"382\":3,\"387\":2,\"389\":2,\"390\":5,\"391\":1,\"392\":1,\"394\":2,\"396\":2,\"421\":1,\"521\":3,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":2,\"574\":2,\"582\":1,\"594\":1,\"614\":1,\"615\":1,\"637\":1}}],[\"packaging\",{\"1\":{\"51\":1}}],[\"packet\",{\"1\":{\"64\":1}}],[\"paho\",{\"1\":{\"64\":1}}],[\"paice\",{\"1\":{\"63\":1}}],[\"paicehusk\",{\"1\":{\"63\":1}}],[\"parsing\",{\"1\":{\"591\":1}}],[\"parseinlocation\",{\"1\":{\"632\":1}}],[\"parseglob基于通配符匹配\",{\"1\":{\"628\":1}}],[\"parseglob\",{\"1\":{\"628\":1}}],[\"parsedtmpl\",{\"1\":{\"617\":2,\"625\":2}}],[\"parse方法解析模板字符串\",{\"1\":{\"615\":1}}],[\"parsecomplex\",{\"1\":{\"591\":4}}],[\"parsecidr\",{\"1\":{\"568\":2}}],[\"parsefiles基于文件名\",{\"1\":{\"628\":1}}],[\"parsefiles\",{\"1\":{\"628\":1}}],[\"parsefields\",{\"1\":{\"46\":1}}],[\"parsefs就是从指定的文件系统中加载匹配pattern的模板\",{\"1\":{\"628\":1}}],[\"parsefs\",{\"1\":{\"628\":3}}],[\"parsefloat\",{\"1\":{\"589\":3}}],[\"parsebool\",{\"1\":{\"586\":6}}],[\"parsemac\",{\"1\":{\"567\":2}}],[\"parse\",{\"1\":{\"43\":1,\"365\":1,\"526\":1,\"528\":1,\"615\":2,\"617\":1,\"625\":1,\"626\":4}}],[\"parser\",{\"1\":{\"43\":1,\"508\":1}}],[\"parent\",{\"1\":{\"346\":5,\"347\":4,\"389\":1}}],[\"parentindex\",{\"1\":{\"263\":7}}],[\"parameters\",{\"1\":{\"264\":1}}],[\"parameter\",{\"1\":{\"239\":1}}],[\"parallel的测试用例并行运行\",{\"1\":{\"388\":1}}],[\"parallel\",{\"1\":{\"56\":1,\"387\":1,\"388\":1,\"392\":3}}],[\"parquet文件\",{\"1\":{\"51\":1}}],[\"parquet\",{\"1\":{\"51\":1}}],[\"pow\",{\"1\":{\"558\":2,\"561\":2}}],[\"powerdns\",{\"1\":{\"64\":2}}],[\"point\",{\"1\":{\"304\":4}}],[\"pointer与类型指针本身是不支持指针运算\",{\"1\":{\"643\":1}}],[\"pointer是一个引用\",{\"1\":{\"643\":1}}],[\"pointer是一种可以指向任意类型的\",{\"1\":{\"643\":1}}],[\"pointer转换为uintptr时\",{\"1\":{\"643\":1}}],[\"pointer转换为uintptr\",{\"1\":{\"643\":1}}],[\"pointer再转换为\",{\"1\":{\"643\":1}}],[\"pointer无法解引用\",{\"1\":{\"643\":1}}],[\"pointer可以转换为uintptr\",{\"1\":{\"643\":1}}],[\"pointer可以转换为任何类型的指针\",{\"1\":{\"643\":1}}],[\"pointer可以进行访问和修改\",{\"1\":{\"227\":1}}],[\"pointer类型可以进行四个特殊操作\",{\"1\":{\"643\":1}}],[\"pointer了解细节\",{\"1\":{\"219\":1}}],[\"pointer\",{\"0\":{\"643\":1},\"1\":{\"206\":1,\"222\":7,\"225\":1,\"227\":1,\"229\":3,\"266\":5,\"267\":1,\"270\":3,\"279\":16,\"357\":1,\"611\":1,\"643\":20,\"644\":4,\"645\":2,\"647\":1}}],[\"pop\",{\"1\":{\"262\":2,\"263\":2,\"426\":1}}],[\"position\",{\"1\":{\"408\":7}}],[\"positive\",{\"1\":{\"217\":2}}],[\"pos\",{\"1\":{\"106\":1}}],[\"post示例\",{\"0\":{\"531\":1}}],[\"postgresql\",{\"1\":{\"432\":1}}],[\"postgresql支持的分布式锁定实现\",{\"1\":{\"47\":1}}],[\"post\",{\"1\":{\"152\":1,\"531\":1}}],[\"postscript以及pdf文档格式\",{\"1\":{\"43\":1}}],[\"pooltimeout\",{\"1\":{\"444\":1}}],[\"poolsize\",{\"1\":{\"444\":1}}],[\"pool一定是并发安全\",{\"1\":{\"354\":1}}],[\"pool在申请对象时\",{\"1\":{\"354\":1}}],[\"pool中\",{\"1\":{\"354\":1}}],[\"pool只适合存放临时对象\",{\"1\":{\"354\":1}}],[\"pool时需要注意几个点\",{\"1\":{\"354\":1}}],[\"pool有一个对外暴露的new字段\",{\"1\":{\"354\":1}}],[\"pool总共只有两个方法\",{\"1\":{\"354\":1}}],[\"pool的设计目的是用于存储临时对象以便后续的复用\",{\"1\":{\"354\":1}}],[\"pool和一些有用的executors\",{\"1\":{\"56\":1}}],[\"pool\",{\"0\":{\"354\":1},\"1\":{\"56\":2,\"354\":7}}],[\"port\",{\"1\":{\"314\":2,\"372\":2,\"444\":1,\"513\":3,\"514\":2}}],[\"portproxy\",{\"1\":{\"64\":1}}],[\"porter2\",{\"1\":{\"63\":1}}],[\"porter的porter干算法的c实现的相当简单的移植\",{\"1\":{\"63\":1}}],[\"porter\",{\"1\":{\"63\":1}}],[\"portmidi\",{\"1\":{\"45\":1}}],[\"portaudio\",{\"1\":{\"45\":1}}],[\"portable\",{\"1\":{\"43\":1}}],[\"portfolio\",{\"1\":{\"2\":1}}],[\"pelletier\",{\"1\":{\"372\":2,\"378\":1}}],[\"peek\",{\"1\":{\"246\":1,\"262\":4,\"263\":3}}],[\"peerdiscovery\",{\"1\":{\"64\":1}}],[\"people\",{\"1\":{\"200\":2}}],[\"persist\",{\"1\":{\"450\":1}}],[\"persons\",{\"1\":{\"580\":3,\"581\":3}}],[\"personslice\",{\"1\":{\"580\":5,\"581\":2}}],[\"person>\",{\"1\":{\"511\":1,\"512\":1}}],[\"person实现了该接口\",{\"1\":{\"257\":1}}],[\"personoptions\",{\"1\":{\"188\":6}}],[\"person类型的参数\",{\"1\":{\"188\":1}}],[\"person\",{\"1\":{\"140\":6,\"186\":1,\"187\":3,\"188\":8,\"189\":9,\"190\":1,\"197\":5,\"200\":4,\"210\":1,\"211\":3,\"212\":2,\"226\":5,\"236\":7,\"257\":3,\"263\":7,\"285\":2,\"286\":2,\"287\":2,\"288\":1,\"289\":6,\"290\":1,\"293\":5,\"298\":3,\"435\":6,\"510\":1,\"511\":3,\"512\":3,\"516\":1,\"517\":3,\"518\":1,\"519\":3,\"520\":4,\"521\":7,\"531\":3,\"580\":3,\"581\":1,\"617\":1,\"626\":1,\"627\":3,\"628\":9,\"640\":2,\"641\":2,\"642\":2,\"643\":2}}],[\"perons\",{\"1\":{\"435\":3}}],[\"perf\",{\"1\":{\"395\":1}}],[\"perm\",{\"1\":{\"319\":1,\"321\":1,\"328\":2}}],[\"permission\",{\"1\":{\"309\":1}}],[\"periph\",{\"1\":{\"59\":1}}],[\"petrovich\",{\"1\":{\"63\":2}}],[\"pem\",{\"1\":{\"43\":1}}],[\"pe\",{\"1\":{\"43\":1}}],[\"ps\",{\"1\":{\"41\":1,\"528\":4,\"643\":3,\"644\":3}}],[\"practice\",{\"1\":{\"389\":1}}],[\"pravite等关键字\",{\"1\":{\"93\":1}}],[\"pr\",{\"1\":{\"61\":1}}],[\"prefix\",{\"1\":{\"510\":1,\"519\":1,\"540\":2,\"541\":1,\"603\":1}}],[\"preference\",{\"1\":{\"407\":1}}],[\"prec\",{\"1\":{\"590\":2,\"592\":2}}],[\"precompiled\",{\"1\":{\"373\":1}}],[\"precedence\",{\"1\":{\"98\":1}}],[\"pretty\",{\"1\":{\"254\":1}}],[\"preparing\",{\"1\":{\"247\":1}}],[\"premailer\",{\"1\":{\"48\":1}}],[\"predicates\",{\"1\":{\"43\":1}}],[\"present\",{\"1\":{\"41\":1}}],[\"primitive\",{\"1\":{\"422\":4}}],[\"primary\",{\"1\":{\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"421\":1,\"434\":1}}],[\"privacy\",{\"1\":{\"43\":1}}],[\"prints\",{\"1\":{\"373\":1}}],[\"printsum\",{\"1\":{\"217\":2}}],[\"printmymap\",{\"1\":{\"303\":2}}],[\"printnum\",{\"1\":{\"229\":2}}],[\"printint32arr\",{\"1\":{\"225\":2}}],[\"printing\",{\"1\":{\"43\":1}}],[\"printgofloat64\",{\"1\":{\"224\":2}}],[\"printgofloat32\",{\"1\":{\"224\":2}}],[\"printgouint64\",{\"1\":{\"223\":2}}],[\"printgouint32\",{\"1\":{\"223\":2}}],[\"printgouint16\",{\"1\":{\"223\":2}}],[\"printgouint8\",{\"1\":{\"223\":1}}],[\"printgoint64\",{\"1\":{\"223\":2}}],[\"printgoint32\",{\"1\":{\"223\":2}}],[\"printgoint16\",{\"1\":{\"223\":2}}],[\"printgoint8\",{\"1\":{\"223\":3}}],[\"printbyte\",{\"1\":{\"220\":4}}],[\"print\",{\"0\":{\"137\":1},\"1\":{\"137\":1,\"620\":2,\"621\":1}}],[\"printer\",{\"1\":{\"43\":1}}],[\"println会反射获取参数的类型\",{\"1\":{\"279\":1}}],[\"println确实是最后执行的\",{\"1\":{\"204\":1}}],[\"println函数\",{\"1\":{\"138\":1}}],[\"println\",{\"1\":{\"40\":1,\"91\":2,\"94\":1,\"96\":1,\"106\":2,\"108\":2,\"111\":1,\"128\":2,\"129\":6,\"133\":1,\"137\":2,\"138\":1,\"143\":1,\"145\":1,\"147\":1,\"148\":2,\"149\":3,\"151\":2,\"152\":3,\"153\":4,\"154\":2,\"155\":2,\"159\":1,\"163\":1,\"164\":3,\"165\":4,\"166\":3,\"167\":2,\"168\":3,\"169\":4,\"170\":2,\"172\":4,\"173\":4,\"174\":4,\"175\":2,\"176\":3,\"177\":2,\"178\":1,\"179\":7,\"180\":4,\"181\":4,\"182\":2,\"183\":2,\"184\":1,\"185\":1,\"189\":2,\"190\":1,\"193\":1,\"194\":9,\"195\":3,\"201\":1,\"202\":9,\"203\":1,\"204\":14,\"205\":2,\"206\":6,\"211\":1,\"212\":9,\"213\":14,\"217\":3,\"222\":1,\"225\":2,\"226\":1,\"227\":4,\"228\":2,\"229\":3,\"231\":1,\"232\":1,\"239\":2,\"257\":1,\"263\":3,\"269\":1,\"270\":1,\"271\":4,\"272\":5,\"273\":4,\"274\":2,\"275\":2,\"276\":1,\"277\":1,\"278\":1,\"279\":10,\"280\":2,\"281\":1,\"283\":4,\"284\":1,\"286\":4,\"287\":1,\"288\":2,\"289\":8,\"290\":2,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":2,\"298\":4,\"300\":2,\"302\":1,\"303\":3,\"304\":2,\"305\":2,\"306\":3,\"307\":4,\"312\":2,\"315\":30,\"316\":9,\"317\":2,\"319\":9,\"320\":10,\"321\":9,\"322\":11,\"323\":2,\"324\":4,\"327\":5,\"328\":2,\"331\":15,\"334\":1,\"335\":2,\"336\":10,\"337\":4,\"338\":1,\"339\":3,\"340\":20,\"341\":7,\"345\":2,\"346\":8,\"347\":2,\"348\":2,\"349\":2,\"350\":5,\"351\":5,\"353\":2,\"354\":1,\"355\":5,\"356\":1,\"358\":2,\"360\":2,\"367\":1,\"387\":2,\"389\":4,\"396\":3,\"404\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":3,\"421\":1,\"426\":2,\"428\":2,\"429\":1,\"435\":3,\"436\":3,\"437\":3,\"438\":3,\"439\":1,\"443\":2,\"448\":1,\"449\":2,\"450\":1,\"451\":2,\"454\":1,\"456\":1,\"457\":1,\"458\":2,\"460\":3,\"511\":2,\"512\":1,\"514\":2,\"515\":3,\"517\":2,\"519\":2,\"520\":1,\"521\":4,\"528\":1,\"530\":2,\"531\":1,\"537\":2,\"539\":1,\"540\":1,\"541\":1,\"546\":1,\"547\":1,\"548\":1,\"549\":2,\"550\":1,\"551\":2,\"552\":2,\"553\":1,\"554\":1,\"555\":2,\"556\":2,\"557\":1,\"558\":2,\"559\":1,\"560\":2,\"561\":2,\"562\":2,\"563\":2,\"564\":2,\"567\":1,\"568\":2,\"569\":2,\"570\":2,\"571\":2,\"572\":1,\"573\":2,\"574\":1,\"577\":1,\"579\":1,\"580\":1,\"581\":1,\"584\":1,\"585\":1,\"586\":3,\"587\":2,\"588\":2,\"589\":2,\"590\":6,\"591\":2,\"592\":3,\"593\":1,\"596\":2,\"597\":4,\"598\":8,\"599\":3,\"601\":3,\"603\":2,\"604\":5,\"605\":3,\"606\":2,\"607\":4,\"609\":4,\"610\":5,\"611\":2,\"612\":1,\"613\":2,\"615\":2,\"620\":2,\"629\":1,\"631\":3,\"632\":3,\"633\":1,\"634\":1,\"635\":2,\"640\":7,\"641\":5,\"642\":3,\"643\":8,\"644\":2,\"645\":2,\"646\":1,\"647\":1,\"648\":1}}],[\"printfgostring\",{\"1\":{\"222\":9}}],[\"printf函数\",{\"1\":{\"198\":1}}],[\"printf函数提供\",{\"1\":{\"140\":1}}],[\"printf来格式化字符串或者输出格式化字符串\",{\"1\":{\"140\":1}}],[\"printf\",{\"1\":{\"40\":1,\"111\":1,\"140\":33,\"143\":1,\"144\":1,\"152\":1,\"160\":6,\"173\":1,\"177\":3,\"198\":1,\"201\":1,\"217\":1,\"218\":1,\"219\":2,\"220\":1,\"221\":1,\"223\":8,\"224\":2,\"225\":1,\"226\":1,\"229\":2,\"233\":2,\"287\":1,\"312\":1,\"382\":1,\"396\":2,\"424\":1,\"425\":2,\"427\":4,\"435\":2,\"520\":1,\"600\":1,\"602\":2,\"608\":4,\"620\":2,\"621\":1,\"643\":1}}],[\"proxy\",{\"1\":{\"538\":2}}],[\"proxies\",{\"1\":{\"372\":2}}],[\"provided\",{\"1\":{\"407\":1}}],[\"produced\",{\"1\":{\"396\":3}}],[\"production\",{\"1\":{\"372\":1}}],[\"properties\",{\"1\":{\"406\":2,\"407\":1}}],[\"propagatecancel\",{\"1\":{\"346\":1}}],[\"proposal\",{\"1\":{\"264\":1}}],[\"process\",{\"1\":{\"373\":1,\"392\":13}}],[\"proc\",{\"1\":{\"247\":1,\"312\":1}}],[\"profile001\",{\"1\":{\"245\":1}}],[\"profile\",{\"1\":{\"242\":1,\"243\":3,\"245\":1,\"246\":1,\"247\":3}}],[\"profiles\",{\"1\":{\"242\":1,\"247\":1}}],[\"profiling\",{\"1\":{\"240\":1,\"244\":1}}],[\"program\",{\"1\":{\"240\":1,\"373\":2}}],[\"programming\",{\"1\":{\"215\":1}}],[\"programmer\",{\"1\":{\"185\":1,\"187\":4,\"191\":1}}],[\"prose\",{\"1\":{\"63\":1}}],[\"probab\",{\"1\":{\"61\":1}}],[\"project\",{\"1\":{\"59\":2,\"64\":1}}],[\"protoc编译器可以根据我们定义好的proto文件生成对应语言的源代码\",{\"1\":{\"521\":1}}],[\"protocol是谷歌2008开源的语言中立\",{\"1\":{\"521\":1}}],[\"protocol\",{\"0\":{\"521\":1},\"1\":{\"43\":1,\"373\":1,\"509\":1}}],[\"proto3\",{\"1\":{\"521\":1}}],[\"proto文件\",{\"1\":{\"521\":1}}],[\"proto\",{\"1\":{\"521\":8}}],[\"protobuf\",{\"0\":{\"23\":1},\"1\":{\"372\":2,\"378\":2,\"509\":1,\"521\":2}}],[\"prometheus\",{\"1\":{\"41\":1,\"79\":1,\"85\":1,\"253\":1}}],[\"cb\",{\"1\":{\"604\":1}}],[\"cbba\",{\"1\":{\"603\":1}}],[\"cbrt\",{\"1\":{\"560\":2}}],[\"cbytes\",{\"1\":{\"222\":6}}],[\"c0e9867c7d446bff72fe46e7e9fe3455e970a8adb0d3df0e1472d55db2612cd5\",{\"1\":{\"404\":1}}],[\"c1\",{\"1\":{\"377\":1}}],[\"c95f2b4c22f2\",{\"1\":{\"373\":1}}],[\"ctx\",{\"1\":{\"345\":3,\"346\":17,\"347\":3,\"389\":4,\"421\":4,\"424\":1,\"425\":4,\"426\":2,\"427\":4,\"428\":2,\"429\":2}}],[\"ctype\",{\"1\":{\"221\":2,\"226\":2}}],[\"cpu个数\",{\"1\":{\"444\":1}}],[\"cpu是一些关于cpu的信息\",{\"1\":{\"394\":1}}],[\"cpu=2\",{\"1\":{\"394\":1,\"395\":2}}],[\"cpu使用情况\",{\"1\":{\"394\":1}}],[\"cpuprofile\",{\"1\":{\"388\":1}}],[\"cpuguy83\",{\"1\":{\"373\":1}}],[\"cpuid\",{\"1\":{\"372\":2,\"378\":1}}],[\"cpu火焰图\",{\"1\":{\"246\":1}}],[\"cpu同理\",{\"1\":{\"245\":1}}],[\"cpu分析图\",{\"1\":{\"246\":1}}],[\"cpu分析\",{\"1\":{\"243\":1}}],[\"cpu\",{\"1\":{\"242\":1,\"387\":1,\"388\":2,\"394\":1,\"395\":3}}],[\"cp镜像功能奇偶校验\",{\"1\":{\"51\":1}}],[\"c举例\",{\"1\":{\"232\":1}}],[\"cfg\",{\"1\":{\"404\":1}}],[\"cfflags和ldflags这两个都是gcc的编译选项\",{\"1\":{\"231\":1}}],[\"cflags\",{\"1\":{\"231\":2,\"232\":1}}],[\"cd\",{\"1\":{\"231\":1,\"364\":1}}],[\"c语言并没有像go这样的依赖管理\",{\"1\":{\"230\":1}}],[\"c语言的内存完全是由开发者手动管理\",{\"1\":{\"229\":1}}],[\"c和go的结构体字段的内存对齐规则并不相同\",{\"1\":{\"226\":1}}],[\"c结构体无法被当作匿名结构体嵌入go结构体\",{\"1\":{\"226\":1}}],[\"c中的数组就是一个指向头部元素的指针\",{\"1\":{\"225\":1}}],[\"c中的char对应go中的int8类型\",{\"1\":{\"221\":1}}],[\"c这个包也是不存在的\",{\"1\":{\"222\":1}}],[\"c文件\",{\"1\":{\"231\":1}}],[\"c文件中导入的\",{\"1\":{\"219\":1}}],[\"c文件为如下内容\",{\"1\":{\"219\":1}}],[\"c调用go\",{\"0\":{\"219\":1},\"1\":{\"219\":1}}],[\"c作为传统的系统编程语言性能是非常优秀的\",{\"1\":{\"215\":1}}],[\"c三个数的值分别计算好再赋给它们\",{\"1\":{\"127\":1}}],[\"c++的构建工具链\",{\"1\":{\"216\":1}}],[\"c++\",{\"0\":{\"87\":1},\"1\":{\"71\":1,\"87\":3,\"187\":2,\"607\":3}}],[\"cidr\",{\"0\":{\"568\":1}}],[\"cidranger\",{\"1\":{\"64\":1}}],[\"cilium\",{\"1\":{\"373\":1}}],[\"cipher\",{\"1\":{\"43\":1}}],[\"c库的cgo绑定\",{\"1\":{\"63\":1}}],[\"c库的go绑定\",{\"1\":{\"57\":1}}],[\"c库检测和转换功能\",{\"1\":{\"63\":1}}],[\"cn\",{\"1\":{\"63\":1,\"370\":2,\"427\":4,\"512\":1,\"642\":1}}],[\"cgo的优势会更大一些\",{\"1\":{\"233\":1}}],[\"cgo的平均耗时是纯go的二十几倍\",{\"1\":{\"233\":1}}],[\"cgo的效率并不如纯go\",{\"1\":{\"233\":1}}],[\"cgo禁用了一些参数\",{\"1\":{\"231\":1}}],[\"cgo也支持这些\",{\"1\":{\"230\":1}}],[\"cgo不支持c中的函数指针\",{\"1\":{\"229\":1}}],[\"cgo之间相互调用最大的问题就是两门语言的内存模型并不相同\",{\"1\":{\"229\":1}}],[\"cgo就会忽略这类结构体成员\",{\"1\":{\"226\":1}}],[\"cgo同时也对<stdint\",{\"1\":{\"223\":1}}],[\"cgo同样支持c调用go\",{\"1\":{\"215\":1}}],[\"cgo提供了一些伪函数用于在c和go之间传递字符串和字节切片\",{\"1\":{\"222\":1}}],[\"cgo给常用类型\",{\"1\":{\"220\":1}}],[\"cgo对c与go之间的类型做了一个映射\",{\"1\":{\"220\":1}}],[\"cgo对此做了兼容\",{\"1\":{\"217\":1}}],[\"cgo支持导出go函数让c调用\",{\"1\":{\"219\":1}}],[\"cgo支持直接把c代码写在go源文件中\",{\"1\":{\"217\":1}}],[\"cgo\",{\"0\":{\"215\":1},\"1\":{\"215\":3,\"216\":4,\"218\":2,\"219\":7,\"223\":3,\"224\":1,\"231\":2,\"232\":2,\"233\":4}}],[\"cgo包装器\",{\"1\":{\"63\":1}}],[\"cgo结合为icu4c\",{\"1\":{\"63\":1}}],[\"cgo与yandex\",{\"1\":{\"63\":1}}],[\"cgi\",{\"1\":{\"43\":1}}],[\"cyclicbarrier\",{\"1\":{\"56\":1}}],[\"c4go\",{\"1\":{\"55\":1}}],[\"ceil\",{\"1\":{\"554\":1}}],[\"certificatefingerprint\",{\"1\":{\"404\":1}}],[\"cel\",{\"1\":{\"49\":1}}],[\"celeriac\",{\"1\":{\"47\":1}}],[\"cedar\",{\"1\":{\"41\":1}}],[\"c\",{\"0\":{\"87\":1},\"1\":{\"46\":1,\"49\":2,\"58\":1,\"61\":1,\"69\":1,\"71\":1,\"80\":1,\"87\":3,\"112\":1,\"127\":13,\"130\":1,\"140\":3,\"148\":2,\"149\":1,\"178\":1,\"179\":3,\"180\":2,\"181\":6,\"182\":4,\"192\":3,\"199\":5,\"201\":3,\"212\":13,\"215\":1,\"216\":4,\"217\":10,\"218\":6,\"219\":17,\"220\":14,\"221\":7,\"222\":44,\"223\":37,\"224\":8,\"225\":10,\"226\":4,\"227\":5,\"228\":8,\"229\":7,\"231\":6,\"232\":6,\"233\":4,\"258\":2,\"263\":1,\"304\":3,\"315\":10,\"319\":1,\"333\":1,\"338\":1,\"340\":5,\"345\":5,\"346\":4,\"351\":3,\"388\":1,\"441\":1,\"460\":2,\"467\":1,\"472\":2,\"592\":2,\"602\":4,\"607\":2,\"609\":2,\"633\":1,\"634\":1}}],[\"cutset\",{\"1\":{\"610\":3}}],[\"cut\",{\"1\":{\"600\":7}}],[\"cum\",{\"1\":{\"245\":6}}],[\"cuckoo过滤器\",{\"1\":{\"46\":1}}],[\"cuckoofilter\",{\"1\":{\"46\":1}}],[\"cursor\",{\"1\":{\"425\":4}}],[\"current\",{\"1\":{\"373\":1}}],[\"currency\",{\"1\":{\"52\":1}}],[\"curl\",{\"1\":{\"247\":1}}],[\"curt\",{\"1\":{\"43\":1}}],[\"curve\",{\"1\":{\"43\":1}}],[\"cmp\",{\"1\":{\"128\":3,\"263\":1}}],[\"cmplx\",{\"1\":{\"43\":1,\"508\":1}}],[\"cmd了解命令的更多有关信息\",{\"1\":{\"375\":1}}],[\"cmdline\",{\"1\":{\"243\":3}}],[\"cmd\",{\"1\":{\"41\":1,\"215\":1,\"365\":1,\"366\":1,\"367\":2,\"368\":6,\"369\":2,\"373\":1,\"376\":1,\"383\":1}}],[\"cst\",{\"1\":{\"245\":2,\"629\":1,\"632\":1,\"633\":1,\"634\":3,\"635\":2}}],[\"cstring\",{\"1\":{\"216\":1,\"222\":6,\"226\":1}}],[\"css和nw\",{\"1\":{\"57\":1}}],[\"css\",{\"1\":{\"57\":2,\"628\":1}}],[\"css内衬为您的html电子邮件\",{\"1\":{\"48\":1}}],[\"csharp\",{\"1\":{\"55\":1}}],[\"csv\",{\"1\":{\"43\":2,\"51\":1}}],[\"csrf\",{\"1\":{\"41\":2}}],[\"credentials\",{\"1\":{\"382\":1}}],[\"creation\",{\"1\":{\"407\":2}}],[\"creationtime\",{\"1\":{\"319\":1}}],[\"creating\",{\"1\":{\"364\":1,\"372\":1}}],[\"creat\",{\"1\":{\"319\":1}}],[\"created\",{\"1\":{\"407\":2,\"411\":2}}],[\"createindices\",{\"1\":{\"406\":3}}],[\"create|o\",{\"1\":{\"321\":1}}],[\"create|os\",{\"1\":{\"321\":3,\"322\":2,\"329\":1}}],[\"create函数用于创建文件\",{\"1\":{\"321\":1}}],[\"create一起使用\",{\"1\":{\"319\":1}}],[\"create\",{\"1\":{\"242\":3,\"319\":2,\"320\":2,\"321\":1,\"325\":5,\"346\":1,\"368\":5,\"406\":1,\"411\":4,\"415\":4,\"434\":1}}],[\"craneb\",{\"1\":{\"212\":5}}],[\"cranea\",{\"1\":{\"212\":5}}],[\"crane\",{\"1\":{\"212\":6}}],[\"crash包无法访问baz包中的类型\",{\"1\":{\"95\":1}}],[\"crash\",{\"1\":{\"95\":1}}],[\"crunch\",{\"1\":{\"46\":1}}],[\"crc64\",{\"1\":{\"43\":1}}],[\"crc32\",{\"1\":{\"43\":1}}],[\"crl和ocsp的asn\",{\"1\":{\"43\":1}}],[\"cryptography\",{\"1\":{\"43\":1}}],[\"crypto\",{\"1\":{\"43\":2,\"372\":2,\"378\":3,\"508\":1}}],[\"cached\",{\"1\":{\"387\":1}}],[\"cache\",{\"1\":{\"376\":2,\"379\":2}}],[\"cache实现\",{\"1\":{\"41\":1}}],[\"cat\",{\"1\":{\"372\":2}}],[\"catch简洁一些\",{\"1\":{\"307\":1}}],[\"catch\",{\"1\":{\"307\":2}}],[\"cayley\",{\"1\":{\"253\":1}}],[\"caddy\",{\"1\":{\"251\":1}}],[\"callgrind\",{\"1\":{\"245\":2}}],[\"call\",{\"1\":{\"239\":1,\"284\":2,\"290\":1,\"297\":1,\"389\":1,\"620\":1}}],[\"calling\",{\"1\":{\"222\":2}}],[\"caller\",{\"1\":{\"222\":2}}],[\"called\",{\"1\":{\"208\":1}}],[\"capturing\",{\"1\":{\"237\":1}}],[\"cap\",{\"1\":{\"159\":1,\"163\":1,\"169\":7,\"294\":1,\"320\":2,\"336\":1,\"354\":1}}],[\"cas相关的函数则需要传入地址\",{\"1\":{\"359\":1}}],[\"cas会将期望值与当前内存值进行比较\",{\"1\":{\"359\":1}}],[\"cas\",{\"0\":{\"359\":1}}],[\"case2\",{\"1\":{\"149\":1}}],[\"case1\",{\"1\":{\"149\":1}}],[\"case\",{\"1\":{\"97\":1,\"132\":4,\"149\":13,\"228\":2,\"256\":2,\"258\":2,\"306\":3,\"340\":18,\"345\":2,\"346\":4,\"347\":1,\"389\":3,\"633\":1,\"634\":1}}],[\"cast\",{\"1\":{\"41\":1}}],[\"cancellation\",{\"1\":{\"389\":1}}],[\"cancelmail\",{\"1\":{\"346\":2}}],[\"cancelauth\",{\"1\":{\"346\":2}}],[\"canceled\",{\"1\":{\"346\":5}}],[\"canceler\",{\"1\":{\"346\":1}}],[\"cancelfunc\",{\"1\":{\"346\":3,\"347\":3}}],[\"cancel方法不对外暴露\",{\"1\":{\"346\":1}}],[\"cancel\",{\"1\":{\"346\":5,\"347\":2,\"389\":2}}],[\"cancelctxmail\",{\"1\":{\"346\":2}}],[\"cancelctxauth\",{\"1\":{\"346\":2}}],[\"cancelctx译为可取消的上下文\",{\"1\":{\"346\":1}}],[\"cancelctx以及timerctx都实现了canceler接口\",{\"1\":{\"346\":1}}],[\"cancelctx\",{\"0\":{\"346\":1},\"1\":{\"342\":1,\"346\":2}}],[\"can\",{\"1\":{\"208\":2,\"212\":2}}],[\"cannot\",{\"1\":{\"172\":1,\"206\":1,\"221\":1,\"300\":1,\"319\":1,\"338\":1,\"346\":1}}],[\"canopus\",{\"1\":{\"64\":1}}],[\"canvas\",{\"1\":{\"58\":1}}],[\"cairo\",{\"1\":{\"58\":1}}],[\"cameron\",{\"1\":{\"58\":1}}],[\"ccc\",{\"1\":{\"578\":1}}],[\"cccc\",{\"1\":{\"149\":1}}],[\"cc\",{\"1\":{\"41\":1}}],[\"cleanuphelper\",{\"1\":{\"391\":3,\"392\":3,\"393\":2}}],[\"cleanup的例子就可以修改为帮助函数\",{\"1\":{\"391\":1}}],[\"cleanup\",{\"1\":{\"390\":2,\"391\":2,\"392\":2,\"393\":2}}],[\"cleanup来注册一个收尾函数专门做此事\",{\"1\":{\"390\":1}}],[\"clean\",{\"1\":{\"375\":1,\"376\":1}}],[\"clearcache\",{\"1\":{\"405\":1}}],[\"clear会将切片内所有的值置为零值\",{\"1\":{\"170\":1}}],[\"clear\",{\"0\":{\"170\":1},\"1\":{\"170\":1,\"183\":1}}],[\"cloud\",{\"1\":{\"379\":1}}],[\"cloudforest\",{\"1\":{\"61\":1}}],[\"cloning\",{\"1\":{\"364\":1}}],[\"clone函数\",{\"1\":{\"175\":1}}],[\"clone\",{\"1\":{\"160\":1,\"175\":1,\"364\":1,\"405\":1,\"596\":2}}],[\"close函数的形参是一个只写通道\",{\"1\":{\"338\":1}}],[\"closed\",{\"1\":{\"309\":1}}],[\"close\",{\"1\":{\"239\":1,\"307\":1,\"319\":2,\"320\":2,\"321\":2,\"322\":4,\"325\":1,\"327\":1,\"329\":2,\"333\":2,\"334\":1,\"335\":2,\"336\":5,\"337\":7,\"338\":1,\"339\":2,\"340\":13,\"405\":1,\"435\":1,\"446\":1,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"574\":2}}],[\"closure\",{\"1\":{\"201\":1}}],[\"class\",{\"1\":{\"124\":1}}],[\"clrs研究\",{\"1\":{\"46\":1}}],[\"cli\",{\"1\":{\"41\":2,\"254\":1}}],[\"clientcodec和servercodec\",{\"1\":{\"43\":1}}],[\"clientv3\",{\"1\":{\"41\":1}}],[\"client\",{\"1\":{\"41\":1,\"373\":1,\"404\":7,\"406\":2,\"407\":2,\"408\":2,\"409\":2,\"411\":2,\"412\":2,\"413\":2,\"414\":2,\"415\":6,\"421\":4,\"424\":1,\"425\":2,\"426\":2,\"427\":4,\"428\":2,\"429\":1,\"441\":2,\"532\":1,\"533\":3,\"534\":3}}],[\"cluster\",{\"1\":{\"41\":1,\"61\":1,\"404\":3}}],[\"copied\",{\"1\":{\"611\":2}}],[\"copycheck\",{\"1\":{\"611\":1}}],[\"copys\",{\"1\":{\"596\":3}}],[\"copydir\",{\"1\":{\"329\":1}}],[\"copybuffer来指定缓冲区大小\",{\"1\":{\"322\":1}}],[\"copy函数\",{\"1\":{\"322\":1}}],[\"copy\",{\"1\":{\"51\":1,\"166\":1,\"175\":1,\"307\":1,\"322\":3,\"329\":1}}],[\"cos\",{\"0\":{\"563\":1},\"1\":{\"563\":2}}],[\"cosiner\",{\"1\":{\"373\":1}}],[\"cookie相关配置\",{\"1\":{\"532\":1}}],[\"cookie\",{\"1\":{\"457\":2}}],[\"coverage\",{\"1\":{\"396\":6}}],[\"coverprofile\",{\"1\":{\"388\":1}}],[\"covermode\",{\"1\":{\"388\":1}}],[\"cover\",{\"1\":{\"388\":2}}],[\"co\",{\"1\":{\"379\":1}}],[\"corpus\",{\"1\":{\"396\":1}}],[\"coroutine\",{\"1\":{\"331\":1}}],[\"core\",{\"1\":{\"373\":2,\"394\":1,\"395\":3}}],[\"core设备的简单框架\",{\"1\":{\"59\":1}}],[\"coreos\",{\"1\":{\"41\":1}}],[\"cockroach\",{\"1\":{\"253\":1}}],[\"cout\",{\"1\":{\"195\":1}}],[\"count=5\",{\"1\":{\"395\":2}}],[\"count=2\",{\"1\":{\"390\":1,\"394\":1}}],[\"count=1\",{\"1\":{\"387\":1}}],[\"counting\",{\"1\":{\"364\":1,\"368\":1}}],[\"count\",{\"1\":{\"46\":1,\"130\":1,\"336\":5,\"348\":3,\"349\":3,\"350\":4,\"351\":4,\"359\":5,\"388\":2,\"482\":1,\"599\":4,\"606\":1}}],[\"coap客户端\",{\"1\":{\"64\":1}}],[\"collate\",{\"1\":{\"434\":4}}],[\"collada\",{\"1\":{\"53\":1}}],[\"collection\",{\"1\":{\"247\":1,\"424\":1,\"425\":2,\"426\":2,\"427\":4,\"428\":2,\"429\":1}}],[\"color\",{\"1\":{\"43\":1,\"186\":1}}],[\"codec\",{\"1\":{\"372\":2,\"378\":1}}],[\"coder\",{\"1\":{\"187\":2}}],[\"code\",{\"1\":{\"43\":1,\"95\":5,\"245\":1,\"312\":2,\"367\":1,\"372\":1,\"384\":1,\"528\":5}}],[\"cobra\",{\"1\":{\"41\":2,\"254\":2}}],[\"conncontext\",{\"1\":{\"536\":1}}],[\"connstate\",{\"1\":{\"536\":1}}],[\"conn\",{\"1\":{\"435\":2,\"444\":2,\"574\":5}}],[\"connect\",{\"1\":{\"373\":2,\"421\":1}}],[\"connectordb\",{\"1\":{\"59\":1}}],[\"config\",{\"1\":{\"404\":2,\"444\":1,\"513\":1,\"514\":3,\"515\":5}}],[\"confidence\",{\"1\":{\"395\":3}}],[\"condition\",{\"1\":{\"351\":1}}],[\"cond提供了如下的方法以供使用\",{\"1\":{\"351\":1}}],[\"cond\",{\"1\":{\"351\":8}}],[\"cond对此提供了实现\",{\"1\":{\"351\":1}}],[\"concatbuilder\",{\"1\":{\"395\":9}}],[\"concatdirect\",{\"1\":{\"395\":10}}],[\"concatstringwithbuilder\",{\"1\":{\"394\":2}}],[\"concatstringdirect\",{\"1\":{\"394\":2}}],[\"concrete\",{\"1\":{\"266\":1}}],[\"concurrent\",{\"1\":{\"41\":1,\"46\":1,\"185\":1,\"355\":1,\"372\":2,\"378\":1}}],[\"convertibleto\",{\"0\":{\"275\":1},\"1\":{\"275\":3}}],[\"convert\",{\"1\":{\"221\":1}}],[\"conventions\",{\"1\":{\"51\":1}}],[\"constant\",{\"1\":{\"221\":1,\"239\":1,\"300\":1}}],[\"constructioncompany\",{\"1\":{\"212\":3}}],[\"const\",{\"1\":{\"93\":2,\"97\":1,\"130\":8,\"131\":5,\"132\":2,\"153\":1,\"158\":1,\"270\":1,\"319\":2,\"541\":1,\"543\":1,\"544\":1,\"545\":1,\"630\":2}}],[\"consistent\",{\"1\":{\"47\":1}}],[\"consul\",{\"0\":{\"18\":1}}],[\"conjungo\",{\"1\":{\"46\":1}}],[\"content\",{\"1\":{\"407\":1,\"530\":2,\"623\":4,\"627\":1}}],[\"context包下提供了两种创建的函数\",{\"1\":{\"347\":1}}],[\"context包下所有的实现都是不对外暴露的\",{\"1\":{\"344\":1}}],[\"context包中的各个实现关系如下图所示\",{\"1\":{\"344\":1}}],[\"context标准库也提供了几个实现\",{\"1\":{\"342\":1}}],[\"context本身是一个接口\",{\"1\":{\"342\":1}}],[\"context译为上下文\",{\"1\":{\"342\":1}}],[\"context更适合子孙协程嵌套层级更深的情况\",{\"1\":{\"331\":1}}],[\"context\",{\"0\":{\"342\":1,\"343\":1},\"1\":{\"41\":2,\"331\":1,\"342\":1,\"343\":1,\"344\":2,\"345\":6,\"346\":21,\"347\":11,\"389\":5,\"421\":2,\"508\":1}}],[\"cont\",{\"1\":{\"392\":4}}],[\"containsrune\",{\"1\":{\"598\":4}}],[\"containsany\",{\"1\":{\"598\":3}}],[\"contains\",{\"1\":{\"378\":1,\"405\":1,\"598\":4}}],[\"containers\",{\"1\":{\"264\":1}}],[\"container\",{\"1\":{\"43\":1,\"508\":3}}],[\"contrib\",{\"1\":{\"372\":2,\"378\":1}}],[\"continue这类操作\",{\"1\":{\"624\":1}}],[\"continue关键字会跳过最内层循环的本次迭代\",{\"1\":{\"155\":1}}],[\"continue的目标\",{\"1\":{\"150\":1}}],[\"continue\",{\"0\":{\"155\":1},\"1\":{\"97\":1,\"155\":2,\"624\":2}}],[\"comment\",{\"1\":{\"618\":2}}],[\"comments\",{\"1\":{\"245\":2}}],[\"commitid一般取前12位\",{\"1\":{\"378\":1}}],[\"commitid\",{\"1\":{\"378\":1}}],[\"commit\",{\"1\":{\"368\":7,\"439\":2}}],[\"communicating\",{\"1\":{\"332\":1,\"373\":1}}],[\"communicate\",{\"1\":{\"332\":1}}],[\"commands\",{\"1\":{\"245\":2,\"373\":1}}],[\"command了解细节\",{\"1\":{\"231\":1}}],[\"command\",{\"1\":{\"215\":1,\"217\":1,\"219\":1,\"245\":1,\"373\":4,\"387\":1,\"390\":3,\"391\":1}}],[\"computer\",{\"0\":{\"658\":1}}],[\"completion\",{\"1\":{\"373\":1}}],[\"completed\",{\"1\":{\"396\":6}}],[\"complete\",{\"1\":{\"368\":9}}],[\"complexs\",{\"1\":{\"640\":2}}],[\"complex\",{\"1\":{\"213\":1,\"272\":1,\"592\":3}}],[\"complex64\",{\"1\":{\"118\":1,\"270\":3}}],[\"complex128\",{\"1\":{\"118\":1,\"270\":3,\"591\":1,\"592\":1,\"640\":1}}],[\"compile\",{\"1\":{\"236\":1,\"373\":3}}],[\"compilation\",{\"1\":{\"219\":1}}],[\"compatibility\",{\"1\":{\"404\":2}}],[\"comparator\",{\"1\":{\"263\":3}}],[\"comparable接口无法并入类型集\",{\"1\":{\"260\":1}}],[\"comparable\",{\"0\":{\"273\":1},\"1\":{\"213\":2,\"257\":1,\"260\":4,\"273\":5}}],[\"compareandswapint64\",{\"1\":{\"359\":2}}],[\"compare\",{\"1\":{\"128\":1,\"263\":4,\"597\":5}}],[\"company\",{\"1\":{\"212\":4,\"257\":4,\"627\":1,\"628\":4}}],[\"compression\",{\"1\":{\"368\":1}}],[\"compressing\",{\"1\":{\"364\":1,\"368\":1}}],[\"compress\",{\"1\":{\"43\":1,\"508\":1}}],[\"com\",{\"1\":{\"41\":68,\"42\":4,\"50\":1,\"244\":1,\"264\":2,\"312\":2,\"362\":1,\"364\":5,\"365\":2,\"366\":1,\"367\":3,\"368\":1,\"369\":5,\"372\":42,\"373\":12,\"376\":2,\"378\":34,\"379\":8,\"381\":2,\"382\":3,\"384\":1,\"403\":2,\"419\":2,\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1,\"432\":2,\"441\":1,\"442\":3,\"443\":1,\"513\":1,\"521\":2,\"530\":1,\"573\":2}}],[\"china\",{\"1\":{\"426\":1}}],[\"checkredirect\",{\"1\":{\"532\":1}}],[\"checks\",{\"1\":{\"434\":2}}],[\"checksum\",{\"1\":{\"51\":1,\"307\":2}}],[\"check\",{\"1\":{\"372\":1}}],[\"chenzhuoyu\",{\"1\":{\"372\":2,\"378\":3}}],[\"chore\",{\"1\":{\"368\":3}}],[\"chc\",{\"1\":{\"340\":14}}],[\"chb\",{\"1\":{\"340\":14}}],[\"chr\",{\"1\":{\"336\":4}}],[\"chw\",{\"1\":{\"336\":4}}],[\"ch\",{\"1\":{\"221\":3,\"227\":1,\"332\":1,\"334\":2,\"335\":8,\"336\":18,\"337\":7,\"338\":5,\"339\":11,\"340\":4,\"580\":1,\"581\":1}}],[\"cha\",{\"1\":{\"340\":19}}],[\"chars\",{\"1\":{\"598\":1,\"604\":2}}],[\"charset=utf\",{\"1\":{\"531\":1}}],[\"character\",{\"1\":{\"434\":4}}],[\"characters\",{\"1\":{\"177\":1}}],[\"char类型\",{\"1\":{\"222\":1}}],[\"char对应go中的uint8也就是byte类型\",{\"1\":{\"221\":1}}],[\"char了\",{\"1\":{\"220\":1}}],[\"charlie\",{\"1\":{\"200\":1}}],[\"char\",{\"0\":{\"221\":1},\"1\":{\"124\":1,\"219\":2,\"220\":4,\"221\":7,\"222\":11,\"223\":4,\"226\":2,\"227\":1,\"647\":2}}],[\"chan是引用类型\",{\"1\":{\"338\":1}}],[\"chan<\",{\"1\":{\"333\":1,\"337\":1,\"338\":2,\"340\":2}}],[\"chan\",{\"1\":{\"97\":1,\"120\":1,\"196\":1,\"270\":3,\"279\":2,\"296\":1,\"304\":4,\"332\":1,\"333\":3,\"334\":1,\"335\":2,\"336\":7,\"337\":8,\"338\":4,\"339\":3,\"340\":15,\"343\":2,\"344\":1,\"346\":1}}],[\"channel就会收到消息并关闭\",{\"1\":{\"633\":1}}],[\"channel就是为此而生\",{\"1\":{\"332\":1}}],[\"channel\",{\"1\":{\"70\":1,\"83\":1,\"331\":1,\"332\":1,\"338\":1,\"486\":3}}],[\"channels\",{\"1\":{\"70\":1}}],[\"changed\",{\"1\":{\"368\":6}}],[\"change\",{\"1\":{\"11\":1}}],[\"chasquid\",{\"1\":{\"48\":1}}],[\"chsrc\",{\"0\":{\"11\":1},\"1\":{\"11\":5}}],[\"gfdecba\",{\"1\":{\"598\":1}}],[\"g的情况是表示最大有效位数\",{\"1\":{\"590\":1}}],[\"gmap2\",{\"1\":{\"257\":1}}],[\"gmap1\",{\"1\":{\"257\":1}}],[\"gmqtt是一个灵活的高性能mqtt代理库\",{\"1\":{\"64\":1}}],[\"gmqtt\",{\"1\":{\"64\":1}}],[\"gws\",{\"1\":{\"251\":1}}],[\"gc移动变量后\",{\"1\":{\"643\":1}}],[\"gc会去更新指针引用的旧地址\",{\"1\":{\"643\":1}}],[\"gc++lang\",{\"1\":{\"607\":1}}],[\"gclang\",{\"1\":{\"607\":1}}],[\"gcflags即编译器gc的参数\",{\"1\":{\"236\":1}}],[\"gcflags=\",{\"1\":{\"236\":2,\"237\":1,\"238\":1,\"239\":2}}],[\"gcc\",{\"1\":{\"223\":1,\"231\":2,\"232\":1}}],[\"gcache\",{\"1\":{\"41\":1}}],[\"g\",{\"1\":{\"140\":2,\"258\":1,\"319\":1,\"467\":1,\"590\":4,\"592\":1,\"602\":4,\"604\":1}}],[\"gui\",{\"1\":{\"84\":2}}],[\"gnxi\",{\"1\":{\"64\":1}}],[\"gnet是一个高性能的\",{\"1\":{\"64\":1}}],[\"gnet\",{\"1\":{\"64\":1}}],[\"gjson\",{\"1\":{\"60\":1}}],[\"gjo\",{\"1\":{\"60\":1}}],[\"gd库的go绑定\",{\"1\":{\"58\":1}}],[\"gd\",{\"1\":{\"58\":1}}],[\"gg\",{\"1\":{\"58\":1,\"467\":1}}],[\"gt\",{\"1\":{\"612\":3,\"620\":2}}],[\"gtk3的绑定\",{\"1\":{\"57\":1}}],[\"gtk的绑定\",{\"1\":{\"57\":1}}],[\"gtk\",{\"1\":{\"57\":1}}],[\"gtfs\",{\"1\":{\"51\":1}}],[\"gpool\",{\"1\":{\"56\":1}}],[\"gpy\",{\"1\":{\"41\":1}}],[\"gathering\",{\"1\":{\"396\":6}}],[\"gatt\",{\"1\":{\"59\":1}}],[\"garbage\",{\"1\":{\"247\":1}}],[\"garageengine\",{\"1\":{\"53\":1}}],[\"galib\",{\"1\":{\"61\":1}}],[\"gaad\",{\"1\":{\"45\":1}}],[\"g3n\",{\"1\":{\"53\":1}}],[\"gstreamer的绑定\",{\"1\":{\"65\":1}}],[\"gst\",{\"1\":{\"65\":1}}],[\"gs\",{\"1\":{\"51\":1}}],[\"gse\",{\"1\":{\"41\":1,\"63\":1}}],[\"gval\",{\"1\":{\"49\":1}}],[\"ge\",{\"1\":{\"620\":2}}],[\"gerrand\",{\"1\":{\"307\":1}}],[\"gender\",{\"1\":{\"521\":6}}],[\"gen\",{\"1\":{\"394\":1,\"395\":3}}],[\"genericity\",{\"1\":{\"264\":1}}],[\"generictype\",{\"1\":{\"258\":2}}],[\"genericstruct\",{\"1\":{\"257\":3,\"258\":2}}],[\"genericslice\",{\"1\":{\"257\":2}}],[\"genericmap\",{\"1\":{\"257\":3}}],[\"generate\",{\"1\":{\"373\":1}}],[\"generating\",{\"1\":{\"245\":1}}],[\"general\",{\"1\":{\"208\":1}}],[\"gentee\",{\"1\":{\"49\":1}}],[\"get示例\",{\"0\":{\"530\":1}}],[\"gets\",{\"1\":{\"389\":1}}],[\"get命令首先会将依赖包下载到本地的缓存目录中\",{\"1\":{\"379\":1}}],[\"get命令来删除该依赖\",{\"1\":{\"372\":1}}],[\"get命令\",{\"1\":{\"372\":1}}],[\"get引用库\",{\"1\":{\"369\":1}}],[\"getperson函数中创建了mom变量\",{\"1\":{\"236\":1}}],[\"getperson\",{\"1\":{\"236\":2}}],[\"get\",{\"1\":{\"204\":2,\"221\":2,\"288\":2,\"353\":2,\"354\":3,\"367\":1,\"369\":1,\"372\":4,\"378\":3,\"379\":1,\"407\":5,\"412\":4,\"420\":1,\"432\":2,\"435\":1,\"442\":2,\"443\":1,\"449\":2,\"450\":1,\"456\":1,\"458\":2,\"513\":1,\"521\":1,\"530\":1,\"533\":1,\"534\":1}}],[\"getter\",{\"1\":{\"64\":1,\"89\":1}}],[\"getlang\",{\"1\":{\"63\":1}}],[\"gev是基于reactor模式的轻量级\",{\"1\":{\"64\":1}}],[\"gev\",{\"1\":{\"64\":1,\"251\":1}}],[\"geomean\",{\"1\":{\"395\":3}}],[\"geometry\",{\"1\":{\"54\":1}}],[\"geopattern\",{\"1\":{\"58\":1}}],[\"geoserver是go软件包\",{\"1\":{\"54\":1}}],[\"geoserver\",{\"1\":{\"54\":1}}],[\"geocache\",{\"1\":{\"54\":1}}],[\"geoindex\",{\"1\":{\"46\":1}}],[\"gltf\",{\"1\":{\"58\":1}}],[\"glop\",{\"1\":{\"53\":2}}],[\"glow\",{\"1\":{\"47\":1}}],[\"gleam\",{\"1\":{\"47\":1}}],[\"gls\",{\"1\":{\"41\":1}}],[\"gzip\",{\"1\":{\"43\":1}}],[\"girl\",{\"1\":{\"599\":2}}],[\"git\",{\"1\":{\"362\":1,\"364\":3,\"368\":12}}],[\"github\",{\"1\":{\"41\":66,\"42\":4,\"244\":1,\"264\":1,\"312\":2,\"362\":1,\"364\":4,\"365\":2,\"366\":1,\"367\":3,\"368\":1,\"369\":5,\"372\":42,\"373\":12,\"376\":2,\"378\":26,\"379\":5,\"381\":2,\"382\":3,\"384\":1,\"403\":2,\"419\":2,\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1,\"432\":2,\"441\":1,\"442\":2,\"443\":1,\"513\":1,\"521\":2,\"573\":2}}],[\"github地址\",{\"1\":{\"10\":1}}],[\"gim\",{\"1\":{\"250\":1}}],[\"gis数据\",{\"1\":{\"54\":1}}],[\"gismanager\",{\"1\":{\"54\":1}}],[\"gisp\",{\"1\":{\"49\":1}}],[\"gif等等\",{\"1\":{\"245\":1}}],[\"gift\",{\"1\":{\"58\":1}}],[\"gif\",{\"1\":{\"43\":1}}],[\"gin的原理\",{\"0\":{\"502\":1}}],[\"gin的模块名就是下载依赖时使用的地址\",{\"1\":{\"378\":1}}],[\"gin使用\",{\"0\":{\"500\":1}}],[\"gin两个引用的是同一个依赖但是本地存放的路径不同\",{\"1\":{\"378\":1}}],[\"gin和go\",{\"1\":{\"378\":1}}],[\"gin\",{\"1\":{\"42\":3,\"77\":1,\"249\":3,\"372\":31,\"378\":9}}],[\"greater\",{\"1\":{\"263\":1}}],[\"grep\",{\"1\":{\"216\":1,\"372\":1}}],[\"grow函数就是一个闭包函数\",{\"1\":{\"201\":1}}],[\"grow函数引用了exp函数的两个变量\",{\"1\":{\"201\":1}}],[\"grow\",{\"1\":{\"201\":2}}],[\"group\",{\"1\":{\"185\":3}}],[\"grokify\",{\"1\":{\"41\":1}}],[\"graph了解更多\",{\"1\":{\"246\":1}}],[\"graph\",{\"1\":{\"245\":4,\"246\":2,\"375\":1}}],[\"graval\",{\"1\":{\"64\":1}}],[\"grab\",{\"1\":{\"64\":1}}],[\"gram的文本分类\",{\"1\":{\"63\":1}}],[\"grpool\",{\"1\":{\"41\":1,\"56\":1}}],[\"grpc的go语言实现\",{\"1\":{\"47\":1}}],[\"grpc电子商务微服务\",{\"1\":{\"47\":1}}],[\"grpc\",{\"0\":{\"22\":1},\"1\":{\"47\":1,\"64\":1,\"188\":1}}],[\"go通过两对花括号\",{\"1\":{\"617\":1}}],[\"go天然支持utf8字符\",{\"1\":{\"594\":1}}],[\"go还提供了很多函数用于dns查询\",{\"1\":{\"573\":1}}],[\"go提供了四个函数来解析网络地址\",{\"1\":{\"566\":1}}],[\"go比较好用的解析xml文件的插件etree\",{\"1\":{\"512\":1}}],[\"go同样的也支持这些数据格式的相关的操作\",{\"1\":{\"509\":1}}],[\"go源代码抽象语法树映射的包\",{\"1\":{\"508\":1}}],[\"go源代码里if\",{\"1\":{\"307\":1}}],[\"goarh代表的是cpu架构\",{\"1\":{\"394\":1}}],[\"goarch\",{\"1\":{\"394\":1,\"395\":3}}],[\"goav\",{\"1\":{\"65\":1}}],[\"go就会缓存测试结果\",{\"1\":{\"387\":1}}],[\"go就会使用本地的hello模块\",{\"1\":{\"381\":1}}],[\"go代码如下\",{\"1\":{\"387\":2}}],[\"go结尾\",{\"1\":{\"386\":1,\"394\":1}}],[\"go结构体字段的内存分布遵循内存对齐的规则\",{\"1\":{\"192\":1}}],[\"goinsecure\",{\"1\":{\"380\":1}}],[\"goimghdr\",{\"1\":{\"58\":1}}],[\"goimagehash\",{\"1\":{\"58\":1}}],[\"go从头到尾都做了些什么事\",{\"1\":{\"379\":1}}],[\"go并不会再次执行已经成功通过的测试用例\",{\"1\":{\"387\":1}}],[\"go并不会直接把大写字母当作存放路径\",{\"1\":{\"378\":1}}],[\"go并非是一个传统oop的语言\",{\"1\":{\"185\":1}}],[\"go最终会选择的版本是a1\",{\"1\":{\"377\":1}}],[\"go官方并没有提供对于yml的支持\",{\"1\":{\"513\":1}}],[\"go官方有专门的依赖查询网站\",{\"1\":{\"371\":1}}],[\"go官方提供了一个格式化工具gofmt\",{\"1\":{\"107\":1}}],[\"go虽然没有像maven\",{\"1\":{\"370\":1}}],[\"go发行版本已经到了1\",{\"1\":{\"361\":1}}],[\"go标准库sync\",{\"1\":{\"357\":1}}],[\"goos代表是运行的操作系统\",{\"1\":{\"394\":1}}],[\"goos\",{\"1\":{\"394\":1,\"395\":3}}],[\"good\",{\"1\":{\"389\":1,\"396\":4}}],[\"goodbye\",{\"1\":{\"355\":2,\"387\":3,\"389\":3}}],[\"googlesource\",{\"1\":{\"264\":1}}],[\"google\",{\"1\":{\"67\":1,\"244\":1,\"372\":2,\"373\":1,\"378\":1,\"379\":2,\"627\":1,\"628\":2}}],[\"google的\",{\"1\":{\"47\":1}}],[\"go所提供的锁都是非递归锁\",{\"1\":{\"348\":1}}],[\"go使用了两种很形象的操作符来表示读写操作\",{\"1\":{\"334\":1}}],[\"go对于管道的作用如下解释\",{\"1\":{\"332\":1}}],[\"go关键字表示了当前编写当前项目所用到的go版本\",{\"1\":{\"378\":1}}],[\"go关键字后面必须是一个函数调用\",{\"1\":{\"331\":1}}],[\"go关于接口的发展历史有一个分水岭\",{\"1\":{\"208\":1}}],[\"goexit\",{\"1\":{\"312\":1}}],[\"go111module=on\",{\"1\":{\"363\":1}}],[\"go111module\",{\"1\":{\"363\":1}}],[\"go1\",{\"1\":{\"312\":2}}],[\"go创始人希望能够将错误可控\",{\"1\":{\"307\":1}}],[\"go为什么要把类型声明放在后面而不是前面\",{\"1\":{\"301\":1}}],[\"go是一个静态强类型语言\",{\"1\":{\"300\":1}}],[\"go是一个典型的静态类型语言\",{\"1\":{\"299\":1}}],[\"go内部使用reflect\",{\"1\":{\"270\":1}}],[\"go团队既想加入泛型又不想太拖累编译速度\",{\"1\":{\"264\":1}}],[\"go团队认为大多数情况下map的使用并不涉及高并发的场景\",{\"1\":{\"185\":1}}],[\"govm\",{\"1\":{\"254\":1}}],[\"govatar\",{\"1\":{\"58\":1}}],[\"go非常适合用于命令行cli工具开发\",{\"1\":{\"254\":1}}],[\"gozero\",{\"1\":{\"249\":1}}],[\"go默认集成该工具\",{\"1\":{\"244\":1}}],[\"go默认使用tab也就是制表符进行缩进\",{\"1\":{\"109\":1}}],[\"go里面了解到更多内容\",{\"1\":{\"236\":1}}],[\"go与c的浮点数类型映射如下\",{\"1\":{\"224\":1}}],[\"go与c之间的整数映射关系如下表所示\",{\"1\":{\"223\":1}}],[\"go看到一些相关信息\",{\"1\":{\"223\":1}}],[\"go调用c是为了利用c的生态和性能\",{\"1\":{\"219\":1}}],[\"go引入c文件\",{\"0\":{\"218\":1}}],[\"go嵌入c代码\",{\"0\":{\"217\":1}}],[\"go负责处理上层逻辑\",{\"1\":{\"215\":1}}],[\"go可能不太适合处理\",{\"1\":{\"215\":1}}],[\"go在处理网络io的时候非常的简洁高效\",{\"1\":{\"565\":1}}],[\"go在测试这一方面提供了非常简便实用的命令行工具go\",{\"1\":{\"385\":1}}],[\"go在依赖版本选择时\",{\"1\":{\"377\":1}}],[\"go在许多层面的设计都是为了可读性而服务的\",{\"1\":{\"301\":1}}],[\"go在运行时将接口分为了两大类\",{\"1\":{\"266\":1}}],[\"go在网络编程这块也有非常多的应用\",{\"1\":{\"251\":1}}],[\"go在1\",{\"1\":{\"208\":1}}],[\"go在进行多个变量赋值运算时\",{\"1\":{\"127\":1}}],[\"go会将test目录下的所有测试文件重新编译后\",{\"1\":{\"387\":1}}],[\"go会将其解释为\",{\"1\":{\"206\":1}}],[\"go会将其解引用\",{\"1\":{\"205\":1}}],[\"go会忽略名为testdata的包\",{\"1\":{\"386\":1}}],[\"go会根据go\",{\"1\":{\"379\":1}}],[\"go会直接将本地计算得到的哈希值写入go\",{\"1\":{\"379\":1}}],[\"go会计算压缩包和go\",{\"1\":{\"379\":1}}],[\"go会自动的插入指针运算符来进行调用\",{\"1\":{\"206\":1}}],[\"go不会等到最后才去调用sum函数\",{\"1\":{\"204\":1}}],[\"go不存在构造方法\",{\"1\":{\"187\":1}}],[\"go允许函数有多个返回值\",{\"1\":{\"199\":1}}],[\"go保留了指针\",{\"1\":{\"193\":1}}],[\"go抛弃了类与继承\",{\"1\":{\"185\":1}}],[\"go抛弃了while语句\",{\"1\":{\"151\":1}}],[\"go了解\",{\"1\":{\"177\":1}}],[\"go字符串是明确支持utf8的\",{\"1\":{\"177\":1}}],[\"go有两个内置的函数print\",{\"1\":{\"137\":1}}],[\"go也对此提供了支持\",{\"1\":{\"331\":1}}],[\"go也不是第一个支持协程的语言\",{\"1\":{\"331\":1}}],[\"go也不支持直接将其转换为字符串\",{\"1\":{\"132\":1}}],[\"go也支持具名返回值\",{\"1\":{\"199\":1}}],[\"go也支持增强赋值运算符\",{\"1\":{\"98\":1}}],[\"go才终于将这两个内置函数用泛型重写\",{\"1\":{\"128\":1}}],[\"go语言内存对齐详解\",{\"1\":{\"642\":1}}],[\"go语言内置的flag包实现了命令行参数的解析\",{\"1\":{\"522\":1}}],[\"go语言的net标准库是一个非常强大的库\",{\"1\":{\"565\":1}}],[\"go语言的标准库非常的丰富\",{\"1\":{\"508\":1}}],[\"go语言标准库log包实现了简单的日志\",{\"1\":{\"539\":1}}],[\"go语言标准库中的net\",{\"1\":{\"529\":1}}],[\"go语言格式化包\",{\"1\":{\"508\":1}}],[\"go语言对于并发的支持是纯天然的\",{\"1\":{\"330\":1}}],[\"go语言提供文件处理的标准库大致以下几个\",{\"1\":{\"318\":1}}],[\"go语言并没有异常\",{\"1\":{\"307\":1}}],[\"go语言没有为枚举单独设计一个数据类型\",{\"1\":{\"132\":1}}],[\"go语言中不存在隐式类型转换\",{\"1\":{\"128\":1}}],[\"go语言中没有自增与自减运算符\",{\"1\":{\"98\":1}}],[\"go语言中没有选择将~作为取反运算符\",{\"1\":{\"98\":1}}],[\"go语言字符串完全兼容utf\",{\"1\":{\"119\":1}}],[\"go支持单行注释和多行注释\",{\"1\":{\"96\":1}}],[\"go文件分别创建两个函数进行两种方式的字符串拼接\",{\"1\":{\"394\":1}}],[\"go文件如下代码\",{\"1\":{\"372\":1}}],[\"go文件的代码\",{\"1\":{\"309\":1}}],[\"go文件内容\",{\"1\":{\"232\":1}}],[\"go文件\",{\"1\":{\"92\":1,\"390\":1,\"394\":1}}],[\"go简介\",{\"0\":{\"67\":1}}],[\"go客户端提供了一个mqtt客户端库\",{\"1\":{\"64\":1}}],[\"go软件包\",{\"1\":{\"63\":1}}],[\"gounidecode\",{\"1\":{\"63\":1}}],[\"go2vec\",{\"1\":{\"63\":1}}],[\"goxlsxwriter\",{\"1\":{\"62\":1}}],[\"gomodcache\",{\"1\":{\"376\":2}}],[\"gomodcache=你的模块缓存路径\",{\"1\":{\"376\":1}}],[\"goml\",{\"1\":{\"61\":1}}],[\"gomind\",{\"1\":{\"61\":1}}],[\"goga\",{\"1\":{\"61\":1}}],[\"gojieba\",{\"1\":{\"63\":1}}],[\"gojson\",{\"1\":{\"60\":1}}],[\"gojq\",{\"1\":{\"60\":1}}],[\"go感知图像哈希包\",{\"1\":{\"58\":1}}],[\"go本机跨平台gui系统自动化\",{\"1\":{\"57\":1}}],[\"got\",{\"1\":{\"365\":1}}],[\"goto将控制权传递给在同一函数中对应标签的语句\",{\"1\":{\"151\":1}}],[\"goto\",{\"0\":{\"151\":1},\"1\":{\"97\":1,\"151\":1}}],[\"gotokenizer\",{\"1\":{\"63\":1}}],[\"gotcp\",{\"1\":{\"64\":1}}],[\"gotk3\",{\"1\":{\"57\":1}}],[\"gota\",{\"1\":{\"46\":1}}],[\"gowd\",{\"1\":{\"57\":1}}],[\"gowp是并发限制goroutine池\",{\"1\":{\"56\":1}}],[\"gowp\",{\"1\":{\"56\":1}}],[\"goworker是一个简单的go异步工作池\",{\"1\":{\"56\":1}}],[\"goworker是基于go的后台工作者\",{\"1\":{\"56\":1}}],[\"goworker\",{\"1\":{\"56\":1}}],[\"goworld\",{\"1\":{\"53\":1,\"252\":1}}],[\"gohive\",{\"1\":{\"56\":1}}],[\"gohbase\",{\"1\":{\"41\":1}}],[\"go游戏引擎\",{\"1\":{\"53\":1}}],[\"gonosumdb\",{\"1\":{\"380\":1}}],[\"gonoproxy\",{\"1\":{\"380\":1}}],[\"gonet\",{\"1\":{\"53\":1,\"252\":1}}],[\"gonic\",{\"1\":{\"42\":1,\"372\":10,\"378\":5}}],[\"go3d\",{\"1\":{\"53\":1}}],[\"go绑定的使用\",{\"1\":{\"61\":1}}],[\"go绑定\",{\"1\":{\"53\":1,\"57\":1}}],[\"go包\",{\"1\":{\"53\":1,\"60\":1}}],[\"go包实现bloom过滤器\",{\"1\":{\"46\":1}}],[\"go包实现了用于轻松处理各种数据类型的缓冲区\",{\"1\":{\"46\":1}}],[\"goproject\",{\"1\":{\"521\":1,\"528\":9}}],[\"goproxy=https\",{\"1\":{\"370\":1}}],[\"goproxy\",{\"1\":{\"251\":1,\"370\":3,\"380\":1}}],[\"goprivate\",{\"1\":{\"380\":1}}],[\"gopkg\",{\"1\":{\"372\":2,\"378\":1,\"379\":1}}],[\"gopcap\",{\"1\":{\"64\":1}}],[\"gopacket\",{\"1\":{\"64\":1}}],[\"goptuna\",{\"1\":{\"61\":1}}],[\"gopher接口\",{\"1\":{\"120\":1}}],[\"gopher结构体\",{\"1\":{\"120\":1}}],[\"gopherjs\",{\"1\":{\"55\":1}}],[\"gopher\",{\"1\":{\"49\":1,\"120\":2}}],[\"gopsutil\",{\"1\":{\"41\":1}}],[\"goleran\",{\"1\":{\"245\":1,\"312\":2}}],[\"golearn\",{\"1\":{\"61\":1,\"236\":1,\"237\":1,\"238\":1,\"239\":2,\"245\":1,\"312\":2,\"372\":2,\"378\":2,\"387\":6,\"389\":2,\"390\":4,\"391\":1,\"392\":4,\"394\":3,\"395\":5,\"396\":6}}],[\"golibwireshark\",{\"1\":{\"64\":1}}],[\"golibstemmer\",{\"1\":{\"63\":1}}],[\"golinear\",{\"1\":{\"61\":1}}],[\"gollback\",{\"1\":{\"56\":1}}],[\"golua\",{\"1\":{\"49\":1}}],[\"golang的\",{\"1\":{\"64\":1}}],[\"golang的货币和货币格式\",{\"1\":{\"52\":1}}],[\"golang库用于读取和写入microsoft\",{\"1\":{\"62\":1}}],[\"golang神经网络\",{\"1\":{\"61\":1}}],[\"golang编写的遗传算法库\",{\"1\":{\"61\":1}}],[\"golang编码器\",{\"1\":{\"54\":1}}],[\"golang中的简单mdns\",{\"1\":{\"64\":1}}],[\"golang中的\",{\"1\":{\"60\":1}}],[\"golang中的osx睡眠\",{\"1\":{\"57\":1}}],[\"golang线程池实现\",{\"1\":{\"56\":1}}],[\"golang使用基于工作程序的分派的简单内存中作业队列\",{\"1\":{\"56\":1}}],[\"golang转换为cpp\",{\"1\":{\"55\":1}}],[\"golang软件包\",{\"1\":{\"48\":1}}],[\"golang\",{\"0\":{\"660\":1},\"1\":{\"41\":2,\"46\":2,\"50\":1,\"60\":1,\"67\":1,\"370\":1,\"372\":14,\"373\":3,\"378\":17,\"379\":3,\"395\":1,\"419\":2,\"441\":2,\"521\":2,\"531\":1,\"533\":1,\"534\":1,\"538\":2,\"607\":6},\"2\":{\"36\":1,\"38\":1,\"66\":1,\"90\":1,\"113\":1,\"399\":1,\"401\":1,\"417\":1,\"501\":1,\"503\":1,\"505\":1,\"507\":1,\"650\":1,\"652\":1,\"654\":1,\"656\":1}}],[\"go库和应用程序的错误处理工具和最佳实践\",{\"1\":{\"50\":1}}],[\"go库\",{\"1\":{\"48\":1,\"58\":2,\"62\":1,\"64\":3}}],[\"go应用程序的可扩展\",{\"1\":{\"47\":1}}],[\"go中有许多操作都是这个包实现的\",{\"1\":{\"508\":1}}],[\"go中很大一部分的并发相关的工具都是sync标准库提供的\",{\"1\":{\"352\":1}}],[\"go中读写互斥锁的实现是sync\",{\"1\":{\"350\":1}}],[\"go中sync包下的mutex与rwmutex提供了互斥锁与读写锁两种实现\",{\"1\":{\"348\":1}}],[\"go中通过关键字chan来代表管道类型\",{\"1\":{\"332\":1}}],[\"go中也并没有try\",{\"1\":{\"307\":1}}],[\"go中所有反射相关的操作都是基于这两个类型\",{\"1\":{\"267\":1}}],[\"go中导入头文件\",{\"1\":{\"218\":1}}],[\"go中获取更加详细的信息\",{\"1\":{\"215\":1}}],[\"go中并没有提供类似的数据结构实现\",{\"1\":{\"184\":1}}],[\"go中为不同位数的整数分配了不同的类型\",{\"1\":{\"116\":1}}],[\"go中没有三元表达式\",{\"1\":{\"112\":1}}],[\"go中大部分间隔都是有意义的\",{\"1\":{\"110\":1}}],[\"go中可用的转义字符\",{\"1\":{\"104\":1}}],[\"go中约定\",{\"1\":{\"95\":1}}],[\"go中无法进行循环导入\",{\"1\":{\"94\":1}}],[\"go中进行导入的最基本单位是一个包\",{\"1\":{\"92\":1}}],[\"go中功能丰富的神经网络库\",{\"1\":{\"61\":1}}],[\"go中功能齐全的高性能多组raft库\",{\"1\":{\"47\":1}}],[\"go中死的简单2d游戏库\",{\"1\":{\"53\":1}}],[\"go中嵌入的perl\",{\"1\":{\"49\":1}}],[\"go中html邮件的内联样式\",{\"1\":{\"48\":1}}],[\"go中的examplewithdeadline测试函数\",{\"1\":{\"389\":1}}],[\"go中的sync\",{\"1\":{\"351\":1}}],[\"go中的s2几何库\",{\"1\":{\"54\":1}}],[\"go中的反射api是由标准库reflect包提供的\",{\"1\":{\"265\":1}}],[\"go中的指针引用c中的内存的话\",{\"1\":{\"229\":1}}],[\"go中的函数参数是传值传递\",{\"1\":{\"198\":1}}],[\"go中的函数声明方式通过func关键字来进行\",{\"1\":{\"106\":1}}],[\"go中的参数名可以不带名称\",{\"1\":{\"198\":1}}],[\"go中的数组也是如此\",{\"1\":{\"195\":1}}],[\"go中的数组是值类型\",{\"1\":{\"157\":1}}],[\"go中的字符串本质上是一个结构体\",{\"1\":{\"222\":1}}],[\"go中的字符串就是一个只读的字节切片\",{\"1\":{\"177\":1}}],[\"go中的字符完全兼容utf8\",{\"1\":{\"103\":1}}],[\"go中的格式化输出功能基本上由fmt\",{\"1\":{\"140\":1}}],[\"go中的输入输出都离不开它们\",{\"1\":{\"134\":1}}],[\"go中的可比较类型有\",{\"1\":{\"128\":1}}],[\"go中的在线机器学习\",{\"1\":{\"61\":1}}],[\"go中的简单神经网络库\",{\"1\":{\"61\":1}}],[\"go中的简单lisp\",{\"1\":{\"49\":1}}],[\"go中的3d线条艺术渲染\",{\"1\":{\"58\":1}}],[\"go中的手工制作2d游戏库\",{\"1\":{\"53\":1}}],[\"go中的综合金融市场数据\",{\"1\":{\"52\":1}}],[\"go中的trie实现\",{\"1\":{\"46\":1}}],[\"go中的跳过列表实现\",{\"1\":{\"46\":2}}],[\"go中的音乐理论模型\",{\"1\":{\"45\":1}}],[\"go中的通用数据结构和算法\",{\"1\":{\"39\":2}}],[\"gofal\",{\"1\":{\"46\":1}}],[\"godebug=cgocheck=0\",{\"1\":{\"219\":1}}],[\"godist\",{\"1\":{\"61\":1}}],[\"gods\",{\"1\":{\"46\":1}}],[\"godoc\",{\"1\":{\"41\":1}}],[\"goccy\",{\"1\":{\"372\":2,\"378\":1}}],[\"gochat\",{\"1\":{\"250\":1}}],[\"gocv\",{\"1\":{\"58\":1}}],[\"goconcurrentqueue\",{\"1\":{\"46\":1}}],[\"gocache\",{\"1\":{\"46\":1}}],[\"go实现\",{\"1\":{\"46\":1}}],[\"go的诞生的时间是\",{\"1\":{\"631\":1}}],[\"go的文化\",{\"1\":{\"389\":1}}],[\"go的文件系统抽象系统\",{\"1\":{\"51\":1}}],[\"go的错误处理的优点有几个\",{\"1\":{\"307\":1}}],[\"go的语法糖不能说很多\",{\"1\":{\"307\":1}}],[\"go的声明方式始终遵循名字在前面\",{\"1\":{\"301\":1}}],[\"go的一大特点就是编译速度非常快\",{\"1\":{\"264\":1}}],[\"go的理念便是\",{\"1\":{\"197\":1}}],[\"go的基本语法十分简单易懂\",{\"1\":{\"91\":1}}],[\"go的基于llvm的编译器\",{\"1\":{\"55\":1}}],[\"go的基于终端的游戏引擎\",{\"1\":{\"53\":1}}],[\"go的字幕格式支持\",{\"1\":{\"65\":1}}],[\"go的快速ip到cidr查找\",{\"1\":{\"64\":1}}],[\"go的自然语言检测程序包\",{\"1\":{\"63\":1}}],[\"go的雪球茎端口\",{\"1\":{\"63\":1}}],[\"go的unicode音译器\",{\"1\":{\"63\":1}}],[\"go的liblinear绑定\",{\"1\":{\"61\":1}}],[\"go的遗传算法库\",{\"1\":{\"61\":1}}],[\"go的裸露检测\",{\"1\":{\"58\":1}}],[\"go的头像生成器\",{\"1\":{\"58\":1}}],[\"go的osx桌面通知库\",{\"1\":{\"57\":1}}],[\"go的windows应用程序库工具包\",{\"1\":{\"57\":1}}],[\"go的平台本地gui库\",{\"1\":{\"57\":1}}],[\"go的qt绑定\",{\"1\":{\"57\":1}}],[\"go的高性能和易于使用的goroutine池\",{\"1\":{\"56\":1}}],[\"go的抽象文件存储\",{\"1\":{\"51\":1}}],[\"go的php绑定\",{\"1\":{\"49\":1}}],[\"go的duktape\",{\"1\":{\"49\":1}}],[\"go的数据框\",{\"1\":{\"46\":1}}],[\"go的有用的set集合实现\",{\"1\":{\"46\":1}}],[\"go的线程安全和非线程安全高性能集\",{\"1\":{\"46\":1}}],[\"go的小数api\",{\"1\":{\"46\":1}}],[\"go的整数压缩库\",{\"1\":{\"46\":1}}],[\"go的类似python的字典\",{\"1\":{\"46\":1}}],[\"go程序包\",{\"1\":{\"45\":1,\"46\":1}}],[\"goslice\",{\"1\":{\"225\":4}}],[\"goslaves\",{\"1\":{\"56\":1}}],[\"gostringn\",{\"1\":{\"222\":1}}],[\"gostring\",{\"1\":{\"222\":1}}],[\"gosocsvr\",{\"1\":{\"64\":1}}],[\"gosnmp\",{\"1\":{\"64\":1}}],[\"goshark\",{\"1\":{\"64\":1}}],[\"gosseract\",{\"1\":{\"61\":1}}],[\"goscore\",{\"1\":{\"61\":1}}],[\"gosx\",{\"1\":{\"57\":1}}],[\"goskiplist\",{\"1\":{\"46\":1}}],[\"goset\",{\"1\":{\"46\":1}}],[\"gosamplerate\",{\"1\":{\"45\":1}}],[\"gosym\",{\"1\":{\"43\":1}}],[\"gobytes\",{\"1\":{\"222\":1}}],[\"gobgp\",{\"1\":{\"64\":1}}],[\"gobrain\",{\"1\":{\"61\":1}}],[\"gobot是机器人技术\",{\"1\":{\"59\":1}}],[\"gobot\",{\"1\":{\"59\":1}}],[\"gob\",{\"1\":{\"43\":1}}],[\"go运行时函数替换\",{\"1\":{\"41\":1}}],[\"gorse\",{\"1\":{\"61\":1}}],[\"gorgonia\",{\"1\":{\"61\":1}}],[\"gorecommend\",{\"1\":{\"61\":1}}],[\"gorpc\",{\"1\":{\"47\":1}}],[\"goroutineprofile\",{\"1\":{\"242\":1}}],[\"goroutine池\",{\"1\":{\"56\":1}}],[\"goroutine\",{\"1\":{\"41\":1,\"70\":4,\"83\":1,\"242\":1,\"243\":1,\"246\":1,\"247\":1}}],[\"goroutines\",{\"0\":{\"56\":1},\"1\":{\"39\":1,\"247\":1,\"339\":1,\"341\":1}}],[\"gorilla\",{\"1\":{\"41\":6}}],[\"gorm\",{\"1\":{\"249\":1,\"379\":1}}],[\"gormgithub\",{\"1\":{\"41\":1}}],[\"gorm实现原理\",{\"0\":{\"37\":1}}],[\"gorm使用\",{\"0\":{\"35\":1}}],[\"go\",{\"0\":{\"14\":1,\"68\":1,\"76\":1,\"82\":1,\"85\":1,\"86\":1,\"378\":1,\"379\":1,\"504\":1,\"506\":1},\"1\":{\"41\":31,\"42\":1,\"43\":1,\"45\":5,\"46\":7,\"47\":6,\"48\":6,\"49\":5,\"50\":2,\"51\":4,\"52\":4,\"53\":5,\"56\":6,\"57\":4,\"58\":5,\"60\":4,\"61\":10,\"62\":1,\"63\":7,\"64\":6,\"65\":4,\"67\":3,\"69\":2,\"70\":4,\"71\":2,\"72\":1,\"73\":1,\"74\":3,\"75\":1,\"76\":1,\"77\":3,\"78\":1,\"79\":2,\"80\":1,\"81\":1,\"83\":5,\"84\":6,\"85\":5,\"87\":4,\"88\":4,\"89\":5,\"95\":11,\"97\":1,\"168\":1,\"172\":1,\"185\":1,\"187\":2,\"192\":1,\"195\":1,\"215\":3,\"216\":4,\"218\":1,\"222\":14,\"223\":2,\"224\":1,\"231\":5,\"232\":1,\"233\":4,\"236\":14,\"237\":14,\"238\":6,\"239\":20,\"243\":1,\"245\":3,\"246\":4,\"247\":2,\"249\":3,\"254\":1,\"264\":1,\"307\":2,\"312\":5,\"315\":2,\"331\":9,\"335\":1,\"336\":3,\"337\":1,\"338\":1,\"339\":2,\"340\":9,\"341\":2,\"345\":1,\"346\":4,\"347\":1,\"348\":1,\"349\":1,\"350\":4,\"351\":4,\"353\":1,\"354\":1,\"355\":2,\"361\":1,\"362\":1,\"363\":3,\"364\":3,\"365\":3,\"366\":4,\"367\":2,\"368\":11,\"369\":6,\"370\":3,\"371\":1,\"372\":59,\"373\":23,\"375\":9,\"376\":7,\"378\":17,\"379\":10,\"380\":1,\"381\":1,\"382\":6,\"383\":1,\"384\":3,\"386\":3,\"387\":9,\"388\":1,\"389\":2,\"390\":16,\"391\":4,\"392\":13,\"394\":3,\"395\":5,\"396\":18,\"397\":1,\"403\":2,\"419\":2,\"420\":2,\"421\":3,\"422\":4,\"423\":3,\"426\":3,\"427\":3,\"428\":3,\"429\":3,\"432\":3,\"441\":1,\"442\":5,\"443\":1,\"508\":4,\"513\":2,\"521\":2,\"528\":4,\"574\":1,\"582\":1,\"594\":1,\"608\":8,\"614\":1,\"628\":1,\"637\":1}}],[\"🌐实用网站\",{\"0\":{\"12\":1}}],[\"fghijk\",{\"1\":{\"605\":1}}],[\"ff\",{\"1\":{\"396\":1}}],[\"ffmpeg的综合go绑定\",{\"1\":{\"65\":1}}],[\"fuzz中的支持的类型如下\",{\"1\":{\"397\":1}}],[\"fuzzing\",{\"1\":{\"396\":1}}],[\"fuzzing来了解更多概念\",{\"1\":{\"396\":1}}],[\"fuzz参数再次执行\",{\"1\":{\"396\":1}}],[\"fuzz时\",{\"1\":{\"396\":1}}],[\"fuzzreverse\",{\"1\":{\"396\":26}}],[\"fuzzminimizetime\",{\"1\":{\"388\":1}}],[\"fuzztime参数限制时间\",{\"1\":{\"396\":1}}],[\"fuzztime\",{\"1\":{\"388\":1,\"396\":3}}],[\"fuzz\",{\"1\":{\"388\":1,\"396\":43}}],[\"fun\",{\"1\":{\"266\":1}}],[\"funcs\",{\"1\":{\"620\":1}}],[\"funcs方法来添加自定义函数\",{\"1\":{\"620\":1}}],[\"funcmap\",{\"1\":{\"620\":4}}],[\"funcname\",{\"1\":{\"620\":1}}],[\"func来进行获取\",{\"1\":{\"289\":1}}],[\"function\",{\"1\":{\"212\":3,\"389\":2}}],[\"func是函数声明关键字\",{\"1\":{\"91\":1}}],[\"func\",{\"1\":{\"91\":1,\"94\":1,\"96\":1,\"97\":1,\"106\":3,\"108\":2,\"120\":1,\"125\":2,\"127\":1,\"128\":3,\"129\":2,\"132\":1,\"133\":1,\"136\":1,\"137\":1,\"138\":1,\"139\":2,\"140\":2,\"142\":1,\"143\":5,\"144\":1,\"145\":1,\"147\":3,\"148\":2,\"149\":5,\"150\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":2,\"155\":2,\"160\":3,\"163\":1,\"166\":1,\"167\":2,\"169\":1,\"170\":2,\"172\":4,\"173\":3,\"174\":2,\"175\":2,\"176\":3,\"177\":5,\"178\":1,\"179\":3,\"180\":3,\"181\":3,\"182\":2,\"183\":2,\"184\":1,\"185\":2,\"187\":1,\"188\":11,\"193\":1,\"194\":6,\"195\":1,\"196\":2,\"197\":6,\"198\":3,\"199\":6,\"200\":4,\"201\":8,\"202\":8,\"203\":1,\"204\":14,\"205\":3,\"206\":14,\"211\":1,\"212\":19,\"213\":4,\"216\":1,\"217\":2,\"218\":1,\"219\":7,\"220\":1,\"221\":1,\"222\":9,\"223\":1,\"224\":1,\"225\":2,\"226\":1,\"227\":2,\"228\":2,\"229\":2,\"231\":1,\"232\":1,\"233\":6,\"236\":2,\"237\":5,\"238\":1,\"239\":3,\"241\":3,\"242\":3,\"243\":4,\"245\":2,\"246\":4,\"256\":4,\"257\":2,\"258\":6,\"259\":6,\"260\":4,\"262\":5,\"263\":10,\"267\":2,\"269\":1,\"270\":4,\"271\":2,\"272\":1,\"273\":1,\"274\":3,\"275\":3,\"276\":1,\"277\":2,\"278\":2,\"279\":8,\"280\":2,\"281\":2,\"283\":2,\"284\":2,\"285\":1,\"286\":2,\"287\":2,\"288\":3,\"289\":9,\"290\":1,\"292\":2,\"293\":2,\"294\":2,\"295\":2,\"296\":2,\"297\":6,\"298\":3,\"300\":2,\"301\":3,\"303\":2,\"304\":4,\"307\":3,\"309\":1,\"310\":2,\"311\":2,\"312\":14,\"313\":1,\"314\":3,\"315\":15,\"316\":10,\"317\":2,\"319\":7,\"320\":8,\"321\":9,\"322\":5,\"323\":2,\"324\":4,\"325\":1,\"327\":4,\"328\":3,\"329\":2,\"331\":8,\"333\":2,\"334\":1,\"335\":3,\"336\":10,\"337\":9,\"338\":5,\"339\":5,\"340\":16,\"341\":9,\"344\":6,\"345\":3,\"346\":8,\"347\":5,\"348\":5,\"349\":2,\"350\":11,\"351\":12,\"353\":14,\"354\":9,\"355\":14,\"356\":1,\"358\":2,\"359\":3,\"360\":2,\"365\":4,\"367\":1,\"368\":3,\"372\":1,\"382\":3,\"387\":5,\"389\":6,\"390\":13,\"391\":5,\"392\":11,\"393\":4,\"394\":4,\"396\":10,\"404\":1,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":4,\"421\":1,\"432\":1,\"433\":1,\"435\":4,\"436\":1,\"437\":1,\"438\":1,\"439\":4,\"443\":1,\"444\":2,\"510\":3,\"511\":1,\"512\":1,\"513\":2,\"514\":1,\"515\":1,\"516\":2,\"517\":1,\"519\":2,\"520\":1,\"521\":1,\"527\":3,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"536\":1,\"537\":4,\"538\":3,\"539\":1,\"540\":3,\"541\":4,\"546\":1,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"567\":2,\"568\":2,\"569\":2,\"570\":2,\"571\":2,\"572\":2,\"573\":2,\"574\":3,\"576\":1,\"577\":1,\"578\":1,\"579\":1,\"580\":4,\"581\":1,\"584\":2,\"585\":2,\"586\":2,\"587\":2,\"588\":1,\"589\":2,\"590\":2,\"591\":2,\"592\":2,\"593\":1,\"596\":2,\"597\":2,\"598\":6,\"599\":2,\"600\":3,\"601\":2,\"602\":5,\"603\":3,\"604\":7,\"605\":6,\"606\":2,\"607\":4,\"608\":5,\"609\":5,\"610\":6,\"611\":2,\"612\":2,\"613\":2,\"615\":3,\"617\":5,\"619\":1,\"620\":3,\"625\":3,\"626\":3,\"628\":4,\"629\":12,\"632\":1,\"633\":2,\"634\":2,\"635\":2,\"640\":2,\"641\":2,\"642\":2,\"643\":6,\"644\":2,\"645\":3,\"646\":2,\"647\":2,\"648\":2}}],[\"fe\",{\"1\":{\"521\":3}}],[\"fe3a3abad311\",{\"1\":{\"372\":2,\"378\":3}}],[\"feat\",{\"1\":{\"368\":6}}],[\"f1\",{\"1\":{\"302\":4,\"304\":3}}],[\"fs作为文件系统\",{\"1\":{\"628\":1}}],[\"fsys\",{\"1\":{\"628\":1}}],[\"fs库\",{\"1\":{\"318\":1}}],[\"fs\",{\"1\":{\"309\":5,\"319\":15,\"329\":1,\"508\":1,\"628\":6}}],[\"fscanln\",{\"1\":{\"144\":1}}],[\"fsa实现\",{\"1\":{\"46\":1}}],[\"f或者\",{\"1\":{\"140\":1}}],[\"fp\",{\"1\":{\"301\":1}}],[\"fprintf函数中\",{\"1\":{\"354\":1}}],[\"fprintf\",{\"1\":{\"198\":1,\"199\":1,\"354\":1}}],[\"fprintln\",{\"1\":{\"139\":1}}],[\"fp+0\",{\"1\":{\"101\":1}}],[\"f\",{\"1\":{\"95\":1,\"104\":1,\"120\":1,\"140\":2,\"148\":2,\"149\":3,\"179\":3,\"201\":2,\"204\":2,\"212\":4,\"224\":1,\"237\":3,\"301\":1,\"302\":4,\"304\":3,\"320\":2,\"321\":3,\"322\":1,\"327\":1,\"353\":5,\"355\":1,\"392\":1,\"396\":12,\"415\":1,\"460\":2,\"537\":1,\"586\":2,\"590\":12,\"592\":1,\"593\":1,\"602\":5,\"605\":1,\"643\":2}}],[\"from\",{\"1\":{\"236\":4,\"237\":3,\"238\":1,\"239\":5,\"346\":1,\"435\":2,\"438\":1}}],[\"frontmatter\",{\"1\":{\"2\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"free\",{\"1\":{\"222\":6,\"229\":2,\"354\":2}}],[\"freed\",{\"1\":{\"222\":2}}],[\"framework\",{\"0\":{\"659\":1},\"1\":{\"64\":1}}],[\"ftp\",{\"1\":{\"64\":1}}],[\"fyne\",{\"1\":{\"57\":1}}],[\"fn就类似于一个单元测试函数的逻辑\",{\"1\":{\"396\":1}}],[\"fn1\",{\"1\":{\"204\":3}}],[\"fn\",{\"1\":{\"56\":1,\"297\":4,\"396\":1}}],[\"fnv\",{\"1\":{\"43\":1}}],[\"f4go\",{\"1\":{\"55\":1}}],[\"fifo\",{\"1\":{\"319\":1,\"334\":1}}],[\"finished的行号变成了调用者的行号\",{\"1\":{\"391\":1}}],[\"finished\",{\"1\":{\"390\":13,\"391\":3,\"392\":7}}],[\"findoneandreplace\",{\"1\":{\"427\":1}}],[\"findone\",{\"1\":{\"424\":2}}],[\"find\",{\"1\":{\"319\":1,\"425\":9}}],[\"finally这种语句\",{\"1\":{\"307\":1}}],[\"finance\",{\"1\":{\"52\":3}}],[\"fieldsfunc\",{\"1\":{\"602\":2}}],[\"fields\",{\"1\":{\"602\":2}}],[\"fieldbyname\",{\"1\":{\"286\":2,\"287\":2,\"288\":1}}],[\"field\",{\"1\":{\"226\":2,\"286\":6,\"287\":2}}],[\"fib\",{\"1\":{\"201\":5}}],[\"filenames\",{\"1\":{\"628\":1}}],[\"files\",{\"1\":{\"387\":1}}],[\"filesizelow\",{\"1\":{\"319\":1}}],[\"filesizehigh\",{\"1\":{\"319\":1}}],[\"file提供的方法readfrom\",{\"1\":{\"322\":1}}],[\"file结构体提供了以下几种方法以供写入数据\",{\"1\":{\"321\":1}}],[\"file类型提供了以下几个公开的方法\",{\"1\":{\"320\":1}}],[\"filetype\",{\"1\":{\"319\":1}}],[\"fileattributes\",{\"1\":{\"319\":1}}],[\"fileinfo\",{\"1\":{\"319\":2,\"329\":1}}],[\"filemode\",{\"1\":{\"319\":1,\"321\":1,\"328\":2,\"329\":1}}],[\"file\",{\"1\":{\"126\":2,\"134\":1,\"219\":1,\"307\":5,\"309\":4,\"319\":12,\"320\":13,\"321\":12,\"322\":2,\"327\":4,\"368\":6,\"373\":1,\"388\":1,\"396\":2}}],[\"filexfer\",{\"1\":{\"64\":1}}],[\"filezilla\",{\"1\":{\"64\":1}}],[\"filepath\",{\"1\":{\"43\":1,\"329\":5,\"508\":1}}],[\"first\",{\"1\":{\"56\":1,\"145\":2,\"396\":18,\"615\":2,\"617\":3,\"622\":2}}],[\"failing\",{\"1\":{\"396\":4}}],[\"failnow\",{\"1\":{\"390\":1}}],[\"failnow同样会标记为测试失败\",{\"1\":{\"390\":1}}],[\"fail\",{\"1\":{\"390\":7,\"396\":8}}],[\"fail用于将当前用例标记为测试失败\",{\"1\":{\"390\":1}}],[\"failure\",{\"1\":{\"389\":1,\"396\":1}}],[\"failfast\",{\"1\":{\"387\":1,\"388\":1}}],[\"failed\",{\"1\":{\"382\":1,\"411\":1,\"413\":1,\"414\":1,\"435\":2}}],[\"father\",{\"1\":{\"298\":3,\"617\":1}}],[\"fatal会在写入日志信息后调用os\",{\"1\":{\"539\":1}}],[\"fatalln\",{\"1\":{\"539\":1}}],[\"fatalf内部使用的是t\",{\"1\":{\"390\":1}}],[\"fatalf\",{\"1\":{\"365\":1,\"390\":3,\"391\":1,\"392\":1,\"393\":2}}],[\"fatal级别的问题一般很少会显式的去触发\",{\"1\":{\"317\":1}}],[\"fatal是一种极其严重的问题\",{\"1\":{\"317\":1}}],[\"fatal\",{\"0\":{\"317\":1},\"1\":{\"185\":1,\"219\":1,\"242\":3,\"307\":1,\"317\":2,\"339\":1,\"341\":1,\"355\":1,\"568\":1}}],[\"fallback\",{\"1\":{\"623\":2,\"624\":1}}],[\"fallthrough\",{\"1\":{\"97\":1,\"149\":2}}],[\"false\",{\"1\":{\"121\":1,\"180\":1,\"201\":1,\"213\":1,\"273\":1,\"274\":1,\"275\":1,\"286\":2,\"298\":2,\"319\":1,\"339\":1,\"353\":2,\"354\":3,\"355\":1,\"382\":2,\"390\":5,\"391\":1,\"392\":1,\"393\":5,\"404\":1,\"528\":1,\"551\":1,\"586\":6,\"587\":2,\"593\":1,\"598\":1,\"620\":2}}],[\"false为假值\",{\"1\":{\"115\":1}}],[\"falcon\",{\"1\":{\"50\":1}}],[\"fasthttp\",{\"1\":{\"64\":1}}],[\"fann\",{\"1\":{\"61\":2}}],[\"fano编码的go实现\",{\"1\":{\"46\":1}}],[\"flush\",{\"1\":{\"139\":2}}],[\"fluent\",{\"1\":{\"60\":1}}],[\"floor\",{\"1\":{\"553\":1}}],[\"floats\",{\"1\":{\"260\":4,\"577\":3,\"579\":3,\"640\":2}}],[\"float\",{\"1\":{\"224\":4,\"306\":1,\"524\":1,\"589\":4}}],[\"float32\",{\"1\":{\"117\":1,\"224\":1,\"270\":3,\"397\":1,\"640\":1}}],[\"float64frombits\",{\"1\":{\"643\":2}}],[\"float64bits\",{\"1\":{\"643\":3}}],[\"float64slice\",{\"1\":{\"579\":1}}],[\"float64s\",{\"1\":{\"577\":1}}],[\"float64构成了一个类型约束\",{\"1\":{\"256\":1}}],[\"float64\",{\"1\":{\"106\":1,\"117\":1,\"120\":1,\"180\":1,\"181\":1,\"182\":1,\"187\":2,\"188\":2,\"194\":1,\"197\":2,\"199\":2,\"200\":1,\"224\":1,\"256\":3,\"258\":3,\"260\":1,\"270\":3,\"302\":4,\"304\":3,\"306\":1,\"397\":1,\"415\":1,\"524\":1,\"577\":1,\"579\":1,\"589\":1,\"590\":1,\"643\":7}}],[\"flogo是一个用于iot\",{\"1\":{\"59\":1}}],[\"flogo\",{\"1\":{\"59\":1}}],[\"flow\",{\"1\":{\"56\":1,\"236\":2,\"237\":2,\"238\":1,\"239\":3}}],[\"flowgraph\",{\"1\":{\"47\":1}}],[\"floc\",{\"1\":{\"56\":1}}],[\"flop\",{\"1\":{\"51\":1}}],[\"flavor\",{\"1\":{\"404\":1}}],[\"flame\",{\"1\":{\"246\":1}}],[\"flat\",{\"1\":{\"245\":6}}],[\"flate\",{\"1\":{\"43\":1,\"508\":1}}],[\"flac编码器\",{\"1\":{\"45\":1}}],[\"flac\",{\"1\":{\"45\":1}}],[\"flag解析会在第一个非命令行参数之前停止\",{\"1\":{\"526\":1}}],[\"flag=xxx\",{\"1\":{\"526\":2}}],[\"flag包使得开发命令行工具更加简单\",{\"1\":{\"522\":1}}],[\"flags\",{\"1\":{\"373\":1,\"541\":1}}],[\"flag标准库\",{\"1\":{\"254\":1}}],[\"flag\",{\"0\":{\"522\":1,\"541\":1},\"1\":{\"40\":1,\"43\":1,\"254\":1,\"267\":1,\"319\":1,\"365\":3,\"373\":2,\"508\":1,\"523\":1,\"525\":6,\"526\":2,\"528\":4,\"541\":2}}],[\"fcgi\",{\"1\":{\"43\":1}}],[\"follows\",{\"1\":{\"367\":1}}],[\"fossil\",{\"1\":{\"362\":1}}],[\"found\",{\"1\":{\"245\":1,\"382\":1,\"412\":1,\"600\":4,\"657\":1}}],[\"foo\",{\"1\":{\"95\":2}}],[\"fonet\",{\"1\":{\"61\":1}}],[\"fowler的money模式的实现\",{\"1\":{\"52\":1}}],[\"fowler\",{\"1\":{\"43\":1}}],[\"forward\",{\"1\":{\"538\":1}}],[\"foreign\",{\"1\":{\"434\":2}}],[\"fork\",{\"1\":{\"378\":5}}],[\"for循环\",{\"1\":{\"167\":1,\"340\":1}}],[\"for语句可以被当作while来使用\",{\"1\":{\"151\":1}}],[\"formatcomplex\",{\"1\":{\"592\":4}}],[\"formatfloat\",{\"1\":{\"590\":7}}],[\"formatbool\",{\"1\":{\"587\":3}}],[\"format\",{\"1\":{\"143\":1,\"198\":3,\"199\":2,\"245\":2,\"354\":2,\"434\":1,\"508\":1,\"631\":3}}],[\"fortio\",{\"1\":{\"64\":1}}],[\"for\",{\"0\":{\"152\":1,\"153\":1,\"339\":1},\"1\":{\"11\":1,\"61\":1,\"97\":1,\"111\":2,\"130\":1,\"143\":1,\"145\":1,\"151\":1,\"152\":8,\"153\":9,\"154\":4,\"155\":4,\"167\":3,\"168\":3,\"177\":5,\"182\":2,\"183\":1,\"184\":1,\"185\":3,\"188\":1,\"201\":2,\"203\":1,\"222\":2,\"225\":3,\"233\":1,\"237\":1,\"238\":2,\"239\":4,\"241\":2,\"243\":1,\"244\":1,\"245\":4,\"246\":3,\"247\":3,\"263\":2,\"266\":2,\"284\":1,\"286\":1,\"289\":4,\"290\":1,\"294\":1,\"297\":1,\"320\":1,\"321\":2,\"327\":2,\"331\":4,\"336\":2,\"339\":9,\"340\":4,\"341\":1,\"345\":1,\"346\":4,\"347\":1,\"348\":1,\"349\":1,\"350\":2,\"351\":4,\"353\":1,\"354\":1,\"355\":4,\"359\":1,\"372\":1,\"373\":2,\"393\":1,\"394\":4,\"395\":3,\"396\":5,\"404\":1,\"415\":2,\"419\":2,\"434\":1,\"441\":1,\"574\":3,\"617\":4,\"619\":1,\"625\":1,\"626\":1,\"634\":1,\"645\":2,\"647\":1}}],[\"fmt\",{\"0\":{\"138\":1,\"143\":1},\"1\":{\"40\":1,\"43\":1,\"74\":1,\"91\":3,\"94\":2,\"96\":2,\"106\":1,\"108\":2,\"111\":1,\"128\":2,\"129\":6,\"133\":2,\"138\":2,\"139\":1,\"140\":33,\"143\":4,\"144\":2,\"145\":1,\"147\":1,\"148\":2,\"149\":3,\"151\":2,\"152\":4,\"153\":4,\"154\":2,\"155\":2,\"159\":1,\"160\":6,\"163\":1,\"164\":3,\"165\":4,\"166\":3,\"167\":2,\"168\":3,\"169\":4,\"170\":3,\"172\":4,\"173\":5,\"174\":4,\"175\":2,\"176\":3,\"177\":5,\"178\":1,\"179\":7,\"180\":4,\"181\":4,\"182\":2,\"183\":2,\"184\":1,\"185\":1,\"189\":2,\"190\":1,\"193\":1,\"194\":9,\"195\":1,\"199\":1,\"201\":2,\"202\":9,\"203\":1,\"204\":14,\"205\":2,\"206\":6,\"211\":1,\"212\":9,\"213\":8,\"217\":4,\"218\":2,\"221\":2,\"222\":2,\"225\":3,\"226\":3,\"227\":5,\"228\":3,\"229\":5,\"231\":2,\"232\":2,\"233\":3,\"239\":3,\"257\":1,\"263\":3,\"269\":1,\"270\":1,\"271\":4,\"272\":5,\"273\":4,\"274\":2,\"275\":2,\"276\":1,\"277\":1,\"278\":1,\"279\":10,\"280\":2,\"281\":1,\"283\":4,\"284\":1,\"286\":4,\"287\":2,\"288\":2,\"289\":8,\"290\":2,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":2,\"298\":4,\"300\":2,\"302\":1,\"303\":3,\"304\":2,\"305\":2,\"306\":3,\"307\":4,\"309\":1,\"311\":1,\"312\":6,\"315\":30,\"316\":9,\"317\":2,\"319\":10,\"320\":10,\"321\":9,\"322\":11,\"323\":2,\"324\":4,\"327\":5,\"328\":2,\"331\":15,\"334\":1,\"335\":2,\"336\":10,\"337\":4,\"338\":1,\"339\":3,\"340\":20,\"341\":7,\"345\":2,\"346\":8,\"347\":2,\"348\":2,\"349\":2,\"350\":5,\"351\":5,\"353\":2,\"354\":2,\"355\":5,\"356\":1,\"358\":2,\"360\":2,\"365\":4,\"366\":1,\"367\":2,\"382\":2,\"387\":3,\"389\":5,\"396\":5,\"404\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":4,\"421\":2,\"424\":1,\"425\":2,\"426\":2,\"427\":4,\"428\":2,\"435\":5,\"436\":3,\"437\":3,\"438\":3,\"439\":1,\"443\":3,\"448\":1,\"449\":2,\"450\":1,\"451\":2,\"454\":1,\"456\":1,\"457\":1,\"458\":2,\"460\":3,\"508\":1,\"511\":2,\"512\":1,\"514\":2,\"515\":3,\"517\":2,\"519\":2,\"520\":2,\"521\":5,\"528\":1,\"530\":2,\"531\":1,\"537\":2,\"546\":1,\"547\":1,\"548\":1,\"549\":2,\"550\":1,\"551\":2,\"552\":2,\"553\":1,\"554\":1,\"555\":2,\"556\":2,\"557\":1,\"558\":2,\"559\":1,\"560\":2,\"561\":2,\"562\":2,\"563\":2,\"564\":2,\"567\":2,\"568\":3,\"569\":3,\"570\":3,\"571\":3,\"572\":2,\"573\":4,\"574\":2,\"577\":1,\"579\":1,\"580\":1,\"584\":1,\"585\":1,\"586\":3,\"587\":2,\"588\":2,\"589\":2,\"590\":8,\"591\":2,\"592\":5,\"593\":1,\"596\":2,\"597\":4,\"598\":8,\"599\":3,\"600\":1,\"601\":3,\"602\":2,\"603\":2,\"604\":5,\"605\":3,\"606\":2,\"607\":4,\"608\":4,\"609\":4,\"610\":5,\"611\":2,\"612\":1,\"613\":2,\"615\":3,\"620\":5,\"629\":1,\"631\":3,\"632\":3,\"633\":1,\"634\":1,\"635\":2,\"640\":7,\"641\":5,\"642\":3,\"643\":9,\"644\":2,\"645\":2,\"646\":1,\"647\":1,\"648\":1}}],[\"s+1=\",{\"1\":{\"621\":1}}],[\"s为源字符串\",{\"1\":{\"607\":1}}],[\"sqrt\",{\"1\":{\"559\":1}}],[\"sqrtphi\",{\"1\":{\"545\":1}}],[\"sqrtpi\",{\"1\":{\"545\":1}}],[\"sqrte\",{\"1\":{\"545\":1}}],[\"sqrt2\",{\"1\":{\"545\":1}}],[\"sql这三个库就可以开发一个独立完整的web项目\",{\"1\":{\"508\":1}}],[\"sqlite\",{\"1\":{\"432\":1}}],[\"sql支持的数据库不止mysql\",{\"1\":{\"432\":1}}],[\"sqlx或者说标准库database\",{\"1\":{\"432\":1}}],[\"sqlx\",{\"1\":{\"249\":1,\"432\":1,\"433\":1,\"435\":2}}],[\"sql\",{\"1\":{\"43\":2,\"432\":1,\"508\":1}}],[\"svn\",{\"1\":{\"362\":1}}],[\"svg或光栅图像\",{\"1\":{\"58\":1}}],[\"svgo\",{\"1\":{\"41\":1,\"58\":1}}],[\"svg\",{\"1\":{\"41\":1,\"245\":1}}],[\"swapped\",{\"1\":{\"359\":1}}],[\"swapint64\",{\"1\":{\"358\":1}}],[\"swap\",{\"1\":{\"358\":2,\"575\":2,\"580\":1}}],[\"switch语句还支持一种特殊的写法\",{\"1\":{\"306\":1}}],[\"switch语句也可以没有入口处的表达式\",{\"1\":{\"149\":1}}],[\"switch语句也是一种多分支的判断语句\",{\"1\":{\"149\":1}}],[\"switch\",{\"0\":{\"149\":1},\"1\":{\"97\":1,\"132\":1,\"146\":1,\"149\":7,\"228\":1,\"256\":1,\"258\":1,\"306\":1,\"372\":1}}],[\"s1与s2是共享的同一个底层数组\",{\"1\":{\"169\":1}}],[\"s1\",{\"1\":{\"169\":9,\"173\":4}}],[\"slot\",{\"1\":{\"627\":2,\"628\":3}}],[\"slice函数接收一个指针\",{\"1\":{\"646\":1}}],[\"slice函数可以将数组指针转换为切片\",{\"1\":{\"225\":1}}],[\"sliceheader类型来获取\",{\"1\":{\"645\":1}}],[\"slicedata就是为了替代它的\",{\"1\":{\"645\":1}}],[\"slicedata直接获取了字符串底层数组的指针\",{\"1\":{\"222\":1}}],[\"slicedata\",{\"0\":{\"645\":1},\"1\":{\"173\":1,\"222\":2,\"225\":1,\"645\":2,\"646\":1,\"648\":1}}],[\"slice的扩容策略变为了\",{\"1\":{\"163\":1}}],[\"slice是要添加元素的目标切片\",{\"1\":{\"163\":1}}],[\"slices\",{\"1\":{\"160\":1,\"168\":5,\"200\":2,\"241\":1,\"246\":1,\"508\":1}}],[\"slice\",{\"0\":{\"646\":1},\"1\":{\"160\":10,\"163\":6,\"167\":5,\"168\":2,\"169\":1,\"173\":1,\"206\":11,\"222\":1,\"225\":3,\"239\":1,\"241\":2,\"245\":2,\"246\":4,\"270\":3,\"279\":2,\"353\":3,\"620\":3,\"640\":2,\"645\":1,\"646\":2}}],[\"sleep来模拟不同的耗时\",{\"1\":{\"348\":1}}],[\"sleep并不是一种良好的解决办法\",{\"1\":{\"331\":1}}],[\"sleep\",{\"0\":{\"635\":1},\"1\":{\"57\":1,\"242\":2,\"315\":2,\"331\":6,\"336\":1,\"340\":3,\"341\":1,\"345\":1,\"346\":6,\"347\":1,\"348\":2,\"349\":2,\"350\":4,\"351\":4,\"449\":1,\"450\":1,\"635\":3}}],[\"sleuth\",{\"1\":{\"47\":1}}],[\"srem\",{\"1\":{\"477\":1}}],[\"srandmembern\",{\"1\":{\"473\":1}}],[\"srcfile\",{\"1\":{\"329\":3}}],[\"srcdir\",{\"1\":{\"231\":2,\"232\":1}}],[\"src\",{\"1\":{\"95\":1,\"166\":4,\"175\":9,\"312\":2,\"322\":1,\"328\":1,\"329\":4,\"515\":1,\"521\":1,\"528\":4}}],[\"srt\",{\"1\":{\"65\":2}}],[\"ss\",{\"1\":{\"480\":1,\"481\":2,\"482\":4,\"483\":1,\"484\":3}}],[\"sscan\",{\"1\":{\"478\":1}}],[\"sse\",{\"1\":{\"372\":2,\"378\":1}}],[\"ssa\",{\"1\":{\"65\":1}}],[\"sslb\",{\"1\":{\"64\":1}}],[\"ssh\",{\"1\":{\"64\":2}}],[\"ssor\",{\"1\":{\"41\":1}}],[\"sftp\",{\"1\":{\"64\":1}}],[\"snapshot\",{\"1\":{\"404\":1,\"407\":1}}],[\"snowball\",{\"1\":{\"63\":1}}],[\"snluu\",{\"1\":{\"41\":1}}],[\"s2\",{\"1\":{\"54\":1,\"169\":9}}],[\"sdiffstore\",{\"1\":{\"474\":1}}],[\"sdiff\",{\"1\":{\"474\":1}}],[\"sdk的ios\",{\"1\":{\"53\":1}}],[\"sdl2\",{\"1\":{\"53\":1}}],[\"s3和gcs\",{\"1\":{\"51\":1}}],[\"s3\",{\"1\":{\"51\":1}}],[\"skipf\",{\"1\":{\"390\":2,\"391\":1,\"392\":1}}],[\"skipnow\",{\"1\":{\"390\":1}}],[\"skip\",{\"1\":{\"388\":1,\"390\":2,\"396\":2}}],[\"skiplist实施\",{\"1\":{\"46\":1}}],[\"skiplist\",{\"1\":{\"46\":2}}],[\"skywalker\",{\"1\":{\"51\":1}}],[\"skylar\",{\"1\":{\"41\":1}}],[\"smallestnonzerofloat64\",{\"1\":{\"544\":1}}],[\"smallestnonzerofloat32\",{\"1\":{\"544\":1}}],[\"smartcrop\",{\"1\":{\"58\":1}}],[\"smove\",{\"1\":{\"476\":1}}],[\"smembers\",{\"1\":{\"473\":1}}],[\"smi等\",{\"1\":{\"65\":1}}],[\"smf\",{\"1\":{\"45\":1}}],[\"smtp服务器协议状态机\",{\"1\":{\"48\":1}}],[\"smtp\",{\"1\":{\"43\":1,\"48\":1}}],[\"suffix\",{\"1\":{\"603\":1,\"610\":2}}],[\"suffixarray\",{\"1\":{\"43\":1}}],[\"sunionstore\",{\"1\":{\"474\":1}}],[\"sunion\",{\"1\":{\"474\":1}}],[\"sundheit\",{\"1\":{\"47\":1}}],[\"succ\",{\"1\":{\"435\":2,\"436\":1,\"437\":1,\"438\":1}}],[\"successful\",{\"1\":{\"411\":1,\"413\":1,\"414\":1}}],[\"such\",{\"1\":{\"208\":2,\"219\":1,\"222\":2}}],[\"sushi\",{\"1\":{\"378\":1}}],[\"support\",{\"1\":{\"309\":1}}],[\"superset\",{\"1\":{\"208\":1}}],[\"substr\",{\"1\":{\"598\":1,\"599\":1,\"604\":2}}],[\"subscribe\",{\"1\":{\"486\":1}}],[\"sub\",{\"1\":{\"233\":1,\"258\":2,\"260\":1,\"336\":1,\"629\":1}}],[\"subtraction\",{\"1\":{\"101\":1}}],[\"subtle\",{\"1\":{\"43\":1}}],[\"sure\",{\"1\":{\"222\":2}}],[\"sumint\",{\"1\":{\"390\":5,\"391\":1,\"392\":1}}],[\"sum是经过gosumdb查询记录的\",{\"1\":{\"379\":1}}],[\"sum是c语言中的函数\",{\"1\":{\"218\":1}}],[\"sum中记录的哈希值进行比对\",{\"1\":{\"379\":1}}],[\"sumdb\",{\"1\":{\"379\":1}}],[\"sum文件\",{\"1\":{\"379\":1}}],[\"sum文件都有可能被修改过\",{\"1\":{\"379\":1}}],[\"sum文件中\",{\"1\":{\"379\":1}}],[\"sum文件插入两条记录\",{\"1\":{\"379\":1}}],[\"sum文件并不适合人类阅读\",{\"1\":{\"379\":1}}],[\"sum文件在创建项目之初并不会存在\",{\"1\":{\"379\":1}}],[\"sum的文件\",{\"1\":{\"372\":1}}],[\"sumpositive\",{\"1\":{\"309\":1}}],[\"sumany\",{\"1\":{\"256\":1}}],[\"sumandmul\",{\"1\":{\"199\":2}}],[\"sumfloat64\",{\"1\":{\"256\":1}}],[\"sum就是sum\",{\"1\":{\"231\":1}}],[\"sum函数早在延迟调用被执行以前就被调用了\",{\"1\":{\"204\":1}}],[\"sum函数返回一个int类型的值\",{\"1\":{\"199\":1}}],[\"summer\",{\"1\":{\"132\":3}}],[\"sum\",{\"0\":{\"379\":1},\"1\":{\"127\":2,\"197\":3,\"199\":2,\"202\":2,\"204\":6,\"217\":4,\"218\":9,\"219\":16,\"231\":10,\"232\":5,\"233\":11,\"245\":1,\"256\":5,\"258\":4,\"260\":1,\"307\":5,\"372\":1,\"390\":14,\"391\":2,\"392\":17,\"393\":2}}],[\"scard\",{\"1\":{\"473\":1}}],[\"scanf\",{\"1\":{\"143\":1}}],[\"scanln\",{\"1\":{\"143\":2}}],[\"scan\",{\"1\":{\"143\":2,\"145\":5,\"454\":1}}],[\"scanner与bufio\",{\"1\":{\"145\":1}}],[\"scanner\",{\"0\":{\"145\":1},\"1\":{\"43\":2,\"145\":3}}],[\"score\",{\"1\":{\"148\":20,\"480\":2,\"483\":1}}],[\"scoring\",{\"1\":{\"61\":1}}],[\"scheme\",{\"1\":{\"538\":1}}],[\"schar\",{\"1\":{\"223\":3}}],[\"school\",{\"1\":{\"124\":1,\"189\":6,\"627\":4,\"628\":4}}],[\"schneier的应用密码学\",{\"1\":{\"43\":1}}],[\"sciter\",{\"1\":{\"57\":1}}],[\"scp\",{\"1\":{\"51\":1}}],[\"scriptexists\",{\"1\":{\"485\":1}}],[\"scriptkill\",{\"1\":{\"485\":1}}],[\"scriptflush\",{\"1\":{\"485\":1}}],[\"scriptload\",{\"1\":{\"485\":1}}],[\"script引擎\",{\"1\":{\"57\":1}}],[\"script\",{\"1\":{\"43\":1,\"373\":1}}],[\"s\",{\"1\":{\"43\":1,\"132\":2,\"140\":9,\"143\":3,\"148\":2,\"170\":7,\"177\":3,\"202\":3,\"206\":23,\"212\":2,\"221\":1,\"222\":14,\"225\":8,\"228\":2,\"229\":4,\"241\":6,\"246\":6,\"257\":9,\"258\":3,\"263\":26,\"310\":2,\"312\":1,\"319\":1,\"321\":2,\"353\":8,\"365\":4,\"367\":1,\"368\":1,\"396\":8,\"415\":1,\"567\":1,\"568\":1,\"584\":2,\"586\":1,\"589\":2,\"591\":2,\"596\":1,\"598\":3,\"599\":1,\"600\":4,\"601\":1,\"602\":2,\"603\":2,\"604\":5,\"605\":3,\"606\":1,\"607\":3,\"608\":4,\"609\":4,\"610\":5,\"613\":1,\"617\":1,\"620\":2,\"643\":2,\"644\":2}}],[\"style\",{\"1\":{\"393\":1}}],[\"stop\",{\"1\":{\"242\":1,\"633\":1,\"634\":1}}],[\"stopcpuprofile\",{\"1\":{\"242\":1}}],[\"storage\",{\"1\":{\"237\":1,\"238\":1,\"239\":4}}],[\"storeint64\",{\"1\":{\"358\":1}}],[\"storeuint32\",{\"1\":{\"353\":1}}],[\"store\",{\"1\":{\"208\":2,\"355\":5,\"358\":2,\"360\":5,\"474\":4}}],[\"stuff\",{\"1\":{\"257\":4}}],[\"student\",{\"1\":{\"189\":8,\"628\":2}}],[\"stun协议\",{\"1\":{\"64\":1}}],[\"stun客户端的go实现\",{\"1\":{\"64\":1}}],[\"stun\",{\"1\":{\"64\":2}}],[\"st\",{\"1\":{\"188\":1}}],[\"starlark\",{\"1\":{\"373\":1}}],[\"starts\",{\"1\":{\"373\":1}}],[\"startcpuprofile\",{\"1\":{\"242\":1}}],[\"startcpuprofile函数\",{\"1\":{\"242\":1}}],[\"start\",{\"1\":{\"233\":2,\"242\":1,\"331\":9,\"340\":1,\"341\":2,\"408\":7,\"635\":2}}],[\"startindex\",{\"1\":{\"160\":1}}],[\"status\",{\"1\":{\"396\":2}}],[\"stat\",{\"1\":{\"319\":2,\"329\":1}}],[\"state\",{\"1\":{\"228\":6,\"319\":1}}],[\"statement以了解更多细节\",{\"1\":{\"153\":1}}],[\"statement\",{\"1\":{\"149\":1,\"152\":5,\"610\":10}}],[\"statement2\",{\"1\":{\"149\":1}}],[\"statement1\",{\"1\":{\"149\":1}}],[\"stack\",{\"1\":{\"238\":1,\"402\":1}}],[\"standard\",{\"1\":{\"43\":1,\"408\":2}}],[\"stdlib\",{\"1\":{\"222\":2}}],[\"stderr\",{\"1\":{\"134\":4,\"199\":1,\"365\":1}}],[\"stdout\",{\"0\":{\"136\":1},\"1\":{\"134\":4,\"136\":1,\"139\":2,\"142\":1,\"198\":1,\"365\":1,\"615\":2,\"617\":4,\"619\":1,\"625\":1,\"626\":1,\"628\":2}}],[\"stdin读入的文本\",{\"1\":{\"143\":1}}],[\"stdin\",{\"1\":{\"134\":4,\"142\":1,\"144\":1,\"145\":1}}],[\"stemmer\",{\"1\":{\"63\":1}}],[\"stem\",{\"1\":{\"63\":1}}],[\"stegify\",{\"1\":{\"58\":1}}],[\"steganography\",{\"1\":{\"58\":1}}],[\"stm\",{\"1\":{\"56\":1}}],[\"stl\",{\"1\":{\"51\":1,\"56\":1,\"65\":1}}],[\"stl迭代器和算法的实现\",{\"1\":{\"46\":1}}],[\"stream等之类的api\",{\"1\":{\"416\":1}}],[\"streadway\",{\"1\":{\"41\":1}}],[\"strconcat\",{\"1\":{\"394\":1}}],[\"strconv\",{\"0\":{\"582\":1},\"1\":{\"40\":1,\"43\":1,\"508\":1,\"582\":3,\"583\":1,\"584\":1,\"585\":1,\"586\":3,\"587\":2,\"588\":2,\"589\":2,\"590\":6,\"591\":3,\"592\":3,\"593\":3}}],[\"strch\",{\"1\":{\"333\":1}}],[\"str2\",{\"1\":{\"174\":5}}],[\"str\",{\"1\":{\"124\":1,\"140\":3,\"149\":8,\"172\":11,\"173\":7,\"174\":4,\"176\":8,\"177\":17,\"269\":2,\"276\":2,\"281\":3,\"317\":2,\"396\":22,\"585\":2,\"586\":1,\"603\":3,\"647\":4,\"648\":2}}],[\"structtag\",{\"1\":{\"286\":1,\"288\":2}}],[\"structfield\",{\"1\":{\"286\":9}}],[\"structfield结构的结构如下\",{\"1\":{\"286\":1}}],[\"structure\",{\"1\":{\"264\":1,\"434\":1}}],[\"struct\",{\"1\":{\"97\":1,\"120\":1,\"140\":1,\"184\":2,\"185\":1,\"186\":2,\"187\":1,\"188\":1,\"189\":6,\"191\":1,\"192\":3,\"193\":1,\"197\":1,\"200\":1,\"206\":2,\"212\":3,\"226\":6,\"236\":2,\"239\":1,\"257\":5,\"258\":2,\"259\":2,\"263\":2,\"266\":5,\"267\":1,\"270\":3,\"273\":1,\"274\":2,\"275\":2,\"285\":1,\"286\":1,\"289\":1,\"293\":1,\"310\":1,\"311\":1,\"312\":1,\"336\":9,\"340\":2,\"343\":2,\"344\":1,\"345\":1,\"346\":1,\"353\":2,\"354\":1,\"360\":1,\"382\":1,\"393\":1,\"405\":1,\"422\":1,\"424\":1,\"425\":2,\"435\":1,\"444\":1,\"510\":1,\"513\":1,\"516\":1,\"518\":1,\"537\":1,\"580\":1,\"611\":2,\"617\":2,\"640\":2,\"641\":1,\"642\":1,\"643\":1}}],[\"stringvar\",{\"1\":{\"365\":1,\"525\":1,\"528\":1}}],[\"string指针\",{\"1\":{\"196\":1}}],[\"stringdata和string在字符串与字节切片的转换过程中不涉及内存拷贝\",{\"1\":{\"648\":1}}],[\"stringdata\",{\"0\":{\"647\":1},\"1\":{\"173\":2,\"647\":2}}],[\"string=\",{\"1\":{\"140\":1}}],[\"string\",{\"0\":{\"648\":1},\"1\":{\"106\":1,\"119\":1,\"120\":1,\"124\":4,\"125\":3,\"126\":1,\"130\":2,\"132\":2,\"140\":4,\"143\":1,\"148\":2,\"172\":7,\"173\":4,\"174\":5,\"175\":5,\"176\":6,\"177\":5,\"178\":5,\"179\":3,\"180\":3,\"181\":2,\"182\":2,\"183\":2,\"185\":4,\"186\":2,\"187\":6,\"188\":5,\"189\":6,\"191\":3,\"194\":1,\"196\":2,\"197\":5,\"198\":2,\"199\":1,\"200\":1,\"210\":2,\"212\":13,\"213\":2,\"222\":19,\"228\":2,\"236\":1,\"237\":9,\"242\":1,\"257\":20,\"258\":6,\"263\":1,\"267\":4,\"269\":1,\"270\":5,\"271\":2,\"272\":1,\"274\":4,\"275\":4,\"279\":1,\"281\":2,\"285\":4,\"286\":5,\"288\":4,\"289\":10,\"292\":1,\"293\":4,\"295\":1,\"300\":2,\"302\":1,\"303\":8,\"306\":2,\"307\":3,\"308\":1,\"310\":3,\"311\":2,\"312\":3,\"313\":1,\"314\":1,\"317\":1,\"319\":3,\"320\":4,\"321\":4,\"323\":1,\"324\":2,\"327\":1,\"328\":2,\"329\":3,\"333\":1,\"338\":1,\"354\":2,\"365\":3,\"382\":4,\"392\":1,\"394\":2,\"396\":17,\"397\":1,\"404\":1,\"407\":3,\"409\":1,\"415\":3,\"422\":2,\"424\":2,\"425\":4,\"432\":1,\"433\":1,\"435\":3,\"444\":3,\"460\":1,\"485\":2,\"510\":4,\"511\":1,\"513\":4,\"514\":1,\"516\":3,\"517\":1,\"518\":3,\"519\":2,\"521\":1,\"524\":1,\"525\":2,\"527\":1,\"528\":2,\"530\":1,\"540\":2,\"541\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"574\":1,\"578\":1,\"580\":3,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"596\":2,\"597\":1,\"598\":3,\"599\":1,\"600\":3,\"601\":1,\"602\":4,\"603\":2,\"604\":5,\"605\":2,\"606\":2,\"607\":4,\"608\":8,\"609\":8,\"610\":10,\"611\":1,\"612\":1,\"613\":2,\"615\":4,\"617\":6,\"619\":1,\"620\":6,\"622\":2,\"623\":2,\"625\":9,\"626\":2,\"627\":1,\"628\":4,\"632\":1,\"640\":4,\"641\":1,\"642\":1,\"643\":2,\"647\":2,\"648\":3}}],[\"strings实现了简单的函数来操作utf\",{\"1\":{\"594\":1}}],[\"strings\",{\"0\":{\"594\":1},\"1\":{\"43\":1,\"175\":1,\"176\":1,\"271\":2,\"394\":3,\"396\":1,\"508\":1,\"578\":3,\"594\":2,\"595\":1,\"596\":1,\"597\":4,\"598\":8,\"599\":3,\"600\":1,\"601\":3,\"602\":2,\"603\":2,\"604\":5,\"605\":3,\"606\":2,\"607\":4,\"608\":4,\"609\":4,\"610\":5,\"611\":3,\"612\":1,\"613\":1}}],[\"stringutil\",{\"1\":{\"41\":1}}],[\"stripmono\",{\"1\":{\"629\":1}}],[\"strip\",{\"1\":{\"41\":1}}],[\"symbol\",{\"1\":{\"243\":2}}],[\"syntax\",{\"1\":{\"43\":1,\"521\":1,\"591\":1}}],[\"sync命令来完成\",{\"1\":{\"382\":1}}],[\"syncmap\",{\"1\":{\"355\":11}}],[\"sync包下还有一些其他的工具可以使用\",{\"1\":{\"352\":1}}],[\"sync这一个函数封装了底层的系统调用fsync\",{\"1\":{\"325\":1}}],[\"synchronization\",{\"1\":{\"247\":1}}],[\"sync\",{\"0\":{\"352\":1},\"1\":{\"40\":1,\"43\":2,\"56\":1,\"315\":1,\"319\":2,\"325\":1,\"341\":6,\"345\":1,\"346\":2,\"347\":1,\"348\":1,\"349\":3,\"350\":2,\"351\":4,\"352\":1,\"353\":3,\"354\":6,\"355\":6,\"359\":1,\"360\":2,\"383\":1,\"508\":1,\"574\":2}}],[\"sys\",{\"1\":{\"372\":2,\"378\":1}}],[\"system\",{\"1\":{\"319\":1}}],[\"systray\",{\"1\":{\"57\":1}}],[\"syslog\",{\"1\":{\"43\":1}}],[\"syscall\",{\"1\":{\"43\":1,\"134\":3,\"217\":1,\"247\":1,\"319\":8,\"508\":1}}],[\"sin\",{\"0\":{\"562\":1},\"1\":{\"562\":2}}],[\"sinterstore\",{\"1\":{\"474\":1}}],[\"sinter\",{\"1\":{\"474\":1}}],[\"singed\",{\"1\":{\"223\":1}}],[\"sismember\",{\"1\":{\"473\":1}}],[\"signedint\",{\"1\":{\"259\":7,\"260\":4}}],[\"signed\",{\"1\":{\"223\":4}}],[\"signal\",{\"1\":{\"51\":1,\"351\":1,\"508\":1}}],[\"signaturealgorithm\",{\"1\":{\"43\":1}}],[\"signature\",{\"1\":{\"43\":1}}],[\"sizeof\",{\"0\":{\"640\":1},\"1\":{\"193\":1,\"225\":2,\"272\":1,\"640\":8,\"641\":3,\"642\":3,\"645\":2,\"647\":1}}],[\"sizeof函数来计算占用的字节大小\",{\"1\":{\"193\":1}}],[\"size\",{\"0\":{\"272\":1},\"1\":{\"130\":1,\"196\":1,\"239\":1,\"262\":5,\"263\":17,\"267\":1,\"272\":6,\"415\":2}}],[\"simple\",{\"1\":{\"43\":1,\"48\":1,\"53\":1,\"367\":1}}],[\"simplejson\",{\"1\":{\"41\":1}}],[\"sirupsen\",{\"1\":{\"41\":1}}],[\"sadd\",{\"1\":{\"472\":2}}],[\"safe\",{\"1\":{\"372\":1,\"441\":1}}],[\"sample\",{\"1\":{\"245\":3}}],[\"samples\",{\"1\":{\"245\":2,\"395\":5}}],[\"samuel\",{\"1\":{\"41\":2}}],[\"sayhello函数就是待测函数\",{\"1\":{\"389\":1}}],[\"sayable\",{\"1\":{\"257\":2}}],[\"sayable是一个泛型接口\",{\"1\":{\"257\":1}}],[\"say\",{\"1\":{\"210\":1,\"212\":3,\"257\":3,\"362\":1,\"365\":1,\"367\":1,\"387\":7,\"389\":6}}],[\"said\",{\"1\":{\"208\":2}}],[\"sailfish\",{\"1\":{\"57\":1}}],[\"salary\",{\"1\":{\"187\":4,\"188\":4,\"197\":4,\"200\":4,\"406\":2,\"407\":1,\"411\":2,\"412\":1,\"413\":2,\"415\":1}}],[\"satori\",{\"1\":{\"41\":1}}],[\"sarama\",{\"1\":{\"41\":1}}],[\"saramahttps\",{\"1\":{\"41\":1}}],[\"sprig\",{\"1\":{\"614\":1}}],[\"sprintln\",{\"1\":{\"620\":1}}],[\"sprint\",{\"1\":{\"620\":1}}],[\"sprintf一致\",{\"1\":{\"617\":1}}],[\"sprintf函数来进行字符串格式化\",{\"1\":{\"614\":1}}],[\"sprintf\",{\"1\":{\"319\":1,\"365\":2,\"415\":1,\"617\":1,\"620\":3}}],[\"sprintf或者fmt\",{\"1\":{\"140\":1}}],[\"spring\",{\"1\":{\"132\":3}}],[\"splitaftern\",{\"1\":{\"608\":2}}],[\"splitafter\",{\"1\":{\"608\":2}}],[\"splitn\",{\"1\":{\"608\":2}}],[\"split\",{\"1\":{\"608\":2}}],[\"splitting\",{\"1\":{\"247\":1}}],[\"spopn\",{\"1\":{\"475\":1}}],[\"spop\",{\"1\":{\"475\":1}}],[\"spcae\",{\"1\":{\"246\":1}}],[\"space\",{\"1\":{\"245\":1,\"246\":1}}],[\"spill\",{\"1\":{\"237\":1,\"239\":2}}],[\"specialcase\",{\"1\":{\"609\":4}}],[\"specified\",{\"1\":{\"319\":1,\"373\":2}}],[\"specifies\",{\"1\":{\"208\":1}}],[\"specs\",{\"1\":{\"64\":1}}],[\"spew\",{\"1\":{\"41\":1}}],[\"spf13\",{\"1\":{\"41\":3}}],[\"shuffle\",{\"1\":{\"388\":1}}],[\"shuralyov\",{\"1\":{\"379\":1}}],[\"shell\",{\"1\":{\"373\":1}}],[\"show\",{\"1\":{\"600\":5}}],[\"showing\",{\"1\":{\"245\":1}}],[\"should\",{\"1\":{\"389\":1}}],[\"shortduration\",{\"1\":{\"389\":1}}],[\"shorthand\",{\"1\":{\"373\":1}}],[\"short\",{\"1\":{\"223\":6,\"387\":1}}],[\"shopspring\",{\"1\":{\"41\":1}}],[\"shopify\",{\"1\":{\"41\":1}}],[\"shield\",{\"1\":{\"61\":1}}],[\"shirou\",{\"1\":{\"41\":2}}],[\"shanghai\",{\"1\":{\"632\":1}}],[\"sha\",{\"1\":{\"485\":1}}],[\"shards\",{\"1\":{\"406\":3,\"407\":1,\"411\":1,\"413\":1,\"414\":1}}],[\"sharing\",{\"1\":{\"332\":1}}],[\"shared\",{\"1\":{\"231\":1}}],[\"share\",{\"1\":{\"332\":1},\"2\":{\"13\":1}}],[\"shamoji是用go编写的单词过滤程序包\",{\"1\":{\"63\":1}}],[\"shamoji\",{\"1\":{\"63\":1}}],[\"sha512\",{\"1\":{\"43\":1}}],[\"sha256\",{\"1\":{\"43\":1,\"307\":1}}],[\"sha1\",{\"1\":{\"43\":1}}],[\"seeker\",{\"1\":{\"613\":1}}],[\"seed\",{\"1\":{\"396\":7}}],[\"sep\",{\"1\":{\"600\":4,\"608\":4}}],[\"sex=false\",{\"1\":{\"528\":1}}],[\"sex\",{\"1\":{\"525\":5,\"528\":5}}],[\"se2\",{\"1\":{\"474\":1}}],[\"seq\",{\"1\":{\"411\":1,\"412\":1,\"413\":1,\"414\":1}}],[\"sequence\",{\"1\":{\"153\":2}}],[\"sema\",{\"1\":{\"319\":1}}],[\"semaphore\",{\"1\":{\"56\":2}}],[\"servehttp\",{\"1\":{\"537\":1,\"538\":1}}],[\"servermux是核心结构体\",{\"1\":{\"537\":1}}],[\"server没有设置可以为空\",{\"1\":{\"444\":1}}],[\"server的实例化方式也是采用了该设计模式\",{\"1\":{\"188\":1}}],[\"server\",{\"1\":{\"41\":1,\"64\":2,\"243\":1,\"247\":1,\"250\":2,\"373\":2,\"536\":3}}],[\"serving\",{\"1\":{\"372\":1}}],[\"services\",{\"1\":{\"370\":1}}],[\"servre\",{\"1\":{\"243\":2}}],[\"search\",{\"1\":{\"177\":1,\"404\":1,\"415\":10}}],[\"season\",{\"1\":{\"132\":4}}],[\"sec表示多少个输入每秒\",{\"1\":{\"396\":1}}],[\"sec\",{\"1\":{\"395\":4,\"396\":11,\"629\":1}}],[\"second\",{\"1\":{\"145\":2,\"242\":2,\"338\":1,\"340\":4,\"345\":1,\"346\":2,\"347\":1,\"389\":1,\"396\":16,\"408\":3,\"449\":2,\"450\":1,\"617\":2,\"622\":2,\"630\":2,\"633\":1,\"634\":1,\"635\":1}}],[\"secsh\",{\"1\":{\"64\":1}}],[\"select会忽略掉nil管道\",{\"1\":{\"345\":1}}],[\"select会伪随机的选择一个case来执行\",{\"1\":{\"340\":1}}],[\"select由于没有默认分支\",{\"1\":{\"340\":1}}],[\"select由多个case和一个default组成\",{\"1\":{\"340\":1}}],[\"select的语法与switch语句类似\",{\"1\":{\"340\":1}}],[\"select是一种管道多路复用的控制结构\",{\"1\":{\"340\":1}}],[\"select在linux系统中\",{\"1\":{\"340\":1}}],[\"select相对前两者而言比较特殊\",{\"1\":{\"146\":1}}],[\"select\",{\"0\":{\"340\":1},\"1\":{\"97\":1,\"146\":1,\"340\":7,\"345\":1,\"346\":4,\"347\":1,\"389\":1,\"435\":3,\"633\":1,\"634\":1}}],[\"segment\",{\"1\":{\"63\":1}}],[\"send\",{\"1\":{\"338\":1,\"340\":8}}],[\"sendgrid的go库\",{\"1\":{\"48\":1}}],[\"sendgrid\",{\"1\":{\"48\":1}}],[\"sentences\",{\"1\":{\"63\":1}}],[\"sentinel\",{\"0\":{\"33\":1}}],[\"sensorbee\",{\"1\":{\"59\":1}}],[\"sessions\",{\"1\":{\"41\":1}}],[\"session\",{\"1\":{\"41\":1,\"373\":1}}],[\"setloc\",{\"1\":{\"629\":1}}],[\"setlimit\",{\"1\":{\"425\":1}}],[\"setoutput\",{\"1\":{\"541\":1}}],[\"setflags\",{\"1\":{\"541\":2}}],[\"setprefix\",{\"1\":{\"540\":2}}],[\"set2\",{\"1\":{\"472\":1,\"474\":4,\"476\":1}}],[\"setsort\",{\"1\":{\"425\":1}}],[\"setstring\",{\"1\":{\"287\":1,\"292\":1}}],[\"settings\",{\"1\":{\"406\":2,\"407\":1}}],[\"setter\",{\"1\":{\"89\":1}}],[\"setup\",{\"1\":{\"392\":4}}],[\"setuid\",{\"1\":{\"319\":1}}],[\"setblockprofilerate查看更多细节\",{\"1\":{\"388\":1}}],[\"setmode\",{\"1\":{\"372\":1}}],[\"setmapindex\",{\"1\":{\"295\":1}}],[\"setgid\",{\"1\":{\"319\":1}}],[\"setint\",{\"1\":{\"280\":1,\"287\":1,\"294\":1}}],[\"set和len\",{\"1\":{\"204\":1}}],[\"set是一种无序的\",{\"1\":{\"184\":1}}],[\"set\",{\"0\":{\"184\":1},\"1\":{\"11\":1,\"46\":2,\"184\":3,\"204\":2,\"205\":4,\"206\":9,\"208\":4,\"221\":2,\"259\":2,\"280\":1,\"372\":1,\"388\":1,\"434\":7,\"437\":1,\"443\":1,\"448\":1,\"449\":1,\"450\":1,\"456\":1,\"458\":1,\"472\":1,\"473\":4,\"474\":6,\"475\":2,\"476\":1,\"477\":1,\"478\":1}}],[\"socket写超时时间\",{\"1\":{\"444\":1}}],[\"socket读取超时时间\",{\"1\":{\"444\":1}}],[\"so\",{\"1\":{\"389\":1}}],[\"soon\",{\"1\":{\"389\":1}}],[\"sonic\",{\"1\":{\"372\":2,\"378\":2,\"379\":4}}],[\"son\",{\"1\":{\"236\":6}}],[\"some\",{\"1\":{\"312\":1}}],[\"something\",{\"1\":{\"213\":2,\"333\":1}}],[\"somthing\",{\"1\":{\"212\":1}}],[\"sox\",{\"1\":{\"45\":1}}],[\"sortslice\",{\"1\":{\"241\":2,\"245\":1,\"246\":3}}],[\"sortfunc接受两个参数\",{\"1\":{\"200\":1}}],[\"sortfunc\",{\"1\":{\"200\":1}}],[\"sort\",{\"0\":{\"575\":1},\"1\":{\"43\":1,\"241\":1,\"246\":1,\"425\":1,\"508\":1,\"576\":1,\"577\":1,\"578\":1,\"579\":4,\"580\":2,\"581\":3}}],[\"software\",{\"1\":{\"11\":1}}],[\"source\",{\"1\":{\"11\":1,\"246\":1,\"412\":1}}],[\"<b>html<\",{\"1\":{\"612\":1}}],[\"<address>usa<\",{\"1\":{\"511\":1,\"512\":1}}],[\"<age>18<\",{\"1\":{\"511\":1,\"512\":1}}],[\"<alphanum>\",{\"1\":{\"408\":7}}],[\"<name>jack<\",{\"1\":{\"511\":1,\"512\":1}}],[\"<nil>\",{\"1\":{\"194\":1,\"211\":1,\"319\":1,\"427\":1,\"460\":1,\"584\":1,\"586\":3,\"589\":2,\"591\":1}}],[\"<id>120<\",{\"1\":{\"511\":1,\"512\":1}}],[\"<person>\",{\"1\":{\"511\":1,\"512\":1}}],[\"<stdlib\",{\"1\":{\"222\":4}}],[\"<stdint\",{\"1\":{\"217\":1,\"219\":3,\"225\":2,\"226\":1,\"227\":1,\"228\":1,\"229\":2,\"231\":2,\"233\":1}}],[\"<stdio\",{\"1\":{\"216\":1,\"217\":2,\"219\":3,\"220\":1,\"221\":1,\"222\":4,\"223\":1,\"224\":1,\"225\":2,\"226\":1,\"227\":1,\"228\":1,\"229\":2}}],[\"<errno\",{\"1\":{\"217\":1}}],[\"<=\",{\"1\":{\"98\":1,\"149\":3,\"152\":4,\"154\":2,\"169\":2,\"217\":2,\"263\":1,\"309\":2}}],[\"<\",{\"1\":{\"98\":1,\"111\":2,\"140\":1,\"148\":10,\"149\":3,\"152\":3,\"154\":4,\"155\":4,\"167\":1,\"168\":1,\"177\":4,\"184\":1,\"185\":3,\"188\":1,\"200\":1,\"201\":1,\"225\":2,\"233\":1,\"241\":1,\"245\":1,\"246\":2,\"263\":5,\"286\":1,\"289\":4,\"294\":1,\"304\":4,\"321\":2,\"327\":1,\"331\":4,\"334\":6,\"335\":4,\"336\":19,\"337\":10,\"338\":5,\"339\":8,\"340\":26,\"341\":1,\"343\":2,\"344\":1,\"345\":2,\"346\":5,\"347\":1,\"348\":1,\"349\":1,\"350\":2,\"351\":3,\"353\":1,\"354\":1,\"355\":4,\"389\":2,\"394\":4,\"396\":3,\"511\":1,\"580\":1,\"605\":1,\"612\":1,\"633\":1,\"634\":2,\"645\":2,\"647\":1}}],[\"<<\",{\"1\":{\"98\":1,\"131\":1,\"195\":8,\"241\":1,\"246\":1,\"541\":1,\"543\":6,\"630\":1}}],[\"<target>\",{\"1\":{\"11\":1}}],[\"<command>\",{\"1\":{\"11\":1}}],[\"软件包publicip返回您的面向公众的ipv4地址\",{\"1\":{\"64\":1}}],[\"软件包goshark使用tshark解码ip数据包并创建数据结构以分析数据包\",{\"1\":{\"64\":1}}],[\"软件包golibwireshark使用libwireshark库来解码pcap文件并分析解剖数据\",{\"1\":{\"64\":1}}],[\"软件包fasthttp是go的一种快速http实现\",{\"1\":{\"64\":1}}],[\"软件包dhcp6实现了dhcpv6服务器\",{\"1\":{\"64\":1}}],[\"软件包tga是targa图像格式的解码器\",{\"1\":{\"58\":1}}],[\"软件包\",{\"1\":{\"50\":1,\"61\":1}}],[\"软件\",{\"1\":{\"11\":1}}],[\"m=+3\",{\"1\":{\"634\":1}}],[\"m=+2\",{\"1\":{\"634\":1,\"635\":1}}],[\"m=+1\",{\"1\":{\"633\":1,\"634\":1}}],[\"m=+0\",{\"1\":{\"629\":1,\"635\":1}}],[\"mm\",{\"1\":{\"631\":1}}],[\"mmsego\",{\"1\":{\"63\":1}}],[\"mxs\",{\"1\":{\"573\":2}}],[\"mget\",{\"1\":{\"457\":1}}],[\"mgutz\",{\"1\":{\"41\":1}}],[\"mkdirall\",{\"1\":{\"328\":1,\"329\":1}}],[\"mkdir\",{\"1\":{\"328\":2}}],[\"m\",{\"1\":{\"181\":1,\"183\":7,\"236\":5,\"237\":2,\"238\":2,\"239\":4,\"242\":1,\"274\":1,\"275\":1,\"312\":2,\"353\":22,\"354\":1,\"355\":6,\"368\":6,\"375\":1,\"378\":1,\"422\":3,\"425\":1}}],[\"myhandler\",{\"1\":{\"537\":3}}],[\"myerr\",{\"1\":{\"312\":3}}],[\"mymap\",{\"1\":{\"302\":1,\"303\":4,\"355\":2}}],[\"myfloat64\",{\"1\":{\"302\":4,\"304\":2}}],[\"my\",{\"1\":{\"274\":3,\"275\":3,\"378\":2,\"537\":1,\"609\":4}}],[\"myinterface\",{\"1\":{\"274\":2,\"275\":2}}],[\"myint\",{\"1\":{\"205\":12,\"206\":8,\"302\":2}}],[\"mysocket\",{\"1\":{\"572\":1}}],[\"myslice\",{\"1\":{\"353\":8}}],[\"mystruct\",{\"1\":{\"274\":3,\"275\":3}}],[\"mystem的绑定\",{\"1\":{\"63\":1}}],[\"mystem\",{\"1\":{\"63\":1}}],[\"mysql是当下最流行的开源关系型数据库\",{\"1\":{\"431\":1}}],[\"mysql\",{\"0\":{\"431\":1},\"1\":{\"94\":1,\"432\":1,\"433\":1,\"435\":2,\"513\":1,\"515\":1}}],[\"mysalary\",{\"1\":{\"93\":1}}],[\"myname\",{\"1\":{\"93\":1,\"94\":1}}],[\"m3u8播放列表的解析器和生成器库\",{\"1\":{\"65\":1}}],[\"m3u8\",{\"1\":{\"65\":2}}],[\"md2man\",{\"1\":{\"373\":1}}],[\"md\",{\"1\":{\"368\":2,\"376\":1,\"382\":1}}],[\"mdns\",{\"1\":{\"64\":1}}],[\"md5\",{\"1\":{\"43\":1}}],[\"mp\",{\"1\":{\"60\":1,\"178\":7,\"179\":9,\"180\":16,\"181\":11,\"182\":7,\"185\":3,\"640\":2}}],[\"mpo\",{\"1\":{\"58\":1}}],[\"mp3解码器\",{\"1\":{\"45\":1}}],[\"mp3\",{\"1\":{\"45\":1}}],[\"mset\",{\"1\":{\"457\":1}}],[\"msg\",{\"1\":{\"130\":1,\"257\":2,\"285\":2,\"293\":2,\"311\":2,\"312\":5,\"365\":2}}],[\"msgfmt\",{\"1\":{\"41\":2}}],[\"mspm\",{\"1\":{\"46\":1}}],[\"mcache\",{\"1\":{\"46\":1}}],[\"mutator\",{\"1\":{\"247\":1}}],[\"mutex是go提供的互斥锁实现\",{\"1\":{\"349\":1}}],[\"mutexprofilefraction\",{\"1\":{\"388\":1}}],[\"mutexprofile\",{\"1\":{\"242\":1,\"388\":1}}],[\"mutex\",{\"1\":{\"242\":1,\"243\":1,\"319\":1,\"331\":1,\"349\":1,\"353\":1,\"359\":1,\"388\":1}}],[\"multithreading\",{\"1\":{\"56\":1}}],[\"multierror\",{\"1\":{\"50\":1}}],[\"multipart\",{\"1\":{\"43\":1}}],[\"music\",{\"1\":{\"45\":1}}],[\"mux\",{\"1\":{\"41\":1,\"243\":3}}],[\"marshalindent\",{\"1\":{\"510\":1,\"511\":1,\"519\":2}}],[\"marshaling\",{\"1\":{\"386\":2}}],[\"marshal\",{\"1\":{\"510\":1,\"513\":1,\"514\":1,\"516\":1,\"517\":1,\"521\":1,\"531\":1}}],[\"mariadb\",{\"1\":{\"432\":1}}],[\"markup\",{\"1\":{\"510\":1}}],[\"mark\",{\"1\":{\"427\":2}}],[\"master\",{\"1\":{\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1}}],[\"may\",{\"1\":{\"389\":1}}],[\"major\",{\"1\":{\"374\":2}}],[\"malloc\",{\"1\":{\"222\":2}}],[\"malgo\",{\"1\":{\"45\":1}}],[\"manual\",{\"1\":{\"418\":1}}],[\"man接口方法集是person的超集\",{\"1\":{\"212\":1}}],[\"man\",{\"1\":{\"212\":1,\"640\":2}}],[\"make函数接收两个参数\",{\"1\":{\"333\":1}}],[\"make函数接收三个参数\",{\"1\":{\"162\":1}}],[\"makefunc\",{\"1\":{\"297\":2}}],[\"makechan\",{\"1\":{\"296\":4}}],[\"makemapwithsize\",{\"1\":{\"295\":2}}],[\"makeslice\",{\"1\":{\"241\":2,\"245\":3,\"246\":3,\"294\":2}}],[\"make\",{\"1\":{\"143\":1,\"162\":1,\"163\":1,\"166\":1,\"168\":3,\"175\":1,\"178\":2,\"180\":3,\"181\":1,\"182\":1,\"184\":1,\"185\":1,\"196\":4,\"206\":3,\"237\":6,\"238\":5,\"239\":5,\"257\":1,\"298\":2,\"320\":1,\"331\":2,\"333\":3,\"334\":1,\"335\":2,\"336\":7,\"337\":5,\"338\":1,\"339\":3,\"340\":14,\"353\":2,\"355\":1,\"574\":1,\"613\":1,\"640\":2}}],[\"maxduration\",{\"1\":{\"630\":1}}],[\"maxfloat64\",{\"1\":{\"544\":1}}],[\"maxfloat32\",{\"1\":{\"544\":1}}],[\"maxuint64\",{\"1\":{\"543\":1}}],[\"maxuint32\",{\"1\":{\"543\":1}}],[\"maxuint16\",{\"1\":{\"543\":1}}],[\"maxuint8\",{\"1\":{\"543\":1}}],[\"maxuint\",{\"1\":{\"543\":1}}],[\"maxint64\",{\"1\":{\"543\":1}}],[\"maxint32\",{\"1\":{\"543\":1}}],[\"maxint16\",{\"1\":{\"543\":1}}],[\"maxint\",{\"1\":{\"543\":1}}],[\"maxint8\",{\"1\":{\"221\":2,\"543\":1}}],[\"maxheaderbytes\",{\"1\":{\"536\":1}}],[\"maxconnage\",{\"1\":{\"444\":1}}],[\"maxretrybackoff\",{\"1\":{\"444\":1}}],[\"maxretries\",{\"1\":{\"444\":1}}],[\"max\",{\"1\":{\"128\":1,\"169\":2,\"283\":2,\"284\":1,\"482\":1,\"546\":1}}],[\"maxval\",{\"1\":{\"128\":1}}],[\"max函数只支持浮点数\",{\"1\":{\"128\":1}}],[\"mac地址\",{\"0\":{\"567\":1}}],[\"mac\",{\"1\":{\"57\":2}}],[\"macos\",{\"1\":{\"57\":4,\"72\":1}}],[\"macho\",{\"1\":{\"43\":1}}],[\"mainwait\",{\"1\":{\"341\":8}}],[\"mainflux\",{\"1\":{\"59\":1}}],[\"main\",{\"1\":{\"56\":1,\"91\":2,\"94\":7,\"95\":1,\"96\":2,\"106\":1,\"108\":2,\"125\":2,\"128\":3,\"129\":2,\"133\":2,\"136\":2,\"137\":2,\"138\":2,\"139\":2,\"140\":2,\"142\":1,\"143\":2,\"144\":1,\"145\":1,\"147\":3,\"148\":2,\"149\":4,\"150\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":2,\"155\":2,\"160\":3,\"166\":1,\"167\":2,\"169\":1,\"170\":3,\"172\":5,\"173\":3,\"174\":2,\"175\":2,\"176\":3,\"177\":5,\"178\":1,\"179\":3,\"180\":3,\"181\":2,\"182\":2,\"183\":2,\"184\":1,\"185\":1,\"188\":2,\"193\":1,\"194\":6,\"195\":3,\"200\":2,\"201\":2,\"202\":3,\"203\":1,\"204\":6,\"205\":2,\"206\":6,\"211\":1,\"212\":2,\"213\":3,\"216\":4,\"217\":4,\"218\":2,\"219\":4,\"220\":2,\"221\":3,\"222\":8,\"223\":2,\"224\":2,\"225\":4,\"226\":3,\"227\":3,\"228\":2,\"229\":4,\"231\":6,\"232\":3,\"233\":2,\"236\":14,\"237\":16,\"238\":7,\"239\":22,\"242\":6,\"243\":4,\"245\":7,\"257\":1,\"259\":3,\"260\":1,\"263\":1,\"269\":1,\"270\":1,\"271\":2,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"279\":2,\"280\":1,\"281\":1,\"283\":1,\"284\":1,\"286\":2,\"287\":2,\"288\":1,\"289\":5,\"290\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"298\":2,\"300\":2,\"307\":3,\"312\":9,\"313\":1,\"314\":1,\"315\":5,\"316\":3,\"317\":1,\"319\":4,\"320\":3,\"321\":3,\"322\":3,\"323\":1,\"324\":2,\"325\":1,\"327\":2,\"328\":1,\"331\":5,\"333\":1,\"334\":1,\"335\":2,\"336\":4,\"337\":8,\"338\":2,\"339\":3,\"340\":7,\"341\":3,\"345\":1,\"346\":2,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"353\":1,\"354\":1,\"355\":3,\"356\":1,\"358\":2,\"360\":2,\"365\":3,\"367\":2,\"368\":12,\"372\":3,\"373\":1,\"382\":3,\"396\":1,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":3,\"421\":2,\"435\":1,\"439\":1,\"511\":1,\"512\":1,\"514\":1,\"515\":1,\"517\":1,\"519\":1,\"520\":1,\"521\":2,\"528\":4,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"536\":1,\"537\":2,\"538\":1,\"539\":1,\"540\":2,\"541\":1,\"567\":2,\"568\":2,\"569\":2,\"570\":2,\"571\":2,\"572\":2,\"573\":4,\"574\":4,\"576\":1,\"577\":1,\"578\":1,\"579\":1,\"580\":1,\"581\":1,\"615\":2,\"617\":4,\"619\":1,\"625\":1,\"626\":1,\"628\":1,\"632\":1,\"633\":1,\"634\":1,\"635\":1,\"640\":1,\"641\":1,\"642\":1,\"643\":4,\"644\":1,\"645\":2,\"646\":1,\"647\":1,\"648\":1}}],[\"mailservice\",{\"1\":{\"346\":2}}],[\"mailhog\",{\"1\":{\"48\":1}}],[\"mailgun\",{\"1\":{\"48\":1}}],[\"mailchain\",{\"1\":{\"48\":1}}],[\"mail\",{\"1\":{\"43\":3,\"48\":1,\"346\":8,\"521\":4}}],[\"mapping\",{\"1\":{\"605\":1}}],[\"mappings\",{\"1\":{\"406\":2,\"407\":1}}],[\"map操作包\",{\"1\":{\"508\":1}}],[\"maps\",{\"1\":{\"508\":1}}],[\"map就可以避免这个问题\",{\"1\":{\"355\":1}}],[\"map是官方提供的一种并发安全map的实现\",{\"1\":{\"355\":1}}],[\"map是引用类型\",{\"1\":{\"178\":1}}],[\"map并不会\",{\"1\":{\"239\":1}}],[\"map并不是一个并发安全的数据结构\",{\"1\":{\"185\":1}}],[\"map类型\",{\"1\":{\"213\":1}}],[\"map来替代\",{\"1\":{\"185\":1}}],[\"map内部有读写检测机制\",{\"1\":{\"185\":1}}],[\"map存值的方式也类似数组存值一样\",{\"1\":{\"180\":1}}],[\"map对于不存的键其返回值是对应类型的零值\",{\"1\":{\"179\":1}}],[\"map的性能要比map低10\",{\"1\":{\"355\":1}}],[\"map的基本使用\",{\"1\":{\"355\":1}}],[\"map的键类型必须是可比较的\",{\"1\":{\"178\":1}}],[\"map的实现是基于哈希桶\",{\"1\":{\"177\":1}}],[\"map\",{\"0\":{\"295\":1,\"355\":1},\"1\":{\"47\":1,\"97\":1,\"120\":1,\"178\":7,\"179\":3,\"180\":4,\"181\":7,\"182\":2,\"183\":3,\"184\":2,\"185\":3,\"196\":1,\"213\":3,\"242\":1,\"257\":1,\"270\":3,\"271\":1,\"279\":4,\"295\":2,\"302\":1,\"303\":6,\"313\":2,\"355\":10,\"422\":1,\"460\":7,\"461\":1,\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"605\":5,\"615\":1,\"617\":5,\"619\":1,\"620\":2,\"622\":2,\"623\":2,\"624\":1,\"625\":6,\"626\":1,\"627\":1,\"628\":1,\"640\":2}}],[\"mafsa\",{\"1\":{\"46\":1}}],[\"matchedcount\",{\"1\":{\"427\":1}}],[\"match\",{\"1\":{\"415\":1}}],[\"mattn\",{\"1\":{\"372\":2,\"373\":1,\"378\":1}}],[\"matter\",{\"1\":{\"0\":1}}],[\"math包下远不止以上函数\",{\"1\":{\"564\":1}}],[\"math是go中的基本数学操作库\",{\"1\":{\"542\":1}}],[\"math\",{\"0\":{\"542\":1},\"1\":{\"43\":2,\"180\":4,\"181\":4,\"182\":3,\"199\":1,\"221\":2,\"390\":1,\"508\":5,\"546\":1,\"547\":1,\"548\":1,\"549\":2,\"550\":2,\"551\":3,\"552\":2,\"553\":1,\"554\":1,\"555\":2,\"556\":4,\"557\":1,\"558\":2,\"559\":1,\"560\":2,\"561\":4,\"562\":2,\"563\":2,\"564\":2}}],[\"meet\",{\"1\":{\"396\":4,\"609\":4}}],[\"methodbyname\",{\"1\":{\"290\":1}}],[\"method结构体如下\",{\"1\":{\"289\":1}}],[\"methods\",{\"1\":{\"266\":1}}],[\"method\",{\"1\":{\"206\":1,\"208\":2,\"226\":1,\"289\":17}}],[\"metrics\",{\"1\":{\"41\":3,\"247\":1}}],[\"mercurial\",{\"1\":{\"362\":1}}],[\"mergi\",{\"1\":{\"58\":1}}],[\"merkle树的实现\",{\"1\":{\"46\":1}}],[\"merkletree\",{\"1\":{\"46\":1}}],[\"member\",{\"1\":{\"480\":2,\"483\":1}}],[\"memprofilerate查看更多细节\",{\"1\":{\"388\":1}}],[\"memprofilerate\",{\"1\":{\"388\":1}}],[\"memprofile\",{\"1\":{\"388\":1}}],[\"memory\",{\"1\":{\"332\":2,\"643\":1}}],[\"mem\",{\"1\":{\"51\":1,\"388\":1}}],[\"memcached\",{\"1\":{\"46\":1}}],[\"memcache\",{\"1\":{\"46\":1}}],[\"mediainfo\",{\"1\":{\"45\":1}}],[\"message\",{\"1\":{\"43\":1,\"48\":1,\"365\":1,\"486\":1,\"521\":1,\"615\":3}}],[\"mvdan\",{\"1\":{\"41\":1}}],[\"more\",{\"1\":{\"373\":1}}],[\"mort\",{\"1\":{\"58\":1}}],[\"moved\",{\"1\":{\"236\":1}}],[\"mom\",{\"1\":{\"236\":8}}],[\"modifiedcount\",{\"1\":{\"427\":1}}],[\"mod中的指令\",{\"1\":{\"384\":1}}],[\"mod中指定的本地依赖计算哈希值\",{\"1\":{\"379\":1}}],[\"mod大多数工具都是针对开源项目而言的\",{\"1\":{\"380\":1}}],[\"mod两个文件的哈希值\",{\"1\":{\"379\":1}}],[\"mod会表现出不同的行为\",{\"1\":{\"378\":1}}],[\"mod目录下\",{\"1\":{\"376\":1}}],[\"mod进行项目管理时\",{\"1\":{\"376\":1}}],[\"modcache\",{\"1\":{\"375\":1,\"376\":1}}],[\"mod仅仅只有这些是完全不够的\",{\"1\":{\"374\":1}}],[\"mod的基本使用\",{\"1\":{\"374\":1}}],[\"mod文件引用最新版本\",{\"1\":{\"382\":1}}],[\"mod文件将依赖重定向到本地文件\",{\"1\":{\"382\":1}}],[\"mod文件为指定版本\",{\"1\":{\"382\":1}}],[\"mod文件的情况下导入其它模块\",{\"1\":{\"382\":1}}],[\"mod文件的内容\",{\"1\":{\"381\":1}}],[\"mod文件的哈希值\",{\"1\":{\"379\":1}}],[\"mod文件支持replace指令\",{\"1\":{\"381\":1}}],[\"mod文件是无法保证的\",{\"1\":{\"379\":1}}],[\"mod文件是非常有必要的\",{\"1\":{\"378\":1}}],[\"mod文件中\",{\"1\":{\"378\":1}}],[\"mod文件中只能出现一个module关键字\",{\"1\":{\"378\":1}}],[\"mod文件可以发现它的module名\",{\"1\":{\"378\":1}}],[\"mod文件加载的\",{\"1\":{\"377\":1}}],[\"mod文件会发现没有了gin依赖\",{\"1\":{\"372\":1}}],[\"mod文件\",{\"1\":{\"372\":1,\"375\":1,\"378\":2,\"379\":3,\"382\":1}}],[\"mod文件所在的路径\",{\"1\":{\"319\":1}}],[\"mod=mod\",{\"1\":{\"369\":1}}],[\"mod项目都会生成一个go\",{\"1\":{\"378\":1}}],[\"mod项目\",{\"1\":{\"362\":1}}],[\"module关键字声明了当前项目的模块名\",{\"1\":{\"378\":1}}],[\"module项目共享该目录下的缓存\",{\"1\":{\"376\":1}}],[\"module\",{\"1\":{\"363\":2,\"364\":1,\"372\":1,\"378\":5}}],[\"module本质上是基于vcs\",{\"1\":{\"362\":1}}],[\"modules\",{\"1\":{\"85\":1,\"361\":1,\"370\":1}}],[\"mod这款官方的依赖管理工具\",{\"1\":{\"361\":1}}],[\"mode=release\",{\"1\":{\"372\":1}}],[\"modeperm\",{\"1\":{\"319\":2}}],[\"modetype\",{\"1\":{\"319\":2}}],[\"modetemporary\",{\"1\":{\"319\":2}}],[\"modeirregular\",{\"1\":{\"319\":2}}],[\"modechardevice\",{\"1\":{\"319\":2}}],[\"modesticky\",{\"1\":{\"319\":2}}],[\"modesetgid\",{\"1\":{\"319\":2}}],[\"modesetuid\",{\"1\":{\"319\":2}}],[\"modesocket\",{\"1\":{\"319\":2}}],[\"modesymlink\",{\"1\":{\"319\":2}}],[\"modenamedpipe\",{\"1\":{\"319\":2}}],[\"modedevice\",{\"1\":{\"319\":3}}],[\"modedir\",{\"1\":{\"319\":2}}],[\"modeexclusive\",{\"1\":{\"319\":2}}],[\"modeappend\",{\"1\":{\"319\":2}}],[\"mode\",{\"1\":{\"245\":1,\"329\":7,\"368\":5,\"372\":2}}],[\"modernc\",{\"1\":{\"379\":1}}],[\"modern\",{\"1\":{\"41\":3,\"372\":4,\"378\":2}}],[\"mod\",{\"0\":{\"378\":1},\"1\":{\"231\":1,\"361\":2,\"363\":1,\"364\":3,\"368\":9,\"372\":3,\"375\":9,\"376\":2,\"378\":3,\"379\":5,\"549\":2}}],[\"monday\",{\"1\":{\"631\":1}}],[\"mongo还提供了replace\",{\"1\":{\"427\":1}}],[\"mongo\",{\"1\":{\"419\":2,\"420\":2,\"421\":7,\"422\":2,\"423\":2,\"426\":2,\"427\":2,\"428\":2,\"429\":3}}],[\"mongodb在go里面使用了以下几种类型来映射数据库中的文档\",{\"1\":{\"422\":1}}],[\"mongodb在go这方面的库比较少\",{\"1\":{\"419\":1}}],[\"mongodb文档\",{\"1\":{\"418\":1}}],[\"mongodb是一个文档数据库\",{\"1\":{\"418\":1}}],[\"mongodb\",{\"0\":{\"418\":1},\"1\":{\"379\":1,\"418\":2,\"419\":4,\"420\":1,\"421\":4,\"422\":1,\"423\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1}}],[\"money\",{\"1\":{\"52\":1,\"285\":1,\"286\":3,\"287\":7,\"293\":1}}],[\"monkey\",{\"1\":{\"41\":1}}],[\"mock\",{\"1\":{\"41\":2}}],[\"mohae\",{\"1\":{\"41\":1}}],[\"mit\",{\"1\":{\"627\":2,\"628\":2}}],[\"middleware\",{\"0\":{\"661\":1},\"1\":{\"372\":1}}],[\"mib\",{\"1\":{\"368\":1}}],[\"millisecond\",{\"1\":{\"315\":2,\"331\":6,\"336\":1,\"340\":2,\"345\":1,\"346\":4,\"347\":1,\"348\":2,\"349\":2,\"350\":4,\"351\":4,\"630\":2}}],[\"miki\",{\"1\":{\"263\":1}}],[\"mike\",{\"1\":{\"188\":1,\"257\":1,\"263\":1,\"298\":5,\"423\":1,\"425\":2,\"580\":1,\"581\":1,\"622\":1}}],[\"missing\",{\"1\":{\"130\":1,\"140\":1}}],[\"mismatched\",{\"1\":{\"128\":1,\"300\":1,\"302\":1}}],[\"mix\",{\"1\":{\"45\":1}}],[\"minute\",{\"1\":{\"630\":2}}],[\"minduration\",{\"1\":{\"630\":1}}],[\"minint64\",{\"1\":{\"543\":1}}],[\"minint32\",{\"1\":{\"543\":1}}],[\"minint16\",{\"1\":{\"543\":1}}],[\"minint8\",{\"1\":{\"543\":1}}],[\"minint\",{\"1\":{\"543\":1}}],[\"minidleconns\",{\"1\":{\"444\":1}}],[\"minimizing\",{\"1\":{\"396\":2}}],[\"minimum\",{\"1\":{\"247\":1,\"404\":2}}],[\"minimp3\",{\"1\":{\"45\":1}}],[\"minretrybackoff\",{\"1\":{\"444\":1}}],[\"minor\",{\"1\":{\"374\":2}}],[\"minval\",{\"1\":{\"128\":1}}],[\"min草图\",{\"1\":{\"46\":1}}],[\"min\",{\"1\":{\"46\":2,\"128\":1,\"482\":1,\"547\":1}}],[\"mine\",{\"1\":{\"43\":1}}],[\"mime\",{\"1\":{\"43\":1}}],[\"microsecond\",{\"1\":{\"630\":2}}],[\"microsoft\",{\"1\":{\"43\":1,\"62\":1}}],[\"micro\",{\"1\":{\"47\":1}}],[\"microcosm\",{\"1\":{\"41\":1}}],[\"mirror\",{\"1\":{\"11\":1}}],[\"mqttpaho\",{\"1\":{\"64\":1}}],[\"mqttcli\",{\"1\":{\"41\":1}}],[\"mqtt\",{\"1\":{\"41\":1}}],[\"mq\",{\"2\":{\"19\":1,\"489\":1,\"491\":1,\"493\":1}}],[\"t3关联了t1\",{\"1\":{\"626\":1}}],[\"t3\",{\"1\":{\"626\":4}}],[\"t2都会加载\",{\"1\":{\"625\":1}}],[\"t2\",{\"1\":{\"625\":11,\"626\":4,\"628\":2,\"643\":2}}],[\"t1转换为unsafe\",{\"1\":{\"643\":1}}],[\"t1\",{\"1\":{\"625\":11,\"626\":4,\"628\":2,\"643\":1}}],[\"turkishcase\",{\"1\":{\"609\":2}}],[\"tunny\",{\"1\":{\"56\":1}}],[\"tx\",{\"1\":{\"439\":6}}],[\"txt作为插槽文件\",{\"1\":{\"628\":1}}],[\"txt文件以做对比\",{\"1\":{\"395\":1}}],[\"txt和new\",{\"1\":{\"395\":1}}],[\"txt的文件\",{\"1\":{\"307\":1}}],[\"txt\",{\"1\":{\"64\":1,\"126\":1,\"307\":1,\"319\":9,\"320\":5,\"321\":3,\"322\":6,\"323\":2,\"324\":1,\"325\":1,\"395\":10,\"627\":1,\"628\":10}}],[\"tmpl3\",{\"1\":{\"626\":2}}],[\"tmpl2\",{\"1\":{\"626\":2}}],[\"tmpl1\",{\"1\":{\"626\":2}}],[\"tmpl是一个模板字符串\",{\"1\":{\"615\":1}}],[\"tmpl\",{\"1\":{\"615\":2,\"617\":10,\"619\":2,\"625\":4}}],[\"tmp\",{\"1\":{\"572\":1}}],[\"tm\",{\"1\":{\"394\":1,\"395\":3}}],[\"t是testing包提供的用于方便测试的结构体\",{\"1\":{\"390\":1}}],[\"t是一个接口\",{\"1\":{\"208\":1}}],[\"t为时间间隔\",{\"1\":{\"388\":1}}],[\"twitchyliquid64\",{\"1\":{\"372\":2,\"378\":1}}],[\"twodmap\",{\"1\":{\"303\":2}}],[\"t就是一个类型形参\",{\"1\":{\"256\":1}}],[\"tb\",{\"1\":{\"256\":2}}],[\"t不是一个接口\",{\"1\":{\"208\":1}}],[\"t制表符但是无效\",{\"1\":{\"171\":2}}],[\"tt\",{\"1\":{\"626\":3}}],[\"ttl\",{\"1\":{\"451\":1}}],[\"ttlcache\",{\"1\":{\"46\":1}}],[\"ttml和\",{\"1\":{\"65\":1}}],[\"ttml\",{\"1\":{\"65\":1}}],[\"ts\",{\"1\":{\"65\":1,\"626\":2}}],[\"tspool\",{\"1\":{\"64\":1}}],[\"tsuna\",{\"1\":{\"41\":1}}],[\"tcp编程的逻辑十分简单\",{\"1\":{\"574\":1}}],[\"tcp4\",{\"1\":{\"570\":1}}],[\"tcp4addr\",{\"1\":{\"570\":2}}],[\"tcpaddr\",{\"1\":{\"570\":1}}],[\"tcp6addr\",{\"1\":{\"570\":2}}],[\"tcp6\",{\"1\":{\"570\":2}}],[\"tcp地址支持tcp4\",{\"1\":{\"570\":1}}],[\"tcp地址\",{\"0\":{\"570\":1}}],[\"tcp库使用工作池来提高性能并保护您的服务器\",{\"1\":{\"64\":1}}],[\"tcp\",{\"1\":{\"64\":2,\"373\":1,\"433\":1,\"435\":1,\"444\":2,\"565\":1,\"574\":2}}],[\"tfgo\",{\"1\":{\"61\":1}}],[\"tga\",{\"1\":{\"58\":1}}],[\"typevar\",{\"1\":{\"525\":1}}],[\"typed\",{\"1\":{\"360\":1}}],[\"typedef\",{\"1\":{\"220\":2}}],[\"type方法可以获取一个反射值的类型\",{\"1\":{\"277\":1}}],[\"type代表着go中的类型\",{\"1\":{\"269\":1}}],[\"type接口类型来表示go中的类型\",{\"1\":{\"267\":1}}],[\"typename\",{\"1\":{\"220\":1}}],[\"typeof函数\",{\"1\":{\"267\":1}}],[\"typeof\",{\"1\":{\"217\":1,\"221\":1,\"226\":1,\"227\":1,\"267\":1,\"268\":1,\"269\":2,\"270\":1,\"271\":2,\"272\":5,\"273\":4,\"274\":3,\"275\":3,\"283\":1,\"286\":2,\"288\":1,\"289\":2,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1}}],[\"type是具体类型\",{\"1\":{\"213\":1}}],[\"type1\",{\"1\":{\"181\":1}}],[\"types\",{\"1\":{\"128\":1,\"300\":1,\"302\":1}}],[\"type\",{\"0\":{\"277\":1},\"1\":{\"97\":1,\"120\":3,\"122\":1,\"132\":1,\"140\":1,\"163\":3,\"172\":1,\"181\":2,\"185\":1,\"186\":2,\"187\":1,\"188\":2,\"189\":6,\"191\":1,\"192\":3,\"193\":1,\"195\":1,\"196\":4,\"197\":1,\"198\":2,\"200\":1,\"204\":1,\"205\":1,\"206\":9,\"208\":10,\"210\":1,\"212\":8,\"213\":4,\"221\":3,\"226\":1,\"228\":1,\"236\":1,\"239\":1,\"245\":3,\"256\":1,\"257\":8,\"258\":4,\"259\":17,\"260\":11,\"262\":2,\"263\":4,\"266\":7,\"267\":4,\"269\":1,\"270\":3,\"271\":3,\"272\":2,\"273\":2,\"274\":6,\"275\":6,\"277\":3,\"285\":1,\"286\":9,\"287\":1,\"289\":9,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":2,\"302\":6,\"303\":3,\"304\":1,\"305\":1,\"306\":1,\"308\":1,\"309\":1,\"310\":1,\"311\":1,\"312\":1,\"331\":1,\"333\":1,\"338\":2,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"349\":1,\"351\":1,\"353\":3,\"354\":1,\"358\":3,\"360\":1,\"382\":1,\"390\":1,\"404\":1,\"405\":1,\"406\":6,\"407\":3,\"408\":7,\"422\":8,\"424\":1,\"425\":2,\"429\":1,\"435\":1,\"441\":1,\"444\":1,\"453\":1,\"510\":1,\"513\":1,\"516\":1,\"518\":1,\"525\":1,\"537\":1,\"575\":1,\"580\":2,\"611\":2,\"620\":1,\"638\":1,\"639\":1,\"640\":2,\"641\":1,\"642\":1,\"643\":2}}],[\"typ\",{\"1\":{\"46\":1,\"266\":2,\"267\":1,\"292\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1}}],[\"thursday\",{\"1\":{\"631\":1}}],[\"though\",{\"1\":{\"389\":1}}],[\"than\",{\"1\":{\"263\":2,\"389\":1}}],[\"that\",{\"1\":{\"172\":2,\"176\":4,\"208\":2,\"389\":1}}],[\"there\",{\"1\":{\"599\":2}}],[\"the\",{\"1\":{\"208\":5,\"215\":1,\"217\":2,\"222\":6,\"245\":1,\"246\":1,\"266\":2,\"319\":2,\"372\":1,\"373\":4,\"389\":1,\"405\":1,\"408\":3,\"419\":2,\"615\":2}}],[\"theory\",{\"1\":{\"45\":1}}],[\"this\",{\"1\":{\"172\":5,\"173\":2,\"174\":2,\"175\":2,\"176\":4,\"222\":9,\"312\":1,\"372\":1,\"389\":1,\"408\":3,\"607\":8,\"608\":8,\"610\":10,\"612\":2,\"615\":1,\"618\":2}}],[\"third\",{\"1\":{\"145\":2}}],[\"through\",{\"1\":{\"245\":2}}],[\"threads\",{\"1\":{\"368\":1}}],[\"thread\",{\"1\":{\"247\":1}}],[\"threadcreateprofile\",{\"1\":{\"242\":1}}],[\"threadcreate\",{\"1\":{\"242\":1,\"243\":1}}],[\"threadpool\",{\"1\":{\"56\":1}}],[\"thrift\",{\"1\":{\"41\":2}}],[\"te\",{\"1\":{\"615\":2}}],[\"tetj8iy+ifbt8slc+rrq\",{\"1\":{\"404\":1}}],[\"teem\",{\"1\":{\"396\":1}}],[\"tee\",{\"1\":{\"395\":2}}],[\"teardown\",{\"1\":{\"392\":4}}],[\"tell\",{\"1\":{\"389\":1}}],[\"term\",{\"1\":{\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":1}}],[\"terminal\",{\"1\":{\"373\":1}}],[\"terminated\",{\"1\":{\"219\":1}}],[\"termloop\",{\"1\":{\"53\":1}}],[\"tempalte\",{\"1\":{\"626\":1}}],[\"temp\",{\"1\":{\"201\":2,\"348\":2,\"349\":2,\"350\":2,\"351\":2,\"521\":3}}],[\"template完全一致\",{\"1\":{\"628\":1}}],[\"template包\",{\"1\":{\"628\":1}}],[\"templatename\",{\"1\":{\"626\":1}}],[\"template关联起来\",{\"1\":{\"626\":1}}],[\"template都有一个funcsmap\",{\"1\":{\"620\":1}}],[\"template\",{\"0\":{\"614\":1},\"1\":{\"43\":3,\"508\":1,\"614\":4,\"615\":9,\"617\":2,\"620\":5,\"625\":9,\"626\":12,\"627\":1,\"628\":8}}],[\"testbuilder\",{\"1\":{\"611\":3}}],[\"testbota\",{\"1\":{\"587\":3}}],[\"testreader\",{\"1\":{\"613\":3}}],[\"testreplacer\",{\"1\":{\"612\":1}}],[\"testreplaceall\",{\"1\":{\"607\":3}}],[\"testreplace\",{\"1\":{\"607\":3}}],[\"testrepeat\",{\"1\":{\"606\":3}}],[\"testround\",{\"1\":{\"555\":3}}],[\"testlowerandupper\",{\"1\":{\"609\":3}}],[\"testlog\",{\"1\":{\"556\":3}}],[\"testlastindex\",{\"1\":{\"604\":1}}],[\"testpresuffix\",{\"1\":{\"603\":3}}],[\"testparsecomplex\",{\"1\":{\"591\":3}}],[\"testparsefloat\",{\"1\":{\"589\":1}}],[\"testpow\",{\"1\":{\"558\":3}}],[\"testquote\",{\"1\":{\"588\":3}}],[\"testquickstart\",{\"1\":{\"443\":1}}],[\"testiota\",{\"1\":{\"585\":3}}],[\"testindex\",{\"1\":{\"604\":3}}],[\"testinf\",{\"1\":{\"551\":3}}],[\"testing\",{\"1\":{\"43\":2,\"365\":2,\"390\":15,\"391\":4,\"392\":8,\"393\":2,\"394\":3,\"396\":7,\"443\":2,\"508\":1,\"546\":1,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"596\":1,\"597\":1,\"598\":3,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":2,\"605\":1,\"606\":1,\"607\":2,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1}}],[\"testappend\",{\"1\":{\"593\":3}}],[\"testaotb\",{\"1\":{\"586\":2}}],[\"testaoti\",{\"1\":{\"584\":3}}],[\"testatob\",{\"1\":{\"586\":1}}],[\"testabs\",{\"1\":{\"548\":3}}],[\"testn\",{\"1\":{\"561\":3}}],[\"testname\",{\"1\":{\"550\":1}}],[\"testex\",{\"1\":{\"557\":3}}],[\"testequalfold\",{\"1\":{\"601\":3}}],[\"testequal\",{\"1\":{\"390\":12,\"391\":3,\"392\":4,\"393\":2}}],[\"testcut\",{\"1\":{\"600\":3}}],[\"testcube\",{\"1\":{\"560\":3}}],[\"testcount\",{\"1\":{\"599\":3}}],[\"testcontainsrune\",{\"1\":{\"598\":3}}],[\"testcontainsany\",{\"1\":{\"598\":3}}],[\"testcontains\",{\"1\":{\"598\":3}}],[\"testcompare\",{\"1\":{\"597\":3}}],[\"testcos\",{\"1\":{\"563\":3}}],[\"testclone\",{\"1\":{\"596\":3}}],[\"testceil\",{\"1\":{\"554\":3}}],[\"testcase\",{\"1\":{\"368\":3}}],[\"testtrim\",{\"1\":{\"610\":3}}],[\"testtrunc\",{\"1\":{\"552\":3}}],[\"testtan\",{\"1\":{\"564\":3}}],[\"testtoolparallel\",{\"1\":{\"392\":30}}],[\"testtool\",{\"1\":{\"392\":10}}],[\"testmap\",{\"1\":{\"605\":3}}],[\"testmax\",{\"1\":{\"546\":3}}],[\"testmod\",{\"1\":{\"549\":3}}],[\"testmin\",{\"1\":{\"547\":3}}],[\"testdata\",{\"1\":{\"393\":2,\"396\":7}}],[\"test或者是想要测试的包或者功能作为文件前缀\",{\"1\":{\"390\":1}}],[\"test的运行目录\",{\"1\":{\"388\":1}}],[\"testfield\",{\"1\":{\"602\":3}}],[\"testformatcomplex\",{\"1\":{\"592\":3}}],[\"testformatfloat\",{\"1\":{\"590\":3}}],[\"testfloat\",{\"1\":{\"589\":2}}],[\"testfloor\",{\"1\":{\"550\":2,\"553\":3}}],[\"testflag命令自行查阅\",{\"1\":{\"388\":1}}],[\"testfunc命令\",{\"1\":{\"385\":1}}],[\"test命令默认运行所有的单元测试\",{\"1\":{\"387\":1}}],[\"test命令\",{\"1\":{\"387\":1}}],[\"testhello\",{\"1\":{\"365\":1,\"366\":2}}],[\"testsplit\",{\"1\":{\"608\":3}}],[\"testsin\",{\"1\":{\"562\":3}}],[\"testsqrt\",{\"1\":{\"559\":3}}],[\"teststruct\",{\"1\":{\"258\":1}}],[\"testsum\",{\"1\":{\"233\":3,\"390\":12,\"391\":3,\"392\":4}}],[\"test\",{\"1\":{\"74\":1,\"325\":1,\"365\":2,\"366\":1,\"368\":6,\"373\":2,\"376\":1,\"385\":1,\"386\":4,\"387\":16,\"389\":5,\"390\":30,\"391\":8,\"392\":24,\"394\":8,\"395\":9,\"396\":23,\"408\":3,\"433\":1,\"435\":1,\"610\":10}}],[\"techan\",{\"1\":{\"52\":1}}],[\"tengo\",{\"1\":{\"49\":1}}],[\"tendermint\",{\"1\":{\"47\":1}}],[\"text3\",{\"1\":{\"623\":1}}],[\"text2\",{\"1\":{\"622\":1,\"623\":1}}],[\"text1\",{\"1\":{\"622\":1,\"623\":1}}],[\"textmpl\",{\"1\":{\"615\":1}}],[\"textcat\",{\"1\":{\"63\":1}}],[\"text\",{\"1\":{\"43\":1,\"145\":1,\"310\":2,\"372\":2,\"378\":2,\"406\":2,\"407\":1,\"408\":5,\"614\":1,\"615\":2,\"622\":1,\"628\":1}}],[\"textproto\",{\"1\":{\"43\":1}}],[\"t\",{\"1\":{\"43\":1,\"103\":1,\"104\":1,\"140\":4,\"160\":2,\"171\":1,\"174\":1,\"196\":1,\"217\":5,\"219\":15,\"223\":16,\"225\":5,\"226\":3,\"227\":3,\"229\":3,\"231\":7,\"232\":2,\"233\":5,\"256\":3,\"257\":17,\"258\":22,\"259\":9,\"260\":9,\"262\":17,\"263\":16,\"319\":2,\"365\":3,\"372\":1,\"388\":2,\"390\":49,\"391\":17,\"392\":41,\"393\":14,\"396\":13,\"443\":2,\"511\":1,\"519\":1,\"546\":2,\"547\":2,\"548\":2,\"549\":2,\"550\":2,\"551\":2,\"552\":2,\"553\":2,\"554\":2,\"555\":2,\"556\":2,\"557\":2,\"558\":2,\"559\":2,\"560\":2,\"561\":2,\"562\":2,\"563\":2,\"564\":2,\"584\":2,\"585\":2,\"586\":4,\"587\":2,\"588\":2,\"589\":2,\"590\":2,\"591\":2,\"592\":2,\"593\":2,\"596\":2,\"597\":2,\"598\":6,\"599\":2,\"600\":2,\"601\":3,\"602\":2,\"603\":2,\"604\":4,\"605\":2,\"606\":2,\"607\":4,\"608\":2,\"609\":2,\"610\":2,\"611\":2,\"612\":2,\"613\":2,\"615\":2,\"620\":1,\"625\":3,\"626\":3,\"629\":11,\"633\":2,\"634\":2}}],[\"tlsnextproto\",{\"1\":{\"536\":1}}],[\"tlsconfig\",{\"1\":{\"444\":1,\"536\":1}}],[\"tls配置\",{\"1\":{\"444\":1}}],[\"tls或websockets连接到mqtt代理\",{\"1\":{\"64\":1}}],[\"tls\",{\"1\":{\"43\":1,\"444\":1}}],[\"tdea\",{\"1\":{\"43\":1}}],[\"trust\",{\"1\":{\"372\":1}}],[\"trusted\",{\"1\":{\"372\":1}}],[\"trunc模式打开文件\",{\"1\":{\"321\":1}}],[\"trunc\",{\"1\":{\"319\":2,\"321\":3,\"322\":2,\"329\":1,\"552\":2}}],[\"true为真值\",{\"1\":{\"115\":1}}],[\"true\",{\"1\":{\"0\":1,\"2\":2,\"140\":1,\"149\":2,\"201\":2,\"213\":1,\"273\":3,\"274\":1,\"275\":1,\"286\":3,\"288\":1,\"289\":2,\"298\":2,\"339\":5,\"340\":9,\"346\":1,\"353\":2,\"355\":4,\"382\":2,\"390\":5,\"393\":2,\"406\":2,\"409\":1,\"412\":1,\"525\":2,\"528\":3,\"551\":1,\"586\":7,\"587\":2,\"598\":6,\"600\":4,\"601\":3,\"603\":2,\"620\":3}}],[\"tryrlock\",{\"1\":{\"350\":1}}],[\"try\",{\"1\":{\"245\":1}}],[\"trylock\",{\"1\":{\"56\":1,\"350\":1}}],[\"trayhost\",{\"1\":{\"57\":1}}],[\"tracing\",{\"1\":{\"373\":1}}],[\"trace命令来完成相关的分析工作\",{\"1\":{\"247\":1}}],[\"trace\",{\"0\":{\"247\":1},\"1\":{\"242\":4,\"243\":5,\"247\":11,\"373\":1,\"388\":2}}],[\"tracerr\",{\"1\":{\"50\":1}}],[\"tracker\",{\"1\":{\"57\":1}}],[\"transport\",{\"1\":{\"532\":1}}],[\"transation\",{\"1\":{\"439\":4}}],[\"transaction\",{\"1\":{\"52\":1}}],[\"translator\",{\"1\":{\"372\":2,\"378\":1}}],[\"transfer\",{\"1\":{\"43\":1}}],[\"trimsuffix\",{\"1\":{\"610\":2}}],[\"trimright\",{\"1\":{\"610\":2}}],[\"trimprefix\",{\"1\":{\"610\":2}}],[\"trimleft\",{\"1\":{\"610\":2}}],[\"trim\",{\"1\":{\"610\":2}}],[\"trie\",{\"1\":{\"46\":1,\"373\":1}}],[\"tripledata\",{\"1\":{\"43\":1}}],[\"treap\",{\"1\":{\"46\":1}}],[\"tree\",{\"1\":{\"46\":1,\"177\":1,\"626\":3}}],[\"tier\",{\"1\":{\"407\":1}}],[\"tidy\",{\"1\":{\"375\":1}}],[\"tidb\",{\"1\":{\"42\":2,\"253\":1}}],[\"ticker是一个定时器\",{\"1\":{\"634\":1}}],[\"ticker\",{\"0\":{\"634\":1},\"1\":{\"345\":2,\"634\":4}}],[\"tinyint\",{\"1\":{\"259\":4,\"260\":4,\"434\":1}}],[\"tips\",{\"1\":{\"236\":1}}],[\"tile38\",{\"1\":{\"54\":1}}],[\"timer是一次性的\",{\"1\":{\"634\":1}}],[\"timer是一个计时器\",{\"1\":{\"633\":1}}],[\"timer\",{\"0\":{\"633\":1},\"1\":{\"633\":4}}],[\"timerctx会在时间到期后自动取消当前上下文\",{\"1\":{\"347\":1}}],[\"timerctx在cancelctx\",{\"1\":{\"347\":1}}],[\"timerctx\",{\"0\":{\"347\":1},\"1\":{\"342\":1}}],[\"time包存放了基础的时间单位常量\",{\"1\":{\"630\":1}}],[\"time包提供了时间和日历的相关的函数与方法\",{\"1\":{\"629\":1}}],[\"timech\",{\"1\":{\"338\":3}}],[\"timeerror类型的\",{\"1\":{\"312\":2}}],[\"timeerror类型的错误\",{\"1\":{\"312\":1}}],[\"timeerror\",{\"1\":{\"312\":4}}],[\"timeout\",{\"1\":{\"309\":1,\"340\":1,\"345\":2,\"347\":3,\"387\":1,\"388\":1,\"532\":1}}],[\"timelines\",{\"1\":{\"247\":1}}],[\"timedmap\",{\"1\":{\"46\":1}}],[\"time\",{\"0\":{\"629\":1},\"1\":{\"43\":1,\"233\":3,\"242\":6,\"245\":1,\"312\":6,\"315\":4,\"331\":13,\"336\":2,\"338\":6,\"340\":12,\"343\":4,\"344\":2,\"345\":4,\"346\":12,\"347\":9,\"348\":6,\"349\":6,\"350\":12,\"351\":12,\"389\":3,\"444\":9,\"449\":3,\"450\":2,\"508\":1,\"629\":19,\"631\":1,\"632\":2,\"633\":2,\"634\":2,\"635\":5}}],[\"tan\",{\"0\":{\"564\":1},\"1\":{\"564\":2}}],[\"tangsengdaodaoserver\",{\"1\":{\"250\":1}}],[\"talk\",{\"1\":{\"285\":1,\"289\":2,\"290\":4,\"293\":1}}],[\"ta\",{\"1\":{\"256\":3}}],[\"tasks\",{\"1\":{\"247\":2}}],[\"tap库\",{\"1\":{\"64\":1}}],[\"tagline\",{\"1\":{\"404\":1}}],[\"taglib\",{\"1\":{\"45\":1}}],[\"tag\",{\"1\":{\"51\":2,\"286\":2,\"288\":4,\"368\":4}}],[\"tags\",{\"1\":{\"41\":1,\"368\":1}}],[\"tab\",{\"1\":{\"266\":1}}],[\"table\",{\"1\":{\"177\":1,\"393\":1,\"434\":3}}],[\"tablewriter\",{\"1\":{\"41\":1}}],[\"tab缩进\",{\"1\":{\"171\":2}}],[\"tabwriter\",{\"1\":{\"43\":2}}],[\"tar归档文件的包\",{\"1\":{\"508\":1}}],[\"tardisgo\",{\"1\":{\"55\":1}}],[\"tar文件filesystem\",{\"1\":{\"51\":1}}],[\"tarfs\",{\"1\":{\"51\":1}}],[\"tar\",{\"1\":{\"43\":1,\"51\":1,\"508\":1}}],[\"target必须是指向error的指针\",{\"1\":{\"312\":1}}],[\"target\",{\"1\":{\"11\":1,\"312\":2,\"322\":6}}],[\"toupperspecial\",{\"1\":{\"609\":2}}],[\"toupper\",{\"1\":{\"609\":2}}],[\"tolowerspecial\",{\"1\":{\"609\":2}}],[\"tolower\",{\"1\":{\"609\":2}}],[\"todo\",{\"1\":{\"344\":3}}],[\"todo来进行创建\",{\"1\":{\"344\":1}}],[\"tom\",{\"1\":{\"298\":3,\"509\":1}}],[\"toml也逐渐开始流行\",{\"1\":{\"509\":1}}],[\"toml\",{\"1\":{\"41\":4,\"372\":2,\"378\":1}}],[\"total\",{\"1\":{\"245\":5,\"364\":1,\"368\":1,\"396\":11,\"411\":1,\"413\":1,\"414\":1}}],[\"topics\",{\"1\":{\"373\":1}}],[\"top\",{\"1\":{\"245\":1,\"246\":1}}],[\"top命令只是简单的看个大概\",{\"1\":{\"245\":1}}],[\"tool\",{\"1\":{\"244\":1,\"245\":2,\"246\":4,\"247\":3,\"390\":30,\"391\":7,\"392\":47,\"393\":2,\"394\":12,\"395\":7,\"396\":23}}],[\"tools\",{\"1\":{\"41\":1,\"56\":1,\"192\":1}}],[\"too\",{\"1\":{\"238\":1}}],[\"to\",{\"1\":{\"60\":1,\"172\":1,\"178\":1,\"208\":2,\"221\":1,\"222\":11,\"236\":2,\"237\":2,\"238\":2,\"239\":4,\"245\":1,\"246\":1,\"263\":2,\"313\":1,\"338\":1,\"365\":1,\"368\":2,\"372\":2,\"373\":2,\"389\":4,\"396\":8,\"418\":1,\"609\":4}}],[\"torrent\",{\"1\":{\"47\":1}}],[\"tokens\",{\"1\":{\"408\":1}}],[\"token\",{\"1\":{\"43\":1,\"408\":7,\"456\":2,\"457\":2}}],[\"n小于0时表示不限制替换次数\",{\"1\":{\"607\":1}}],[\"n指的是替换次数\",{\"1\":{\"607\":1}}],[\"n<\",{\"1\":{\"512\":1}}],[\"nginx\",{\"0\":{\"494\":1}}],[\"ngaro\",{\"1\":{\"49\":1}}],[\"nice\",{\"1\":{\"396\":4,\"609\":4}}],[\"nilch\",{\"1\":{\"340\":3}}],[\"nil就占了相当一部分\",{\"1\":{\"307\":1}}],[\"nil这样的语句是无法通过编译的\",{\"1\":{\"122\":1}}],[\"nil仅仅只是一些引用类型的零值\",{\"1\":{\"122\":1}}],[\"nil类似于其它语言中的none或者null\",{\"1\":{\"122\":1}}],[\"nil\",{\"0\":{\"122\":1},\"1\":{\"121\":1,\"122\":1,\"125\":1,\"148\":2,\"178\":1,\"199\":1,\"217\":1,\"239\":2,\"242\":3,\"243\":1,\"256\":1,\"297\":1,\"298\":1,\"307\":8,\"309\":1,\"312\":2,\"313\":1,\"316\":4,\"319\":3,\"320\":7,\"321\":5,\"322\":8,\"323\":1,\"324\":2,\"325\":3,\"327\":3,\"328\":1,\"329\":9,\"344\":3,\"346\":2,\"353\":4,\"354\":2,\"360\":2,\"365\":1,\"382\":4,\"396\":3,\"404\":2,\"406\":2,\"407\":2,\"408\":2,\"409\":2,\"411\":2,\"412\":2,\"413\":2,\"414\":2,\"415\":6,\"421\":1,\"424\":1,\"425\":4,\"426\":2,\"427\":4,\"428\":2,\"429\":2,\"435\":3,\"436\":2,\"437\":2,\"438\":2,\"439\":1,\"443\":2,\"511\":1,\"512\":1,\"514\":1,\"515\":2,\"517\":1,\"519\":1,\"520\":1,\"521\":2,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"535\":1,\"536\":7,\"537\":2,\"538\":1,\"567\":1,\"568\":1,\"569\":2,\"570\":2,\"571\":2,\"572\":1,\"573\":2,\"574\":5,\"611\":1,\"613\":1,\"615\":2,\"617\":5,\"619\":1,\"620\":1,\"625\":2,\"626\":7,\"628\":2,\"632\":2,\"643\":1}}],[\"n=5\",{\"1\":{\"395\":19}}],[\"n=3\",{\"1\":{\"165\":3}}],[\"n的大小\",{\"1\":{\"394\":1}}],[\"n为随机种子\",{\"1\":{\"388\":1}}],[\"n值为并行的最大数量\",{\"1\":{\"388\":1}}],[\"nhooyr\",{\"1\":{\"379\":1}}],[\"np\",{\"1\":{\"643\":2}}],[\"npm这样类似的中央仓库\",{\"1\":{\"370\":1}}],[\"nps\",{\"1\":{\"251\":1}}],[\"nsec\",{\"1\":{\"629\":1}}],[\"ns为纳秒\",{\"1\":{\"394\":1}}],[\"nsop2\",{\"1\":{\"233\":2}}],[\"nsop1\",{\"1\":{\"233\":2}}],[\"ns\",{\"1\":{\"233\":4,\"394\":13,\"395\":60}}],[\"n循环\",{\"1\":{\"203\":1}}],[\"n`\",{\"1\":{\"105\":1}}],[\"n\",{\"1\":{\"104\":1,\"105\":6,\"137\":1,\"140\":26,\"142\":2,\"143\":7,\"144\":1,\"153\":4,\"160\":6,\"165\":2,\"171\":1,\"177\":3,\"198\":1,\"201\":8,\"203\":2,\"212\":2,\"218\":1,\"220\":1,\"223\":24,\"224\":6,\"229\":2,\"233\":8,\"239\":12,\"259\":6,\"260\":6,\"287\":1,\"295\":1,\"320\":2,\"321\":7,\"322\":1,\"327\":2,\"335\":4,\"336\":2,\"339\":6,\"340\":26,\"354\":2,\"355\":6,\"388\":6,\"394\":2,\"396\":2,\"424\":1,\"425\":2,\"512\":4,\"520\":1,\"574\":2,\"600\":1,\"602\":2,\"607\":1,\"608\":6,\"617\":3}}],[\"nflag\",{\"1\":{\"527\":1}}],[\"nff\",{\"1\":{\"64\":1}}],[\"nfnt\",{\"1\":{\"41\":1}}],[\"nlp\",{\"1\":{\"63\":3}}],[\"ne\",{\"1\":{\"620\":2}}],[\"need\",{\"1\":{\"395\":3}}],[\"needed\",{\"1\":{\"222\":2}}],[\"necessary\",{\"1\":{\"389\":1}}],[\"next\",{\"1\":{\"201\":3}}],[\"newticker\",{\"1\":{\"634\":3}}],[\"newtimer\",{\"1\":{\"345\":1,\"633\":3}}],[\"new指old的替换部分\",{\"1\":{\"607\":1}}],[\"newreplacer\",{\"1\":{\"612\":2}}],[\"newrequest\",{\"1\":{\"533\":1,\"534\":1}}],[\"newreader\",{\"1\":{\"144\":1,\"531\":1,\"613\":2}}],[\"newname\",{\"1\":{\"452\":1}}],[\"newbufferstring\",{\"1\":{\"406\":1,\"408\":1,\"411\":1,\"413\":1,\"415\":3}}],[\"new执行耗时1123\",{\"1\":{\"395\":1}}],[\"newval\",{\"1\":{\"358\":1}}],[\"newprinter\",{\"1\":{\"354\":2}}],[\"newpath\",{\"1\":{\"323\":1}}],[\"newperson\",{\"1\":{\"187\":1,\"188\":3,\"197\":2}}],[\"newmyerror\",{\"1\":{\"312\":2}}],[\"new函数是由使用者传入的\",{\"1\":{\"354\":1}}],[\"new函数\",{\"1\":{\"293\":1}}],[\"new函数只有一个参数那就是类型\",{\"1\":{\"194\":1}}],[\"newat\",{\"1\":{\"287\":1}}],[\"newheap\",{\"1\":{\"263\":1}}],[\"newservemux\",{\"1\":{\"243\":1}}],[\"newscanner\",{\"1\":{\"145\":1}}],[\"newclient\",{\"1\":{\"404\":2,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":3,\"443\":1,\"445\":1}}],[\"newclient来建立一个新的连接\",{\"1\":{\"404\":1}}],[\"newcond\",{\"1\":{\"351\":2}}],[\"newcancelctx\",{\"1\":{\"346\":1}}],[\"newcap\",{\"1\":{\"163\":1}}],[\"newcharptr\",{\"1\":{\"219\":2}}],[\"new和make\",{\"0\":{\"196\":1}}],[\"new\",{\"1\":{\"158\":1,\"162\":1,\"194\":6,\"196\":4,\"199\":1,\"219\":1,\"256\":1,\"271\":1,\"274\":3,\"275\":3,\"278\":1,\"280\":1,\"286\":2,\"288\":1,\"289\":2,\"290\":1,\"292\":3,\"293\":2,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"307\":1,\"309\":2,\"310\":1,\"311\":1,\"312\":2,\"344\":2,\"354\":2,\"359\":1,\"364\":1,\"368\":1,\"382\":2,\"395\":5,\"396\":13,\"541\":1,\"607\":3,\"615\":1,\"617\":1,\"625\":1,\"626\":3}}],[\"newwriter\",{\"1\":{\"139\":2}}],[\"newfile\",{\"1\":{\"134\":3}}],[\"neural\",{\"1\":{\"61\":1}}],[\"neat\",{\"1\":{\"61\":2}}],[\"network\",{\"1\":{\"247\":1,\"444\":2,\"569\":1,\"570\":1,\"571\":1,\"572\":1}}],[\"net\",{\"0\":{\"565\":1},\"1\":{\"43\":2,\"64\":2,\"77\":1,\"243\":5,\"249\":1,\"372\":2,\"373\":1,\"378\":12,\"444\":1,\"508\":1,\"567\":2,\"568\":2,\"569\":3,\"570\":3,\"571\":3,\"572\":2,\"573\":4,\"574\":4}}],[\"nutsdb\",{\"1\":{\"253\":1}}],[\"numofobject\",{\"1\":{\"354\":3}}],[\"numout\",{\"1\":{\"283\":1,\"289\":1}}],[\"nummethod\",{\"1\":{\"289\":4,\"290\":1}}],[\"numfield\",{\"1\":{\"286\":3}}],[\"numin\",{\"1\":{\"283\":1,\"289\":1}}],[\"numeric\",{\"1\":{\"195\":1}}],[\"numexpression\",{\"1\":{\"130\":1}}],[\"numptr\",{\"1\":{\"194\":7}}],[\"numsref1\",{\"1\":{\"646\":2}}],[\"nums4\",{\"1\":{\"158\":1}}],[\"nums3\",{\"1\":{\"158\":1}}],[\"nums2\",{\"1\":{\"158\":1}}],[\"nums\",{\"1\":{\"158\":6,\"159\":4,\"160\":5,\"162\":5,\"163\":5,\"164\":11,\"165\":15,\"168\":2,\"645\":7,\"646\":4}}],[\"num++\",{\"1\":{\"149\":3}}],[\"num5\",{\"1\":{\"131\":1}}],[\"num4\",{\"1\":{\"131\":4}}],[\"num\",{\"1\":{\"130\":2,\"131\":4,\"149\":27,\"152\":3,\"168\":2,\"192\":3,\"194\":4,\"204\":2,\"229\":7,\"277\":2,\"278\":3,\"279\":5,\"280\":3,\"359\":3,\"643\":5,\"645\":4}}],[\"num3\",{\"1\":{\"127\":3,\"131\":4}}],[\"num2\",{\"1\":{\"127\":6,\"131\":4,\"304\":2}}],[\"num1被正确的转换为了int32类型\",{\"1\":{\"304\":1}}],[\"num1\",{\"1\":{\"127\":6,\"131\":3,\"304\":2}}],[\"numc\",{\"1\":{\"124\":1}}],[\"number\",{\"1\":{\"212\":3,\"259\":2,\"260\":1,\"390\":3,\"404\":1,\"406\":4,\"407\":2}}],[\"numb\",{\"1\":{\"124\":1}}],[\"numa\",{\"1\":{\"124\":1}}],[\"nude\",{\"1\":{\"58\":1}}],[\"null\",{\"1\":{\"46\":1,\"434\":7}}],[\"nntp和smtp中基于文本的通用的请求\",{\"1\":{\"43\":1}}],[\"nov\",{\"1\":{\"631\":1}}],[\"noverb\",{\"1\":{\"140\":1}}],[\"noescape\",{\"1\":{\"611\":1}}],[\"nodejs的npm等\",{\"1\":{\"361\":1}}],[\"nodes\",{\"1\":{\"245\":1}}],[\"node版本管理工具\",{\"1\":{\"10\":1}}],[\"node版本控制\",{\"0\":{\"10\":1}}],[\"now\",{\"1\":{\"233\":2,\"312\":1,\"338\":1,\"347\":2,\"389\":1,\"396\":1,\"629\":5,\"631\":5,\"635\":2}}],[\"no\",{\"1\":{\"219\":1,\"226\":1,\"245\":1,\"387\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1}}],[\"none即可删除该依赖\",{\"1\":{\"372\":1}}],[\"none\",{\"1\":{\"372\":1}}],[\"nonemptyinterface\",{\"1\":{\"266\":3}}],[\"non\",{\"1\":{\"195\":1,\"239\":1,\"611\":2}}],[\"nopqrst\",{\"1\":{\"171\":1}}],[\"not\",{\"1\":{\"125\":1,\"206\":1,\"212\":2,\"217\":1,\"237\":2,\"239\":1,\"309\":2,\"332\":1,\"372\":1,\"382\":1,\"396\":1,\"434\":1,\"443\":1,\"620\":2,\"657\":1}}],[\"notifier\",{\"1\":{\"57\":2}}],[\"notify\",{\"1\":{\"51\":1}}],[\"noll和phong\",{\"1\":{\"43\":1}}],[\"narg\",{\"1\":{\"527\":1}}],[\"nan检测\",{\"0\":{\"550\":1}}],[\"nan虽然没法正常获取\",{\"1\":{\"182\":1}}],[\"nan也不等于自身\",{\"1\":{\"180\":1}}],[\"nan\",{\"1\":{\"180\":8,\"181\":10,\"182\":6,\"199\":1,\"550\":1}}],[\"nanosecond\",{\"1\":{\"630\":2}}],[\"nanoseconds\",{\"1\":{\"233\":1}}],[\"nano\",{\"1\":{\"53\":1,\"252\":1}}],[\"name>\",{\"1\":{\"511\":1,\"512\":1}}],[\"names\",{\"1\":{\"434\":1}}],[\"name注释\",{\"1\":{\"219\":1}}],[\"name\",{\"1\":{\"106\":2,\"124\":1,\"125\":8,\"126\":1,\"130\":4,\"140\":1,\"185\":1,\"186\":1,\"187\":5,\"188\":4,\"189\":6,\"190\":3,\"191\":2,\"197\":7,\"200\":8,\"226\":4,\"236\":3,\"257\":7,\"258\":4,\"263\":5,\"267\":1,\"271\":1,\"283\":1,\"285\":2,\"286\":5,\"287\":6,\"288\":6,\"289\":3,\"293\":2,\"298\":3,\"307\":1,\"319\":6,\"320\":3,\"321\":5,\"324\":1,\"327\":3,\"328\":1,\"365\":10,\"366\":1,\"369\":2,\"382\":3,\"392\":7,\"396\":3,\"404\":2,\"406\":2,\"407\":2,\"411\":2,\"412\":1,\"413\":2,\"415\":1,\"423\":3,\"424\":3,\"425\":8,\"426\":3,\"427\":5,\"428\":1,\"432\":1,\"435\":1,\"437\":1,\"448\":2,\"449\":4,\"450\":3,\"451\":2,\"452\":1,\"453\":1,\"460\":2,\"510\":1,\"518\":2,\"519\":1,\"520\":1,\"521\":3,\"525\":5,\"528\":6,\"609\":4,\"617\":1,\"619\":3,\"620\":2,\"621\":1,\"622\":5,\"625\":5,\"626\":5,\"627\":4,\"628\":5,\"640\":2,\"641\":4,\"642\":4,\"643\":2}}],[\"nad83\",{\"1\":{\"54\":1}}],[\"nats\",{\"1\":{\"47\":1}}],[\"nats的轻量级\",{\"1\":{\"47\":1}}],[\"native\",{\"1\":{\"45\":1}}],[\"naoina\",{\"1\":{\"41\":2}}],[\"nacos\",{\"0\":{\"31\":1}}],[\"nvm\",{\"0\":{\"10\":1},\"1\":{\"10\":1}}],[\"📝开源项目\",{\"0\":{\"9\":1}}],[\"💻软件\",{\"0\":{\"4\":1}}],[\"截图\",{\"0\":{\"8\":1}}],[\"视频库\",{\"0\":{\"65\":1}}],[\"视频\",{\"0\":{\"5\":1},\"1\":{\"39\":1}}],[\"和t2\",{\"1\":{\"626\":1}}],[\"和测试文件\",{\"1\":{\"387\":1}}],[\"和其他不安全协议检索的模块路径前缀的通用模式列表\",{\"1\":{\"380\":1}}],[\"和上面例子中的withdeadline用法一样\",{\"1\":{\"347\":1}}],[\"和一个内嵌的context类型的字段\",{\"1\":{\"345\":1}}],[\"和hoist\",{\"1\":{\"212\":1}}],[\"和参数一样\",{\"1\":{\"199\":1}}],[\"和搜索树\",{\"1\":{\"177\":1}}],[\"和powerpoint\",{\"1\":{\"62\":1}}],[\"和解码器\",{\"1\":{\"43\":1}}],[\"和三重数据加密算法\",{\"1\":{\"43\":1}}],[\"和fmt\",{\"1\":{\"40\":1}}],[\"和\",{\"1\":{\"2\":1,\"72\":1,\"83\":1,\"613\":1,\"618\":1}}],[\"介绍\",{\"0\":{\"2\":1},\"1\":{\"383\":1}}],[\"档案主页\",{\"0\":{\"1\":1},\"1\":{\"2\":1}}],[\"你好\",{\"1\":{\"601\":2,\"623\":2}}],[\"你好世界\",{\"1\":{\"598\":1}}],[\"你也没法找到它们的定义\",{\"1\":{\"222\":1}}],[\"你也可以自己进行丰富\",{\"1\":{\"367\":1}}],[\"你也可以使用io\",{\"1\":{\"322\":1}}],[\"你也可以在defer中修改函数的返回值\",{\"1\":{\"202\":1}}],[\"你也可以把它理解为一个构造函数\",{\"1\":{\"187\":1}}],[\"你也可以把它和fmt包结合起来用\",{\"1\":{\"139\":1}}],[\"你也可以编写一个函数来实例化结构体\",{\"1\":{\"187\":1}}],[\"你也可以通过官方工具stringer来自动生成枚举\",{\"1\":{\"132\":1}}],[\"你也可以给它们起别名\",{\"1\":{\"94\":1}}],[\"你\",{\"1\":{\"103\":1,\"598\":1}}],[\"你可能会以为它会被展开成下面这段\",{\"1\":{\"127\":1}}],[\"你可能会疑惑为什么不是\",{\"1\":{\"127\":1}}],[\"你可能在其它oop语言中见过public\",{\"1\":{\"93\":1}}],[\"你可以看到的是go在服务端领域应用较为广泛\",{\"1\":{\"254\":1}}],[\"你可以参照下面这些项目来进行学习\",{\"1\":{\"249\":1}}],[\"你可以尝试以下的几个开源web框架\",{\"1\":{\"249\":1}}],[\"你可以前往go\",{\"1\":{\"153\":1}}],[\"你可以同时初始化多个变量\",{\"1\":{\"152\":1}}],[\"你可以像直接读文件一样\",{\"1\":{\"142\":1}}],[\"你可以只写一行\",{\"1\":{\"111\":1}}],[\"你可以这么写\",{\"1\":{\"94\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"0\":1}}],[\"你应该在页面\",{\"1\":{\"2\":1}}],[\"你需要在页面\",{\"1\":{\"0\":1}}]],\"version\":2}}")).map(([e,t])=>[e,It(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const r=Ct[s];e==="suggest"?self.postMessage([e,o,et(t,r,n)]):e==="search"?self.postMessage([e,o,tt(t,r,n)]):self.postMessage({suggestions:[e,o,et(t,r,n)],results:[e,o,tt(t,r,n)]})};
//# sourceMappingURL=index.js.map
